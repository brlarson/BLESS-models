opening dump file "/Applications/osate2_2023-03-master/Eclipse.app/Contents/MacOS/dump.txt" 
opening proof script file "/Applications/osate2_2023-03-master/Eclipse.app/Contents/MacOS/script.txt"

Declarative Model has been Loaded.

 extracting initial proof obligation(s) for a package:  "Train"
  no proof obligations created for "Operator"
  creating proof obligations for "ServiceBrake"
  creating proof obligations for "Motor"
  creating proof obligations for "Train"
  creating proof obligations for "EmergencyBrake"
  no proof obligations created for "ControllerProcess"
  creating proof obligations for "Sensor"
  creating proof obligations for "Train.i"
 extracting initial proof obligation(s) for a package:  "CTCS"
  creating proof obligations for "MovementAuthority"
  creating proof obligations for "RadioBlockCenter"
  creating proof obligations for "MovementAuthority.i"
 extracting initial proof obligation(s) for a package:  "CTCS_Types"
  no proof obligations created for "Position"
  no proof obligations created for "movementAuthorization"
  no proof obligations created for "Acceleration"
  no proof obligations created for "Velocity"
  no proof obligations created for "Segment"
 extracting initial proof obligation(s) for a package:  "Physical_Types"
  no proof obligations created for "Minute"
  no proof obligations created for "Voltage"
  no proof obligations created for "Fluid_Volume"
  no proof obligations created for "Light_Wavelength"
  no proof obligations created for "Sound"
  no proof obligations created for "Touch"
  no proof obligations created for "Image"
  no proof obligations created for "Current"
  no proof obligations created for "Fluid_Flow"
  no proof obligations created for "Light_Intensity"
 extracting initial proof obligation(s) for a package:  "CTCS_Assertion"
 extracting initial proof obligation(s) for a package:  "Threads"
  creating proof obligations for "AutoBrake"
  creating proof obligations for "AutoBrake.i"
extracting proof obligations for "AutoBrake.i"
making initial obligations for complete states
making Serban's theorems
making initial proof obligations for transitions
source Assertion of ma -> controller.control.m_a:  << ma_m_a = RMA >>
destination Assertion of ma -> controller.control.m_a:  << ma_m_a = RMA >>
source Assertion of driver.xl -> motor.xl:  << xl = OPERATOR_XL >>
destination Assertion of driver.xl -> motor.xl:  << xl = OPERATOR_XL >>
source Assertion of sensor.p -> controller.control.p:  << p = POSITION >>
destination Assertion of sensor.p -> controller.control.p:  << p = POSITION >>
source Assertion of sensor.v -> controller.control.v:  << v = VELOCITY >>
destination Assertion of sensor.v -> controller.control.v:  << v = VELOCITY >>
source Assertion of controller.control.sb -> sbrake.brake:  << SB()
  and not EB() >>
destination Assertion of controller.control.sb -> sbrake.brake:  << SB()
  and not EB() >>
source Assertion of controller.control.eb -> ebrake.brake:  << EB() >>
destination Assertion of controller.control.eb -> ebrake.brake:  << EB() >>
6 instance model connection assume-guarantee verification conditions generated.
source Assertion of auth:  << ma_m_a = RMA >>
destination Assertion of auth:  << ma_m_a = RMA >>
source Assertion of pos:  << p = POSITION >>
destination Assertion of pos:  << p = POSITION >>
source Assertion of vel:  << v = VELOCITY >>
destination Assertion of vel:  << v = VELOCITY >>
source Assertion of dxl:  << xl = OPERATOR_XL >>
destination Assertion of dxl:  << xl = OPERATOR_XL >>
source Assertion of cpsb:  << SB()
  and not EB() >>
destination Assertion of cpsb:  << SB()
  and not EB() >>
source Assertion of cpeb:  << EB() >>
destination Assertion of cpeb:  << EB() >>
source Assertion of conn_s:  << p = POSITION >>
destination Assertion of conn_s:  << p = POSITION >>
source Assertion of conn_v:  << v = VELOCITY >>
destination Assertion of conn_v:  << v = VELOCITY >>
source Assertion of conn_ma:  << m_a = RMA >>
destination Assertion of conn_ma:  << m_a = RMA >>
source Assertion of conn_sb:  << SB()
  and not EB() >>
destination Assertion of conn_sb:  << SB()
  and not EB() >>
source Assertion of conn_eb:  << EB() >>
destination Assertion of conn_eb:  << EB() >>
source Assertion of ma:  << ma = RMA >>
destination Assertion of ma:  << ma = RMA >>
12 declarative model connection assume-guarantee verification conditions generated.
There was one instance model connection lacking a BLESS::Assertion property on both ends.
There was one Declarative model connection lacking a BLESS::Assertion property on one end.
There were 3 Declarative model connections lacking a BLESS::Assertion property on both ends.
No errors found.
Executing proof script . . .
You chose proof script: /Users/brianlarson/git3/BLESS-models/CTCS-3/proof/CTCS3.ps
step:  1
#This file, script.txt, was produced the BLESS Proof Assistant v3.2.2
step:  2
#  at Fri Jan 26 04:52:13 CST 2024 by brianlarson
step:  3
#  You chose proof script: /Users/brianlarson/git3/BLESS-models/CTCS-3/proof/CTCS3.ps
step:  4
#  You chose proof script: /Users/brianlarson/git3/BLESS-models/CTCS-3/proof/CTCS3.ps
step:  5
#Threads::AutoBrake.i
step:  6
#[serial 1003] <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definitio
step:  7
****make-an****
Making obligation 0
Obligations:

[serial 1003]: Threads::AutoBrake.i
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39]->
Q [39] << true >>
Why created:    <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.

Done making obligation 0
step:  8
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1003]: Threads::AutoBrake.i
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39]->
Q [39] << true >>
Why created:    <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.5 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1004]: Threads::AutoBrake.i
P [54] << true >>
S [39]->
Q [39] << true >>
Why created:    <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  9
#[serial 1004] <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
step:  10
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1004]: Threads::AutoBrake.i
P [54] << true >>
S [39]->
Q [39] << true >>
Why created:    <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.5 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1005]: Threads::AutoBrake.i
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [39]->
Q [39] << true >>
Why created:    <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  11
#[serial 1005] <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
step:  12
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1005]: Threads::AutoBrake.i
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [39]->
Q [39] << true >>
Why created:    <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.5 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1006]: Threads::AutoBrake.i
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39]->
Q [39] << true >>
Why created:    <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  13
#[serial 1006] <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
step:  14
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1006]: Threads::AutoBrake.i
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39]->
Q [39] << true >>
Why created:    <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1048]: Threads::AutoBrake.i
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [39]->
Q [39] << true >>
Why created:      normalization of [serial 1006]

. . . done Normalizing Unsolved Proof Obligations [7.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1048]: Threads::AutoBrake.i
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [39]->
Q [39] << true >>
Why created:      normalization of [serial 1006]

Done Normalizing
step:  15
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1048]: Threads::AutoBrake.i
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [39]->
Q [39] << true >>
Why created:      normalization of [serial 1006]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1007]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [59]->
Q [59] << ( p < iSeg.e ) or ( p >= iSeg.e ) >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  16
#[serial 1007] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
step:  17
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1007]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [59]->
Q [59] << ( p < iSeg.e ) or ( p >= iSeg.e ) >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1050]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59]->
Q [59] << p < iSeg.e or iSeg.e <= p >>
Why created:      normalization of [serial 1007]

. . . done Normalizing Unsolved Proof Obligations [7.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1050]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59]->
Q [59] << p < iSeg.e or iSeg.e <= p >>
Why created:      normalization of [serial 1007]

Done Normalizing
step:  18
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1050]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59]->
Q [59] << p < iSeg.e or iSeg.e <= p >>
Why created:      normalization of [serial 1007]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1051]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59]->
Q [59] << p < iSeg.e or ( not ( p < iSeg.e ) ) >>
Why created:    Replacing <= with not < of [serial 1050]

. . . Substituting <= with not < [7.6 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1051]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59]->
Q [59] << p < iSeg.e or ( not ( p < iSeg.e ) ) >>
Why created:    Replacing <= with not < of [serial 1050]

Done replacing a<=b with (not b<a)
step:  19
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1051]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59]->
Q [59] << p < iSeg.e or ( not ( p < iSeg.e ) ) >>
Why created:    Replacing <= with not < of [serial 1050]

Reason solved:  
   Law of Excluded middle. (exmid)

Has applied Law of Excluded middle. (exmid)
   to get:

[serial 1052]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59]->
Q [59] << true >>
Why created:    laws applied to [serial 1051]

. . . done Applying Laws [7.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1052]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59]->
Q [59] << true >>
Why created:    laws applied to [serial 1051]

Done applying laws
step:  20
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1052]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59]->
Q [59] << true >>
Why created:    laws applied to [serial 1051]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1008]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << ( not m_a'fresh ) or m_a'fresh >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  21
#[serial 1008] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
step:  22
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1008]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << ( not m_a'fresh ) or m_a'fresh >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>

Reason solved:  
   Law of Excluded middle. (exmid)

Has applied Law of Excluded middle. (exmid)
   to get:

[serial 1053]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << true >>
Why created:    laws applied to [serial 1008]

. . . done Applying Laws [7.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1053]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << true >>
Why created:    laws applied to [serial 1008]

Done applying laws
step:  23
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1053]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << true >>
Why created:    laws applied to [serial 1008]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1009]: Threads::AutoBrake.i
P [53] << true >>
S [53]->
Q [53] << true >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  24
#[serial 1009] Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
step:  25
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1009]: Threads::AutoBrake.i
P [53] << true >>
S [53]->
Q [53] << true >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1010]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61]->
Q [61] << ( i < ma.num_segments ) or ( i = ma.num_segments ) or ( i > ma.num_segments ) >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  26
#[serial 1010] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
step:  27
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1010]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61]->
Q [61] << ( i < ma.num_segments ) or ( i = ma.num_segments ) or ( i > ma.num_segments ) >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
   [change A>B to B<A]
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1055]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << i < ma.num_segments or ma.num_segments < i or i = ma.num_segments >>
Why created:      normalization of [serial 1010]

. . . done Normalizing Unsolved Proof Obligations [7.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1055]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << i < ma.num_segments or ma.num_segments < i or i = ma.num_segments >>
Why created:      normalization of [serial 1010]

Done Normalizing
step:  28
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1055]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << i < ma.num_segments or ma.num_segments < i or i = ma.num_segments >>
Why created:      normalization of [serial 1010]

Reason solved:  
   Trichotomy law for 'less than'. (lttri4)

Has applied Trichotomy law for 'less than'. (lttri4)
   to get:

[serial 1056]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << true >>
Why created:    laws applied to [serial 1055]

. . . done Applying Laws [7.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1056]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << true >>
Why created:    laws applied to [serial 1055]

Done applying laws
step:  29
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1056]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << true >>
Why created:    laws applied to [serial 1055]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1011]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << ( not m_a'fresh ) or m_a'fresh >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  30
#[serial 1011] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
step:  31
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1011]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << ( not m_a'fresh ) or m_a'fresh >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>

Reason solved:  
   Law of Excluded middle. (exmid)

Has applied Law of Excluded middle. (exmid)
   to get:

[serial 1057]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << true >>
Why created:    laws applied to [serial 1011]

. . . done Applying Laws [7.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1057]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << true >>
Why created:    laws applied to [serial 1011]

Done applying laws
step:  32
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1057]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << true >>
Why created:    laws applied to [serial 1011]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1012]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70]->
Q [70] << ( p < ma.ea ) or ( p >= ma.ea ) >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  33
#[serial 1012] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
step:  34
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1012]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70]->
Q [70] << ( p < ma.ea ) or ( p >= ma.ea ) >>
Why created:    Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1059]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [70] << p < ma.ea or ma.ea <= p >>
Why created:      normalization of [serial 1012]

. . . done Normalizing Unsolved Proof Obligations [7.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1059]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [70] << p < ma.ea or ma.ea <= p >>
Why created:      normalization of [serial 1012]

Done Normalizing
step:  35
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1059]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [70] << p < ma.ea or ma.ea <= p >>
Why created:      normalization of [serial 1012]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1060]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [70] << p < ma.ea or ( not ( p < ma.ea ) ) >>
Why created:    Replacing <= with not < of [serial 1059]

. . . Substituting <= with not < [7.6 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1060]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [70] << p < ma.ea or ( not ( p < ma.ea ) ) >>
Why created:    Replacing <= with not < of [serial 1059]

Done replacing a<=b with (not b<a)
step:  36
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1060]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [70] << p < ma.ea or ( not ( p < ma.ea ) ) >>
Why created:    Replacing <= with not < of [serial 1059]

Reason solved:  
   Law of Excluded middle. (exmid)

Has applied Law of Excluded middle. (exmid)
   to get:

[serial 1061]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [70] << true >>
Why created:    laws applied to [serial 1060]

. . . done Applying Laws [7.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1061]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [70] << true >>
Why created:    laws applied to [serial 1060]

Done applying laws
step:  37
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1061]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [70] << true >>
Why created:    laws applied to [serial 1060]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1013]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
Why created:     <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  38
#[serial 1013]  <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A};
step:  39
****reduce****

[serial 1062]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
Why created:    as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1062]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
Why created:    as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]

done reducing composite actions
step:  40
****atomic****
applying atomic actions . . .
out event port r on line 76 does not have a BLESS::Assertion property AutoBrake.i; <<true>> used instead.

This Proof Obligation:

[serial 1062]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
Why created:    as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]

Has applied <<pre>> -> <<M(r)>> for <<pre>> r! <<post>> to get:

[serial 1063]: Threads::AutoBrake.i
P [53] << true >>
S [76]->
Q [76] << true >>
Why created:    applied port output <<pre>> -> <<M[r]>> [serial 1062]

Has applied <<pre and r@now>> -> <<post>> for <<pre>> r! <<post>> to get:

[serial 1064]: Threads::AutoBrake.i
P [76] << ( true )
  and true@now >>
S [76]->
Q [54] << true >>
Why created:    applied port output <<pre and M[r]@now>> -> <<post>> [serial 1062]

. . . done applying atomic actions [7.6 seconds ]
After "atomic" remaining 
Obligations:

[serial 1063]: Threads::AutoBrake.i
P [53] << true >>
S [76]->
Q [76] << true >>
Why created:    applied port output <<pre>> -> <<M[r]>> [serial 1062]


[serial 1064]: Threads::AutoBrake.i
P [76] << ( true )
  and true@now >>
S [76]->
Q [54] << true >>
Why created:    applied port output <<pre and M[r]@now>> -> <<post>> [serial 1062]

Done reducing atomic actions
step:  41
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1063]: Threads::AutoBrake.i
P [53] << true >>
S [76]->
Q [76] << true >>
Why created:    applied port output <<pre>> -> <<M[r]>> [serial 1062]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true

This Proof Obligation:

[serial 1064]: Threads::AutoBrake.i
P [76] << ( true )
  and true@now >>
S [76]->
Q [54] << true >>
Why created:    applied port output <<pre and M[r]@now>> -> <<post>> [serial 1062]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1014]: Threads::AutoBrake.i
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [78]->
Q [55] << true >>
Why created:     <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  42
#[serial 1014]  <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{};
step:  43
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1014]: Threads::AutoBrake.i
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [78]->
Q [55] << true >>
Why created:     <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{};

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1015]: Threads::AutoBrake.i
P [82] << not m_a'fresh >>
S [81]->
Q [54] << true >>
Why created:     <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  44
#[serial 1015]  <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{};
step:  45
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1015]: Threads::AutoBrake.i
P [82] << not m_a'fresh >>
S [81]->
Q [54] << true >>
Why created:     <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{};

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1016]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [86]  << GIVEN_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1 
  ;
  << i = 1 
    and ma = CMA >>
  iSeg := ma.seg[1 ]
  ;
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and GIVEN_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2 ]
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1 ]
    and GIVEN_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  46
#[serial 1016]  <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A};
step:  47
****reduce****
This proof obligation:

[serial 1016]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [86]  << GIVEN_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1 
  ;
  << i = 1 
    and ma = CMA >>
  iSeg := ma.seg[1 ]
  ;
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and GIVEN_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2 ]
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1 ]
    and GIVEN_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P3>> S3 <<Q3>>
 
was reduced to:

[serial 1065]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << GIVEN_CMA_IS_RMA() >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1016]


[serial 1066]: Threads::AutoBrake.i
P [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<Q4>> -> <<Q>> in sequential composition for [serial 1016]


[serial 1067]: Threads::AutoBrake.i
P [86] << GIVEN_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]


[serial 1068]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1 
Q [90] << i = 1 
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]


[serial 1069]: Threads::AutoBrake.i
P [90] << i = 1 
  and ma = CMA >>
S [91]iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:    <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016]


[serial 1070]: Threads::AutoBrake.i
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
Why created:    <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1065]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << GIVEN_CMA_IS_RMA() >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1016]


[serial 1066]: Threads::AutoBrake.i
P [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<Q4>> -> <<Q>> in sequential composition for [serial 1016]


[serial 1067]: Threads::AutoBrake.i
P [86] << GIVEN_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]


[serial 1068]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1 
Q [90] << i = 1 
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]


[serial 1069]: Threads::AutoBrake.i
P [90] << i = 1 
  and ma = CMA >>
S [91]iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:    <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016]


[serial 1070]: Threads::AutoBrake.i
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
Why created:    <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016]

done reducing composite actions
step:  48
****remove-givens-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1065]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << GIVEN_CMA_IS_RMA() >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1016]

Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1071]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
Why created:     add user-defined "givens" to postcondition

by removing "givens" from postconditions.

This proof obligation:

[serial 1069]: Threads::AutoBrake.i
P [90] << i = 1 
  and ma = CMA >>
S [91]iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:    <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016]

Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1072]: Threads::AutoBrake.i
P [90] << i = 1 
  and ma = CMA >>
S [91]iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:     add user-defined "givens" to postcondition

by removing "givens" from postconditions.

This proof obligation:

[serial 1070]: Threads::AutoBrake.i
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
Why created:    <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016]

Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1073]: Threads::AutoBrake.i
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:     add user-defined "givens" to postcondition

by removing "givens" from postconditions.

. . . done removing axioms from postconditions  [7.6 seconds ]
After "remove givens from postconditions" remaining 
Obligations:

[serial 1066]: Threads::AutoBrake.i
P [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<Q4>> -> <<Q>> in sequential composition for [serial 1016]


[serial 1067]: Threads::AutoBrake.i
P [86] << GIVEN_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]


[serial 1068]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1 
Q [90] << i = 1 
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]


[serial 1071]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
Why created:     add user-defined "givens" to postcondition


[serial 1072]: Threads::AutoBrake.i
P [90] << i = 1 
  and ma = CMA >>
S [91]iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:     add user-defined "givens" to postcondition


[serial 1073]: Threads::AutoBrake.i
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:     add user-defined "givens" to postcondition

Done removing givens from postconditions
step:  49
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1072]: Threads::AutoBrake.i
P [90] << i = 1 
  and ma = CMA >>
S [91]iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:     add user-defined "givens" to postcondition

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1074]: Threads::AutoBrake.i
P [90] << i = 1 
  and ma = CMA >>
S [91]iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:    laws applied to [serial 1072]


This Proof Obligation:

[serial 1073]: Threads::AutoBrake.i
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:     add user-defined "givens" to postcondition

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1075]: Threads::AutoBrake.i
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ] >>
Why created:    laws applied to [serial 1073]

. . . done Applying Laws [7.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1066]: Threads::AutoBrake.i
P [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<Q4>> -> <<Q>> in sequential composition for [serial 1016]


[serial 1067]: Threads::AutoBrake.i
P [86] << GIVEN_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]


[serial 1068]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1 
Q [90] << i = 1 
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]


[serial 1071]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
Why created:     add user-defined "givens" to postcondition


[serial 1074]: Threads::AutoBrake.i
P [90] << i = 1 
  and ma = CMA >>
S [91]iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:    laws applied to [serial 1072]


[serial 1075]: Threads::AutoBrake.i
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ] >>
Why created:    laws applied to [serial 1073]

Done applying laws
step:  50
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1066]: Threads::AutoBrake.i
P [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<Q4>> -> <<Q>> in sequential composition for [serial 1016]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1077]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1066]


This Proof Obligation:

[serial 1067]: Threads::AutoBrake.i
P [86] << GIVEN_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

Reason solved:  
   Equality Commutes. (eqcom)
Has been normalized to get:

[serial 1079]: Threads::AutoBrake.i
P [86] << GIVEN_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
Why created:      normalization of [serial 1067]


This Proof Obligation:

[serial 1068]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1 
Q [90] << i = 1 
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1081]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1 
Q [90] << CMA = ma
  and 1  = i >>
Why created:      normalization of [serial 1068]


This Proof Obligation:

[serial 1074]: Threads::AutoBrake.i
P [90] << i = 1 
  and ma = CMA >>
S [91]iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:    laws applied to [serial 1072]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1084]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]iSeg := ma.seg[1 ]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
Why created:      normalization of [serial 1074]


This Proof Obligation:

[serial 1075]: Threads::AutoBrake.i
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ] >>
Why created:    laws applied to [serial 1073]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1086]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
Why created:      normalization of [serial 1075]

. . . done Normalizing Unsolved Proof Obligations [7.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1071]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
Why created:     add user-defined "givens" to postcondition


[serial 1077]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1066]


[serial 1079]: Threads::AutoBrake.i
P [86] << GIVEN_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
Why created:      normalization of [serial 1067]


[serial 1081]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1 
Q [90] << CMA = ma
  and 1  = i >>
Why created:      normalization of [serial 1068]


[serial 1084]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]iSeg := ma.seg[1 ]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
Why created:      normalization of [serial 1074]


[serial 1086]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
Why created:      normalization of [serial 1075]

Done Normalizing
step:  51
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  52
#Threads::AutoBrake.i
step:  53
#[serial 1071]  add user-defined "givens" to postconditi
step:  54
****make-an****
Making obligation 14
Obligations:

[serial 1071]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
Why created:     add user-defined "givens" to postcondition

Done making obligation 14
step:  55
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1071]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
Why created:     add user-defined "givens" to postcondition

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1077]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1066]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  56
#[serial 1077]   normalization of [serial 1066]
step:  57
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1077]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1066]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1087]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]


[serial 1088]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]


[serial 1089]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]


[serial 1090]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]

. . . done splitting postcondition  [7.6 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1087]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]


[serial 1088]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]


[serial 1089]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]


[serial 1090]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]

Done splitting postcondition
step:  58
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1088]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1089]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1090]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1087]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]

Done trying to apply tautologies
step:  59
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1087]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1077]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1091]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1087]

. . . done substituting assertions' for Labels [7.6 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1091]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1087]

Done substituting Assertion labels in preconditions
step:  60
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1091]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1087]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1092]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57]->
Q [57] << i < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1091]

. . . done guided substitution of equals  [7.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1092]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57]->
Q [57] << i < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1091]

Done guided substituting an equals
step:  61
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1092]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57]->
Q [57] << i < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1091]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1094]: Threads::AutoBrake.i
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < ma.num_segments >>
Why created:      normalization of [serial 1092]

. . . done Normalizing Unsolved Proof Obligations [7.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1094]: Threads::AutoBrake.i
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < ma.num_segments >>
Why created:      normalization of [serial 1092]

Done Normalizing
step:  62
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  1  = i

This Proof Obligation:

[serial 1094]: Threads::AutoBrake.i
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < ma.num_segments >>
Why created:      normalization of [serial 1092]

Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "1 "
 to get:

[serial 1095]: Threads::AutoBrake.i
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1094]

. . . done guided substitution of equals  [7.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1095]: Threads::AutoBrake.i
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1094]

Done guided substituting an equals
step:  63
****guided-sub-equals****
guided substitution of equals "ma" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1095]: Threads::AutoBrake.i
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1094]

Reason solved:  Guided Substitution of Equals
Has substituted 
"ma" with its = "CMA"
 to get:

[serial 1096]: Threads::AutoBrake.i
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < CMA.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1095]

. . . done guided substitution of equals  [7.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1096]: Threads::AutoBrake.i
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < CMA.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1095]

Done guided substituting an equals
step:  64
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1096]: Threads::AutoBrake.i
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < CMA.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1095]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1079]: Threads::AutoBrake.i
P [86] << GIVEN_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
Why created:      normalization of [serial 1067]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  65
#[serial 1079]   normalization of [serial 1067]
step:  66
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1079]: Threads::AutoBrake.i
P [86] << GIVEN_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
Why created:      normalization of [serial 1067]

Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(m_a)>> -> <<post>> for <<pre>> m_a?(ma) <<post>> to get:

[serial 1097]: Threads::AutoBrake.i
P [87] << ( GIVEN_CMA_IS_RMA() )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
Why created:    applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1079]

. . . done applying atomic actions [7.6 seconds ]
After "atomic" remaining 
Obligations:

[serial 1097]: Threads::AutoBrake.i
P [87] << ( GIVEN_CMA_IS_RMA() )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
Why created:    applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1079]

Done reducing atomic actions
step:  67
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1097]: Threads::AutoBrake.i
P [87] << ( GIVEN_CMA_IS_RMA() )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
Why created:    applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1079]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1098]: Threads::AutoBrake.i
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1097]

. . . done substituting assertions' for Labels [7.6 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1098]: Threads::AutoBrake.i
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1097]

Done substituting Assertion labels in preconditions
step:  68
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1098]: Threads::AutoBrake.i
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1097]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1100]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << CMA = ma >>
Why created:      normalization of [serial 1098]

. . . done Normalizing Unsolved Proof Obligations [7.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1100]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << CMA = ma >>
Why created:      normalization of [serial 1098]

Done Normalizing
step:  69
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = RMA

This Proof Obligation:

[serial 1100]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << CMA = ma >>
Why created:      normalization of [serial 1098]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "RMA"
 to get:

[serial 1101]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << RMA = ma >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1100]

. . . done guided substitution of equals  [7.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1101]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << RMA = ma >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1100]

Done guided substituting an equals
step:  70
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1101]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << RMA = ma >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1100]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [7.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1081]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1 
Q [90] << CMA = ma
  and 1  = i >>
Why created:      normalization of [serial 1068]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  71
#[serial 1081]   normalization of [serial 1068]
step:  72
****atomic****
applying atomic actions . . .
solving assignment on line 89
replacing "i" with "1 "
makes:  << CMA = ma
  and 1  = 1  >>

This Proof Obligation:

[serial 1081]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1 
Q [90] << CMA = ma
  and 1  = i >>
Why created:      normalization of [serial 1068]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1102]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and 1  = 1  >>
Why created:    applied wp for assignment [serial 1081]

. . . done applying atomic actions [7.6 seconds ]
After "atomic" remaining 
Obligations:

[serial 1102]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and 1  = 1  >>
Why created:    applied wp for assignment [serial 1081]

Done reducing atomic actions
step:  73
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1102]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and 1  = 1  >>
Why created:    applied wp for assignment [serial 1081]

Reason solved:  
   Law of identity. (eqid)

Has applied Law of identity. (eqid)
   to get:

[serial 1103]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and true >>
Why created:    laws applied to [serial 1102]

. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1103]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and true >>
Why created:    laws applied to [serial 1102]

Done applying laws
step:  74
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1103]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and true >>
Why created:    laws applied to [serial 1102]

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1104]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << ( CMA = ma ) >>
Why created:    laws applied to [serial 1103]

. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1104]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << ( CMA = ma ) >>
Why created:    laws applied to [serial 1103]

Done applying laws
step:  75
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1104]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << ( CMA = ma ) >>
Why created:    laws applied to [serial 1103]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1106]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma >>
Why created:      normalization of [serial 1104]

. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1106]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma >>
Why created:      normalization of [serial 1104]

Done Normalizing
step:  76
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1106]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma >>
Why created:      normalization of [serial 1104]

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [7.7 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1084]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]iSeg := ma.seg[1 ]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
Why created:      normalization of [serial 1074]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  77
#[serial 1084]   normalization of [serial 1074]
step:  78
****atomic****
applying atomic actions . . .
solving assignment on line 91
replacing "iSeg" with "ma.seg[1 ]"
makes:  << CMA = ma
  and CMA.seg[i] = ma.seg[1 ]
  and 1  = i >>

This Proof Obligation:

[serial 1084]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]iSeg := ma.seg[1 ]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
Why created:      normalization of [serial 1074]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1107]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1 ]
  and 1  = i >>
Why created:    applied wp for assignment [serial 1084]

. . . done applying atomic actions [7.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 1107]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1 ]
  and 1  = i >>
Why created:    applied wp for assignment [serial 1084]

Done reducing atomic actions
step:  79
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1107]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1 ]
  and 1  = i >>
Why created:    applied wp for assignment [serial 1084]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1108]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]


[serial 1109]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]


[serial 1110]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << 1  = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]

. . . done splitting postcondition  [7.7 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1108]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]


[serial 1109]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]


[serial 1110]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << 1  = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]

Done splitting postcondition
step:  80
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1108]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1110]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << 1  = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [7.7 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1109]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]

Done trying to apply tautologies
step:  81
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1109]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1107]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1111]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << ma.seg[i] = ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1109]

. . . done guided substitution of equals  [7.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1111]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << ma.seg[i] = ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1109]

Done guided substituting an equals
step:  82
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  1  = i

This Proof Obligation:

[serial 1111]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << ma.seg[i] = ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1109]

Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "1 "
 to get:

[serial 1112]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1111]

. . . done guided substitution of equals  [7.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1112]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1111]

Done guided substituting an equals
step:  83
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1112]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1111]

Reason solved:  
   Law of identity. (eqid)

Has applied Law of identity. (eqid)
   to get:

[serial 1113]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << true >>
Why created:    laws applied to [serial 1112]

. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1113]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << true >>
Why created:    laws applied to [serial 1112]

Done applying laws
step:  84
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1113]: Threads::AutoBrake.i
P [90] << CMA = ma
  and 1  = i >>
S [91]->
Q [92] << true >>
Why created:    laws applied to [serial 1112]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.7 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1086]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
Why created:      normalization of [serial 1075]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  85
#[serial 1086]   normalization of [serial 1075]
step:  86
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  1  = i

This Proof Obligation:

[serial 1086]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
Why created:      normalization of [serial 1075]

Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "1 "
 to get:

[serial 1114]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1  + 1 ] = nSeg
  and CMA.seg[1 ] = iSeg
  and 1  = 1  >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1086]

. . . done guided substitution of equals  [7.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1114]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1  + 1 ] = nSeg
  and CMA.seg[1 ] = iSeg
  and 1  = 1  >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1086]

Done guided substituting an equals
step:  87
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1114]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1  + 1 ] = nSeg
  and CMA.seg[1 ] = iSeg
  and 1  = 1  >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1086]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1116]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1 ] = iSeg
  and CMA.seg[2 ] = nSeg
  and 1  = 1  >>
Why created:      normalization of [serial 1114]

. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1116]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1 ] = iSeg
  and CMA.seg[2 ] = nSeg
  and 1  = 1  >>
Why created:      normalization of [serial 1114]

Done Normalizing
step:  88
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1116]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << CMA = ma
  and CMA.seg[1 ] = iSeg
  and CMA.seg[2 ] = nSeg
  and 1  = 1  >>
Why created:      normalization of [serial 1114]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1117]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << ma = ma
  and ma.seg[1 ] = iSeg
  and ma.seg[2 ] = nSeg
  and 1  = 1  >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1116]

. . . done guided substitution of equals  [7.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1117]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << ma = ma
  and ma.seg[1 ] = iSeg
  and ma.seg[2 ] = nSeg
  and 1  = 1  >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1116]

Done guided substituting an equals
step:  89
****atomic****
applying atomic actions . . .
solving assignment on line 94
replacing "nSeg" with "ma.seg[2 ]"
makes:  << ma = ma
  and ma.seg[1 ] = iSeg
  and ma.seg[2 ] = ma.seg[2 ]
  and 1  = 1  >>

This Proof Obligation:

[serial 1117]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2 ]
Q [95] << ma = ma
  and ma.seg[1 ] = iSeg
  and ma.seg[2 ] = nSeg
  and 1  = 1  >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1116]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1118]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ma = ma
  and ma.seg[1 ] = iSeg
  and ma.seg[2 ] = ma.seg[2 ]
  and 1  = 1  >>
Why created:    applied wp for assignment [serial 1117]

. . . done applying atomic actions [7.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 1118]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ma = ma
  and ma.seg[1 ] = iSeg
  and ma.seg[2 ] = ma.seg[2 ]
  and 1  = 1  >>
Why created:    applied wp for assignment [serial 1117]

Done reducing atomic actions
step:  90
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1118]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ma = ma
  and ma.seg[1 ] = iSeg
  and ma.seg[2 ] = ma.seg[2 ]
  and 1  = 1  >>
Why created:    applied wp for assignment [serial 1117]

Reason solved:  
   Law of identity. (eqid)

Has applied Law of identity. (eqid)
   to get:

[serial 1119]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << true
  and ma.seg[1 ] = iSeg
  and true
  and true >>
Why created:    laws applied to [serial 1118]

. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1119]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << true
  and ma.seg[1 ] = iSeg
  and true
  and true >>
Why created:    laws applied to [serial 1118]

Done applying laws
step:  91
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1119]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << true
  and ma.seg[1 ] = iSeg
  and true
  and true >>
Why created:    laws applied to [serial 1118]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1121]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = ma.seg[1 ]
  and true
  and true
  and true >>
Why created:      normalization of [serial 1119]

. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1121]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = ma.seg[1 ]
  and true
  and true
  and true >>
Why created:      normalization of [serial 1119]

Done Normalizing
step:  92
****guided-sub-equals****
guided substitution of equals "ma" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1121]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = ma.seg[1 ]
  and true
  and true
  and true >>
Why created:      normalization of [serial 1119]

Reason solved:  Guided Substitution of Equals
Has substituted 
"ma" with its = "CMA"
 to get:

[serial 1122]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = CMA.seg[1 ]
  and true
  and true
  and true >>
Why created:    Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1121]

. . . done guided substitution of equals  [7.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1122]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = CMA.seg[1 ]
  and true
  and true
  and true >>
Why created:    Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1121]

Done guided substituting an equals
step:  93
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1122]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = CMA.seg[1 ]
  and true
  and true
  and true >>
Why created:    Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1121]

Reason solved:  
   Equality Commutes. (eqcom)
Has been normalized to get:

[serial 1124]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[1 ] = iSeg
  and true
  and true
  and true >>
Why created:      normalization of [serial 1122]

. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1124]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[1 ] = iSeg
  and true
  and true
  and true >>
Why created:      normalization of [serial 1122]

Done Normalizing
step:  94
****guided-sub-equals****
guided substitution of equals "1 " . . .
equality selected for substitution:  1  = i

This Proof Obligation:

[serial 1124]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[1 ] = iSeg
  and true
  and true
  and true >>
Why created:      normalization of [serial 1122]

Reason solved:  Guided Substitution of Equals
Has substituted 
"1 " with its = "i"
 to get:

[serial 1125]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[i] = iSeg
  and true
  and true
  and true >>
Why created:    Guided Substitution of Equals 
 replacing "1 " with its = "i" in its postcondition [serial 1124]

. . . done guided substitution of equals  [7.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1125]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[i] = iSeg
  and true
  and true
  and true >>
Why created:    Guided Substitution of Equals 
 replacing "1 " with its = "i" in its postcondition [serial 1124]

Done guided substituting an equals
step:  95
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1125]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[i] = iSeg
  and true
  and true
  and true >>
Why created:    Guided Substitution of Equals 
 replacing "1 " with its = "i" in its postcondition [serial 1124]

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1126]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ( CMA.seg[i] = iSeg ) >>
Why created:    laws applied to [serial 1125]

. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1126]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ( CMA.seg[i] = iSeg ) >>
Why created:    laws applied to [serial 1125]

Done applying laws
step:  96
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1126]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ( CMA.seg[i] = iSeg ) >>
Why created:    laws applied to [serial 1125]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [7.7 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1017]: Threads::AutoBrake.i
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  97
#[serial 1017]  <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A};
step:  98
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1017]: Threads::AutoBrake.i
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A};

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1127]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1017]

. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1127]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1017]

Done applying laws
step:  99
****reduce****

[serial 1128]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1127]


[serial 1129]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1127]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1128]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1127]


[serial 1129]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1127]

done reducing composite actions
step:  100
****reduce****
This proof obligation:

[serial 1129]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1127]

as <<P>> if (B1)-><<P1>>S1<<Q1>> [] (B2)-><<P2>>S2<<Q2>> [] . . . [] (Bn)-><<Pn>>Sn<<Qn>> fi <<Q>> 

was reduced to:

[serial 1130]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:      <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1129]


[serial 1131]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B0>> S0 <<Q>> in alternative for [serial 1129]


[serial 1132]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B1>> S1 <<Q>> in alternative for [serial 1129]


[serial 1133]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B2>> S2 <<Q>> in alternative for [serial 1129]


[serial 1134]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B3>> S3 <<Q>> in alternative for [serial 1129]


[serial 1135]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [124]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B4>> S4 <<Q>> in alternative for [serial 1129]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1128]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1127]


[serial 1130]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:      <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1129]


[serial 1131]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B0>> S0 <<Q>> in alternative for [serial 1129]


[serial 1132]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B1>> S1 <<Q>> in alternative for [serial 1129]


[serial 1133]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B2>> S2 <<Q>> in alternative for [serial 1129]


[serial 1134]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B3>> S3 <<Q>> in alternative for [serial 1129]


[serial 1135]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [124]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B4>> S4 <<Q>> in alternative for [serial 1129]

done reducing composite actions
step:  101
****reduce****
Reducing Behavior Action Block, simple:

[serial 1131]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B0>> S0 <<Q>> in alternative for [serial 1129]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1136]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1131]

Reducing Behavior Action Block, simple:

[serial 1132]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B1>> S1 <<Q>> in alternative for [serial 1129]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1137]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1132]

Reducing Behavior Action Block, simple:

[serial 1133]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B2>> S2 <<Q>> in alternative for [serial 1129]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1138]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1133]

Reducing Behavior Action Block, simple:

[serial 1134]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B3>> S3 <<Q>> in alternative for [serial 1129]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1139]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1134]

Reducing Behavior Action Block, simple:

[serial 1135]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [124]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:      <<P and B4>> S4 <<Q>> in alternative for [serial 1129]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1140]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1135]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1128]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1127]


[serial 1130]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:      <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1129]


[serial 1136]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1131]


[serial 1137]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1132]


[serial 1138]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1133]


[serial 1139]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1134]


[serial 1140]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1135]

done reducing composite actions
step:  102
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  103
#Threads::AutoBrake.i
step:  104
#[serial 1133] as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 113
step:  105
****make-an****
Making obligation 21
Obligations:

[serial 1128]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1127]

Done making obligation 21
step:  106
****remove-givens-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1128]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1127]

Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1141]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and true
  and true
  and true
  and true >>
Why created:     add user-defined "givens" to postcondition

by removing "givens" from postconditions.

. . . done removing axioms from postconditions  [7.7 seconds ]
After "remove givens from postconditions" remaining 
Obligations:

[serial 1141]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and true
  and true
  and true
  and true >>
Why created:     add user-defined "givens" to postcondition

Done removing givens from postconditions
step:  107
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1141]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and true
  and true
  and true
  and true >>
Why created:     add user-defined "givens" to postcondition

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1142]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1141]

. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1142]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1141]

Done applying laws
step:  108
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1142]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1141]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [7.7 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1130]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:      <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1129]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  109
#[serial 1135]   <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1134]
step:  110
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1130]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:      <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1129]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1144]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1130]

. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1144]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1130]

Done Normalizing
step:  111
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1144]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1130]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1145]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) ) or ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) ) or ( not ( v*v < ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) >>
Why created:    Replacing <= with not < of [serial 1144]

. . . Substituting <= with not < [7.7 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1145]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) ) or ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) ) or ( not ( v*v < ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) >>
Why created:    Replacing <= with not < of [serial 1144]

Done replacing a<=b with (not b<a)
step:  112
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1145]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) ) or ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) ) or ( not ( v*v < ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) >>
Why created:    Replacing <= with not < of [serial 1144]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1147]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1145]

. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1147]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1145]

Done Normalizing
step:  113
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1147]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1145]

Reason solved:  
   Distribution and-over-or with wff lists. (bl.dba2owl)
Has applied Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into conjunctive normal form to get:

[serial 1148]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or not ( v < iSeg.v_n ) or not ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) ) >>
Why created:    Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1147]

. . . done putting into conjunctive normal form [7.8 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1148]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or not ( v < iSeg.v_n ) or not ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) ) >>
Why created:    Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1147]

Done making conjunctive normal forms.
step:  114
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1148]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or not ( v < iSeg.v_n ) or not ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) ) >>
Why created:    Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1147]

Reason solved:  
   Law of Excluded middle. (exmid)

Has applied Law of Excluded middle. (exmid)
   to get:

[serial 1149]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:    laws applied to [serial 1148]

. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1149]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:    laws applied to [serial 1148]

Done applying laws
step:  115
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1149]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:    laws applied to [serial 1148]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1151]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true >>
Why created:      normalization of [serial 1149]

. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1151]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true >>
Why created:      normalization of [serial 1149]

Done Normalizing
step:  116
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1151]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true >>
Why created:      normalization of [serial 1149]

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1152]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << true >>
Why created:    laws applied to [serial 1151]

. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1152]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << true >>
Why created:    laws applied to [serial 1151]

Done applying laws
step:  117
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1152]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [105]->
Q [105] << true >>
Why created:    laws applied to [serial 1151]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [7.8 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1136]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1131]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  118
#[serial 1141] <<P>> T <<Q>> in behavior action block for [serial 1136]
step:  119
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1136]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1131]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1153]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1136]

. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1153]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1136]

Done applying laws
step:  120
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1153]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1136]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1155]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1153]

. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1155]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1153]

Done Normalizing
step:  121
****reduce****

Reducing Concurrent Computation of:

[serial 1155]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1153]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1156]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]eb!(true)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1155]


[serial 1157]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1155]


[serial 1158]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1155]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1156]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]eb!(true)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1155]


[serial 1157]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1155]


[serial 1158]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1155]

done reducing composite actions
step:  122
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1156]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]eb!(true)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1155]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1159]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1156]


The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1160]: Threads::AutoBrake.i
P [107] << ( i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( EB() )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1156]

Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1157]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1155]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1161]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1157]


The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1162]: Threads::AutoBrake.i
P [107] << ( i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1157]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1158]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1155]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=0.0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1163]: Threads::AutoBrake.i
P [107] << ( i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1158]

Has applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>>where (( SB() or EB() ))-> 0.0 mpss for ca!(0.0 mpss) to get:

[serial 1164]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1158]

. . . done applying atomic actions [7.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1159]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1156]


[serial 1160]: Threads::AutoBrake.i
P [107] << ( i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( EB() )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1156]


[serial 1161]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1157]


[serial 1162]: Threads::AutoBrake.i
P [107] << ( i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1157]


[serial 1163]: Threads::AutoBrake.i
P [107] << ( i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1158]


[serial 1164]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1158]

Done reducing atomic actions
step:  123
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1160]: Threads::AutoBrake.i
P [107] << ( i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( EB() )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1156]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1165]: Threads::AutoBrake.i
P [107] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( EB() )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1160]


This Proof Obligation:

[serial 1162]: Threads::AutoBrake.i
P [107] << ( i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1157]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1166]: Threads::AutoBrake.i
P [107] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1162]


This Proof Obligation:

[serial 1163]: Threads::AutoBrake.i
P [107] << ( i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1158]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1167]: Threads::AutoBrake.i
P [107] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1163]

. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1159]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1156]


[serial 1161]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1157]


[serial 1164]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1158]


[serial 1165]: Threads::AutoBrake.i
P [107] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( EB() )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1160]


[serial 1166]: Threads::AutoBrake.i
P [107] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1162]


[serial 1167]: Threads::AutoBrake.i
P [107] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1163]

Done applying laws
step:  124
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1165]: Threads::AutoBrake.i
P [107] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( EB() )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1160]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1166]: Threads::AutoBrake.i
P [107] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1162]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1167]: Threads::AutoBrake.i
P [107] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [107]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1163]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [7.8 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1159]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1156]


[serial 1161]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1157]


[serial 1164]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1158]

Done trying to apply tautologies
step:  125
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1161]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1157]

Reason solved:  
   Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
Has applied Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   to get:

[serial 1168]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1161]

. . . done applying DeMorgan's Law  [7.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1159]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1156]


[serial 1164]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1158]


[serial 1168]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1161]

step:  126
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1164]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1158]

Reasons solved:  
   [Add unnecessary parentheses]
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1171]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1164]


This Proof Obligation:

[serial 1168]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1161]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1173]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << EB() or not SB() >>
Why created:      normalization of [serial 1168]

. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1159]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1156]


[serial 1171]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1164]


[serial 1173]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << EB() or not SB() >>
Why created:      normalization of [serial 1168]

Done Normalizing
step:  127
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1159]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1156]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1174]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [107]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1159]


This Proof Obligation:

[serial 1171]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1164]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1175]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [107]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1171]


This Proof Obligation:

[serial 1173]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [107]->
Q [107] << EB() or not SB() >>
Why created:      normalization of [serial 1168]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1176]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [107]->
Q [107] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1173]

. . . done substituting assertions' for Labels [7.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 1174]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [107]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1159]


[serial 1175]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [107]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1171]


[serial 1176]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [107]->
Q [107] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1173]

Done substituting Assertion labels.
step:  128
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1174]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [107]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1159]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1178]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1174]


This Proof Obligation:

[serial 1175]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [107]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1171]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1180]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1175]


This Proof Obligation:

[serial 1176]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [107]->
Q [107] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1173]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1182]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [107] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1176]

. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1178]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1174]


[serial 1180]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1175]


[serial 1182]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [107] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1176]

Done Normalizing
step:  129
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1180]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1175]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1183]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1180]


This Proof Obligation:

[serial 1182]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [107] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1176]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1184]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [107] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1182]

. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1178]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1174]


[serial 1183]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1180]


[serial 1184]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [107] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1182]

Done applying laws
step:  130
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1178]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1174]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1183]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1180]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1184]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [107]->
Q [107] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1182]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Tautologies [7.9 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1137]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1132]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  131
#[serial 1142] <<P>> T <<Q>> in behavior action block for [serial 1137]
step:  132
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1137]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1132]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1185]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1137]

. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1185]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1137]

Done applying laws
step:  133
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1185]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1137]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Multiplication Commutes. (bl.mulcom)
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1187]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1185]

. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1187]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1185]

Done Normalizing
step:  134
****reduce****

Reducing Concurrent Computation of:

[serial 1187]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1185]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1188]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]eb!(true)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1187]


[serial 1189]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1187]


[serial 1190]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1187]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1188]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]eb!(true)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1187]


[serial 1189]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1187]


[serial 1190]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1187]

done reducing composite actions
step:  135
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1188]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]eb!(true)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1187]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1191]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]


The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1192]: Threads::AutoBrake.i
P [110] << ( i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( EB() )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]

Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1189]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1187]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1193]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]


The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1194]: Threads::AutoBrake.i
P [110] << ( i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1190]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1187]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=0.0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1195]: Threads::AutoBrake.i
P [110] << ( i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1190]

Has applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>>where (( SB() or EB() ))-> 0.0 mpss for ca!(0.0 mpss) to get:

[serial 1196]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1190]

. . . done applying atomic actions [7.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]


[serial 1192]: Threads::AutoBrake.i
P [110] << ( i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( EB() )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]


[serial 1193]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]


[serial 1194]: Threads::AutoBrake.i
P [110] << ( i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]


[serial 1195]: Threads::AutoBrake.i
P [110] << ( i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1190]


[serial 1196]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1190]

Done reducing atomic actions
step:  136
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1192]: Threads::AutoBrake.i
P [110] << ( i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( EB() )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1197]: Threads::AutoBrake.i
P [110] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( EB() )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1192]


This Proof Obligation:

[serial 1194]: Threads::AutoBrake.i
P [110] << ( i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1198]: Threads::AutoBrake.i
P [110] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1194]


This Proof Obligation:

[serial 1195]: Threads::AutoBrake.i
P [110] << ( i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1190]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1199]: Threads::AutoBrake.i
P [110] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1195]

. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]


[serial 1193]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]


[serial 1196]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1190]


[serial 1197]: Threads::AutoBrake.i
P [110] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( EB() )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1192]


[serial 1198]: Threads::AutoBrake.i
P [110] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1194]


[serial 1199]: Threads::AutoBrake.i
P [110] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1195]

Done applying laws
step:  137
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1197]: Threads::AutoBrake.i
P [110] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( EB() )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1192]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1198]: Threads::AutoBrake.i
P [110] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1194]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1199]: Threads::AutoBrake.i
P [110] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [110]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1195]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [7.9 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]


[serial 1193]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]


[serial 1196]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1190]

Done trying to apply tautologies
step:  138
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1191]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1200]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [110]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1191]


This Proof Obligation:

[serial 1193]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1201]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [110]->
Q [110] << not ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1193]


This Proof Obligation:

[serial 1196]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [110]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1190]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1202]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [110]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1196]

. . . done substituting assertions' for Labels [7.9 seconds ]
After "substitute" remaining 
Obligations:

[serial 1200]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [110]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1191]


[serial 1201]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [110]->
Q [110] << not ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1193]


[serial 1202]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [110]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1196]

Done substituting Assertion labels.
step:  139
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1200]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [110]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1191]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1204]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1200]


This Proof Obligation:

[serial 1201]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [110]->
Q [110] << not ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1193]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1206]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) ) >>
Why created:      normalization of [serial 1201]


This Proof Obligation:

[serial 1202]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [110]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1196]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1208]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1202]

. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1204]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1200]


[serial 1206]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) ) >>
Why created:      normalization of [serial 1201]


[serial 1208]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1202]

Done Normalizing
step:  140
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1204]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1200]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Tautologies [7.9 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1206]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) ) >>
Why created:      normalization of [serial 1201]


[serial 1208]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1202]

Done trying to apply tautologies
step:  141
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1206]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) ) >>
Why created:      normalization of [serial 1201]

Reasons solved:  
   Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1209]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) ) or 
not ( ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1206]

. . . done applying DeMorgan's Law  [7.9 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1208]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1202]


[serial 1209]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) ) or 
not ( ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1206]

step:  142
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1209]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) ) or 
not ( ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1206]

Reasons solved:  
   [Add unnecessary parentheses]
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1212]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) or not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= 
v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1209]

. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1208]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1202]


[serial 1212]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) or not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= 
v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1209]

Done Normalizing
step:  143
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1212]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) or not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= 
v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1209]

Reasons solved:  
   Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1213]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v ) ) or not ( not ( iSeg.v_e <= v ) ) ) or 
( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1212]

. . . done applying DeMorgan's Law  [7.9 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1208]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1202]


[serial 1213]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v ) ) or not ( not ( iSeg.v_e <= v ) ) ) or 
( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1212]

step:  144
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1213]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v ) ) or not ( not ( iSeg.v_e <= v ) ) ) or 
( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1212]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1216]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) or ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= 
v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1213]

. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1208]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1202]


[serial 1216]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) or ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= 
v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1213]

Done Normalizing
step:  145
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1208]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1202]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1217]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1208]


This Proof Obligation:

[serial 1216]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) or ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= 
v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1213]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1218]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or ( not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    laws applied to [serial 1216]

. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1217]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1208]


[serial 1218]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or ( not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    laws applied to [serial 1216]

Done applying laws
step:  146
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1217]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1208]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1218]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [110]->
Q [110] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or ( not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    laws applied to [serial 1216]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Tautologies [7.9 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1138]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1133]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  147
#[serial 1143] <<P>> T <<Q>> in behavior action block for [serial 1138]
step:  148
****reduce****

Reducing Concurrent Computation of:

[serial 1138]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1133]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1219]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1138]


[serial 1220]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1138]


[serial 1221]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1138]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1219]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1138]


[serial 1220]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1138]


[serial 1221]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1138]

done reducing composite actions
step:  149
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1219]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1138]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1222]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1219]


The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1223]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1219]

Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1220]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1138]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1224]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]->
Q [114] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1220]


The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1225]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1220]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1221]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1138]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=0.0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1226]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )
  and ( ca = 0.0 mpss )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1221]

Has applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>>where (( SB() or EB() ))-> 0.0 mpss for ca!(0.0 mpss) to get:

[serial 1227]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1221]

. . . done applying atomic actions [7.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 1222]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1219]


[serial 1223]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1219]


[serial 1224]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]->
Q [114] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1220]


[serial 1225]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1220]


[serial 1226]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )
  and ( ca = 0.0 mpss )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1221]


[serial 1227]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1221]

Done reducing atomic actions
step:  150
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1222]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1219]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1228]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
Why created:    laws applied to [serial 1222]


This Proof Obligation:

[serial 1223]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1219]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1229]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1223]


This Proof Obligation:

[serial 1224]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]->
Q [114] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1220]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1230]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
S [114]->
Q [114] << not EB() >>
Why created:    laws applied to [serial 1224]


This Proof Obligation:

[serial 1225]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1220]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1231]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1225]


This Proof Obligation:

[serial 1226]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )
  and ( ca = 0.0 mpss )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1221]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1232]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) )
  and ( ca = 0.0 mpss )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1226]


This Proof Obligation:

[serial 1227]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [114]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1221]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1233]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
S [114]->
Q [33] << ( SB() or EB() ) >>
Why created:    laws applied to [serial 1227]

. . . done Applying Laws [8.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1228]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
Why created:    laws applied to [serial 1222]


[serial 1229]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1223]


[serial 1230]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
S [114]->
Q [114] << not EB() >>
Why created:    laws applied to [serial 1224]


[serial 1231]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1225]


[serial 1232]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) )
  and ( ca = 0.0 mpss )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1226]


[serial 1233]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
S [114]->
Q [33] << ( SB() or EB() ) >>
Why created:    laws applied to [serial 1227]

Done applying laws
step:  151
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1228]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
Why created:    laws applied to [serial 1222]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1235]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [114]->
Q [12] << SB()
  and not EB() >>
Why created:      normalization of [serial 1228]


This Proof Obligation:

[serial 1229]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1223]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1237]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1229]


This Proof Obligation:

[serial 1230]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
S [114]->
Q [114] << not EB() >>
Why created:    laws applied to [serial 1224]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1239]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [114]->
Q [114] << not EB() >>
Why created:      normalization of [serial 1230]


This Proof Obligation:

[serial 1231]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1225]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1241]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1231]


This Proof Obligation:

[serial 1232]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) )
  and ( ca = 0.0 mpss )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1226]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1243]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1232]


This Proof Obligation:

[serial 1233]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
S [114]->
Q [33] << ( SB() or EB() ) >>
Why created:    laws applied to [serial 1227]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1245]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [114]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1233]

. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1235]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [114]->
Q [12] << SB()
  and not EB() >>
Why created:      normalization of [serial 1228]


[serial 1237]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1229]


[serial 1239]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [114]->
Q [114] << not EB() >>
Why created:      normalization of [serial 1230]


[serial 1241]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1231]


[serial 1243]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1232]


[serial 1245]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [114]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1233]

Done Normalizing
step:  152
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1235]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [114]->
Q [12] << SB()
  and not EB() >>
Why created:      normalization of [serial 1228]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1246]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [114]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1235]


This Proof Obligation:

[serial 1237]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1229]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1247]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1237]


This Proof Obligation:

[serial 1239]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [114]->
Q [114] << not EB() >>
Why created:      normalization of [serial 1230]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1248]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [114]->
Q [114] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1239]


This Proof Obligation:

[serial 1241]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1231]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1249]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1241]


This Proof Obligation:

[serial 1243]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1232]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1250]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1243]


This Proof Obligation:

[serial 1245]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [114]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1233]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1251]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [114]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1245]

. . . done substituting assertions' for Labels [8.0 seconds ]
After "substitute" remaining 
Obligations:

[serial 1246]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [114]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1235]


[serial 1247]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1237]


[serial 1248]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [114]->
Q [114] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1239]


[serial 1249]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1241]


[serial 1250]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1243]


[serial 1251]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [114]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1245]

Done substituting Assertion labels.
step:  153
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1246]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [114]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1235]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1253]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1246]


This Proof Obligation:

[serial 1247]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1237]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1255]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1247]


This Proof Obligation:

[serial 1248]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [114]->
Q [114] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1239]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1257]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [114] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1248]


This Proof Obligation:

[serial 1249]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1241]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1259]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1249]


This Proof Obligation:

[serial 1250]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1243]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1261]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1250]


This Proof Obligation:

[serial 1251]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [114]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1245]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1263]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1251]

. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1253]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1246]


[serial 1255]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1247]


[serial 1257]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [114] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1248]


[serial 1259]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1249]


[serial 1261]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1250]


[serial 1263]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1251]

Done Normalizing
step:  154
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1253]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1246]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1264]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1253]


This Proof Obligation:

[serial 1255]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1247]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1265]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1255]


This Proof Obligation:

[serial 1257]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [114] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1248]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1266]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [114] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1257]


This Proof Obligation:

[serial 1259]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1249]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1267]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1259]


This Proof Obligation:

[serial 1261]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1250]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1268]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1261]


This Proof Obligation:

[serial 1263]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1251]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1269]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1263]

. . . Substituting <= with not < [8.0 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1264]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1253]


[serial 1265]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1255]


[serial 1266]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [114] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1257]


[serial 1267]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1259]


[serial 1268]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1261]


[serial 1269]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1263]

Done replacing a<=b with (not b<a)
step:  155
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1264]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1253]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1271]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1264]


This Proof Obligation:

[serial 1265]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1255]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1273]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1265]


This Proof Obligation:

[serial 1266]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [114] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1257]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1275]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1266]


This Proof Obligation:

[serial 1267]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1259]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1277]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1267]


This Proof Obligation:

[serial 1268]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1261]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1279]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1268]


This Proof Obligation:

[serial 1269]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [114]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1263]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1281]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1269]

. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1271]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1264]


[serial 1273]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1265]


[serial 1275]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1266]


[serial 1277]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1267]


[serial 1279]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1268]


[serial 1281]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1269]

Done Normalizing
step:  156
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1271]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1264]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1282]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1271]


This Proof Obligation:

[serial 1273]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1265]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1283]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1273]


This Proof Obligation:

[serial 1275]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1266]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1284]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1275]


This Proof Obligation:

[serial 1277]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1267]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1285]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1277]

. . . done applying DeMorgan's Law  [8.1 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1279]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1268]


[serial 1281]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1269]


[serial 1282]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1271]


[serial 1283]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1273]


[serial 1284]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1275]


[serial 1285]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1277]

step:  157
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1282]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1271]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1289]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1282]


This Proof Obligation:

[serial 1283]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1273]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1291]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1283]


This Proof Obligation:

[serial 1284]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1275]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
Has been normalized to get:

[serial 1293]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1284]


This Proof Obligation:

[serial 1285]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1277]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
Has been normalized to get:

[serial 1295]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1285]

. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1279]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1268]


[serial 1281]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1269]


[serial 1289]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1282]


[serial 1291]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1283]


[serial 1293]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1284]


[serial 1295]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1285]

Done Normalizing
step:  158
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1279]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1268]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1296]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1279]


This Proof Obligation:

[serial 1281]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1269]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1297]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1281]


This Proof Obligation:

[serial 1289]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1282]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1298]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1289]


This Proof Obligation:

[serial 1291]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1283]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1299]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1291]


This Proof Obligation:

[serial 1295]: Threads::AutoBrake.i
P [114] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1285]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1300]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1295]

. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1293]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1284]


[serial 1296]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1279]


[serial 1297]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1281]


[serial 1298]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1289]


[serial 1299]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1291]


[serial 1300]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1295]

Done applying laws
step:  159
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1296]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1279]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1303]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1296]


This Proof Obligation:

[serial 1297]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1281]

Reason solved:  
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1305]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1297]


This Proof Obligation:

[serial 1298]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1289]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1307]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1298]


This Proof Obligation:

[serial 1299]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1291]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1309]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1299]


This Proof Obligation:

[serial 1300]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1295]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1311]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1300]

. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1293]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1284]


[serial 1303]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1296]


[serial 1305]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1297]


[serial 1307]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1298]


[serial 1309]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1299]


[serial 1311]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1300]

Done Normalizing
step:  160
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1293]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1284]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1303]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1296]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1305]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1297]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1309]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1299]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1311]: Threads::AutoBrake.i
P [114] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1300]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.1 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1307]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1298]

Done trying to apply tautologies
step:  161
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1307]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1298]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1312]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]


[serial 1313]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]


[serial 1314]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]

. . . done splitting postcondition  [8.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1312]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]


[serial 1313]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]


[serial 1314]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]

Done splitting postcondition
step:  162
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1313]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1314]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.1 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1312]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]

Done trying to apply tautologies
step:  163
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1312]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1307]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1316]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1312]

. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1316]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1312]

Done Normalizing
step:  164
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1316]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v < iSeg.v_n ) >>
S [114]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1312]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Tautologies [8.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1139]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1134]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  165
#[serial 1144] <<P>> T <<Q>> in behavior action block for [serial 1139]
step:  166
****reduce****

Reducing Concurrent Computation of:

[serial 1139]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1134]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1317]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1139]


[serial 1318]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1139]


[serial 1319]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1139]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1317]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1139]


[serial 1318]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1139]


[serial 1319]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1139]

done reducing composite actions
step:  167
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1317]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1139]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1320]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1317]


The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1321]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1317]

Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1318]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1139]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1322]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]->
Q [119] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1318]


The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1323]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1318]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1319]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]ca!(0.0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1139]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=0.0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1324]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) )
  and ( ca = 0.0 mpss )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1319]

Has applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>>where (( SB() or EB() ))-> 0.0 mpss for ca!(0.0 mpss) to get:

[serial 1325]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1319]

. . . done applying atomic actions [8.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1320]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1317]


[serial 1321]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1317]


[serial 1322]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]->
Q [119] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1318]


[serial 1323]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1318]


[serial 1324]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) )
  and ( ca = 0.0 mpss )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1319]


[serial 1325]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1319]

Done reducing atomic actions
step:  168
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1320]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1317]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1326]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
Why created:    laws applied to [serial 1320]


This Proof Obligation:

[serial 1321]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1317]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1327]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1321]


This Proof Obligation:

[serial 1322]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]->
Q [119] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1318]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1328]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) >>
S [119]->
Q [119] << not EB() >>
Why created:    laws applied to [serial 1322]


This Proof Obligation:

[serial 1323]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1318]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1329]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1323]


This Proof Obligation:

[serial 1324]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) )
  and ( ca = 0.0 mpss )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1319]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1330]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and ( ca = 0.0 mpss )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1324]


This Proof Obligation:

[serial 1325]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [119]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1319]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1331]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) >>
S [119]->
Q [33] << ( SB() or EB() ) >>
Why created:    laws applied to [serial 1325]

. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1326]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
Why created:    laws applied to [serial 1320]


[serial 1327]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1321]


[serial 1328]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) >>
S [119]->
Q [119] << not EB() >>
Why created:    laws applied to [serial 1322]


[serial 1329]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1323]


[serial 1330]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and ( ca = 0.0 mpss )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1324]


[serial 1331]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) >>
S [119]->
Q [33] << ( SB() or EB() ) >>
Why created:    laws applied to [serial 1325]

Done applying laws
step:  169
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1326]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
Why created:    laws applied to [serial 1320]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Multiplication Commutes. (bl.mulcom)
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1333]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [119]->
Q [12] << SB()
  and not EB() >>
Why created:      normalization of [serial 1326]


This Proof Obligation:

[serial 1327]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1321]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Multiplication Commutes. (bl.mulcom)
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1335]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1327]


This Proof Obligation:

[serial 1328]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) >>
S [119]->
Q [119] << not EB() >>
Why created:    laws applied to [serial 1322]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Multiplication Commutes. (bl.mulcom)
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1337]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [119]->
Q [119] << not EB() >>
Why created:      normalization of [serial 1328]


This Proof Obligation:

[serial 1329]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1323]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Multiplication Commutes. (bl.mulcom)
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1339]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1329]


This Proof Obligation:

[serial 1330]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and ( ca = 0.0 mpss )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    laws applied to [serial 1324]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Multiplication Commutes. (bl.mulcom)
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1341]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1330]


This Proof Obligation:

[serial 1331]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) >>
S [119]->
Q [33] << ( SB() or EB() ) >>
Why created:    laws applied to [serial 1325]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Multiplication Commutes. (bl.mulcom)
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1343]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [119]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1331]

. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1333]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [119]->
Q [12] << SB()
  and not EB() >>
Why created:      normalization of [serial 1326]


[serial 1335]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1327]


[serial 1337]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [119]->
Q [119] << not EB() >>
Why created:      normalization of [serial 1328]


[serial 1339]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1329]


[serial 1341]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1330]


[serial 1343]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [119]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1331]

Done Normalizing
step:  170
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1333]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [119]->
Q [12] << SB()
  and not EB() >>
Why created:      normalization of [serial 1326]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1344]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [119]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1333]


This Proof Obligation:

[serial 1335]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1327]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1345]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1335]


This Proof Obligation:

[serial 1337]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [119]->
Q [119] << not EB() >>
Why created:      normalization of [serial 1328]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1346]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [119]->
Q [119] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1337]


This Proof Obligation:

[serial 1339]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1329]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1347]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1339]


This Proof Obligation:

[serial 1341]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1330]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1348]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1341]


This Proof Obligation:

[serial 1343]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [119]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1331]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1349]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [119]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1343]

. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute" remaining 
Obligations:

[serial 1344]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [119]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1333]


[serial 1345]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1335]


[serial 1346]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [119]->
Q [119] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1337]


[serial 1347]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1339]


[serial 1348]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1341]


[serial 1349]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [119]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1343]

Done substituting Assertion labels.
step:  171
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1344]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [119]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1333]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1351]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1344]


This Proof Obligation:

[serial 1345]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1335]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1353]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1345]


This Proof Obligation:

[serial 1346]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [119]->
Q [119] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1337]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1355]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [119] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1346]


This Proof Obligation:

[serial 1347]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1339]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1357]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1347]


This Proof Obligation:

[serial 1348]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Substituted assertions' predicates for labels  [serial 1341]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1359]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1348]


This Proof Obligation:

[serial 1349]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [119]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1343]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1361]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1349]

. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1351]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1344]


[serial 1353]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1345]


[serial 1355]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [119] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1346]


[serial 1357]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1347]


[serial 1359]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1348]


[serial 1361]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1349]

Done Normalizing
step:  172
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1351]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1344]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1362]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1351]


This Proof Obligation:

[serial 1353]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1345]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1363]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1353]


This Proof Obligation:

[serial 1355]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [119] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1346]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1364]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [119] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1355]


This Proof Obligation:

[serial 1357]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1347]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1365]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1357]


This Proof Obligation:

[serial 1359]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1348]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1366]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1359]


This Proof Obligation:

[serial 1361]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1349]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1367]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1361]

. . . Substituting <= with not < [8.2 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1362]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1351]


[serial 1363]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1353]


[serial 1364]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [119] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1355]


[serial 1365]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1357]


[serial 1366]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1359]


[serial 1367]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1361]

Done replacing a<=b with (not b<a)
step:  173
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1362]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1351]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1369]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1362]


This Proof Obligation:

[serial 1363]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1353]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1371]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1363]


This Proof Obligation:

[serial 1364]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [119] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1355]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1373]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [119] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1364]


This Proof Obligation:

[serial 1365]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1357]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1375]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1365]


This Proof Obligation:

[serial 1366]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Replacing <= with not < of [serial 1359]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1377]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1366]


This Proof Obligation:

[serial 1367]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [119]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1361]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1379]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1367]

. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1369]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1362]


[serial 1371]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1363]


[serial 1373]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [119] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1364]


[serial 1375]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1365]


[serial 1377]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1366]


[serial 1379]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1367]

Done Normalizing
step:  174
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1369]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1362]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1380]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1369]


This Proof Obligation:

[serial 1371]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1363]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1381]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1371]


This Proof Obligation:

[serial 1373]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [119] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1364]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1382]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [119] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1373]


This Proof Obligation:

[serial 1375]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1365]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1383]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1375]

. . . done applying DeMorgan's Law  [8.3 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1377]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1366]


[serial 1379]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1367]


[serial 1380]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1369]


[serial 1381]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1371]


[serial 1382]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [119] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1373]


[serial 1383]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1375]

step:  175
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1380]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1369]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1387]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1380]


This Proof Obligation:

[serial 1381]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1371]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1389]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1381]


This Proof Obligation:

[serial 1382]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [119] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1373]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
Has been normalized to get:

[serial 1391]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1382]


This Proof Obligation:

[serial 1383]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1375]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
Has been normalized to get:

[serial 1393]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1383]

. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1377]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1366]


[serial 1379]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1367]


[serial 1387]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1380]


[serial 1389]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1381]


[serial 1391]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1382]


[serial 1393]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1383]

Done Normalizing
step:  176
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1391]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1382]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.3 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1377]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1366]


[serial 1379]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1367]


[serial 1387]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1380]


[serial 1389]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1381]


[serial 1393]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1383]

Done trying to apply tautologies
step:  177
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1377]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1366]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1394]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1377]


This Proof Obligation:

[serial 1379]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1367]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1395]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1379]


This Proof Obligation:

[serial 1387]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1380]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1396]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1387]


This Proof Obligation:

[serial 1389]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1381]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1397]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1389]


This Proof Obligation:

[serial 1393]: Threads::AutoBrake.i
P [119] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and ( i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1383]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1398]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1393]

. . . done Applying Laws [8.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1394]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1377]


[serial 1395]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1379]


[serial 1396]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1387]


[serial 1397]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1389]


[serial 1398]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1393]

Done applying laws
step:  178
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1394]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1377]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1399]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]


[serial 1400]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]


[serial 1401]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]


[serial 1402]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]


This Proof Obligation:

[serial 1396]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1387]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1403]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]


[serial 1404]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]


[serial 1405]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]


This Proof Obligation:

[serial 1397]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1389]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1406]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]


[serial 1407]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]


[serial 1408]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]


[serial 1409]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]


This Proof Obligation:

[serial 1398]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1393]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1410]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]


[serial 1411]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]


[serial 1412]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]


[serial 1413]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]

. . . done splitting postcondition  [8.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1395]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1379]


[serial 1399]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]


[serial 1400]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]


[serial 1401]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]


[serial 1402]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]


[serial 1403]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]


[serial 1404]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]


[serial 1405]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]


[serial 1406]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]


[serial 1407]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]


[serial 1408]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]


[serial 1409]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]


[serial 1410]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]


[serial 1411]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]


[serial 1412]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]


[serial 1413]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]

Done splitting postcondition
step:  179
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1395]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1379]

Reason solved:  
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1415]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1395]


This Proof Obligation:

[serial 1399]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1417]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:      normalization of [serial 1399]


This Proof Obligation:

[serial 1400]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1419]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA = ma >>
Why created:      normalization of [serial 1400]


This Proof Obligation:

[serial 1401]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1421]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1401]


This Proof Obligation:

[serial 1402]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1394]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1423]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1402]


This Proof Obligation:

[serial 1405]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1427]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1405]


This Proof Obligation:

[serial 1406]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1429]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:      normalization of [serial 1406]


This Proof Obligation:

[serial 1407]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1431]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA = ma >>
Why created:      normalization of [serial 1407]


This Proof Obligation:

[serial 1408]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1433]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1408]


This Proof Obligation:

[serial 1409]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) )@now >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1397]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1435]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1409]


This Proof Obligation:

[serial 1410]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1437]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:      normalization of [serial 1410]


This Proof Obligation:

[serial 1411]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1439]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA = ma >>
Why created:      normalization of [serial 1411]


This Proof Obligation:

[serial 1412]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1441]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1412]


This Proof Obligation:

[serial 1413]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1398]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1443]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1413]

. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1403]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]


[serial 1404]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]


[serial 1415]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1395]


[serial 1417]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:      normalization of [serial 1399]


[serial 1419]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA = ma >>
Why created:      normalization of [serial 1400]


[serial 1421]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1401]


[serial 1423]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1402]


[serial 1427]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1405]


[serial 1429]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:      normalization of [serial 1406]


[serial 1431]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA = ma >>
Why created:      normalization of [serial 1407]


[serial 1433]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1408]


[serial 1435]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1409]


[serial 1437]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:      normalization of [serial 1410]


[serial 1439]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA = ma >>
Why created:      normalization of [serial 1411]


[serial 1441]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1412]


[serial 1443]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1413]

Done Normalizing
step:  180
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1403]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1404]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1396]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1415]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1395]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1417]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:      normalization of [serial 1399]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1419]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA = ma >>
Why created:      normalization of [serial 1400]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1421]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1401]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1423]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( 0.0 mpss = ca )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1402]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1427]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1405]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1429]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:      normalization of [serial 1406]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1431]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA = ma >>
Why created:      normalization of [serial 1407]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1433]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1408]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1435]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1409]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1437]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << i < CMA.num_segments >>
Why created:      normalization of [serial 1410]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1439]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA = ma >>
Why created:      normalization of [serial 1411]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1441]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1412]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1443]: Threads::AutoBrake.i
P [119] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )@now
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [119]->
Q [59] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1413]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.4 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1140]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1135]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  181
#[serial 1145] <<P>> T <<Q>> in behavior action block for [serial 1140]
step:  182
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1140]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1135]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1445]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1140]

. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1445]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1140]

Done Normalizing
step:  183
****reduce****

Reducing Concurrent Computation of:

[serial 1445]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1140]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1446]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1445]


[serial 1447]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]eb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1445]


[serial 1448]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]ca!(xl)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1445]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1446]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1445]


[serial 1447]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]eb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1445]


[serial 1448]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]ca!(xl)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1445]

done reducing composite actions
step:  184
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1446]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1445]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1449]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1446]


This Proof Obligation:

[serial 1447]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]eb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1445]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1450]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]eb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1447]


This Proof Obligation:

[serial 1448]: Threads::AutoBrake.i
P [105] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [124]ca!(xl)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1445]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1451]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]ca!(xl)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1448]

. . . done Applying Laws [8.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1449]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1446]


[serial 1450]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]eb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1447]


[serial 1451]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]ca!(xl)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1448]

Done applying laws
step:  185
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1449]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]sb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1446]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1452]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1449]


The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1453]: Threads::AutoBrake.i
P [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1449]

Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1450]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]eb!(false)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1447]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1454]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1450]


The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1455]: Threads::AutoBrake.i
P [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1450]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1451]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]ca!(xl)
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1448]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=xl)@now>> -> <<post>> for  <<pre>> ca!(xl) <<post>> to get:

[serial 1456]: Threads::AutoBrake.i
P [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = xl )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1451]

looking through terms of
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]
no term was found that had expression e:
 xl
. . . done applying atomic actions [8.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 1452]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1449]


[serial 1453]: Threads::AutoBrake.i
P [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1449]


[serial 1454]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1450]


[serial 1455]: Threads::AutoBrake.i
P [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1450]


[serial 1456]: Threads::AutoBrake.i
P [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = xl )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1451]

Done reducing atomic actions
step:  186
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1453]: Threads::AutoBrake.i
P [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1449]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1457]: Threads::AutoBrake.i
P [124] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1453]


This Proof Obligation:

[serial 1455]: Threads::AutoBrake.i
P [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1450]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1458]: Threads::AutoBrake.i
P [124] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1455]


This Proof Obligation:

[serial 1456]: Threads::AutoBrake.i
P [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = xl )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1451]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1459]: Threads::AutoBrake.i
P [124] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = xl )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1456]

. . . done Applying Laws [8.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1452]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1449]


[serial 1454]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1450]


[serial 1457]: Threads::AutoBrake.i
P [124] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1453]


[serial 1458]: Threads::AutoBrake.i
P [124] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1455]


[serial 1459]: Threads::AutoBrake.i
P [124] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = xl )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1456]

Done applying laws
step:  187
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1457]: Threads::AutoBrake.i
P [124] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1453]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1458]: Threads::AutoBrake.i
P [124] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1455]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1459]: Threads::AutoBrake.i
P [124] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = xl )@now >>
S [124]->
Q [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1456]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.4 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1452]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1449]


[serial 1454]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1450]

Done trying to apply tautologies
step:  188
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1452]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1449]

Reason solved:  
   Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
Has applied Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   to get:

[serial 1460]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1452]

. . . done applying DeMorgan's Law  [8.4 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1454]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1450]


[serial 1460]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1452]

step:  189
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1454]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1450]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1462]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not EB() >>
Why created:      normalization of [serial 1454]


This Proof Obligation:

[serial 1460]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1452]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
   Not Not. (notnot)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1464]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << EB() or not SB() >>
Why created:      normalization of [serial 1460]

. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1462]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not EB() >>
Why created:      normalization of [serial 1454]


[serial 1464]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << EB() or not SB() >>
Why created:      normalization of [serial 1460]

Done Normalizing
step:  190
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1462]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << not EB() >>
Why created:      normalization of [serial 1454]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1465]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [124]->
Q [124] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1462]


This Proof Obligation:

[serial 1464]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [124]->
Q [124] << EB() or not SB() >>
Why created:      normalization of [serial 1460]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1466]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [124]->
Q [124] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1464]

. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute" remaining 
Obligations:

[serial 1465]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [124]->
Q [124] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1462]


[serial 1466]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [124]->
Q [124] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1464]

Done substituting Assertion labels.
step:  191
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1465]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [124]->
Q [124] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1462]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1468]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1465]


This Proof Obligation:

[serial 1466]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [124]->
Q [124] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1464]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1470]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1466]

. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1468]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1465]


[serial 1470]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1466]

Done Normalizing
step:  192
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1470]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1466]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1471]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1470]

. . . done Applying Laws [8.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1468]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1465]


[serial 1471]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1470]

Done applying laws
step:  193
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1468]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1465]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1472]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1468]


This Proof Obligation:

[serial 1471]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1470]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1473]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) or 
not ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Replacing <= with not < of [serial 1471]

. . . Substituting <= with not < [8.4 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1472]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1468]


[serial 1473]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) or 
not ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Replacing <= with not < of [serial 1471]

Done replacing a<=b with (not b<a)
step:  194
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1472]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1468]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1475]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1472]


This Proof Obligation:

[serial 1473]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) or 
not ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Replacing <= with not < of [serial 1471]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1477]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or 
not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1473]

. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1475]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1472]


[serial 1477]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or 
not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1473]

Done Normalizing
step:  195
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1475]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1472]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1478]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1475]


This Proof Obligation:

[serial 1477]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or 
not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1473]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1479]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or 
( not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and not ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1477]

. . . done applying DeMorgan's Law  [8.5 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1478]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1475]


[serial 1479]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or 
( not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and not ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1477]

step:  196
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1478]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1475]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
Has been normalized to get:

[serial 1481]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1478]


This Proof Obligation:

[serial 1479]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or 
( not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and not ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1477]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1483]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1479]

. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1481]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1478]


[serial 1483]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1479]

Done Normalizing
step:  197
****tautologies****
Applying Tautologies . . .
Tautology.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v < iSeg.v_n


This Proof Obligation:

[serial 1483]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1479]

Reason solved:  
   Premise Has All Terms of Conjunction within Disjunction (bl.animporan)(bl.animporanl)

 Has been solved by Premise Has All Terms of Conjunction within Disjunction (bl.animporan)(bl.animporanl)
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1481]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1478]

Done trying to apply tautologies
step:  198
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  v < iSeg.v_n and iSeg.v_n < iSeg.v_e -> v < iSeg.v_e

This Proof Obligation:

[serial 1481]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b >>
S [124]->
Q [124] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1478]

Reason solved:  
   Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
Has applied Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
   to get:

[serial 1484]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and v < iSeg.v_e >>
S [124]->
Q [124] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:    Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
   [serial 1481]

. . . done adding transitive terms [8.5 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 1484]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and v < iSeg.v_e >>
S [124]->
Q [124] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:    Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
   [serial 1481]

Done adding transitive relations
step:  199
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1484]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and v < iSeg.v_e >>
S [124]->
Q [124] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:    Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
   [serial 1481]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1485]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and v < iSeg.v_e >>
S [124]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1484]


[serial 1486]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and v < iSeg.v_e >>
S [124]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1484]

. . . done splitting postcondition  [8.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1485]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and v < iSeg.v_e >>
S [124]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1484]


[serial 1486]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and v < iSeg.v_e >>
S [124]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1484]

Done splitting postcondition
step:  200
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1485]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and v < iSeg.v_e >>
S [124]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1484]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1486]: Threads::AutoBrake.i
P [105] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and v < iSeg.v_e >>
S [124]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1484]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1018]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  201
#[serial 1018]  <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{};
step:  202
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1018]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{};

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1488]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and p < iSeg.e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [128]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1018]

. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1488]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and p < iSeg.e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [128]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1018]

Done Normalizing
step:  203
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1488]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and p < iSeg.e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [128]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1018]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1019]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]  iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1 ]
    and ma = CMA >>
  i := i + 1  
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:     <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  204
#[serial 1019]  <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A};
step:  205
****reduce****
This proof obligation:

[serial 1019]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]  iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1 ]
    and ma = CMA >>
  i := i + 1  
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:     <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1489]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]


[serial 1490]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136]i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1489]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]


[serial 1490]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136]i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]

done reducing composite actions
step:  206
****atomic****
applying atomic actions . . .
solving assignment on line 134
replacing "iSeg" with "nSeg"
makes:  << nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>

This Proof Obligation:

[serial 1489]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1491]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]->
Q [135] << nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1489]

solving assignment on line 136
replacing "i" with "i + 1 "
makes:  << iSeg = CMA.seg[( i + 1  )]
  and ma = CMA >>

This Proof Obligation:

[serial 1490]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136]i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1492]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136]->
Q [61] << iSeg = CMA.seg[( i + 1  )]
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1490]

. . . done applying atomic actions [8.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1491]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]->
Q [135] << nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1489]


[serial 1492]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136]->
Q [61] << iSeg = CMA.seg[( i + 1  )]
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1490]

Done reducing atomic actions
step:  207
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1491]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]->
Q [135] << nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1489]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1494]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg.e <= p
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [134]->
Q [135] << CMA = ma
  and CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1491]


This Proof Obligation:

[serial 1492]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136]->
Q [61] << iSeg = CMA.seg[( i + 1  )]
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1490]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1496]: Threads::AutoBrake.i
P [135] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
S [136]->
Q [61] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
Why created:      normalization of [serial 1492]

. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1494]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg.e <= p
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [134]->
Q [135] << CMA = ma
  and CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1491]


[serial 1496]: Threads::AutoBrake.i
P [135] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
S [136]->
Q [61] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
Why created:      normalization of [serial 1492]

Done Normalizing
step:  208
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1494]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg.e <= p
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [134]->
Q [135] << CMA = ma
  and CMA.seg[1  + i] = nSeg >>
Why created:      normalization of [serial 1491]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1496]: Threads::AutoBrake.i
P [135] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
S [136]->
Q [61] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
Why created:      normalization of [serial 1492]

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1020]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]nSeg := ma.seg[i + 1 ]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  209
#[serial 1020]  <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A};
step:  210
****atomic****
applying atomic actions . . .
reduce asserted action
solving assignment on line 141
replacing "nSeg" with "ma.seg[i + 1 ]"
makes:  << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1 ] = CMA.seg[i + 1 ]
  and ma = CMA >>

This Proof Obligation:

[serial 1020]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]nSeg := ma.seg[i + 1 ]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A};

Reasons solved:  
   Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
   Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1497]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1 ] = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1020]

. . . done applying atomic actions [8.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1497]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1 ] = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1020]

Done reducing atomic actions
step:  211
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1497]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1 ] = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1020]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1499]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = ma.seg[1  + i]
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1497]

. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1499]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = ma.seg[1  + i]
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1497]

Done Normalizing
step:  212
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1499]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = ma.seg[1  + i]
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1497]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1500]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]


[serial 1501]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]


[serial 1502]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA.seg[1  + i] = ma.seg[1  + i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]


[serial 1503]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]

. . . done splitting postcondition  [8.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1500]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]


[serial 1501]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]


[serial 1502]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA.seg[1  + i] = ma.seg[1  + i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]


[serial 1503]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]

Done splitting postcondition
step:  213
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1501]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1503]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1500]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]


[serial 1502]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA.seg[1  + i] = ma.seg[1  + i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]

Done trying to apply tautologies
step:  214
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1500]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1504]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1500]

equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1502]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << CMA.seg[1  + i] = ma.seg[1  + i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1499]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1505]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << ma.seg[1  + i] = ma.seg[1  + i] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1502]

. . . done guided substitution of equals  [8.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1504]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1500]


[serial 1505]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << ma.seg[1  + i] = ma.seg[1  + i] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1502]

Done guided substituting an equals
step:  215
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1504]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << i < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1500]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1505]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << ma.seg[1  + i] = ma.seg[1  + i] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1502]

Done trying to apply tautologies
step:  216
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1505]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << ma.seg[1  + i] = ma.seg[1  + i] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1502]

Reason solved:  
   Law of identity. (eqid)

Has applied Law of identity. (eqid)
   to get:

[serial 1506]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << true >>
Why created:    laws applied to [serial 1505]

. . . done Applying Laws [8.5 seconds ]
After "laws" remaining 
Obligations:

[serial 1506]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << true >>
Why created:    laws applied to [serial 1505]

Done applying laws
step:  217
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1506]: Threads::AutoBrake.i
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141]->
Q [57] << true >>
Why created:    laws applied to [serial 1505]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1021]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]  r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:     <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  218
#[serial 1021]  <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A};
step:  219
****reduce****
This proof obligation:

[serial 1021]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]  r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:     <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1507]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021]


[serial 1508]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]nSeg := [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1507]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021]


[serial 1508]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]nSeg := [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021]

done reducing composite actions
step:  220
****atomic****
applying atomic actions . . .
out event port r on line 146 does not have a BLESS::Assertion property AutoBrake.i; <<true>> used instead.

This Proof Obligation:

[serial 1507]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021]

Has applied <<pre>> -> <<M(r)>> for <<pre>> r! <<post>> to get:

[serial 1509]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]->
Q [146] << true >>
Why created:    applied port output <<pre>> -> <<M[r]>> [serial 1507]

Has applied <<pre and r@now>> -> <<post>> for <<pre>> r! <<post>> to get:

[serial 1510]: Threads::AutoBrake.i
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146]->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:    applied port output <<pre and M[r]@now>> -> <<post>> [serial 1507]

solving assignment on line 149
replacing "nSeg" with "
^{RECORD_TERM[segment] segment 
 ^{=> v_n 
  ^{QUANTITY 0.0 mps}} 
 ^{=> v_e 
  ^{QUANTITY 0.0 mps}} 
 ^{=> e 
  ^{ma 
   ^{. ea}}}}"
makes:  << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>

This Proof Obligation:

[serial 1508]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]nSeg := [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1511]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1508]

. . . done applying atomic actions [8.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1509]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]->
Q [146] << true >>
Why created:    applied port output <<pre>> -> <<M[r]>> [serial 1507]


[serial 1510]: Threads::AutoBrake.i
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146]->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:    applied port output <<pre and M[r]@now>> -> <<post>> [serial 1507]


[serial 1511]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1508]

Done reducing atomic actions
step:  221
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1509]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]->
Q [146] << true >>
Why created:    applied port output <<pre>> -> <<M[r]>> [serial 1507]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1513]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
Why created:      normalization of [serial 1509]


This Proof Obligation:

[serial 1510]: Threads::AutoBrake.i
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146]->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:    applied port output <<pre and M[r]@now>> -> <<post>> [serial 1507]

Reasons solved:  
   At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc) 
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1515]: Threads::AutoBrake.i
P [146] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments )
  and true >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1510]


This Proof Obligation:

[serial 1511]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1508]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1517]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:      normalization of [serial 1511]

. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1513]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
Why created:      normalization of [serial 1509]


[serial 1515]: Threads::AutoBrake.i
P [146] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments )
  and true >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1510]


[serial 1517]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:      normalization of [serial 1511]

Done Normalizing
step:  222
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1515]: Threads::AutoBrake.i
P [146] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments )
  and true >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1510]

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1518]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1515]

. . . done Applying Laws [8.5 seconds ]
After "laws" remaining 
Obligations:

[serial 1513]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
Why created:      normalization of [serial 1509]


[serial 1517]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:      normalization of [serial 1511]


[serial 1518]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1515]

Done applying laws
step:  223
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1517]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:      normalization of [serial 1511]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1519]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1520]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1522]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


This Proof Obligation:

[serial 1518]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1515]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1523]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]


[serial 1524]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]


[serial 1525]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]

. . . done splitting postcondition  [8.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1513]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
Why created:      normalization of [serial 1509]


[serial 1519]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1520]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1522]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1523]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]


[serial 1524]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]


[serial 1525]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]

Done splitting postcondition
step:  224
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1513]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
Why created:      normalization of [serial 1509]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true

This Proof Obligation:

[serial 1519]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1520]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1522]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1523]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]


[serial 1524]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]


[serial 1525]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]

Done trying to apply tautologies
step:  225
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1523]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1528]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA = ma >>
Why created:      normalization of [serial 1523]


This Proof Obligation:

[serial 1524]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1530]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
Why created:      normalization of [serial 1524]


This Proof Obligation:

[serial 1525]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1518]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1532]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1525]

. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1522]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1528]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA = ma >>
Why created:      normalization of [serial 1523]


[serial 1530]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
Why created:      normalization of [serial 1524]


[serial 1532]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1525]

Done Normalizing
step:  226
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1528]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA = ma >>
Why created:      normalization of [serial 1523]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1532]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1525]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1522]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]


[serial 1530]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
Why created:      normalization of [serial 1524]

Done trying to apply tautologies
step:  227
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1530]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
Why created:      normalization of [serial 1524]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1533]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << ma.num_segments = i >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1530]

. . . done guided substitution of equals  [8.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1522]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]

Reason solved:  Guided Substitution of Equals

[serial 1533]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << ma.num_segments = i >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1530]

Done guided substituting an equals
step:  228
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1533]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << ma.num_segments = i >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1530]

Reason solved:  
   Equality Commutes. (eqcom)
Has been normalized to get:

[serial 1536]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << i = ma.num_segments >>
Why created:      normalization of [serial 1533]

. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1522]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]

Reason solved:  Guided Substitution of Equals

[serial 1536]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << i = ma.num_segments >>
Why created:      normalization of [serial 1533]

Done Normalizing
step:  229
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1536]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << i = ma.num_segments >>
Why created:      normalization of [serial 1533]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1522]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]

Reason solved:  Guided Substitution of Equals
Done trying to apply tautologies
step:  230
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1522]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1517]

Reason solved:  Guided Substitution of Equals
Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1537]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:    Substituted assertions' predicates for labels in postconditions [serial 1522]

. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1537]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:    Substituted assertions' predicates for labels in postconditions [serial 1522]

Done substituting Assertion labels in postconditions.
step:  231
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1537]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:    Substituted assertions' predicates for labels in postconditions [serial 1522]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1538]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1537]

. . . done guided substitution of equals  [8.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1538]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1537]

Done guided substituting an equals
step:  232
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1538]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1537]

Reason solved:  
   Law of identity. (eqid)

Has applied Law of identity. (eqid)
   to get:

[serial 1539]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << true >>
Why created:    laws applied to [serial 1538]

. . . done Applying Laws [8.5 seconds ]
After "laws" remaining 
Obligations:

[serial 1539]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << true >>
Why created:    laws applied to [serial 1538]

Done applying laws
step:  233
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1539]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << true >>
Why created:    laws applied to [serial 1538]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1022]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155]->
Q [72] << true >>
Why created:     <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  234
#[serial 1022]  <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{};
step:  235
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1022]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155]->
Q [72] << true >>
Why created:     <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{};

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [8.5 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1023]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [160]<< i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:     <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  236
#[serial 1023]  <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
step:  237
****reduce****

[serial 1540]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]


[serial 1541]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1540]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]


[serial 1541]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]

done reducing composite actions
step:  238
****reduce****
This proof obligation:

[serial 1541]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]

as <<P>> if (B1)-><<P1>>S1<<Q1>> [] (B2)-><<P2>>S2<<Q2>> [] . . . [] (Bn)-><<Pn>>Sn<<Qn>> fi <<Q>> 

was reduced to:

[serial 1542]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:      <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1541]


[serial 1543]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B0>> S0 <<Q>> in alternative for [serial 1541]


[serial 1544]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B1>> S1 <<Q>> in alternative for [serial 1541]


[serial 1545]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B2>> S2 <<Q>> in alternative for [serial 1541]


[serial 1546]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B3>> S3 <<Q>> in alternative for [serial 1541]


[serial 1547]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B4>> S4 <<Q>> in alternative for [serial 1541]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1540]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]


[serial 1542]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:      <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1541]


[serial 1543]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B0>> S0 <<Q>> in alternative for [serial 1541]


[serial 1544]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B1>> S1 <<Q>> in alternative for [serial 1541]


[serial 1545]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B2>> S2 <<Q>> in alternative for [serial 1541]


[serial 1546]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B3>> S3 <<Q>> in alternative for [serial 1541]


[serial 1547]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B4>> S4 <<Q>> in alternative for [serial 1541]

done reducing composite actions
step:  239
****reduce****
Reducing Behavior Action Block, simple:

[serial 1543]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B0>> S0 <<Q>> in alternative for [serial 1541]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1548]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1543]

Reducing Behavior Action Block, simple:

[serial 1544]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B1>> S1 <<Q>> in alternative for [serial 1541]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1549]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1544]

Reducing Behavior Action Block, simple:

[serial 1545]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B2>> S2 <<Q>> in alternative for [serial 1541]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1550]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1545]

Reducing Behavior Action Block, simple:

[serial 1546]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B3>> S3 <<Q>> in alternative for [serial 1541]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1551]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1546]

Reducing Behavior Action Block, simple:

[serial 1547]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:      <<P and B4>> S4 <<Q>> in alternative for [serial 1541]

Reason solved:  
   Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>

as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1552]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1547]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1540]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]


[serial 1542]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:      <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1541]


[serial 1548]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1543]


[serial 1549]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1544]


[serial 1550]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1545]


[serial 1551]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1546]


[serial 1552]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1547]

done reducing composite actions
step:  240
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1540]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1554]: Threads::AutoBrake.i
P [159] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg )
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:      normalization of [serial 1540]


This Proof Obligation:

[serial 1542]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:      <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1541]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1556]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1542]


This Proof Obligation:

[serial 1548]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1543]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1558]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1548]


This Proof Obligation:

[serial 1549]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1544]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Multiplication Commutes. (bl.mulcom)
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1560]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1549]


This Proof Obligation:

[serial 1550]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1545]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1562]: Threads::AutoBrake.i
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1550]


This Proof Obligation:

[serial 1551]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1546]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Multiplication Commutes. (bl.mulcom)
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1564]: Threads::AutoBrake.i
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1551]


This Proof Obligation:

[serial 1552]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P>> T <<Q>> in behavior action block for [serial 1547]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1566]: Threads::AutoBrake.i
P [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1552]

. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1554]: Threads::AutoBrake.i
P [159] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg )
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:      normalization of [serial 1540]


[serial 1556]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1542]


[serial 1558]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1548]


[serial 1560]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1549]


[serial 1562]: Threads::AutoBrake.i
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1550]


[serial 1564]: Threads::AutoBrake.i
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1551]


[serial 1566]: Threads::AutoBrake.i
P [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1552]

Done Normalizing
step:  241
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1554]: Threads::AutoBrake.i
P [159] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg )
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:      normalization of [serial 1540]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1567]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    laws applied to [serial 1554]


This Proof Obligation:

[serial 1558]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1548]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1568]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1558]


This Proof Obligation:

[serial 1560]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1549]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1569]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1560]


This Proof Obligation:

[serial 1562]: Threads::AutoBrake.i
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1550]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1570]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1562]


This Proof Obligation:

[serial 1564]: Threads::AutoBrake.i
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1551]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1571]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1564]


This Proof Obligation:

[serial 1566]: Threads::AutoBrake.i
P [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1552]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1572]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1566]

. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1556]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1542]


[serial 1567]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    laws applied to [serial 1554]


[serial 1568]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1558]


[serial 1569]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1560]


[serial 1570]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1562]


[serial 1571]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1564]


[serial 1572]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1566]

Done applying laws
step:  242
****remove-givens-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1567]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    laws applied to [serial 1554]

Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1573]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and true
  and true
  and true
  and true >>
Why created:     add user-defined "givens" to postcondition

by removing "givens" from postconditions.

. . . done removing axioms from postconditions  [8.6 seconds ]
After "remove givens from postconditions" remaining 
Obligations:

[serial 1556]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1542]


[serial 1568]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1558]


[serial 1569]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1560]


[serial 1570]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1562]


[serial 1571]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1564]


[serial 1572]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1566]


[serial 1573]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and true
  and true
  and true
  and true >>
Why created:     add user-defined "givens" to postcondition

Done removing givens from postconditions
step:  243
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1573]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and true
  and true
  and true
  and true >>
Why created:     add user-defined "givens" to postcondition

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1574]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1573]

. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1556]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1542]


[serial 1568]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1558]


[serial 1569]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1560]


[serial 1570]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1562]


[serial 1571]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1564]


[serial 1572]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1566]


[serial 1574]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1573]

Done applying laws
step:  244
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1574]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1573]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.6 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1556]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1542]


[serial 1568]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1558]


[serial 1569]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1560]


[serial 1570]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1562]


[serial 1571]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1564]


[serial 1572]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1566]

Done trying to apply tautologies
step:  245
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  246
#Threads::AutoBrake.i
step:  247
#[serial 1561]   normalization of [serial 154
step:  248
****make-an****
Making obligation 34
Obligations:

[serial 1556]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1542]

Done making obligation 34
step:  249
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1556]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:      normalization of [serial 1542]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1575]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) ) or ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) ) or ( not ( v*v < ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) >>
Why created:    Replacing <= with not < of [serial 1556]

. . . Substituting <= with not < [8.6 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1575]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) ) or ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) ) or ( not ( v*v < ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) >>
Why created:    Replacing <= with not < of [serial 1556]

Done replacing a<=b with (not b<a)
step:  250
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1575]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) ) or ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) ) or ( not ( v*v < ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) >>
Why created:    Replacing <= with not < of [serial 1556]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1577]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1575]

. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1577]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1575]

Done Normalizing
step:  251
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1577]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1575]

Reason solved:  
   Distribution and-over-or with wff lists. (bl.dba2owl)
Has applied Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into conjunctive normal form to get:

[serial 1578]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or not ( v < iSeg.v_n ) or not ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) ) >>
Why created:    Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1577]

. . . done putting into conjunctive normal form [8.6 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1578]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or not ( v < iSeg.v_n ) or not ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) ) >>
Why created:    Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1577]

Done making conjunctive normal forms.
step:  252
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1578]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or not ( v < iSeg.v_n ) or not ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) ) >>
Why created:    Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1577]

Reason solved:  
   Law of Excluded middle. (exmid)

Has applied Law of Excluded middle. (exmid)
   to get:

[serial 1579]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:    laws applied to [serial 1578]

. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1579]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:    laws applied to [serial 1578]

Done applying laws
step:  253
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1579]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:    laws applied to [serial 1578]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1581]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true >>
Why created:      normalization of [serial 1579]

. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1581]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true >>
Why created:      normalization of [serial 1579]

Done Normalizing
step:  254
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1581]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true
  and true >>
Why created:      normalization of [serial 1579]

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1582]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << true >>
Why created:    laws applied to [serial 1581]

. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1582]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << true >>
Why created:    laws applied to [serial 1581]

Done applying laws
step:  255
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1582]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]->
Q [163] << true >>
Why created:    laws applied to [serial 1581]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [8.6 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1568]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1558]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  256
#[serial 1573] laws applied to [serial 1563]
step:  257
****reduce****

Reducing Concurrent Computation of:

[serial 1568]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1558]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1583]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1568]


[serial 1584]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1568]


[serial 1585]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1568]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1583]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1568]


[serial 1584]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1568]


[serial 1585]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1568]

done reducing composite actions
step:  258
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1583]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1568]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1586]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1583]


The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1587]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1583]

Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1584]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1568]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1588]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1584]


The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1589]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1584]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1585]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1568]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=0.0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1590]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = 0.0 mpss )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1585]

Has applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>>where (( SB() or EB() ))-> 0.0 mpss for ca!(0.0 mpss) to get:

[serial 1591]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1585]

. . . done applying atomic actions [8.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 1586]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1583]


[serial 1587]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1583]


[serial 1588]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1584]


[serial 1589]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1584]


[serial 1590]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = 0.0 mpss )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1585]


[serial 1591]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1585]

Done reducing atomic actions
step:  259
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1587]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1583]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1592]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1587]


This Proof Obligation:

[serial 1589]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1584]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1593]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1589]


This Proof Obligation:

[serial 1590]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = 0.0 mpss )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1585]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1594]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = 0.0 mpss )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1590]

. . . done Applying Laws [8.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1586]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1583]


[serial 1588]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1584]


[serial 1591]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1585]


[serial 1592]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1587]


[serial 1593]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1589]


[serial 1594]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = 0.0 mpss )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1590]

Done applying laws
step:  260
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1592]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1587]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1593]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1589]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1594]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = 0.0 mpss )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1590]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.7 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1586]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1583]


[serial 1588]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1584]


[serial 1591]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1585]

Done trying to apply tautologies
step:  261
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1586]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1583]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1595]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1586]


This Proof Obligation:

[serial 1588]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1584]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1596]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1588]


This Proof Obligation:

[serial 1591]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1585]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1597]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1591]

. . . done substituting assertions' for Labels [8.7 seconds ]
After "substitute" remaining 
Obligations:

[serial 1595]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1586]


[serial 1596]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1588]


[serial 1597]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1591]

Done substituting Assertion labels.
step:  262
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1595]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1586]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1599]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1595]


This Proof Obligation:

[serial 1596]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1588]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1601]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) ) >>
Why created:      normalization of [serial 1596]


This Proof Obligation:

[serial 1597]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1591]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1603]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1597]

. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1599]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1595]


[serial 1601]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) ) >>
Why created:      normalization of [serial 1596]


[serial 1603]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1597]

Done Normalizing
step:  263
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1599]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1595]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Tautologies [8.7 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1601]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) ) >>
Why created:      normalization of [serial 1596]


[serial 1603]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1597]

Done trying to apply tautologies
step:  264
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1601]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) ) >>
Why created:      normalization of [serial 1596]

Reasons solved:  
   Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1604]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) ) or 
not ( ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1601]

. . . done applying DeMorgan's Law  [8.7 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1603]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1597]


[serial 1604]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) ) or 
not ( ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1601]

step:  265
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1604]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( not ( ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) ) or 
not ( ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1601]

Reasons solved:  
   [Add unnecessary parentheses]
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1607]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) or not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= 
v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1604]

. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1603]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1597]


[serial 1607]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) or not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= 
v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1604]

Done Normalizing
step:  266
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1607]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and not ( iSeg.v_e <= v ) ) or not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= 
v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1604]

Reasons solved:  
   Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1608]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v ) ) or not ( not ( iSeg.v_e <= v ) ) ) or 
( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1607]

. . . done applying DeMorgan's Law  [8.7 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1603]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1597]


[serial 1608]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v ) ) or not ( not ( iSeg.v_e <= v ) ) ) or 
( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1607]

step:  267
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1608]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( not ( not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v ) ) or not ( not ( iSeg.v_e <= v ) ) ) or 
( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
  Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1607]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) or ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= 
v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1608]

. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1603]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1597]


[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) or ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= 
v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1608]

Done Normalizing
step:  268
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1603]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1597]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1612]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1603]


This Proof Obligation:

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) or ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= 
v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1608]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1613]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or ( not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    laws applied to [serial 1611]

. . . done Applying Laws [8.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1612]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1603]


[serial 1613]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or ( not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    laws applied to [serial 1611]

Done applying laws
step:  269
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1612]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1603]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1613]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [165]->
Q [165] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or ( not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and not ( iSeg.v_n <= v ) ) >>
Why created:    laws applied to [serial 1611]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Tautologies [8.7 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1569]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1560]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  270
#[serial 1574] laws applied to [serial 1565]
step:  271
****reduce****

Reducing Concurrent Computation of:

[serial 1569]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1560]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1614]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1569]


[serial 1615]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1569]


[serial 1616]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1569]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1614]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1569]


[serial 1615]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1569]


[serial 1616]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1569]

done reducing composite actions
step:  272
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1614]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1569]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1617]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1614]


The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1618]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1614]

Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1615]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1569]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1619]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1615]


The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1620]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1615]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1616]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1569]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=0.0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1621]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = 0.0 mpss )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1616]

Has applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>>where (( SB() or EB() ))-> 0.0 mpss for ca!(0.0 mpss) to get:

[serial 1622]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1616]

. . . done applying atomic actions [8.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 1617]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1614]


[serial 1618]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1614]


[serial 1619]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1615]


[serial 1620]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1615]


[serial 1621]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = 0.0 mpss )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1616]


[serial 1622]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1616]

Done reducing atomic actions
step:  273
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1617]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [14] << EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1614]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1624]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
Why created:      normalization of [serial 1617]


This Proof Obligation:

[serial 1618]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (EB())@now>> -> <<post>> [serial 1614]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1626]: Threads::AutoBrake.i
P [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1618]


This Proof Obligation:

[serial 1619]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1615]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1628]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:      normalization of [serial 1619]


This Proof Obligation:

[serial 1620]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1615]

Reason solved:  
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1630]: Threads::AutoBrake.i
P [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1620]


This Proof Obligation:

[serial 1621]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = 0.0 mpss )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1616]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1632]: Threads::AutoBrake.i
P [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( 0.0 mpss = ca )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1621]


This Proof Obligation:

[serial 1622]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1616]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1634]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1622]

. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1624]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
Why created:      normalization of [serial 1617]


[serial 1626]: Threads::AutoBrake.i
P [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1618]


[serial 1628]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:      normalization of [serial 1619]


[serial 1630]: Threads::AutoBrake.i
P [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1620]


[serial 1632]: Threads::AutoBrake.i
P [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( 0.0 mpss = ca )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1621]


[serial 1634]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1622]

Done Normalizing
step:  274
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1626]: Threads::AutoBrake.i
P [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1618]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1635]: Threads::AutoBrake.i
P [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1626]


This Proof Obligation:

[serial 1630]: Threads::AutoBrake.i
P [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1620]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1636]: Threads::AutoBrake.i
P [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1630]


This Proof Obligation:

[serial 1632]: Threads::AutoBrake.i
P [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( 0.0 mpss = ca )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:      normalization of [serial 1621]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1637]: Threads::AutoBrake.i
P [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( 0.0 mpss = ca )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1632]

. . . done Applying Laws [8.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1624]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
Why created:      normalization of [serial 1617]


[serial 1628]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:      normalization of [serial 1619]


[serial 1634]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1622]


[serial 1635]: Threads::AutoBrake.i
P [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1626]


[serial 1636]: Threads::AutoBrake.i
P [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1630]


[serial 1637]: Threads::AutoBrake.i
P [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( 0.0 mpss = ca )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1632]

Done applying laws
step:  275
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1635]: Threads::AutoBrake.i
P [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1626]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1636]: Threads::AutoBrake.i
P [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1630]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1637]: Threads::AutoBrake.i
P [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( 0.0 mpss = ca )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1632]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.7 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1624]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
Why created:      normalization of [serial 1617]


[serial 1628]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:      normalization of [serial 1619]


[serial 1634]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1622]

Done trying to apply tautologies
step:  276
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1628]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:      normalization of [serial 1619]

Reason solved:  
   Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
Has applied Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   to get:

[serial 1638]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1628]

. . . done applying DeMorgan's Law  [8.7 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1624]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
Why created:      normalization of [serial 1617]


[serial 1634]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1622]


[serial 1638]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1628]

step:  277
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1638]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1628]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1642]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << EB() or not SB() >>
Why created:      normalization of [serial 1638]

. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1624]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
Why created:      normalization of [serial 1617]


[serial 1634]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1622]


[serial 1642]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << EB() or not SB() >>
Why created:      normalization of [serial 1638]

Done Normalizing
step:  278
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1624]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
Why created:      normalization of [serial 1617]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1643]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1624]


This Proof Obligation:

[serial 1634]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [33] << EB() or SB() >>
Why created:      normalization of [serial 1622]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1644]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1634]


This Proof Obligation:

[serial 1642]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [168]->
Q [168] << EB() or not SB() >>
Why created:      normalization of [serial 1638]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1645]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [168] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1642]

. . . done substituting assertions' for Labels [8.7 seconds ]
After "substitute" remaining 
Obligations:

[serial 1643]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1624]


[serial 1644]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1634]


[serial 1645]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [168] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1642]

Done substituting Assertion labels.
step:  279
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1643]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [14] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1624]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1647]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1643]


This Proof Obligation:

[serial 1644]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [33] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1634]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1649]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1644]


This Proof Obligation:

[serial 1645]: Threads::AutoBrake.i
P [163] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [168] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1642]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1651]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1645]

. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1647]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1643]


[serial 1649]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1644]


[serial 1651]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1645]

Done Normalizing
step:  280
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1649]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1644]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1652]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1649]


This Proof Obligation:

[serial 1651]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [168] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1645]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1653]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1651]

. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1647]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1643]


[serial 1652]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1649]


[serial 1653]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1651]

Done applying laws
step:  281
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1652]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v or ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:    laws applied to [serial 1649]

Reason solved:  
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1656]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or iSeg.v_n <= v >>
Why created:      normalization of [serial 1652]

. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1647]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1643]


[serial 1653]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1651]


[serial 1656]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or iSeg.v_n <= v >>
Why created:      normalization of [serial 1652]

Done Normalizing
step:  282
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1647]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [14] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v >>
Why created:      normalization of [serial 1643]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1653]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [168] << ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or not ( 
( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:    laws applied to [serial 1651]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1656]: Threads::AutoBrake.i
P [163] << iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [168]->
Q [33] << ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v or iSeg.v_n <= v >>
Why created:      normalization of [serial 1652]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Tautologies [8.8 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1570]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1562]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  283
#[serial 1575] laws applied to [serial 1567]
step:  284
****reduce****

Reducing Concurrent Computation of:

[serial 1570]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1562]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1658]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1570]


[serial 1659]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1570]


[serial 1660]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1570]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1658]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1570]


[serial 1659]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1570]


[serial 1660]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1570]

done reducing composite actions
step:  285
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1658]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1570]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1661]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1658]


The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1662]: Threads::AutoBrake.i
P [172] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1658]

Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1659]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1570]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1663]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1659]


The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1664]: Threads::AutoBrake.i
P [172] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1659]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1660]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1570]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=0.0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1665]: Threads::AutoBrake.i
P [172] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1660]

Has applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>>where (( SB() or EB() ))-> 0.0 mpss for ca!(0.0 mpss) to get:

[serial 1666]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1660]

. . . done applying atomic actions [8.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1661]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1658]


[serial 1662]: Threads::AutoBrake.i
P [172] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1658]


[serial 1663]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1659]


[serial 1664]: Threads::AutoBrake.i
P [172] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1659]


[serial 1665]: Threads::AutoBrake.i
P [172] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1660]


[serial 1666]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1660]

Done reducing atomic actions
step:  286
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1662]: Threads::AutoBrake.i
P [172] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1658]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1667]: Threads::AutoBrake.i
P [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1662]


This Proof Obligation:

[serial 1664]: Threads::AutoBrake.i
P [172] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1659]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1668]: Threads::AutoBrake.i
P [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1664]


This Proof Obligation:

[serial 1665]: Threads::AutoBrake.i
P [172] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1660]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1669]: Threads::AutoBrake.i
P [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1665]

. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1661]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1658]


[serial 1663]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1659]


[serial 1666]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1660]


[serial 1667]: Threads::AutoBrake.i
P [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1662]


[serial 1668]: Threads::AutoBrake.i
P [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1664]


[serial 1669]: Threads::AutoBrake.i
P [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1665]

Done applying laws
step:  287
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1667]: Threads::AutoBrake.i
P [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1662]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1668]: Threads::AutoBrake.i
P [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1664]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1669]: Threads::AutoBrake.i
P [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1665]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.8 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1661]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1658]


[serial 1663]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1659]


[serial 1666]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1660]

Done trying to apply tautologies
step:  288
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1661]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1658]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1670]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1661]


This Proof Obligation:

[serial 1663]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1659]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1671]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [172] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1663]


This Proof Obligation:

[serial 1666]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1660]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1672]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1666]

. . . done substituting assertions' for Labels [8.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 1670]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1661]


[serial 1671]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [172] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1663]


[serial 1672]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1666]

Done substituting Assertion labels.
step:  289
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1670]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1661]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1674]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1670]


This Proof Obligation:

[serial 1671]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [172] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1663]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1676]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [172] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1671]


This Proof Obligation:

[serial 1672]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1666]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1678]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1672]

. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1674]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1670]


[serial 1676]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [172] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1671]


[serial 1678]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1672]

Done Normalizing
step:  290
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1674]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1670]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1679]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1674]


This Proof Obligation:

[serial 1676]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [172] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1671]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1680]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [172] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1676]


This Proof Obligation:

[serial 1678]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1672]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1681]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1678]

. . . Substituting <= with not < [8.8 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1679]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1674]


[serial 1680]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [172] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1676]


[serial 1681]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1678]

Done replacing a<=b with (not b<a)
step:  291
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1679]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1674]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1683]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1679]


This Proof Obligation:

[serial 1680]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [172] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1676]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1685]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [172] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1680]


This Proof Obligation:

[serial 1681]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [172]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1678]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1687]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1681]

. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1683]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1679]


[serial 1685]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [172] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1680]


[serial 1687]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1681]

Done Normalizing
step:  292
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1683]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1679]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1688]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1683]


This Proof Obligation:

[serial 1685]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [172] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1680]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1689]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [172] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1685]

. . . done applying DeMorgan's Law  [8.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1687]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1681]


[serial 1688]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1683]


[serial 1689]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [172] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1685]

step:  293
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1688]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1683]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1692]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1688]


This Proof Obligation:

[serial 1689]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [172] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1685]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
Has been normalized to get:

[serial 1694]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1689]

. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1687]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1681]


[serial 1692]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1688]


[serial 1694]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1689]

Done Normalizing
step:  294
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1694]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [172] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1689]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.8 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1687]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1681]


[serial 1692]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1688]

Done trying to apply tautologies
step:  295
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1687]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1681]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1695]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1687]


This Proof Obligation:

[serial 1692]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1688]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1696]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1692]

. . . done Applying Laws [8.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1695]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1687]


[serial 1696]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1692]

Done applying laws
step:  296
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1696]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1692]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1697]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]


[serial 1698]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]


[serial 1699]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]

. . . done splitting postcondition  [8.9 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1695]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1687]


[serial 1697]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]


[serial 1698]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]


[serial 1699]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]

Done splitting postcondition
step:  297
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1695]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1687]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1697]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1698]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.9 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1699]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]

Done trying to apply tautologies
step:  298
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1699]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1696]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1701]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1699]

. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1701]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1699]

Done Normalizing
step:  299
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1701]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v < iSeg.v_n ) >>
S [172]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1699]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Tautologies [8.9 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1571]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1564]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  300
#[serial 1576] laws applied to [serial 1569]
step:  301
****reduce****

Reducing Concurrent Computation of:

[serial 1571]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1564]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1702]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1571]


[serial 1703]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1571]


[serial 1704]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1571]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1702]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1571]


[serial 1703]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1571]


[serial 1704]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1571]

done reducing composite actions
step:  302
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1702]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1571]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1705]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1702]


The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1706]: Threads::AutoBrake.i
P [177] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1702]

Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1703]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1571]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1707]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1703]


The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1708]: Threads::AutoBrake.i
P [177] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1703]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1704]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]ca!(0.0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1571]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=0.0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1709]: Threads::AutoBrake.i
P [177] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1704]

Has applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>>where (( SB() or EB() ))-> 0.0 mpss for ca!(0.0 mpss) to get:

[serial 1710]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1704]

. . . done applying atomic actions [8.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 1705]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1702]


[serial 1706]: Threads::AutoBrake.i
P [177] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1702]


[serial 1707]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1703]


[serial 1708]: Threads::AutoBrake.i
P [177] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1703]


[serial 1709]: Threads::AutoBrake.i
P [177] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1704]


[serial 1710]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1704]

Done reducing atomic actions
step:  303
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1706]: Threads::AutoBrake.i
P [177] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1702]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1711]: Threads::AutoBrake.i
P [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1706]


This Proof Obligation:

[serial 1708]: Threads::AutoBrake.i
P [177] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1703]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1712]: Threads::AutoBrake.i
P [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1708]


This Proof Obligation:

[serial 1709]: Threads::AutoBrake.i
P [177] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = 0.0 mpss )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=0.0 mpss)@now>> -> <<post>> [serial 1704]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1713]: Threads::AutoBrake.i
P [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1709]

. . . done Applying Laws [8.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1705]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1702]


[serial 1707]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1703]


[serial 1710]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1704]


[serial 1711]: Threads::AutoBrake.i
P [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1706]


[serial 1712]: Threads::AutoBrake.i
P [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1708]


[serial 1713]: Threads::AutoBrake.i
P [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1709]

Done applying laws
step:  304
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1711]: Threads::AutoBrake.i
P [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1706]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1712]: Threads::AutoBrake.i
P [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1708]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1713]: Threads::AutoBrake.i
P [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = 0.0 mpss )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1709]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.9 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1705]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1702]


[serial 1707]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1703]


[serial 1710]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1704]

Done trying to apply tautologies
step:  305
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1705]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1702]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1714]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1705]


This Proof Obligation:

[serial 1707]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1703]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1715]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [177] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1707]


This Proof Obligation:

[serial 1710]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB() or EB() ) >>
Why created:    applied port output of conditional expression <<pre>> -> <<( SB() or EB() )>> where ( SB() or EB() ) -> 0.0 mpss for ca!(0.0 mpss) 
[serial 1704]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1716]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1710]

. . . done substituting assertions' for Labels [8.9 seconds ]
After "substitute" remaining 
Obligations:

[serial 1714]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1705]


[serial 1715]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [177] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1707]


[serial 1716]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1710]

Done substituting Assertion labels.
step:  306
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1714]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [12] << ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1705]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1718]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1714]


This Proof Obligation:

[serial 1715]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [177] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1707]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1720]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [177] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1715]


This Proof Obligation:

[serial 1716]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [33] << ( ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or 
( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1710]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1722]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1716]

. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1718]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1714]


[serial 1720]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [177] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1715]


[serial 1722]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1716]

Done Normalizing
step:  307
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1718]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [12] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v )
  and not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1714]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1723]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1718]


This Proof Obligation:

[serial 1720]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [177] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1715]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1724]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [177] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1720]


This Proof Obligation:

[serial 1722]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [33] << ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) or 
( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1716]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1725]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1722]

. . . Substituting <= with not < [8.9 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1723]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1718]


[serial 1724]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [177] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1720]


[serial 1725]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1722]

Done replacing a<=b with (not b<a)
step:  308
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1723]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [12] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) )
  and not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or 
( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1718]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1727]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1723]


This Proof Obligation:

[serial 1724]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [177] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1720]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1729]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [177] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1724]


This Proof Obligation:

[serial 1725]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [177]->
Q [33] << ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) or 
( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1722]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1731]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1725]

. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1727]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1723]


[serial 1729]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [177] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1724]


[serial 1731]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1725]

Done Normalizing
step:  309
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1727]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1723]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1732]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1727]


This Proof Obligation:

[serial 1729]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [177] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1724]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1733]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [177] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1729]

. . . done applying DeMorgan's Law  [8.9 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1731]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1725]


[serial 1732]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1727]


[serial 1733]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [177] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1729]

step:  310
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1732]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) )
  and ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1727]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1736]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1732]


This Proof Obligation:

[serial 1733]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [177] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1729]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
Has been normalized to get:

[serial 1738]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1733]

. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1731]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1725]


[serial 1736]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1732]


[serial 1738]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1733]

Done Normalizing
step:  311
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1738]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [177] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1733]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [8.9 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1731]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1725]


[serial 1736]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1732]

Done trying to apply tautologies
step:  312
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1731]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) or 
( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1725]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1739]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1731]


This Proof Obligation:

[serial 1736]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e )
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1732]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1740]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1736]

. . . done Applying Laws [8.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1739]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1731]


[serial 1740]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1736]

Done applying laws
step:  313
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1740]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [12] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    laws applied to [serial 1736]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1741]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]


[serial 1742]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]


[serial 1743]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]

. . . done splitting postcondition  [8.9 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1739]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1731]


[serial 1741]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]


[serial 1742]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]


[serial 1743]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]

Done splitting postcondition
step:  314
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1739]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [33] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    laws applied to [serial 1731]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1741]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1742]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [8.9 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1743]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]

Done trying to apply tautologies
step:  315
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1743]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [35] << ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1740]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1745]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1743]

. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1745]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1743]

Done Normalizing
step:  316
****tautologies****
Applying Tautologies . . .
Tautology.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1745]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) >>
S [177]->
Q [35] << not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) >>
Why created:      normalization of [serial 1743]

Reason solved:  
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

 Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Tautologies [9.0 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1572]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1566]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  317
#[serial 1577] laws applied to [serial 1571]
step:  318
****reduce****

Reducing Concurrent Computation of:

[serial 1572]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1566]

Reason solved:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1746]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1572]


[serial 1747]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1572]


[serial 1748]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1572]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1746]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1572]


[serial 1747]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1572]


[serial 1748]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1572]

done reducing composite actions
step:  319
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1746]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S1 <<Q>> in concurrent composition for [serial 1572]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1749]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1746]


The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1750]: Threads::AutoBrake.i
P [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1746]

Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1747]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S2 <<Q>> in concurrent composition for [serial 1572]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1751]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]


The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1752]: Threads::AutoBrake.i
P [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1747]

Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB() or EB() ))-> 0.0 mpss, 
                                          (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1748]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    <<P>> S3 <<Q>> in concurrent composition for [serial 1572]

Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Reasons solved:  
Has applied <<pre and (ca=xl)@now>> -> <<post>> for  <<pre>> ca!(xl) <<post>> to get:

[serial 1753]: Threads::AutoBrake.i
P [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1748]

looking through terms of
  [(( SB() or EB() ))-> 0.0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]
no term was found that had expression e:
 xl
. . . done applying atomic actions [9.0 seconds ]
After "atomic" remaining 
Obligations:

[serial 1749]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1746]


[serial 1750]: Threads::AutoBrake.i
P [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1746]


[serial 1751]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]


[serial 1752]: Threads::AutoBrake.i
P [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1747]


[serial 1753]: Threads::AutoBrake.i
P [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1748]

Done reducing atomic actions
step:  320
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1750]: Threads::AutoBrake.i
P [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1746]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1754]: Threads::AutoBrake.i
P [182] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1750]


This Proof Obligation:

[serial 1752]: Threads::AutoBrake.i
P [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1747]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1755]: Threads::AutoBrake.i
P [182] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1752]


This Proof Obligation:

[serial 1753]: Threads::AutoBrake.i
P [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1748]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1756]: Threads::AutoBrake.i
P [182] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1753]

. . . done Applying Laws [9.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1749]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1746]


[serial 1751]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]


[serial 1754]: Threads::AutoBrake.i
P [182] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1750]


[serial 1755]: Threads::AutoBrake.i
P [182] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1752]


[serial 1756]: Threads::AutoBrake.i
P [182] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1753]

Done applying laws
step:  321
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1754]: Threads::AutoBrake.i
P [182] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1750]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1755]: Threads::AutoBrake.i
P [182] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1752]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1756]: Threads::AutoBrake.i
P [182] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg)
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    laws applied to [serial 1753]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [9.0 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1749]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1746]


[serial 1751]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]

Done trying to apply tautologies
step:  322
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1749]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
Why created:    applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1746]

Reason solved:  
   Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
Has applied Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   to get:

[serial 1757]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1749]

. . . done applying DeMorgan's Law  [9.0 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1751]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]


[serial 1757]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1749]

step:  323
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1757]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << ( not ( SB() ) or not ( not EB() ) ) >>
Why created:    Negated conjunction in terms of disjunction (De Morgan's law). (ianor)
   [serial 1749]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1760]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << EB() or not SB() >>
Why created:      normalization of [serial 1757]

. . . done Normalizing Unsolved Proof Obligations [9.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1751]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]


[serial 1760]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << EB() or not SB() >>
Why created:      normalization of [serial 1757]

Done Normalizing
step:  324
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1751]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << not EB() >>
Why created:    applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1761]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [182]->
Q [182] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1751]


This Proof Obligation:

[serial 1760]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [182]->
Q [182] << EB() or not SB() >>
Why created:      normalization of [serial 1757]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1762]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [182]->
Q [182] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1760]

. . . done substituting assertions' for Labels [9.0 seconds ]
After "substitute" remaining 
Obligations:

[serial 1761]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [182]->
Q [182] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1751]


[serial 1762]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [182]->
Q [182] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1760]

Done substituting Assertion labels.
step:  325
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1761]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [182]->
Q [182] << not ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1751]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1764]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1761]


This Proof Obligation:

[serial 1762]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [182]->
Q [182] << ( v >= iSeg.v_e or v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
not ( v >= iSeg.v_n or v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
Why created:    Substituted assertions' predicates for labels  [serial 1760]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Multiplication Commutes. (bl.mulcom)
   Conjunction Commutes. (bl.ancom)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1766]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1762]

. . . done Normalizing Unsolved Proof Obligations [9.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1764]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1761]


[serial 1766]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1762]

Done Normalizing
step:  326
****replace<=****
Replacing <= with not < . . .

This Proof Obligation:

[serial 1764]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) >>
Why created:      normalization of [serial 1761]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1767]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1764]


This Proof Obligation:

[serial 1766]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or iSeg.v_e <= v ) or 
not ( ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v or iSeg.v_n <= v ) >>
Why created:      normalization of [serial 1762]

Reason solved:  
   'Less than' expressed in terms of 'less than or equal to'. (ltnle)

Has applied 'Less than' expressed in terms of 'less than or equal to'. (ltnle)
   to get:

[serial 1768]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) or 
not ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Replacing <= with not < of [serial 1766]

. . . Substituting <= with not < [9.0 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1767]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1764]


[serial 1768]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) or 
not ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Replacing <= with not < of [serial 1766]

Done replacing a<=b with (not b<a)
step:  327
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1767]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Replacing <= with not < of [serial 1764]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1770]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1767]


This Proof Obligation:

[serial 1768]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) ) or 
not ( ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Replacing <= with not < of [serial 1766]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1772]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) or 
not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1768]

. . . done Normalizing Unsolved Proof Obligations [9.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1770]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1767]


[serial 1772]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) or 
not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1768]

Done Normalizing
step:  328
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1770]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) >>
Why created:      normalization of [serial 1767]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1773]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1770]


This Proof Obligation:

[serial 1772]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) or 
not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) ) >>
Why created:      normalization of [serial 1768]

Reason solved:  
   Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
Has applied Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   to get:

[serial 1774]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) or 
( not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and not ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1772]

. . . done applying DeMorgan's Law  [9.0 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1773]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1770]


[serial 1774]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) or 
( not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and not ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1772]

step:  329
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1774]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) ) or 
( not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and not ( not ( v < iSeg.v_n ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1772]

Reason solved:  
   Absorb parentheses, middle term in disjunction (bl.orabpm)

Has applied Absorb parentheses, middle term in disjunction (bl.orabpm)
   to get:

[serial 1775]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or 
( not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and not ( not ( v < iSeg.v_n ) ) ) >>
Why created:    laws applied to [serial 1774]

. . . done Applying Laws [9.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1773]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1770]


[serial 1775]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or 
( not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and not ( not ( v < iSeg.v_n ) ) ) >>
Why created:    laws applied to [serial 1774]

Done applying laws
step:  330
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1773]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( not ( not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) )
  and not ( not ( v < iSeg.v_e ) ) ) >>
Why created:    Negated disjunction in terms of conjunction (De Morgan's law). (ioran)
   [serial 1770]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
Has been normalized to get:

[serial 1777]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1773]


This Proof Obligation:

[serial 1775]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) or 
( not ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) )
  and not ( not ( v < iSeg.v_n ) ) ) >>
Why created:    laws applied to [serial 1774]

Reasons solved:  
   [Add unnecessary parentheses]
   Not Not. (notnot)
   Disjunction Commutes. (bl.orcom)
Has been normalized to get:

[serial 1779]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1775]

. . . done Normalizing Unsolved Proof Obligations [9.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1777]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1773]


[serial 1779]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1775]

Done Normalizing
step:  331
****tautologies****
Applying Tautologies . . .
Tautology.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v < iSeg.v_n


This Proof Obligation:

[serial 1779]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) >>
Why created:      normalization of [serial 1775]

Reason solved:  
   Premise Has All Terms of Conjunction within Disjunction (bl.animporan)(bl.animporanl)

 Has been solved by Premise Has All Terms of Conjunction within Disjunction (bl.animporan)(bl.animporanl)
. . . done Applying Tautologies [9.0 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1777]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1773]

Done trying to apply tautologies
step:  332
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1777]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [182] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
Why created:      normalization of [serial 1773]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1780]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1777]


[serial 1781]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1777]

. . . done splitting postcondition  [9.0 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1780]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1777]


[serial 1781]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1777]

Done splitting postcondition
step:  333
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1780]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [13] << v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1777]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.0 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1781]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1777]

Done trying to apply tautologies
step:  334
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  v < iSeg.v_n and iSeg.v_n < iSeg.v_e -> v < iSeg.v_e

This Proof Obligation:

[serial 1781]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg >>
S [182]->
Q [13] << v < iSeg.v_e >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1777]

Reason solved:  
   Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
Has applied Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
   to get:

[serial 1782]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and v < iSeg.v_e >>
S [182]->
Q [13] << v < iSeg.v_e >>
Why created:    Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
   [serial 1781]

. . . done adding transitive terms [9.0 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 1782]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and v < iSeg.v_e >>
S [182]->
Q [13] << v < iSeg.v_e >>
Why created:    Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
   [serial 1781]

Done adding transitive relations
step:  335
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1782]: Threads::AutoBrake.i
P [163] << v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and CTCS_Property::EB_Rate mpss = e
  and CTCS_Property::SB_Rate mpss = b
  and [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] = nSeg
  and v < iSeg.v_e >>
S [182]->
Q [13] << v < iSeg.v_e >>
Why created:    Transitive Law for Inequality. (ltletr)(ltleletr)(xrlttr)(xrltletr)
   [serial 1781]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.0 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1024]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:     <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  336
#[serial 1024]  <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
step:  337
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1024]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:     <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [9.0 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1025]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and GIVEN_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1 ]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1 ] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:     <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  338
#[serial 1025]  <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A};
step:  339
****reduce****
This proof obligation:

[serial 1025]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and GIVEN_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1 ]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1 ] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:     <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1783]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65]->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1025]


[serial 1784]: Threads::AutoBrake.i
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
S [67]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:    <<Q2>> -> <<Q>> in sequential composition for [serial 1025]


[serial 1785]: Threads::AutoBrake.i
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]


[serial 1786]: Threads::AutoBrake.i
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
Why created:    <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1783]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65]->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1025]


[serial 1784]: Threads::AutoBrake.i
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
S [67]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:    <<Q2>> -> <<Q>> in sequential composition for [serial 1025]


[serial 1785]: Threads::AutoBrake.i
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]


[serial 1786]: Threads::AutoBrake.i
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
Why created:    <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]

done reducing composite actions
step:  340
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1783]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65]->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1025]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1788]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:      normalization of [serial 1783]


This Proof Obligation:

[serial 1784]: Threads::AutoBrake.i
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
S [67]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:    <<Q2>> -> <<Q>> in sequential composition for [serial 1025]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1790]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1784]


This Proof Obligation:

[serial 1785]: Threads::AutoBrake.i
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1792]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1785]


This Proof Obligation:

[serial 1786]: Threads::AutoBrake.i
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
Why created:    <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1794]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1786]

. . . done Normalizing Unsolved Proof Obligations [9.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1788]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:      normalization of [serial 1783]


[serial 1790]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1784]


[serial 1792]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1785]


[serial 1794]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1786]

Done Normalizing
step:  341
****remove-givens-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1788]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:      normalization of [serial 1783]

Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1795]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:     add user-defined "givens" to postcondition

by removing "givens" from postconditions.

. . . done removing axioms from postconditions  [9.0 seconds ]
After "remove givens from postconditions" remaining 
Obligations:

[serial 1790]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1784]


[serial 1792]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1785]


[serial 1794]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1786]


[serial 1795]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:     add user-defined "givens" to postcondition

Done removing givens from postconditions
step:  342
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1795]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:     add user-defined "givens" to postcondition

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1796]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1795]

. . . done Applying Laws [9.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1790]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1784]


[serial 1792]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1785]


[serial 1794]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1786]


[serial 1796]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1795]

Done applying laws
step:  343
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1796]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    laws applied to [serial 1795]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [9.0 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1790]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1784]


[serial 1792]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1785]


[serial 1794]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1786]

Done trying to apply tautologies
step:  344
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  345
#Threads::AutoBrake.i
step:  346
#[serial 1795]   normalization of [serial 178
step:  347
****make-an****
Making obligation 42
Obligations:

[serial 1790]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1784]

Done making obligation 42
step:  348
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1790]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1784]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1797]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]


[serial 1798]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]


[serial 1799]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]


[serial 1800]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [68] << NEXT_MA = next_ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]


[serial 1801]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << NEXT_MA.seg[1 ] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]

. . . done splitting postcondition  [9.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1797]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]


[serial 1798]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]


[serial 1799]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]


[serial 1800]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [68] << NEXT_MA = next_ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]


[serial 1801]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << NEXT_MA.seg[1 ] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]

Done splitting postcondition
step:  349
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1797]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1798]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1800]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [68] << NEXT_MA = next_ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1801]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << NEXT_MA.seg[1 ] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1799]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]

Done trying to apply tautologies
step:  350
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  CMA.num_segments = i

This Proof Obligation:

[serial 1799]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1790]

Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "CMA.num_segments"
 to get:

[serial 1802]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "CMA.num_segments" in its postcondition [serial 1799]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1802]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "CMA.num_segments" in its postcondition [serial 1799]

Done guided substituting an equals
step:  351
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1802]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67]->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "CMA.num_segments" in its postcondition [serial 1799]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1792]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1785]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  352
#[serial 1797]   normalization of [serial 1790]
step:  353
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1792]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1785]

Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(m_a)>> -> <<post>> for <<pre>> m_a?(next_ma) <<post>> to get:

[serial 1803]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1792]

. . . done applying atomic actions [9.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1803]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1792]

Done reducing atomic actions
step:  354
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1803]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1792]

Reason solved:  
   Equality Commutes. (eqcom)
Has been normalized to get:

[serial 1805]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1803]

. . . done Normalizing Unsolved Proof Obligations [9.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1805]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1803]

Done Normalizing
step:  355
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1805]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:      normalization of [serial 1803]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1806]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]


[serial 1807]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]


[serial 1808]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]


[serial 1809]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]

. . . done splitting postcondition  [9.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1806]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]


[serial 1807]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]


[serial 1808]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]


[serial 1809]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]

Done splitting postcondition
step:  356
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1806]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1810]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
Why created:    laws applied to [serial 1806]


This Proof Obligation:

[serial 1807]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1811]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
Why created:    laws applied to [serial 1807]


This Proof Obligation:

[serial 1808]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1812]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    laws applied to [serial 1808]


This Proof Obligation:

[serial 1809]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1805]

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1813]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    laws applied to [serial 1809]

. . . done Applying Laws [9.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1810]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
Why created:    laws applied to [serial 1806]


[serial 1811]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
Why created:    laws applied to [serial 1807]


[serial 1812]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    laws applied to [serial 1808]


[serial 1813]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    laws applied to [serial 1809]

Done applying laws
step:  357
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1810]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
Why created:    laws applied to [serial 1806]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1811]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
Why created:    laws applied to [serial 1807]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1812]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    laws applied to [serial 1808]


[serial 1813]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    laws applied to [serial 1809]

Done trying to apply tautologies
step:  358
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1812]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    laws applied to [serial 1808]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1814]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1812]


This Proof Obligation:

[serial 1813]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    laws applied to [serial 1809]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1815]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1813]

. . . done substituting assertions' for Labels [9.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1814]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1812]


[serial 1815]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1813]

Done substituting Assertion labels in preconditions
step:  359
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1814]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1812]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1817]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:      normalization of [serial 1814]


This Proof Obligation:

[serial 1815]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1813]

Reasons solved:  
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1819]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:      normalization of [serial 1815]

. . . done Normalizing Unsolved Proof Obligations [9.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1817]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:      normalization of [serial 1814]


[serial 1819]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:      normalization of [serial 1815]

Done Normalizing
step:  360
****guided-sub-equals****
guided substitution of equals "NEXT_MA" . . .
equality selected for substitution:  NEXT_MA = RMA
equality selected for substitution:  NEXT_MA = RMA

This Proof Obligation:

[serial 1819]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
Why created:      normalization of [serial 1815]

Reason solved:  Guided Substitution of Equals
Has substituted 
"NEXT_MA" with its = "RMA"
 to get:

[serial 1820]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << RMA = next_ma >>
Why created:    Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1819]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1817]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:      normalization of [serial 1814]

Reason solved:  Guided Substitution of Equals

[serial 1820]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << RMA = next_ma >>
Why created:    Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1819]

Done guided substituting an equals
step:  361
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1820]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << RMA = next_ma >>
Why created:    Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1819]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1817]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:      normalization of [serial 1814]

Reason solved:  Guided Substitution of Equals
Done trying to apply tautologies
step:  362
****guided-sub-equals****
guided substitution of equals "CMA.num_segments" . . .
equality selected for substitution:  CMA.num_segments = i

This Proof Obligation:

[serial 1817]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:      normalization of [serial 1814]

Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
Has substituted 
"CMA.num_segments" with its = "i"
 to get:

[serial 1821]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[i] = iSeg >>
Why created:    Guided Substitution of Equals Guided Substitution of Equals 
 replacing "CMA.num_segments" with its = "i" in its postcondition [serial 1817]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1821]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[i] = iSeg >>
Why created:    Guided Substitution of Equals Guided Substitution of Equals 
 replacing "CMA.num_segments" with its = "i" in its postcondition [serial 1817]

Done guided substituting an equals
step:  363
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1821]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[i] = iSeg >>
Why created:    Guided Substitution of Equals Guided Substitution of Equals 
 replacing "CMA.num_segments" with its = "i" in its postcondition [serial 1817]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1794]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1786]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  364
#[serial 1799]   normalization of [serial 1791]
step:  365
****atomic****
applying atomic actions . . .
solving assignment on line 196
replacing "nSeg" with "next_ma.seg[1 ]"
makes:  << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>

This Proof Obligation:

[serial 1794]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1 ]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:      normalization of [serial 1786]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1822]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:    applied wp for assignment [serial 1794]

. . . done applying atomic actions [9.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1822]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:    applied wp for assignment [serial 1794]

Done reducing atomic actions
step:  366
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1822]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:    applied wp for assignment [serial 1794]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1823]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]


[serial 1824]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]


[serial 1825]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]


[serial 1826]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << NEXT_MA = next_ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]


[serial 1827]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]

. . . done splitting postcondition  [9.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1823]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]


[serial 1824]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]


[serial 1825]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]


[serial 1826]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << NEXT_MA = next_ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]


[serial 1827]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]

Done splitting postcondition
step:  367
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1823]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1824]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA.num_segments = i >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1825]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1826]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << NEXT_MA = next_ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1827]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]

Done trying to apply tautologies
step:  368
****guided-sub-equals****
guided substitution of equals "NEXT_MA" . . .
equality selected for substitution:  NEXT_MA = next_ma

This Proof Obligation:

[serial 1827]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1822]

Reason solved:  Guided Substitution of Equals
Has substituted 
"NEXT_MA" with its = "next_ma"
 to get:

[serial 1828]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << next_ma.seg[1 ] = next_ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1827]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1828]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << next_ma.seg[1 ] = next_ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1827]

Done guided substituting an equals
step:  369
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1828]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << next_ma.seg[1 ] = next_ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1827]

Reason solved:  
   Law of identity. (eqid)

Has applied Law of identity. (eqid)
   to get:

[serial 1829]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << true >>
Why created:    laws applied to [serial 1828]

. . . done Applying Laws [9.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1829]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << true >>
Why created:    laws applied to [serial 1828]

Done applying laws
step:  370
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1829]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << true >>
Why created:    laws applied to [serial 1828]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1026]: Threads::AutoBrake.i
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:     <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  371
#[serial 1026]  <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{};
step:  372
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1026]: Threads::AutoBrake.i
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:     <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{};

Reason solved:  
   Absorb parentheses, middle term in conjunction (bl.anabpm)

Has applied Absorb parentheses, middle term in conjunction (bl.anabpm)
   to get:

[serial 1830]: Threads::AutoBrake.i
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:    laws applied to [serial 1026]

. . . done Applying Laws [9.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1830]: Threads::AutoBrake.i
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:    laws applied to [serial 1026]

Done applying laws
step:  373
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1830]: Threads::AutoBrake.i
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:    laws applied to [serial 1026]

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1027]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:     <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  374
#[serial 1027]  <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{};
step:  375
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1027]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:     <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{};

Reason solved:  
   And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

 Has been solved by And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1028]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]  << GIVEN_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1 
  ;
  << i = 1 
    and ma = CMA >>
  iSeg := ma.seg[1 ]
  ;
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2 ]
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1 ]
    and GIVEN_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A};

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  376
#[serial 1028]  <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A};
step:  377
****reduce****
This proof obligation:

[serial 1028]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]  << GIVEN_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1 
  ;
  << i = 1 
    and ma = CMA >>
  iSeg := ma.seg[1 ]
  ;
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2 ]
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1 ]
    and GIVEN_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:     <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P3>> S3 <<Q3>>
 
was reduced to:

[serial 1831]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1028]


[serial 1832]: Threads::AutoBrake.i
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<Q4>> -> <<Q>> in sequential composition for [serial 1028]


[serial 1833]: Threads::AutoBrake.i
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]


[serial 1834]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1 
Q [214] << i = 1 
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]


[serial 1835]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]iSeg := ma.seg[1 ]
Q [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:    <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]


[serial 1836]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:    <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1831]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1028]


[serial 1832]: Threads::AutoBrake.i
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<Q4>> -> <<Q>> in sequential composition for [serial 1028]


[serial 1833]: Threads::AutoBrake.i
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]


[serial 1834]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1 
Q [214] << i = 1 
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]


[serial 1835]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]iSeg := ma.seg[1 ]
Q [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:    <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]


[serial 1836]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:    <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]

done reducing composite actions
step:  378
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  379
#Threads::AutoBrake.i
step:  380
#[serial 1836] <<P>> -> <<P1>> in sequential composition for [serial 102
step:  381
****make-an****
Making obligation 48
Obligations:

[serial 1831]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1028]

Done making obligation 48
step:  382
****remove-givens-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1831]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
Why created:    <<P>> -> <<P1>> in sequential composition for [serial 1028]

Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1837]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:     add user-defined "givens" to postcondition

by removing "givens" from postconditions.

. . . done removing axioms from postconditions  [9.1 seconds ]
After "remove givens from postconditions" remaining 
Obligations:

[serial 1837]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:     add user-defined "givens" to postcondition

Done removing givens from postconditions
step:  383
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1837]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:     add user-defined "givens" to postcondition

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1838]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << ( next_ma = NEXT_MA ) >>
Why created:    laws applied to [serial 1837]

. . . done Applying Laws [9.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1838]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << ( next_ma = NEXT_MA ) >>
Why created:    laws applied to [serial 1837]

Done applying laws
step:  384
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1838]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << ( next_ma = NEXT_MA ) >>
Why created:    laws applied to [serial 1837]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   [change A>=B to B<=A]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1840]: Threads::AutoBrake.i
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [210] << NEXT_MA = next_ma >>
Why created:      normalization of [serial 1838]

. . . done Normalizing Unsolved Proof Obligations [9.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1840]: Threads::AutoBrake.i
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [210] << NEXT_MA = next_ma >>
Why created:      normalization of [serial 1838]

Done Normalizing
step:  385
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1840]: Threads::AutoBrake.i
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70]->
Q [210] << NEXT_MA = next_ma >>
Why created:      normalization of [serial 1838]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1832]: Threads::AutoBrake.i
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<Q4>> -> <<Q>> in sequential composition for [serial 1028]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  386
#[serial 1837] <<Q4>> -> <<Q>> in sequential composition for [serial 1028]
step:  387
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1832]: Threads::AutoBrake.i
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    <<Q4>> -> <<Q>> in sequential composition for [serial 1028]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1841]: Threads::AutoBrake.i
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ( 1  < ma.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1832]

. . . done substituting assertions' for Labels [9.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1841]: Threads::AutoBrake.i
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ( 1  < ma.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1832]

Done substituting Assertion labels in preconditions
step:  388
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1841]: Threads::AutoBrake.i
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ( 1  < ma.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1832]

Reasons solved:  
   Addition Commutes. (bl.addcom)
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1843]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1841]

. . . done Normalizing Unsolved Proof Obligations [9.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1843]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1841]

Done Normalizing
step:  389
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1843]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:      normalization of [serial 1841]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1844]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]


[serial 1845]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]


[serial 1846]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]


[serial 1847]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]

. . . done splitting postcondition  [9.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1844]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]


[serial 1845]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]


[serial 1846]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]


[serial 1847]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]

Done splitting postcondition
step:  390
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1845]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << CMA = ma >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1846]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1847]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1844]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]

Done trying to apply tautologies
step:  391
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  1  = i

This Proof Obligation:

[serial 1844]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << i < CMA.num_segments >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1843]

Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "1 "
 to get:

[serial 1848]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < CMA.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1844]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1848]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < CMA.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1844]

Done guided substituting an equals
step:  392
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1848]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < CMA.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1844]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1849]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1848]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1849]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1848]

Done guided substituting an equals
step:  393
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1849]: Threads::AutoBrake.i
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57]->
Q [57] << 1  < ma.num_segments >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1848]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1833]: Threads::AutoBrake.i
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  394
#[serial 1838] <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
step:  395
****atomic****
applying atomic actions . . .
solving assignment on line 211
replacing "ma" with "next_ma"
makes:  << next_ma = CMA >>

This Proof Obligation:

[serial 1833]: Threads::AutoBrake.i
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
Why created:    <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1850]: Threads::AutoBrake.i
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
Why created:    applied wp for assignment [serial 1833]

. . . done applying atomic actions [9.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1850]: Threads::AutoBrake.i
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
Why created:    applied wp for assignment [serial 1833]

Done reducing atomic actions
step:  396
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1850]: Threads::AutoBrake.i
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
Why created:    applied wp for assignment [serial 1833]

Reason solved:  
   Predicate Invocation. (PI)
Has substituted assertions' predicates for labels to get:

[serial 1851]: Threads::AutoBrake.i
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1850]

. . . done substituting assertions' for Labels [9.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1851]: Threads::AutoBrake.i
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1850]

Done substituting Assertion labels in preconditions
step:  397
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1851]: Threads::AutoBrake.i
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
Why created:    Substituted assertions' predicates for labels in preconditions [serial 1850]

Reasons solved:  
   Equality Commutes. (eqcom)
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1853]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << CMA = next_ma >>
Why created:      normalization of [serial 1851]

. . . done Normalizing Unsolved Proof Obligations [9.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1853]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << CMA = next_ma >>
Why created:      normalization of [serial 1851]

Done Normalizing
step:  398
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = NEXT_MA

This Proof Obligation:

[serial 1853]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << CMA = next_ma >>
Why created:      normalization of [serial 1851]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "NEXT_MA"
 to get:

[serial 1854]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << NEXT_MA = next_ma >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1853]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1854]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << NEXT_MA = next_ma >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1853]

Done guided substituting an equals
step:  399
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1854]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << NEXT_MA = next_ma >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1853]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1834]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1 
Q [214] << i = 1 
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  400
#[serial 1839] <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
step:  401
****atomic****
applying atomic actions . . .
solving assignment on line 213
replacing "i" with "1 "
makes:  << 1  = 1 
  and ma = CMA >>

This Proof Obligation:

[serial 1834]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1 
Q [214] << i = 1 
  and ma = CMA >>
Why created:    <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1855]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]->
Q [214] << 1  = 1 
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1834]

. . . done applying atomic actions [9.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1855]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]->
Q [214] << 1  = 1 
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1834]

Done reducing atomic actions
step:  402
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1855]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]->
Q [214] << 1  = 1 
  and ma = CMA >>
Why created:    applied wp for assignment [serial 1834]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1857]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and 1  = 1  >>
Why created:      normalization of [serial 1855]

. . . done Normalizing Unsolved Proof Obligations [9.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1857]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and 1  = 1  >>
Why created:      normalization of [serial 1855]

Done Normalizing
step:  403
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1857]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and 1  = 1  >>
Why created:      normalization of [serial 1855]

Reason solved:  
   Law of identity. (eqid)

Has applied Law of identity. (eqid)
   to get:

[serial 1858]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and true >>
Why created:    laws applied to [serial 1857]

. . . done Applying Laws [9.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1858]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and true >>
Why created:    laws applied to [serial 1857]

Done applying laws
step:  404
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1858]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and true >>
Why created:    laws applied to [serial 1857]

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1859]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << ( CMA = ma ) >>
Why created:    laws applied to [serial 1858]

. . . done Applying Laws [9.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1859]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << ( CMA = ma ) >>
Why created:    laws applied to [serial 1858]

Done applying laws
step:  405
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1859]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << ( CMA = ma ) >>
Why created:    laws applied to [serial 1858]

Reason solved:  
   [Add unnecessary parentheses]
Has been normalized to get:

[serial 1861]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma >>
Why created:      normalization of [serial 1859]

. . . done Normalizing Unsolved Proof Obligations [9.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1861]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma >>
Why created:      normalization of [serial 1859]

Done Normalizing
step:  406
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1861]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma >>
Why created:      normalization of [serial 1859]

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1835]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]iSeg := ma.seg[1 ]
Q [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:    <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  407
#[serial 1840] <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
step:  408
****atomic****
applying atomic actions . . .
solving assignment on line 215
replacing "iSeg" with "ma.seg[1 ]"
makes:  << i = 1 
  and ma = CMA
  and ma.seg[1 ] = CMA.seg[i] >>

This Proof Obligation:

[serial 1835]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]iSeg := ma.seg[1 ]
Q [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:    <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1862]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << i = 1 
  and ma = CMA
  and ma.seg[1 ] = CMA.seg[i] >>
Why created:    applied wp for assignment [serial 1835]

. . . done applying atomic actions [9.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1862]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << i = 1 
  and ma = CMA
  and ma.seg[1 ] = CMA.seg[i] >>
Why created:    applied wp for assignment [serial 1835]

Done reducing atomic actions
step:  409
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1862]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << i = 1 
  and ma = CMA
  and ma.seg[1 ] = CMA.seg[i] >>
Why created:    applied wp for assignment [serial 1835]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1863]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << i = 1  >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]


[serial 1864]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma = CMA >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]


[serial 1865]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = CMA.seg[i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]

. . . done splitting postcondition  [9.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1863]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << i = 1  >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]


[serial 1864]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma = CMA >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]


[serial 1865]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = CMA.seg[i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]

Done splitting postcondition
step:  410
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1863]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << i = 1  >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1864]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma = CMA >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1865]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = CMA.seg[i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]

Done trying to apply tautologies
step:  411
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  ma = CMA

This Proof Obligation:

[serial 1865]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = CMA.seg[i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1862]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1866]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = ma.seg[i] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1865]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1866]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = ma.seg[i] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1865]

Done guided substituting an equals
step:  412
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1 

This Proof Obligation:

[serial 1866]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = ma.seg[i] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1865]

Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "1 "
 to get:

[serial 1867]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1866]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1867]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1866]

Done guided substituting an equals
step:  413
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1867]: Threads::AutoBrake.i
P [214] << i = 1 
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1866]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1869]: Threads::AutoBrake.i
P [214] << CMA = ma
  and 1  = i >>
S [215]->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:      normalization of [serial 1867]

. . . done Normalizing Unsolved Proof Obligations [9.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1869]: Threads::AutoBrake.i
P [214] << CMA = ma
  and 1  = i >>
S [215]->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:      normalization of [serial 1867]

Done Normalizing
step:  414
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1869]: Threads::AutoBrake.i
P [214] << CMA = ma
  and 1  = i >>
S [215]->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:      normalization of [serial 1867]

Reason solved:  
   Law of identity. (eqid)

Has applied Law of identity. (eqid)
   to get:

[serial 1870]: Threads::AutoBrake.i
P [214] << CMA = ma
  and 1  = i >>
S [215]->
Q [216] << true >>
Why created:    laws applied to [serial 1869]

. . . done Applying Laws [9.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1870]: Threads::AutoBrake.i
P [214] << CMA = ma
  and 1  = i >>
S [215]->
Q [216] << true >>
Why created:    laws applied to [serial 1869]

Done applying laws
step:  415
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1870]: Threads::AutoBrake.i
P [214] << CMA = ma
  and 1  = i >>
S [215]->
Q [216] << true >>
Why created:    laws applied to [serial 1869]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1836]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:    <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  416
#[serial 1841] <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]
step:  417
****remove-givens-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1836]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:    <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]

Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1871]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:     add user-defined "givens" to postcondition

by removing "givens" from postconditions.

. . . done removing axioms from postconditions  [9.1 seconds ]
After "remove givens from postconditions" remaining 
Obligations:

[serial 1871]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:     add user-defined "givens" to postcondition

Done removing givens from postconditions
step:  418
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1871]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:     add user-defined "givens" to postcondition

Reason solved:  
   True can be removed from conjunction. (truan)(truconj)

Has applied True can be removed from conjunction. (truan)(truconj)
   to get:

[serial 1872]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ] >>
Why created:    laws applied to [serial 1871]

. . . done Applying Laws [9.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1872]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ] >>
Why created:    laws applied to [serial 1871]

Done applying laws
step:  419
****atomic****
applying atomic actions . . .
solving assignment on line 217
replacing "nSeg" with "ma.seg[2 ]"
makes:  << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2 ] = CMA.seg[i + 1 ] >>

This Proof Obligation:

[serial 1872]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ] >>
Why created:    laws applied to [serial 1871]

Reason solved:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1873]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2 ] = CMA.seg[i + 1 ] >>
Why created:    applied wp for assignment [serial 1872]

. . . done applying atomic actions [9.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1873]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2 ] = CMA.seg[i + 1 ] >>
Why created:    applied wp for assignment [serial 1872]

Done reducing atomic actions
step:  420
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1873]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2 ] = CMA.seg[i + 1 ] >>
Why created:    applied wp for assignment [serial 1872]

Reason solved:  
   Join consequents with conjunction. (3jca)
Has split postcondition to get:

[serial 1874]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1  >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]


[serial 1875]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma = CMA >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]


[serial 1876]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << iSeg = CMA.seg[i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]


[serial 1877]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2 ] = CMA.seg[i + 1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]

. . . done splitting postcondition  [9.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1874]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1  >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]


[serial 1875]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma = CMA >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]


[serial 1876]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << iSeg = CMA.seg[i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]


[serial 1877]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2 ] = CMA.seg[i + 1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]

Done splitting postcondition
step:  421
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1874]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1  >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1875]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma = CMA >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

This Proof Obligation:

[serial 1876]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << iSeg = CMA.seg[i] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]

Reason solved:  
   And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

 Has been solved by And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:

[serial 1877]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2 ] = CMA.seg[i + 1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]

Done trying to apply tautologies
step:  422
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1 

This Proof Obligation:

[serial 1877]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2 ] = CMA.seg[i + 1 ] >>
Why created:    Join consequents with conjunction. (3jca)
   [serial 1873]

Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "1 "
 to get:

[serial 1878]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2 ] = CMA.seg[1  + 1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1877]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1878]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2 ] = CMA.seg[1  + 1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1877]

Done guided substituting an equals
step:  423
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1878]: Threads::AutoBrake.i
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2 ] = CMA.seg[1  + 1 ] >>
Why created:    Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1877]

Reasons solved:  
   Equality Commutes. (eqcom)
   Conjunction Commutes. (bl.ancom)
Has been normalized to get:

[serial 1880]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [217]->
Q [218] << CMA.seg[2 ] = ma.seg[2 ] >>
Why created:      normalization of [serial 1878]

. . . done Normalizing Unsolved Proof Obligations [9.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1880]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [217]->
Q [218] << CMA.seg[2 ] = ma.seg[2 ] >>
Why created:      normalization of [serial 1878]

Done Normalizing
step:  424
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1880]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [217]->
Q [218] << CMA.seg[2 ] = ma.seg[2 ] >>
Why created:      normalization of [serial 1878]

Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1881]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [217]->
Q [218] << ma.seg[2 ] = ma.seg[2 ] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1880]

. . . done guided substitution of equals  [9.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1881]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [217]->
Q [218] << ma.seg[2 ] = ma.seg[2 ] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1880]

Done guided substituting an equals
step:  425
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1881]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [217]->
Q [218] << ma.seg[2 ] = ma.seg[2 ] >>
Why created:    Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1880]

Reason solved:  
   Law of identity. (eqid)

Has applied Law of identity. (eqid)
   to get:

[serial 1882]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [217]->
Q [218] << true >>
Why created:    laws applied to [serial 1881]

. . . done Applying Laws [9.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1882]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [217]->
Q [218] << true >>
Why created:    laws applied to [serial 1881]

Done applying laws
step:  426
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1882]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [217]->
Q [218] << true >>
Why created:    laws applied to [serial 1881]

Reason solved:  
   Anything Implies True (a1tru): P->true

 Has been solved by Anything Implies True (a1tru): P->true
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1029]: ma -> controller.control.m_a
P [1] << ma_m_a = RMA >>
S [2]->
Q [1] << ma_m_a = RMA >>
Why created:    Composition of Subcomponents via Directional Connection ma -> controller.control.m_a:
 ma -> m_a

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  427
#[serial 1029] Composition of Subcomponents via Directional Connection ma -> controller.control.m_a:
step:  428
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1029]: ma -> controller.control.m_a
P [1] << ma_m_a = RMA >>
S [2]->
Q [1] << ma_m_a = RMA >>
Why created:    Composition of Subcomponents via Directional Connection ma -> controller.control.m_a:
 ma -> m_a

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1030]: driver.xl -> motor.xl
P [1] << xl = OPERATOR_XL >>
S [2]->
Q [1] << xl = OPERATOR_XL >>
Why created:    Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  429
#[serial 1030] Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
step:  430
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1030]: driver.xl -> motor.xl
P [1] << xl = OPERATOR_XL >>
S [2]->
Q [1] << xl = OPERATOR_XL >>
Why created:    Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1031]: sensor.p -> controller.control.p
P [1] << p = POSITION >>
S [2]->
Q [1] << p = POSITION >>
Why created:    Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  431
#[serial 1031] Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
step:  432
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1031]: sensor.p -> controller.control.p
P [1] << p = POSITION >>
S [2]->
Q [1] << p = POSITION >>
Why created:    Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1032]: sensor.v -> controller.control.v
P [1] << v = VELOCITY >>
S [2]->
Q [1] << v = VELOCITY >>
Why created:    Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  433
#[serial 1032] Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
step:  434
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1032]: sensor.v -> controller.control.v
P [1] << v = VELOCITY >>
S [2]->
Q [1] << v = VELOCITY >>
Why created:    Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1033]: controller.control.sb -> sbrake.brake
P [1] << SB()
  and not EB() >>
S [2]->
Q [1] << SB()
  and not EB() >>
Why created:    Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  435
#[serial 1033] Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
step:  436
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1033]: controller.control.sb -> sbrake.brake
P [1] << SB()
  and not EB() >>
S [2]->
Q [1] << SB()
  and not EB() >>
Why created:    Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1034]: controller.control.eb -> ebrake.brake
P [1] << EB() >>
S [2]->
Q [1] << EB() >>
Why created:    Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  437
#[serial 1034] Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
step:  438
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1034]: controller.control.eb -> ebrake.brake
P [1] << EB() >>
S [2]->
Q [1] << EB() >>
Why created:    Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1035]: Train::Train.i.auth
P [14] << ma_m_a = RMA >>
S [73]->
Q [94] << ma_m_a = RMA >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  439
#[serial 1035] Composition of Subcomponents via Directional Connection Train::Train.i.auth:
step:  440
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1035]: Train::Train.i.auth
P [14] << ma_m_a = RMA >>
S [73]->
Q [94] << ma_m_a = RMA >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1036]: Train::Train.i.pos
P [32] << p = POSITION >>
S [74]->
Q [89] << p = POSITION >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  441
#[serial 1036] Composition of Subcomponents via Directional Connection Train::Train.i.pos:
step:  442
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1036]: Train::Train.i.pos
P [32] << p = POSITION >>
S [74]->
Q [89] << p = POSITION >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1037]: Train::Train.i.vel
P [34] << v = VELOCITY >>
S [75]->
Q [91] << v = VELOCITY >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  443
#[serial 1037] Composition of Subcomponents via Directional Connection Train::Train.i.vel:
step:  444
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1037]: Train::Train.i.vel
P [34] << v = VELOCITY >>
S [75]->
Q [91] << v = VELOCITY >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1038]: Train::Train.i.dxl
P [59] << xl = OPERATOR_XL >>
S [76]->
Q [23] << xl = OPERATOR_XL >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  445
#[serial 1038] Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
step:  446
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1038]: Train::Train.i.dxl
P [59] << xl = OPERATOR_XL >>
S [76]->
Q [23] << xl = OPERATOR_XL >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1039]: Train::Train.i.cpsb
P [85] << SB()
  and not EB() >>
S [77]->
Q [44] << SB()
  and not EB() >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  447
#[serial 1039] Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
step:  448
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1039]: Train::Train.i.cpsb
P [85] << SB()
  and not EB() >>
S [77]->
Q [44] << SB()
  and not EB() >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1040]: Train::Train.i.cpeb
P [87] << EB() >>
S [78]->
Q [51] << EB() >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  449
#[serial 1040] Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
step:  450
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1040]: Train::Train.i.cpeb
P [87] << EB() >>
S [78]->
Q [51] << EB() >>
Why created:    Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1041]: Train::ControllerProcess.i.conn_s
P [89] << p = POSITION >>
S [103]->
Q [19] << p = POSITION >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  451
#[serial 1041] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
step:  452
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1041]: Train::ControllerProcess.i.conn_s
P [89] << p = POSITION >>
S [103]->
Q [19] << p = POSITION >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1042]: Train::ControllerProcess.i.conn_v
P [91] << v = VELOCITY >>
S [104]->
Q [21] << v = VELOCITY >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  453
#[serial 1042] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
step:  454
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1042]: Train::ControllerProcess.i.conn_v
P [91] << v = VELOCITY >>
S [104]->
Q [21] << v = VELOCITY >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1043]: Train::ControllerProcess.i.conn_ma
P [94] << m_a = RMA >>
S [106]->
Q [17] << m_a = RMA >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  455
#[serial 1043] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
step:  456
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1043]: Train::ControllerProcess.i.conn_ma
P [94] << m_a = RMA >>
S [106]->
Q [17] << m_a = RMA >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1044]: Train::ControllerProcess.i.conn_sb
P [12] << SB()
  and not EB() >>
S [108]->
Q [85] << SB()
  and not EB() >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  457
#[serial 1044] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
step:  458
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1044]: Train::ControllerProcess.i.conn_sb
P [12] << SB()
  and not EB() >>
S [108]->
Q [85] << SB()
  and not EB() >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1045]: Train::ControllerProcess.i.conn_eb
P [14] << EB() >>
S [109]->
Q [87] << EB() >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  459
#[serial 1045] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
step:  460
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1045]: Train::ControllerProcess.i.conn_eb
P [14] << EB() >>
S [109]->
Q [87] << EB() >>
Why created:    Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
Obligations:

[serial 1046]: CTCS::MovementAuthority.i.ma
P [27] << ma = RMA >>
S [19]->
Q [14] << ma = RMA >>
Why created:    Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma

The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  461
#[serial 1046] Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
step:  462
****tautologies****
Applying Tautologies . . .

This Proof Obligation:

[serial 1046]: CTCS::MovementAuthority.i.ma
P [27] << ma = RMA >>
S [19]->
Q [14] << ma = RMA >>
Why created:    Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma

Reason solved:  
   Identity (id):  P->P is tautology

 Has been solved by Identity (id):  P->P is tautology
. . . done Applying Tautologies [9.1 seconds ]
After "tautologies" remaining 
Obligations:
Done trying to apply tautologies
There are no more unsolved proof obligations.
All proof obligations have been solved.  Q.E.D.
opening proof file "/Applications/osate2_2023-03-master/Eclipse.app/Contents/MacOS/proof.txt" Fri Jan 26 05:07:33 CST 2024
Theorem (1)                               [serial 1003] 
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
Solved by: Anything Implies True (a1tru): P->true

Theorem (2)                               [serial 1004] 
P [54] << true >>
S [39] ->
Q [39] << true >>
Why created:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
Solved by: Anything Implies True (a1tru): P->true

Theorem (3)                               [serial 1005] 
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
Solved by: Anything Implies True (a1tru): P->true

Theorem (4)                               [serial 1048] 
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [39] ->
Q [39] << true >>
Why created:    normalization of [serial 1006]
  Using: (eqcom) (bl.ancom) 
Solved by: Anything Implies True (a1tru): P->true

Theorem (5)                               [serial 1006] 
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 4:
Theorem (4) [serial 1048] used for:
    normalization of [serial 1006] 


Theorem (6)                               [serial 1051] 
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59] ->
Q [59] << p < iSeg.e or ( not ( p < iSeg.e ) ) >>
Why created:  Replacing <= with not < of [serial 1050]
Solved by: Law of Excluded middle. (exmid)

Theorem (7)                               [serial 1050] 
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59] ->
Q [59] << p < iSeg.e or iSeg.e <= p >>
Why created:    normalization of [serial 1007]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 6:
Theorem (6) [serial 1051] used for:
  Replacing <= with not < of [serial 1050] 


Theorem (8)                               [serial 1007] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [59] ->
Q [59] << ( p < iSeg.e ) or ( p >= iSeg.e ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 7:
Theorem (7) [serial 1050] used for:
    normalization of [serial 1007] 


Theorem (9)                               [serial 1008] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65] ->
Q [65] << ( not m_a'fresh ) or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by: Law of Excluded middle. (exmid)

Theorem (10)                               [serial 1009] 
P [53] << true >>
S [53] ->
Q [53] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (11)                               [serial 1055] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61] ->
Q [61] << i < ma.num_segments or ma.num_segments < i or i = ma.num_segments >>
Why created:    normalization of [serial 1010]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) changeGreaterThanToLessThan (bl.orcom) 
Solved by: Trichotomy law for 'less than'. (lttri4)

Theorem (12)                               [serial 1010] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61] ->
Q [61] << ( i < ma.num_segments ) or ( i = ma.num_segments ) or ( i > ma.num_segments ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) [change A>B to B<A] Disjunction Commutes. (bl.orcom) and theorem 11:
Theorem (11) [serial 1055] used for:
    normalization of [serial 1010] 


Theorem (13)                               [serial 1011] 
P [55] << true >>
S [55] ->
Q [55] << ( not m_a'fresh ) or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
Solved by: Law of Excluded middle. (exmid)

Theorem (14)                               [serial 1060] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70] ->
Q [70] << p < ma.ea or ( not ( p < ma.ea ) ) >>
Why created:  Replacing <= with not < of [serial 1059]
Solved by: Law of Excluded middle. (exmid)

Theorem (15)                               [serial 1059] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70] ->
Q [70] << p < ma.ea or ma.ea <= p >>
Why created:    normalization of [serial 1012]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 14:
Theorem (14) [serial 1060] used for:
  Replacing <= with not < of [serial 1059] 


Theorem (16)                               [serial 1012] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70] ->
Q [70] << ( p < ma.ea ) or ( p >= ma.ea ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 15:
Theorem (15) [serial 1059] used for:
    normalization of [serial 1012] 


Theorem (17)                               [serial 1063] 
P [53] << true >>
S [76] ->
Q [76] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1062]
Solved by: Anything Implies True (a1tru): P->true

Theorem (18)                               [serial 1064] 
P [76] << ( true )
  and true@now >>
S [76] ->
Q [54] << true >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1062]
Solved by: Anything Implies True (a1tru): P->true

Theorem (19)                               [serial 1062] 
P [53] << true >>
S [76] r!
Q [54] << true >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 17 18:
Theorem (17) [serial 1063] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1062] 
Theorem (18) [serial 1064] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1062] 


Theorem (20)                               [serial 1013] 
P [53] << true >>
S [76] r!
Q [54] << true >>
Why created:   <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A};
Solved by: null and theorem 19:
Theorem (19) [serial 1062] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013] 


Theorem (21)                               [serial 1014] 
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [78] ->
Q [55] << true >>
Why created:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{};
Solved by: Anything Implies True (a1tru): P->true

Theorem (22)                               [serial 1015] 
P [82] << not m_a'fresh >>
S [81] ->
Q [54] << true >>
Why created:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{};
Solved by: Anything Implies True (a1tru): P->true

Theorem (23)                               [serial 1071] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Anything Implies True (a1tru): P->true

Theorem (24)                               [serial 1071] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Anything Implies True (a1tru): P->true

Theorem (25)                               [serial 1065] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << GIVEN_CMA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 24 24:
Theorem (24) [serial 1071] used for:
   add user-defined "givens" to postcondition 
Theorem (24) [serial 1071] used for:
   add user-defined "givens" to postcondition 


Theorem (26)                               [serial 1096] 
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << 1  < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1095]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (27)                               [serial 1095] 
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << 1  < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1094]
Solved by:  Guided Substitution of Equals
 and theorem 26:
Theorem (26) [serial 1096] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1095] 


Theorem (28)                               [serial 1094] 
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << i < ma.num_segments >>
Why created:    normalization of [serial 1092]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Guided Substitution of Equals
 and theorem 27:
Theorem (27) [serial 1095] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1094] 


Theorem (29)                               [serial 1092] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57] ->
Q [57] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1091]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 28:
Theorem (28) [serial 1094] used for:
    normalization of [serial 1092] 


Theorem (30)                               [serial 1091] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1087]
Solved by:  Guided Substitution of Equals
 and theorem 29:
Theorem (29) [serial 1092] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1091] 


Theorem (31)                               [serial 1087] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1077]
Solved by: Predicate Invocation. (PI) and theorem 30:
Theorem (30) [serial 1091] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1087] 


Theorem (32)                               [serial 1088] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1077]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (33)                               [serial 1089] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1077]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (34)                               [serial 1090] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1077]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (35)                               [serial 1077] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1066]
  Using: (bl.addcom) (eqcom) (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 31 32 33 34:
Theorem (31) [serial 1087] used for:
  Join consequents with conjunction. (3jca)
   [serial 1077] 
Theorem (32) [serial 1088] used for:
  Join consequents with conjunction. (3jca)
   [serial 1077] 
Theorem (33) [serial 1089] used for:
  Join consequents with conjunction. (3jca)
   [serial 1077] 
Theorem (34) [serial 1090] used for:
  Join consequents with conjunction. (3jca)
   [serial 1077] 


Theorem (36)                               [serial 1066] 
P [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  <<Q4>> -> <<Q>> in sequential composition for [serial 1016]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 35:
Theorem (35) [serial 1077] used for:
    normalization of [serial 1066] 


Theorem (37)                               [serial 1101] 
P [87] << CMA = RMA
  and RMA = ma >>
S [87] ->
Q [88] << RMA = ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1100]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (38)                               [serial 1100] 
P [87] << CMA = RMA
  and RMA = ma >>
S [87] ->
Q [88] << CMA = ma >>
Why created:    normalization of [serial 1098]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Guided Substitution of Equals
 and theorem 37:
Theorem (37) [serial 1101] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1100] 


Theorem (39)                               [serial 1098] 
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87] ->
Q [88] << CMA = ma >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1097]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 38:
Theorem (38) [serial 1100] used for:
    normalization of [serial 1098] 


Theorem (40)                               [serial 1097] 
P [87] << ( GIVEN_CMA_IS_RMA() )
  and ma = RMA >>
S [87] ->
Q [88] << CMA = ma >>
Why created:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1079]
Solved by: Predicate Invocation. (PI) and theorem 39:
Theorem (39) [serial 1098] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1097] 


Theorem (41)                               [serial 1079] 
P [86] << GIVEN_CMA_IS_RMA() >>
S [87] m_a?(ma)
Q [88] << CMA = ma >>
Why created:    normalization of [serial 1067]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 40:
Theorem (40) [serial 1097] used for:
  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1079] 


Theorem (42)                               [serial 1067] 
P [86] << GIVEN_CMA_IS_RMA() >>
S [87] m_a?(ma)
Q [88] << ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
Solved by: Equality Commutes. (eqcom) and theorem 41:
Theorem (41) [serial 1079] used for:
    normalization of [serial 1067] 


Theorem (43)                               [serial 1102] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma
  and 1  = 1  >>
Why created:  applied wp for assignment [serial 1081]
Solved by: Law of identity. (eqid)

Theorem (44)                               [serial 1081] 
P [88] << CMA = ma >>
S [89] i := 1 
Q [90] << CMA = ma
  and 1  = i >>
Why created:    normalization of [serial 1068]
  Using: (eqcom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 43:
Theorem (43) [serial 1102] used for:
  applied wp for assignment [serial 1081] 


Theorem (45)                               [serial 1068] 
P [88] << ma = CMA >>
S [89] i := 1 
Q [90] << i = 1 
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 44:
Theorem (44) [serial 1081] used for:
    normalization of [serial 1068] 


Theorem (46)                               [serial 1072] 
P [90] << i = 1 
  and ma = CMA >>
S [91] iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (47)                               [serial 1072] 
P [90] << i = 1 
  and ma = CMA >>
S [91] iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (48)                               [serial 1069] 
P [90] << i = 1 
  and ma = CMA >>
S [91] iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 47 47:
Theorem (47) [serial 1072] used for:
   add user-defined "givens" to postcondition 
Theorem (47) [serial 1072] used for:
   add user-defined "givens" to postcondition 


Theorem (49)                               [serial 1073] 
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (50)                               [serial 1073] 
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (51)                               [serial 1070] 
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 50 50:
Theorem (50) [serial 1073] used for:
   add user-defined "givens" to postcondition 
Theorem (50) [serial 1073] used for:
   add user-defined "givens" to postcondition 


Theorem (52)                               [serial 1016] 
P [85] << m_a'fresh >>
S [86]   << GIVEN_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1 
  ;
  << i = 1 
    and ma = CMA >>
  iSeg := ma.seg[1 ]
  ;
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and GIVEN_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2 ]
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1 ]
    and GIVEN_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 25 36 42 45 48 51:
Theorem (25) [serial 1065] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1016] 
Theorem (36) [serial 1066] used for:
  <<Q4>> -> <<Q>> in sequential composition for [serial 1016] 
Theorem (42) [serial 1067] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016] 
Theorem (45) [serial 1068] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016] 
Theorem (48) [serial 1069] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016] 
Theorem (51) [serial 1070] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016] 


Theorem (53)                               [serial 1017] 
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A};
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (54)                               [serial 1488] 
P [59] << i < CMA.num_segments
  and p < iSeg.e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [128] ->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1018]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (55)                               [serial 1018] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{};
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 54:
Theorem (54) [serial 1488] used for:
    normalization of [serial 1018] 


Theorem (56)                               [serial 1494] 
P [59] << i < CMA.num_segments
  and iSeg.e <= p
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [134] ->
Q [135] << CMA = ma
  and CMA.seg[1  + i] = nSeg >>
Why created:    normalization of [serial 1491]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (57)                               [serial 1491] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134] ->
Q [135] << nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1489]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 56:
Theorem (56) [serial 1494] used for:
    normalization of [serial 1491] 


Theorem (58)                               [serial 1489] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134] iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 57:
Theorem (57) [serial 1491] used for:
  applied wp for assignment [serial 1489] 


Theorem (59)                               [serial 1496] 
P [135] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
S [136] ->
Q [61] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
Why created:    normalization of [serial 1492]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (60)                               [serial 1492] 
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136] ->
Q [61] << iSeg = CMA.seg[( i + 1  )]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1490]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 59:
Theorem (59) [serial 1496] used for:
    normalization of [serial 1492] 


Theorem (61)                               [serial 1490] 
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136] i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 60:
Theorem (60) [serial 1492] used for:
  applied wp for assignment [serial 1490] 


Theorem (62)                               [serial 1019] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]   iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1 ]
    and ma = CMA >>
  i := i + 1  
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 58 61:
Theorem (58) [serial 1489] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019] 
Theorem (61) [serial 1490] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019] 


Theorem (63)                               [serial 1504] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1500]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (64)                               [serial 1500] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << i < CMA.num_segments >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1499]
Solved by:  Guided Substitution of Equals
 and theorem 63:
Theorem (63) [serial 1504] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1500] 


Theorem (65)                               [serial 1501] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1499]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (66)                               [serial 1505] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << ma.seg[1  + i] = ma.seg[1  + i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1502]
Solved by: Law of identity. (eqid)

Theorem (67)                               [serial 1502] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << CMA.seg[1  + i] = ma.seg[1  + i] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1499]
Solved by:  Guided Substitution of Equals
 and theorem 66:
Theorem (66) [serial 1505] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1502] 


Theorem (68)                               [serial 1503] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1499]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (69)                               [serial 1499] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = ma.seg[1  + i]
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1497]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 64 65 67 68:
Theorem (64) [serial 1500] used for:
  Join consequents with conjunction. (3jca)
   [serial 1499] 
Theorem (65) [serial 1501] used for:
  Join consequents with conjunction. (3jca)
   [serial 1499] 
Theorem (67) [serial 1502] used for:
  Join consequents with conjunction. (3jca)
   [serial 1499] 
Theorem (68) [serial 1503] used for:
  Join consequents with conjunction. (3jca)
   [serial 1499] 


Theorem (70)                               [serial 1497] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1 ] = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1020]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 69:
Theorem (69) [serial 1499] used for:
    normalization of [serial 1497] 


Theorem (71)                               [serial 1020] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141] nSeg := ma.seg[i + 1 ]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 70:
Theorem (70) [serial 1497] used for:
  applied wp for assignment [serial 1020] 


Theorem (72)                               [serial 1513] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [146] << true >>
Why created:    normalization of [serial 1509]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Anything Implies True (a1tru): P->true

Theorem (73)                               [serial 1509] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146] ->
Q [146] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1507]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 72:
Theorem (72) [serial 1513] used for:
    normalization of [serial 1509] 


Theorem (74)                               [serial 1515] 
P [146] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments )
  and true >>
S [146] ->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1510]
  Using: (bl.atintro) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (75)                               [serial 1510] 
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146] ->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1507]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 74:
Theorem (74) [serial 1515] used for:
    normalization of [serial 1510] 


Theorem (76)                               [serial 1507] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146] r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 73 75:
Theorem (73) [serial 1509] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1507] 
Theorem (75) [serial 1510] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1507] 


Theorem (77)                               [serial 1519] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1517]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (78)                               [serial 1520] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA.num_segments = i >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1517]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (79)                               [serial 1521] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1517]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (80)                               [serial 1538] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1537]
Solved by: Law of identity. (eqid)

Theorem (81)                               [serial 1537] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1522]
Solved by:  Guided Substitution of Equals
 and theorem 80:
Theorem (80) [serial 1538] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1537] 


Theorem (82)                               [serial 1522] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1517]
Solved by:  Guided Substitution of Equals
 Predicate Invocation. (PI) and theorem 81:
Theorem (81) [serial 1537] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1522] 


Theorem (83)                               [serial 1517] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    normalization of [serial 1511]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 77 78 79 82:
Theorem (77) [serial 1519] used for:
  Join consequents with conjunction. (3jca)
   [serial 1517] 
Theorem (78) [serial 1520] used for:
  Join consequents with conjunction. (3jca)
   [serial 1517] 
Theorem (79) [serial 1521] used for:
  Join consequents with conjunction. (3jca)
   [serial 1517] 
Theorem (82) [serial 1522] used for:
  Join consequents with conjunction. (3jca)
   [serial 1517] 


Theorem (84)                               [serial 1511] 
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149] ->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1508]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 83:
Theorem (83) [serial 1517] used for:
    normalization of [serial 1511] 


Theorem (85)                               [serial 1508] 
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149] nSeg := [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 84:
Theorem (84) [serial 1511] used for:
  applied wp for assignment [serial 1508] 


Theorem (86)                               [serial 1021] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]   r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 76 85:
Theorem (76) [serial 1507] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021] 
Theorem (85) [serial 1508] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021] 


Theorem (87)                               [serial 1022] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155] ->
Q [72] << true >>
Why created:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{};
Solved by: Anything Implies True (a1tru): P->true

Theorem (88)                               [serial 1554] 
P [159] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg )
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    normalization of [serial 1540]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (89)                               [serial 1540] 
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159] ->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 88:
Theorem (88) [serial 1554] used for:
    normalization of [serial 1540] 


Theorem (90)                               [serial 1578] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or not ( v < iSeg.v_n ) or not ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) ) >>
Why created:  Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1577]
Solved by: Law of Excluded middle. (exmid)

Theorem (91)                               [serial 1577] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    normalization of [serial 1575]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bl.orcom) 
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 90:
Theorem (90) [serial 1578] used for:
  Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1577] 


Theorem (92)                               [serial 1575] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) ) or ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) ) or ( not ( v*v < ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) >>
Why created:  Replacing <= with not < of [serial 1556]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 91:
Theorem (91) [serial 1577] used for:
    normalization of [serial 1575] 


Theorem (93)                               [serial 1556] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:    normalization of [serial 1542]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.mulcom) (bl.ancom) (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 92:
Theorem (92) [serial 1575] used for:
  Replacing <= with not < of [serial 1556] 


Theorem (94)                               [serial 1542] 
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1541]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Multiplication Commutes. (bl.mulcom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 93:
Theorem (93) [serial 1556] used for:
    normalization of [serial 1542] 


Theorem (95)                               [serial 1558] 
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and iSeg.v_e <= v >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1548]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (96)                               [serial 1548] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1543]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 95:
Theorem (95) [serial 1558] used for:
    normalization of [serial 1548] 


Theorem (97)                               [serial 1543] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 96:
Theorem (96) [serial 1548] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1543] 


Theorem (98)                               [serial 1560] 
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1549]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.mulcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (99)                               [serial 1549] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1544]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Multiplication Commutes. (bl.mulcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 98:
Theorem (98) [serial 1560] used for:
    normalization of [serial 1549] 


Theorem (100)                               [serial 1544] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 99:
Theorem (99) [serial 1549] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1544] 


Theorem (101)                               [serial 1562] 
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1550]
  Using: (bl.addcom) (eqcom) changeAtLeastToAtMost (bl.mulcom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (102)                               [serial 1550] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1545]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [change A>=B to B<=A] Multiplication Commutes. (bl.mulcom) Conjunction Commutes. (bl.ancom) and theorem 101:
Theorem (101) [serial 1562] used for:
    normalization of [serial 1550] 


Theorem (103)                               [serial 1545] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 102:
Theorem (102) [serial 1550] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1545] 


Theorem (104)                               [serial 1564] 
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1551]
  Using: (bl.addcom) (eqcom) (bl.mulcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (105)                               [serial 1551] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1546]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) Multiplication Commutes. (bl.mulcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 104:
Theorem (104) [serial 1564] used for:
    normalization of [serial 1551] 


Theorem (106)                               [serial 1546] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B3>> S3 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 105:
Theorem (105) [serial 1551] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1546] 


Theorem (107)                               [serial 1566] 
P [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1552]
  Using: (bl.addcom) (eqcom) (bl.mulcom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (108)                               [serial 1552] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1547]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) Multiplication Commutes. (bl.mulcom) Conjunction Commutes. (bl.ancom) and theorem 107:
Theorem (107) [serial 1566] used for:
    normalization of [serial 1552] 


Theorem (109)                               [serial 1547] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]   {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B4>> S4 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 108:
Theorem (108) [serial 1552] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1547] 


Theorem (110)                               [serial 1541] 
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]   if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
Solved by: and theorems 94 97 100 103 106 109:
Theorem (94) [serial 1542] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1541] 
Theorem (97) [serial 1543] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1541] 
Theorem (100) [serial 1544] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1541] 
Theorem (103) [serial 1545] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1541] 
Theorem (106) [serial 1546] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1541] 
Theorem (109) [serial 1547] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1541] 


Theorem (111)                               [serial 1023] 
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
Solved by: null and theorems 89 110:
Theorem (89) [serial 1540] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023] 
Theorem (110) [serial 1541] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023] 


Theorem (112)                               [serial 1024] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186] ->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (113)                               [serial 1795] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (114)                               [serial 1795] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (115)                               [serial 1788] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:    normalization of [serial 1783]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 114 114:
Theorem (114) [serial 1795] used for:
   add user-defined "givens" to postcondition 
Theorem (114) [serial 1795] used for:
   add user-defined "givens" to postcondition 


Theorem (116)                               [serial 1783] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65] ->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 115:
Theorem (115) [serial 1788] used for:
    normalization of [serial 1783] 


Theorem (117)                               [serial 1797] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (118)                               [serial 1798] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA.num_segments = i >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (119)                               [serial 1802] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "CMA.num_segments" in its postcondition [serial 1799]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (120)                               [serial 1799] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by:  Guided Substitution of Equals
 and theorem 119:
Theorem (119) [serial 1802] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "CMA.num_segments" in its postcondition [serial 1799] 


Theorem (121)                               [serial 1800] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [68] << NEXT_MA = next_ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (122)                               [serial 1801] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << NEXT_MA.seg[1 ] = nSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (123)                               [serial 1790] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:    normalization of [serial 1784]
  Using: (eqcom) (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 117 118 120 121 122:
Theorem (117) [serial 1797] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 
Theorem (118) [serial 1798] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 
Theorem (120) [serial 1799] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 
Theorem (121) [serial 1800] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 
Theorem (122) [serial 1801] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 


Theorem (124)                               [serial 1784] 
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
S [67] ->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 123:
Theorem (123) [serial 1790] used for:
    normalization of [serial 1784] 


Theorem (125)                               [serial 1806] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1805]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (126)                               [serial 1807] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [194] << CMA.num_segments = i >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1805]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (127)                               [serial 1808] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1805]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (128)                               [serial 1809] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1805]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (129)                               [serial 1805] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1803]
Solved by: Join consequents with conjunction. (3jca) and theorems 125 126 127 128:
Theorem (125) [serial 1806] used for:
  Join consequents with conjunction. (3jca)
   [serial 1805] 
Theorem (126) [serial 1807] used for:
  Join consequents with conjunction. (3jca)
   [serial 1805] 
Theorem (127) [serial 1808] used for:
  Join consequents with conjunction. (3jca)
   [serial 1805] 
Theorem (128) [serial 1809] used for:
  Join consequents with conjunction. (3jca)
   [serial 1805] 


Theorem (130)                               [serial 1803] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193] ->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1792]
Solved by: Equality Commutes. (eqcom) and theorem 129:
Theorem (129) [serial 1805] used for:
    normalization of [serial 1803] 


Theorem (131)                               [serial 1792] 
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193] m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1785]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 130:
Theorem (130) [serial 1803] used for:
  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1792] 


Theorem (132)                               [serial 1785] 
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193] m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 131:
Theorem (131) [serial 1792] used for:
    normalization of [serial 1785] 


Theorem (133)                               [serial 1823] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [198] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (134)                               [serial 1824] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << CMA.num_segments = i >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (135)                               [serial 1825] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (136)                               [serial 1826] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << NEXT_MA = next_ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (137)                               [serial 1828] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << next_ma.seg[1 ] = next_ma.seg[1 ] >>
Why created:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1827]
Solved by: Law of identity. (eqid)

Theorem (138)                               [serial 1827] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by:  Guided Substitution of Equals
 and theorem 137:
Theorem (137) [serial 1828] used for:
  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1827] 


Theorem (139)                               [serial 1822] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:  applied wp for assignment [serial 1794]
Solved by: Join consequents with conjunction. (3jca) and theorems 133 134 135 136 138:
Theorem (133) [serial 1823] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 
Theorem (134) [serial 1824] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 
Theorem (135) [serial 1825] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 
Theorem (136) [serial 1826] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 
Theorem (138) [serial 1827] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 


Theorem (140)                               [serial 1794] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] nSeg := next_ma.seg[1 ]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:    normalization of [serial 1786]
  Using: (eqcom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 139:
Theorem (139) [serial 1822] used for:
  applied wp for assignment [serial 1794] 


Theorem (141)                               [serial 1786] 
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196] nSeg := next_ma.seg[1 ]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 140:
Theorem (140) [serial 1794] used for:
    normalization of [serial 1786] 


Theorem (142)                               [serial 1025] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]   << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and GIVEN_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1 ]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1 ] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 116 124 132 141:
Theorem (116) [serial 1783] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1025] 
Theorem (124) [serial 1784] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1025] 
Theorem (132) [serial 1785] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025] 
Theorem (141) [serial 1786] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025] 


Theorem (143)                               [serial 1026] 
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [202] ->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{};
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (144)                               [serial 1027] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205] ->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{};
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (145)                               [serial 1837] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (146)                               [serial 1837] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (147)                               [serial 1831] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 146 146:
Theorem (146) [serial 1837] used for:
   add user-defined "givens" to postcondition 
Theorem (146) [serial 1837] used for:
   add user-defined "givens" to postcondition 


Theorem (148)                               [serial 1849] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << 1  < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1848]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (149)                               [serial 1848] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << 1  < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1844]
Solved by:  Guided Substitution of Equals
 and theorem 148:
Theorem (148) [serial 1849] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1848] 


Theorem (150)                               [serial 1844] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1843]
Solved by:  Guided Substitution of Equals
 and theorem 149:
Theorem (149) [serial 1848] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1844] 


Theorem (151)                               [serial 1845] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1843]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (152)                               [serial 1846] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1843]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (153)                               [serial 1847] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1843]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (154)                               [serial 1843] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1841]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 150 151 152 153:
Theorem (150) [serial 1844] used for:
  Join consequents with conjunction. (3jca)
   [serial 1843] 
Theorem (151) [serial 1845] used for:
  Join consequents with conjunction. (3jca)
   [serial 1843] 
Theorem (152) [serial 1846] used for:
  Join consequents with conjunction. (3jca)
   [serial 1843] 
Theorem (153) [serial 1847] used for:
  Join consequents with conjunction. (3jca)
   [serial 1843] 


Theorem (155)                               [serial 1841] 
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ( 1  < ma.num_segments ) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1832]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 154:
Theorem (154) [serial 1843] used for:
    normalization of [serial 1841] 


Theorem (156)                               [serial 1832] 
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  <<Q4>> -> <<Q>> in sequential composition for [serial 1028]
Solved by: Predicate Invocation. (PI) and theorem 155:
Theorem (155) [serial 1841] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1832] 


Theorem (157)                               [serial 1854] 
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211] ->
Q [212] << NEXT_MA = next_ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1853]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (158)                               [serial 1853] 
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211] ->
Q [212] << CMA = next_ma >>
Why created:    normalization of [serial 1851]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Guided Substitution of Equals
 and theorem 157:
Theorem (157) [serial 1854] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1853] 


Theorem (159)                               [serial 1851] 
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211] ->
Q [212] << next_ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1850]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 158:
Theorem (158) [serial 1853] used for:
    normalization of [serial 1851] 


Theorem (160)                               [serial 1850] 
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211] ->
Q [212] << next_ma = CMA >>
Why created:  applied wp for assignment [serial 1833]
Solved by: Predicate Invocation. (PI) and theorem 159:
Theorem (159) [serial 1851] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1850] 


Theorem (161)                               [serial 1833] 
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211] ma := next_ma
Q [212] << ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 160:
Theorem (160) [serial 1850] used for:
  applied wp for assignment [serial 1833] 


Theorem (162)                               [serial 1857] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << CMA = ma
  and 1  = 1  >>
Why created:    normalization of [serial 1855]
  Using: (eqcom) (bl.ancom) 
Solved by: Law of identity. (eqid)

Theorem (163)                               [serial 1855] 
P [212] << ma = CMA >>
S [213] ->
Q [214] << 1  = 1 
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1834]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 162:
Theorem (162) [serial 1857] used for:
    normalization of [serial 1855] 


Theorem (164)                               [serial 1834] 
P [212] << ma = CMA >>
S [213] i := 1 
Q [214] << i = 1 
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 163:
Theorem (163) [serial 1855] used for:
  applied wp for assignment [serial 1834] 


Theorem (165)                               [serial 1863] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << i = 1  >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1862]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (166)                               [serial 1864] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << ma = CMA >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1862]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (167)                               [serial 1869] 
P [214] << CMA = ma
  and 1  = i >>
S [215] ->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:    normalization of [serial 1867]
  Using: (eqcom) (bl.ancom) 
Solved by: Law of identity. (eqid)

Theorem (168)                               [serial 1867] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1866]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 167:
Theorem (167) [serial 1869] used for:
    normalization of [serial 1867] 


Theorem (169)                               [serial 1866] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1 ] = ma.seg[i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1865]
Solved by:  Guided Substitution of Equals
 and theorem 168:
Theorem (168) [serial 1867] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1866] 


Theorem (170)                               [serial 1865] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1 ] = CMA.seg[i] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1862]
Solved by:  Guided Substitution of Equals
 and theorem 169:
Theorem (169) [serial 1866] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1865] 


Theorem (171)                               [serial 1862] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << i = 1 
  and ma = CMA
  and ma.seg[1 ] = CMA.seg[i] >>
Why created:  applied wp for assignment [serial 1835]
Solved by: Join consequents with conjunction. (3jca) and theorems 165 166 170:
Theorem (165) [serial 1863] used for:
  Join consequents with conjunction. (3jca)
   [serial 1862] 
Theorem (166) [serial 1864] used for:
  Join consequents with conjunction. (3jca)
   [serial 1862] 
Theorem (170) [serial 1865] used for:
  Join consequents with conjunction. (3jca)
   [serial 1862] 


Theorem (172)                               [serial 1835] 
P [214] << i = 1 
  and ma = CMA >>
S [215] iSeg := ma.seg[1 ]
Q [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 171:
Theorem (171) [serial 1862] used for:
  applied wp for assignment [serial 1835] 


Theorem (173)                               [serial 1871] 
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (174)                               [serial 1871] 
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (175)                               [serial 1836] 
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 174 174:
Theorem (174) [serial 1871] used for:
   add user-defined "givens" to postcondition 
Theorem (174) [serial 1871] used for:
   add user-defined "givens" to postcondition 


Theorem (176)                               [serial 1028] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]   << GIVEN_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1 
  ;
  << i = 1 
    and ma = CMA >>
  iSeg := ma.seg[1 ]
  ;
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2 ]
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1 ]
    and GIVEN_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 147 156 161 164 172 175:
Theorem (147) [serial 1831] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1028] 
Theorem (156) [serial 1832] used for:
  <<Q4>> -> <<Q>> in sequential composition for [serial 1028] 
Theorem (161) [serial 1833] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028] 
Theorem (164) [serial 1834] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028] 
Theorem (172) [serial 1835] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028] 
Theorem (175) [serial 1836] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028] 


Theorem (177)                               [serial 1002] 
P [33] <<   >>
S [39] ->
Q [33] << AutoBrake.i proof obligations >>
Why created:  Initial proof obligations for AutoBrake.i
Solved by:  Component verification conditions
 and theorems 1 2 3 5 8 9 10 12 13 16 20 21 22 52 53 55 62 71 86 87 111 112 142 143 144 176:
Theorem (1) [serial 1003] used for:
  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition. 
Theorem (2) [serial 1004] used for:
  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition. 
Theorem (3) [serial 1005] used for:
  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition. 
Theorem (5) [serial 1006] used for:
  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition. 
Theorem (8) [serial 1007] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>> 
Theorem (9) [serial 1008] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (10) [serial 1009] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>> 
Theorem (12) [serial 1010] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (13) [serial 1011] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>> 
Theorem (16) [serial 1012] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>> 
Theorem (20) [serial 1013] used for:
   <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A}; 
Theorem (21) [serial 1014] used for:
   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{}; 
Theorem (22) [serial 1015] used for:
   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{}; 
Theorem (52) [serial 1016] used for:
   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A}; 
Theorem (53) [serial 1017] used for:
   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A}; 
Theorem (55) [serial 1018] used for:
   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{}; 
Theorem (62) [serial 1019] used for:
   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A}; 
Theorem (71) [serial 1020] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A}; 
Theorem (86) [serial 1021] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A}; 
Theorem (87) [serial 1022] used for:
   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{}; 
Theorem (111) [serial 1023] used for:
   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A}; 
Theorem (112) [serial 1024] used for:
   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{}; 
Theorem (142) [serial 1025] used for:
   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A}; 
Theorem (143) [serial 1026] used for:
   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{}; 
Theorem (144) [serial 1027] used for:
   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{}; 
Theorem (176) [serial 1028] used for:
   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A}; 


Theorem (178)                               [serial 1029] 
P [1] << ma_m_a = RMA >>
S [2] ->
Q [1] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection ma -> controller.control.m_a:
 ma -> m_a
Solved by: Identity (id):  P->P is tautology

Theorem (179)                               [serial 1030] 
P [1] << xl = OPERATOR_XL >>
S [2] ->
Q [1] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
Solved by: Identity (id):  P->P is tautology

Theorem (180)                               [serial 1031] 
P [1] << p = POSITION >>
S [2] ->
Q [1] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
Solved by: Identity (id):  P->P is tautology

Theorem (181)                               [serial 1032] 
P [1] << v = VELOCITY >>
S [2] ->
Q [1] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
Solved by: Identity (id):  P->P is tautology

Theorem (182)                               [serial 1033] 
P [1] << SB()
  and not EB() >>
S [2] ->
Q [1] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
Solved by: Identity (id):  P->P is tautology

Theorem (183)                               [serial 1034] 
P [1] << EB() >>
S [2] ->
Q [1] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
Solved by: Identity (id):  P->P is tautology

Theorem (184)                               [serial 1035] 
P [14] << ma_m_a = RMA >>
S [73] ->
Q [94] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
Solved by: Identity (id):  P->P is tautology

Theorem (185)                               [serial 1036] 
P [32] << p = POSITION >>
S [74] ->
Q [89] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
Solved by: Identity (id):  P->P is tautology

Theorem (186)                               [serial 1037] 
P [34] << v = VELOCITY >>
S [75] ->
Q [91] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
Solved by: Identity (id):  P->P is tautology

Theorem (187)                               [serial 1038] 
P [59] << xl = OPERATOR_XL >>
S [76] ->
Q [23] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
Solved by: Identity (id):  P->P is tautology

Theorem (188)                               [serial 1039] 
P [85] << SB()
  and not EB() >>
S [77] ->
Q [44] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
Solved by: Identity (id):  P->P is tautology

Theorem (189)                               [serial 1040] 
P [87] << EB() >>
S [78] ->
Q [51] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
Solved by: Identity (id):  P->P is tautology

Theorem (190)                               [serial 1041] 
P [89] << p = POSITION >>
S [103] ->
Q [19] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
Solved by: Identity (id):  P->P is tautology

Theorem (191)                               [serial 1042] 
P [91] << v = VELOCITY >>
S [104] ->
Q [21] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
Solved by: Identity (id):  P->P is tautology

Theorem (192)                               [serial 1043] 
P [94] << m_a = RMA >>
S [106] ->
Q [17] << m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
Solved by: Identity (id):  P->P is tautology

Theorem (193)                               [serial 1044] 
P [12] << SB()
  and not EB() >>
S [108] ->
Q [85] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
Solved by: Identity (id):  P->P is tautology

Theorem (194)                               [serial 1045] 
P [14] << EB() >>
S [109] ->
Q [87] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
Solved by: Identity (id):  P->P is tautology

Theorem (195)                               [serial 1046] 
P [27] << ma = RMA >>
S [19] ->
Q [14] << ma = RMA >>
Why created:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
Solved by: Identity (id):  P->P is tautology

Theorem (196)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
 and theorems 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195:
Theorem (177) [serial 1002] used for:
  Initial proof obligations for AutoBrake.i 
Theorem (178) [serial 1029] used for:
  Composition of Subcomponents via Directional Connection ma -> controller.control.m_a:
 ma -> m_a 
Theorem (179) [serial 1030] used for:
  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl 
Theorem (180) [serial 1031] used for:
  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p 
Theorem (181) [serial 1032] used for:
  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v 
Theorem (182) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake 
Theorem (183) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake 
Theorem (184) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a 
Theorem (185) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p 
Theorem (186) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v 
Theorem (187) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl 
Theorem (188) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake 
Theorem (189) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake 
Theorem (190) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p 
Theorem (191) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v 
Theorem (192) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a 
Theorem (193) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb 
Theorem (194) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb 
Theorem (195) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma 


showing tree: Derivations
closing proof file "/Applications/osate2_2023-03-master/Eclipse.app/Contents/MacOS/proof.txt" 
proof duration:  9.2 seconds 

