opening dump file "/Applications/osate2/Eclipse.app/Contents/MacOS/dump.txt" Wed Apr 26 14:28:58 CDT 2023
opening proof script file "/Applications/osate2/Eclipse.app/Contents/MacOS/script.txt"

Declarative Model has been Loaded.

 extracting initial proof obligation(s) for a package:  "CTCS"
  creating proof obligations for "MovementAuthority"
  creating proof obligations for "RadioBlockCenter"
  creating proof obligations for "MovementAuthority.i"
 extracting initial proof obligation(s) for a package:  "CTCS_Types"
  no proof obligations created for "Position"
  no proof obligations created for "movementAuthorization"
  no proof obligations created for "Acceleration"
  no proof obligations created for "Velocity"
  no proof obligations created for "Segment"
 extracting initial proof obligation(s) for a package:  "Threads"
  creating proof obligations for "AutoBrake"
  creating proof obligations for "AutoBrake.i"
[source=WaitFirstMA destination=CheckFirstMA dispatch condition=p, source=MoveForward destination=CheckMoveForward dispatch condition=p, source=MoveForwardLastSegment destination=CheckMoveForwardLastSegment dispatch condition=p, source=GotNewMA destination=CheckMATransition dispatch condition=p]
extracting proof obligations for "AutoBrake.i"

[serial 1002]: Threads::AutoBrake.i
P [33] <<   >>
S [39]->
Q [33] << AutoBrake.i proof obligations >>
What for:  Initial proof obligations for AutoBrake.i
Reason solved:  Component verification conditions
making initial obligations for complete states

[serial 1003]: Threads::AutoBrake.i
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.

[serial 1004]: Threads::AutoBrake.i
P [54] << true >>
S [39]->
Q [39] << true >>
What for:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.

[serial 1005]: Threads::AutoBrake.i
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.

[serial 1006]: Threads::AutoBrake.i
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39]->
Q [39] << true >>
What for:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
making Serban's theorems

[serial 1007]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [59]->
Q [59] << ( p < iSeg.e )
   or ( p >= iSeg.e ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>

[serial 1008]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>

[serial 1009]: Threads::AutoBrake.i
P [53] << true >>
S [53]->
Q [53] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>

[serial 1010]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61]->
Q [61] << ( i < ma.num_segments )
   or ( i = ma.num_segments )
   or ( i > ma.num_segments ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>

[serial 1011]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>

[serial 1012]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70]->
Q [70] << ( p < ma.ea )
   or ( p >= ma.ea ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
making initial proof obligations for transitions

[serial 1013]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:   <<M(Start)>> A <<M(WaitFirstMA)>> for GoStart-[ ]->WaitFirstMA{A};

[serial 1014]: Threads::AutoBrake.i
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [78]->
Q [55] << true >>
What for:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMAWaitFirstMA-[x]->CheckFirstMA{};

[serial 1015]: Threads::AutoBrake.i
P [82] << not m_a'fresh >>
S [81]->
Q [54] << true >>
What for:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYetCheckFirstMA-[x]->WaitFirstMA{};

[serial 1016]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [86]  << AXIOM_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and AXIOM_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A};

[serial 1017]: Threads::AutoBrake.i
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A};

[serial 1018]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{};

[serial 1019]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]  iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1]
    and ma = CMA >>
  i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A};

[serial 1020]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]nSeg := ma.seg[i + 1]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A};

[serial 1021]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]  r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A};

[serial 1022]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155]->
Q [72] << true >>
What for:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{};

[serial 1023]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [160]<< i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegmentMoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};

[serial 1024]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};

[serial 1025]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and AXIOM_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A};

[serial 1026]: Threads::AutoBrake.i
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{};

[serial 1027]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{};

[serial 1028]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]  << AXIOM_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A};
 extracting initial proof obligation(s) for a package:  "Train"
  no proof obligations created for "Operator"
  creating proof obligations for "ServiceBrake"
  creating proof obligations for "Motor"
  creating proof obligations for "Train"
  creating proof obligations for "EmergencyBrake"
  no proof obligations created for "ControllerProcess"
  creating proof obligations for "Sensor"
  creating proof obligations for "Train.i"
 extracting initial proof obligation(s) for a package:  "CTCS_Assertion"
source Assertion of driver.xl -> motor.xl:  << xl = OPERATOR_XL >>
destination Assertion of driver.xl -> motor.xl:  << xl = OPERATOR_XL >>

[serial 1029]: driver.xl -> motor.xl
P [1] << xl = OPERATOR_XL >>
S [2]->
Q [1] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
source Assertion of sensor.p -> controller.control.p:  << p = POSITION >>
destination Assertion of sensor.p -> controller.control.p:  << p = POSITION >>

[serial 1030]: sensor.p -> controller.control.p
P [1] << p = POSITION >>
S [2]->
Q [1] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
source Assertion of sensor.v -> controller.control.v:  << v = VELOCITY >>
destination Assertion of sensor.v -> controller.control.v:  << v = VELOCITY >>

[serial 1031]: sensor.v -> controller.control.v
P [1] << v = VELOCITY >>
S [2]->
Q [1] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
source Assertion of controller.control.sb -> sbrake.brake:  << SB()
  and not EB() >>
destination Assertion of controller.control.sb -> sbrake.brake:  << SB()
  and not EB() >>

[serial 1032]: controller.control.sb -> sbrake.brake
P [1] << SB()
  and not EB() >>
S [2]->
Q [1] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
source Assertion of controller.control.eb -> ebrake.brake:  << EB() >>
destination Assertion of controller.control.eb -> ebrake.brake:  << EB() >>

[serial 1033]: controller.control.eb -> ebrake.brake
P [1] << EB() >>
S [2]->
Q [1] << EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
source Assertion of rbc.ma -> train.controller.control.m_a:  << ma_m_a = RMA >>
destination Assertion of rbc.ma -> train.controller.control.m_a:  << ma_m_a = RMA >>

[serial 1034]: rbc.ma -> train.controller.control.m_a
P [1] << ma_m_a = RMA >>
S [2]->
Q [1] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
6 instance model connection assume-guarantee verification conditions generated.
source Assertion of ma:  << ma = RMA >>
destination Assertion of ma:  << ma = RMA >>

[serial 1035]: CTCS::MovementAuthority.i.ma
P [27] << ma = RMA >>
S [19]->
Q [14] << ma = RMA >>
What for:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
source Assertion of auth:  << ma_m_a = RMA >>
destination Assertion of auth:  << ma_m_a = RMA >>

[serial 1036]: Train::Train.i.auth
P [14] << ma_m_a = RMA >>
S [73]->
Q [94] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
source Assertion of pos:  << p = POSITION >>
destination Assertion of pos:  << p = POSITION >>

[serial 1037]: Train::Train.i.pos
P [32] << p = POSITION >>
S [74]->
Q [89] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
source Assertion of vel:  << v = VELOCITY >>
destination Assertion of vel:  << v = VELOCITY >>

[serial 1038]: Train::Train.i.vel
P [34] << v = VELOCITY >>
S [75]->
Q [91] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
source Assertion of dxl:  << xl = OPERATOR_XL >>
destination Assertion of dxl:  << xl = OPERATOR_XL >>

[serial 1039]: Train::Train.i.dxl
P [59] << xl = OPERATOR_XL >>
S [76]->
Q [23] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
source Assertion of cpsb:  << SB()
  and not EB() >>
destination Assertion of cpsb:  << SB()
  and not EB() >>

[serial 1040]: Train::Train.i.cpsb
P [85] << SB()
  and not EB() >>
S [77]->
Q [44] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
source Assertion of cpeb:  << EB() >>
destination Assertion of cpeb:  << EB() >>

[serial 1041]: Train::Train.i.cpeb
P [87] << EB() >>
S [78]->
Q [51] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
source Assertion of conn_s:  << p = POSITION >>
destination Assertion of conn_s:  << p = POSITION >>

[serial 1042]: Train::ControllerProcess.i.conn_s
P [89] << p = POSITION >>
S [103]->
Q [19] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
source Assertion of conn_v:  << v = VELOCITY >>
destination Assertion of conn_v:  << v = VELOCITY >>

[serial 1043]: Train::ControllerProcess.i.conn_v
P [91] << v = VELOCITY >>
S [104]->
Q [21] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
source Assertion of conn_ma:  << m_a = RMA >>
destination Assertion of conn_ma:  << m_a = RMA >>

[serial 1044]: Train::ControllerProcess.i.conn_ma
P [94] << m_a = RMA >>
S [106]->
Q [17] << m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
source Assertion of conn_sb:  << SB()
  and not EB() >>
destination Assertion of conn_sb:  << SB()
  and not EB() >>

[serial 1045]: Train::ControllerProcess.i.conn_sb
P [12] << SB()
  and not EB() >>
S [108]->
Q [85] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
source Assertion of conn_eb:  << EB() >>
destination Assertion of conn_eb:  << EB() >>

[serial 1046]: Train::ControllerProcess.i.conn_eb
P [14] << EB() >>
S [109]->
Q [87] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
12 declarative model connection assume-guarantee verification conditions generated.
There was one instance model connection lacking a BLESS::Assertion property on both ends.
There was one Declarative model connection lacking a BLESS::Assertion property on one end.
There were 3 Declarative model connections lacking a BLESS::Assertion property on both ends.
No errors found.
Executing proof script . . .
You chose proof script: /Users/brianlarson/git/BLESS-models/CTCS-3/proof/CTCS3.ps
step:  1
#This file, script.txt, was produced the BLESS Proof Assistant v3.2.0
step:  2
#  at Fri Apr 21 10:23:36 CDT 2023 by brianlarson
step:  3
#  You chose proof script: /Users/brianlarson/git/BLESS-models/CTCS-3/proof/CTCS3.ps
step:  4
#Threads::AutoBrake.i
step:  5
#[serial 1003] <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definitio
step:  6
****make-an****
Making obligation 0
Obligations:

[serial 1003]: Threads::AutoBrake.i
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
Done making obligation 0
step:  7
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1003]: Threads::AutoBrake.i
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1004]: Threads::AutoBrake.i
P [54] << true >>
S [39]->
Q [39] << true >>
What for:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  8
#[serial 1004] <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
step:  9
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1004]: Threads::AutoBrake.i
P [54] << true >>
S [39]->
Q [39] << true >>
What for:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1005]: Threads::AutoBrake.i
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  10
#[serial 1005] <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
step:  11
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1005]: Threads::AutoBrake.i
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1006]: Threads::AutoBrake.i
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39]->
Q [39] << true >>
What for:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  12
#[serial 1006] <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
step:  13
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1006]: Threads::AutoBrake.i
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39]->
Q [39] << true >>
What for:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1048]: Threads::AutoBrake.i
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [39]->
Q [39] << true >>
What for:    normalization of [serial 1006]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1048]: Threads::AutoBrake.i
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [39]->
Q [39] << true >>
What for:    normalization of [serial 1006]
Done Normalizing
step:  14
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1048]: Threads::AutoBrake.i
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [39]->
Q [39] << true >>
What for:    normalization of [serial 1006]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1007]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [59]->
Q [59] << ( p < iSeg.e )
   or ( p >= iSeg.e ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  15
#[serial 1007] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
step:  16
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1007]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [59]->
Q [59] << ( p < iSeg.e )
   or ( p >= iSeg.e ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1051]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << iSeg.e <= p
   or p < iSeg.e >>
What for:    normalization of [serial 1007]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1051]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << iSeg.e <= p
   or p < iSeg.e >>
What for:    normalization of [serial 1007]
Done Normalizing
step:  17
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1051]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << iSeg.e <= p
   or p < iSeg.e >>
What for:    normalization of [serial 1007]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1053]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << ( not ( p < iSeg.e ) )
   or p < iSeg.e >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051]
. . . Substituting <= with not < [3570 minutes 46 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1053]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << ( not ( p < iSeg.e ) )
   or p < iSeg.e >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051]
Done replacing a<=b with (not b<a)
step:  18
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1053]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << ( not ( p < iSeg.e ) )
   or p < iSeg.e >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1054]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1053]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1054]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1053]
Done applying laws
step:  19
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1054]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1053]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1008]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  20
#[serial 1008] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
step:  21
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1008]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1055]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1008]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1055]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1008]
Done applying laws
step:  22
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1055]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1008]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1009]: Threads::AutoBrake.i
P [53] << true >>
S [53]->
Q [53] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  23
#[serial 1009] Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
step:  24
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1009]: Threads::AutoBrake.i
P [53] << true >>
S [53]->
Q [53] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1010]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61]->
Q [61] << ( i < ma.num_segments )
   or ( i = ma.num_segments )
   or ( i > ma.num_segments ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  25
#[serial 1010] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
step:  26
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1010]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61]->
Q [61] << ( i < ma.num_segments )
   or ( i = ma.num_segments )
   or ( i > ma.num_segments ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1057]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << i = ma.num_segments
   or i < ma.num_segments
   or ma.num_segments < i >>
What for:    normalization of [serial 1010]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1057]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << i = ma.num_segments
   or i < ma.num_segments
   or ma.num_segments < i >>
What for:    normalization of [serial 1010]
Done Normalizing
step:  27
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1057]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << i = ma.num_segments
   or i < ma.num_segments
   or ma.num_segments < i >>
What for:    normalization of [serial 1010]
Reason solved:  Less than, greater than, or equal:  |-a<b or b<a or a=b
Has applied law "Less than, greater than, or equal:  |-a<b or b<a or a=b " to get:

[serial 1059]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << true >>
What for:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1059]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << true >>
What for:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057]
Done applying laws
step:  28
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1059]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << true >>
What for:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1011]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  29
#[serial 1011] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
step:  30
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1011]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1060]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1011]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1060]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1011]
Done applying laws
step:  31
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1060]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1011]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1012]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70]->
Q [70] << ( p < ma.ea )
   or ( p >= ma.ea ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  32
#[serial 1012] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
step:  33
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1012]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70]->
Q [70] << ( p < ma.ea )
   or ( p >= ma.ea ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1062]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ma.ea <= p
   or p < ma.ea >>
What for:    normalization of [serial 1012]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1062]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ma.ea <= p
   or p < ma.ea >>
What for:    normalization of [serial 1012]
Done Normalizing
step:  34
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1062]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ma.ea <= p
   or p < ma.ea >>
What for:    normalization of [serial 1012]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1064]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ( not ( p < ma.ea ) )
   or p < ma.ea >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062]
. . . Substituting <= with not < [3570 minutes 46 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1064]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ( not ( p < ma.ea ) )
   or p < ma.ea >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062]
Done replacing a<=b with (not b<a)
step:  35
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1064]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ( not ( p < ma.ea ) )
   or p < ma.ea >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1065]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1064]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1065]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1064]
Done applying laws
step:  36
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1065]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1064]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1013]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:   <<M(Start)>> A <<M(WaitFirstMA)>> for GoStart-[ ]->WaitFirstMA{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  37
#[serial 1013]  <<M(Start)>> A <<M(WaitFirstMA)>> for GoStart-[ ]->WaitFirstMA{A};
step:  38
****reduce****

[serial 1066]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1066]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
done reducing composite actions
step:  39
****atomic****
applying atomic actions . . .
out event port r on line 76 does not have a BLESS::Assertion property AutoBrake.i; <<true>> used instead.

This Proof Obligation:

[serial 1066]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
Has applied <<pre>> -> <<M(r)>> for <<pre>> r! <<post>> to get:

[serial 1067]: Threads::AutoBrake.i
P [53] << true >>
S [76]->
Q [76] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1066]
Has applied <<pre and r@now>> -> <<post>> for <<pre>> r! <<post>> to get:

[serial 1068]: Threads::AutoBrake.i
P [76] << ( true )
  and true@now >>
S [76]->
Q [54] << true >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066]
. . . done applying atomic actions [3570 minutes 46 seconds ]
After "atomic" remaining 
Obligations:

[serial 1067]: Threads::AutoBrake.i
P [53] << true >>
S [76]->
Q [76] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1066]

[serial 1068]: Threads::AutoBrake.i
P [76] << ( true )
  and true@now >>
S [76]->
Q [54] << true >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066]
Done reducing atomic actions
step:  40
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1067]: Threads::AutoBrake.i
P [53] << true >>
S [76]->
Q [76] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1066]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1068]: Threads::AutoBrake.i
P [76] << ( true )
  and true@now >>
S [76]->
Q [54] << true >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1014]: Threads::AutoBrake.i
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [78]->
Q [55] << true >>
What for:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMAWaitFirstMA-[x]->CheckFirstMA{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  41
#[serial 1014]  <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMAWaitFirstMA-[x]->CheckFirstMA{};
step:  42
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1014]: Threads::AutoBrake.i
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [78]->
Q [55] << true >>
What for:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMAWaitFirstMA-[x]->CheckFirstMA{};
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1015]: Threads::AutoBrake.i
P [82] << not m_a'fresh >>
S [81]->
Q [54] << true >>
What for:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYetCheckFirstMA-[x]->WaitFirstMA{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  43
#[serial 1015]  <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYetCheckFirstMA-[x]->WaitFirstMA{};
step:  44
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1015]: Threads::AutoBrake.i
P [82] << not m_a'fresh >>
S [81]->
Q [54] << true >>
What for:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYetCheckFirstMA-[x]->WaitFirstMA{};
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1016]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [86]  << AXIOM_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and AXIOM_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  45
#[serial 1016]  <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A};
step:  46
****reduce****
This proof obligation:

[serial 1016]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [86]  << AXIOM_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and AXIOM_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P3>> S3 <<Q3>>
 
was reduced to:

[serial 1069]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << AXIOM_CMA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1016]

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q3>> -> <<Q>> in sequential composition for [serial 1016]

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

[serial 1073]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]

[serial 1074]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
What for:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1016]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1069]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << AXIOM_CMA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1016]

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q3>> -> <<Q>> in sequential composition for [serial 1016]

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

[serial 1073]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]

[serial 1074]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
What for:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1016]
done reducing composite actions
step:  47
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1069]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << AXIOM_CMA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1016]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

This proof obligation:

[serial 1073]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1076]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

This proof obligation:

[serial 1074]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
What for:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1016]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1077]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [3570 minutes 46 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q3>> -> <<Q>> in sequential composition for [serial 1016]

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition

[serial 1076]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
What for:   add user-defined axioms to postcondition

[serial 1077]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  48
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1076]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1078]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  Law of And-Simplification:  P and true is P [serial 1076]

This Proof Obligation:

[serial 1077]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1079]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1077]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q3>> -> <<Q>> in sequential composition for [serial 1016]

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition

[serial 1078]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  Law of And-Simplification:  P and true is P [serial 1076]

[serial 1079]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1077]
Done applying laws
step:  49
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q3>> -> <<Q>> in sequential composition for [serial 1016]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1081]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1070]

This Proof Obligation:

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1083]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
What for:    normalization of [serial 1071]

This Proof Obligation:

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1085]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1
Q [90] << CMA = ma
  and i = 1 >>
What for:    normalization of [serial 1072]

This Proof Obligation:

[serial 1078]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  Law of And-Simplification:  P and true is P [serial 1076]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1088]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
What for:    normalization of [serial 1078]

This Proof Obligation:

[serial 1079]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1077]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1090]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
What for:    normalization of [serial 1079]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition

[serial 1081]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1070]

[serial 1083]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
What for:    normalization of [serial 1071]

[serial 1085]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1
Q [90] << CMA = ma
  and i = 1 >>
What for:    normalization of [serial 1072]

[serial 1088]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
What for:    normalization of [serial 1078]

[serial 1090]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
What for:    normalization of [serial 1079]
Done Normalizing
step:  50
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  51
#Threads::AutoBrake.i
step:  52
#[serial 1075]  add user-defined axioms to postconditi
step:  53
****make-an****
Making obligation 14
Obligations:

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition
Done making obligation 14
step:  54
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1081]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1070]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  55
#[serial 1081]   normalization of [serial 1070]
step:  56
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1081]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1070]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1096]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1097]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1098]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1099]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
. . . done splitting postcondition  [3570 minutes 46 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1096]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1097]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1098]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1099]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Done splitting postcondition
step:  57
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1096]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1097]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1098]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:

[serial 1099]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Done trying to apply axioms
step:  58
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1099]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1100]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1099]
. . . done substituting assertions' for Labels [3570 minutes 46 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1100]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1099]
Done substituting Assertion labels in preconditions
step:  59
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1100]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1099]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1101]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1101]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100]
Done guided substituting an equals
step:  60
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1101]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1103]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:    normalization of [serial 1101]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1103]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:    normalization of [serial 1101]
Done Normalizing
step:  61
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1103]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:    normalization of [serial 1101]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1105]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1105]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103]
Done guided substituting an equals
step:  62
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1105]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1107]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1105]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1107]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1105]
Done Normalizing
step:  63
****guided-sub-equals****
guided substitution of equals "ma" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1107]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1105]
Reason solved:  Guided Substitution of Equals
Has substituted 
"ma" with its = "CMA"
 to get:

[serial 1109]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1109]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107]
Done guided substituting an equals
step:  64
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1109]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1083]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
What for:    normalization of [serial 1071]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  65
#[serial 1083]   normalization of [serial 1071]
step:  66
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1083]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
What for:    normalization of [serial 1071]
Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(m_a)>> -> <<post>> for <<pre>> m_a?(ma) <<post>> to get:

[serial 1110]: Threads::AutoBrake.i
P [87] << ( AXIOM_CMA_IS_RMA() )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083]
. . . done applying atomic actions [3570 minutes 46 seconds ]
After "atomic" remaining 
Obligations:

[serial 1110]: Threads::AutoBrake.i
P [87] << ( AXIOM_CMA_IS_RMA() )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083]
Done reducing atomic actions
step:  67
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1110]: Threads::AutoBrake.i
P [87] << ( AXIOM_CMA_IS_RMA() )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1111]: Threads::AutoBrake.i
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1110]
. . . done substituting assertions' for Labels [3570 minutes 46 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1111]: Threads::AutoBrake.i
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1110]
Done substituting Assertion labels in preconditions
step:  68
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1111]: Threads::AutoBrake.i
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1110]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1113]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << CMA = ma >>
What for:    normalization of [serial 1111]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1113]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << CMA = ma >>
What for:    normalization of [serial 1111]
Done Normalizing
step:  69
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = RMA

This Proof Obligation:

[serial 1113]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << CMA = ma >>
What for:    normalization of [serial 1111]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "RMA"
 to get:

[serial 1115]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << RMA = ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1115]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << RMA = ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113]
Done guided substituting an equals
step:  70
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1115]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << RMA = ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1085]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1
Q [90] << CMA = ma
  and i = 1 >>
What for:    normalization of [serial 1072]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  71
#[serial 1085]   normalization of [serial 1072]
step:  72
****atomic****
applying atomic actions . . .
solving assignment on line 89
replacing "i" with "1"
makes:  << CMA = ma
  and ( 1 ) = 1 >>

This Proof Obligation:

[serial 1085]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1
Q [90] << CMA = ma
  and i = 1 >>
What for:    normalization of [serial 1072]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1116]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and ( 1 ) = 1 >>
What for:  applied wp for assignment [serial 1085]
. . . done applying atomic actions [3570 minutes 46 seconds ]
After "atomic" remaining 
Obligations:

[serial 1116]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and ( 1 ) = 1 >>
What for:  applied wp for assignment [serial 1085]
Done reducing atomic actions
step:  73
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1116]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and ( 1 ) = 1 >>
What for:  applied wp for assignment [serial 1085]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1118]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1116]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1118]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1116]
Done Normalizing
step:  74
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1118]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1116]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1120]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1118]

This Proof Obligation:

[serial 1120]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1118]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1121]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1120]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1121]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1120]
Done applying laws
step:  75
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1121]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1120]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1123]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma >>
What for:    normalization of [serial 1121]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1123]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma >>
What for:    normalization of [serial 1121]
Done Normalizing
step:  76
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1123]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma >>
What for:    normalization of [serial 1121]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1088]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
What for:    normalization of [serial 1078]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  77
#[serial 1088]   normalization of [serial 1078]
step:  78
****atomic****
applying atomic actions . . .
solving assignment on line 91
replacing "iSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 1}}}}}"
makes:  << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>

This Proof Obligation:

[serial 1088]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
What for:    normalization of [serial 1078]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1125]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
What for:  applied wp for assignment [serial 1088]
. . . done applying atomic actions [3570 minutes 46 seconds ]
After "atomic" remaining 
Obligations:

[serial 1125]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
What for:  applied wp for assignment [serial 1088]
Done reducing atomic actions
step:  79
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1125]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
What for:  applied wp for assignment [serial 1088]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1126]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]

[serial 1127]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]

[serial 1128]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
. . . done splitting postcondition  [3570 minutes 46 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1126]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]

[serial 1127]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]

[serial 1128]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Done splitting postcondition
step:  80
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1126]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1128]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:

[serial 1127]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Done trying to apply axioms
step:  81
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1127]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1129]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[i] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1129]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[i] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Done guided substituting an equals
step:  82
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1129]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[i] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1130]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1130]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Done guided substituting an equals
step:  83
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1130]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1132]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1130]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1132]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1130]
Done Normalizing
step:  84
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1132]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1130]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1134]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1132]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1134]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1132]
Done applying laws
step:  85
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1134]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1132]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1090]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
What for:    normalization of [serial 1079]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  86
#[serial 1090]   normalization of [serial 1079]
step:  87
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1090]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
What for:    normalization of [serial 1079]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1135]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1135]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Done guided substituting an equals
step:  88
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1135]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1137]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
What for:    normalization of [serial 1135]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1137]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
What for:    normalization of [serial 1135]
Done Normalizing
step:  89
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1137]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
What for:    normalization of [serial 1135]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1139]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1139]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Done guided substituting an equals
step:  90
****atomic****
applying atomic actions . . .
solving assignment on line 94
replacing "nSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 2}}}}}"
makes:  << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>

This Proof Obligation:

[serial 1139]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1140]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
What for:  applied wp for assignment [serial 1139]
. . . done applying atomic actions [3570 minutes 46 seconds ]
After "atomic" remaining 
Obligations:

[serial 1140]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
What for:  applied wp for assignment [serial 1139]
Done reducing atomic actions
step:  91
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1140]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
What for:  applied wp for assignment [serial 1139]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1141]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1140]

This Proof Obligation:

[serial 1141]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1140]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1142]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ( ma.seg[1] = iSeg ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1141]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1142]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ( ma.seg[1] = iSeg ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1141]
Done applying laws
step:  92
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1142]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ( ma.seg[1] = iSeg ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1141]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1144]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = ma.seg[1] >>
What for:    normalization of [serial 1142]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1144]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = ma.seg[1] >>
What for:    normalization of [serial 1142]
Done Normalizing
step:  93
****guided-sub-equals****
guided substitution of equals "ma" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1144]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = ma.seg[1] >>
What for:    normalization of [serial 1142]
Reason solved:  Guided Substitution of Equals
Has substituted 
"ma" with its = "CMA"
 to get:

[serial 1146]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = CMA.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1146]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = CMA.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Done guided substituting an equals
step:  94
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1146]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = CMA.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1148]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[1] = iSeg >>
What for:    normalization of [serial 1146]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 46 seconds ]
After "normalize" remaining 
Obligations:

[serial 1148]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[1] = iSeg >>
What for:    normalization of [serial 1146]
Done Normalizing
step:  95
****guided-sub-equals****
guided substitution of equals "1" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1148]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[1] = iSeg >>
What for:    normalization of [serial 1146]
Reason solved:  Guided Substitution of Equals
Has substituted 
"1" with its = "i"
 to get:

[serial 1150]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
. . . done guided substitution of equals  [3570 minutes 46 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1150]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Done guided substituting an equals
step:  96
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1150]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1017]: Threads::AutoBrake.i
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  97
#[serial 1017]  <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A};
step:  98
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1017]: Threads::AutoBrake.i
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A};
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1151]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1017]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1151]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1017]
Done applying laws
step:  99
****reduce****

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]

[serial 1153]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]

[serial 1153]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151]
done reducing composite actions
step:  100
****reduce****
This proof obligation:

[serial 1153]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151]
Reason solved:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
as <<P>> if (B1)-><<P1>>S1<<Q1>> [] (B2)-><<P2>>S2<<Q2>> [] . . . [] (Bn)-><<Pn>>Sn<<Qn>> fi <<Q>> 

was reduced to:

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]

[serial 1155]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1153]

[serial 1156]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1153]

[serial 1157]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1153]

[serial 1158]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1153]

[serial 1159]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1153]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]

[serial 1155]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1153]

[serial 1156]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1153]

[serial 1157]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1153]

[serial 1158]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1153]

[serial 1159]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1153]
done reducing composite actions
step:  101
****reduce****
Reducing Existential Quantification of:

[serial 1155]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1160]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
Reducing Existential Quantification of:

[serial 1156]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1161]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
Reducing Existential Quantification of:

[serial 1157]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1162]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
Reducing Existential Quantification of:

[serial 1158]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1163]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
Reducing Existential Quantification of:

[serial 1159]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1164]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]

[serial 1160]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]

[serial 1161]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]

[serial 1162]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]

[serial 1163]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]

[serial 1164]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
done reducing composite actions
step:  102
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  103
#Threads::AutoBrake.i
step:  104
#[serial 1152] as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 115
step:  105
****make-an****
Making obligation 21
Obligations:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]
Done making obligation 21
step:  106
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1165]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [3570 minutes 46 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1165]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  107
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1165]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1166]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Law of And-Simplification:  P and true is P [serial 1165]
. . . done Applying Laws [3570 minutes 46 seconds ]
After "laws" remaining 
Obligations:

[serial 1166]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Law of And-Simplification:  P and true is P [serial 1165]
Done applying laws
step:  108
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1166]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Law of And-Simplification:  P and true is P [serial 1165]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 46 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  109
#[serial 1154]   <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]
step:  110
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1168]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1154]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1168]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1154]
Done Normalizing
step:  111
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1168]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1154]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1170]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168]
. . . Substituting <= with not < [3570 minutes 47 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1170]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168]
Done replacing a<=b with (not b<a)
step:  112
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1170]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1172]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1170]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1172]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1170]
Done Normalizing
step:  113
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1172]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1170]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 1174]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172]
. . . done putting into conjunctive normal form [3570 minutes 47 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1174]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172]
Done making conjunctive normal forms.
step:  114
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1174]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1175]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1174]

This Proof Obligation:

[serial 1175]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1174]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1176]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1175]

This Proof Obligation:

[serial 1176]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1175]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1177]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1176]

This Proof Obligation:

[serial 1177]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1176]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1178]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1177]

This Proof Obligation:

[serial 1178]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1177]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1179]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1178]

This Proof Obligation:

[serial 1179]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1178]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1180]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1179]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1180]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1179]
Done applying laws
step:  115
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1180]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1179]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1182]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << true >>
What for:    normalization of [serial 1180]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1182]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << true >>
What for:    normalization of [serial 1180]
Done Normalizing
step:  116
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1182]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << true >>
What for:    normalization of [serial 1180]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1160]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  117
#[serial 1160] <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
step:  118
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1160]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1184]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1160]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1184]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1160]
Done applying laws
step:  119
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1184]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1160]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1186]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1184]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1186]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1184]
Done Normalizing
step:  120
****reduce****

Reducing Concurrent Computation of:

[serial 1186]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1184]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1188]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1186]

[serial 1189]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1186]

[serial 1190]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1186]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1188]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1186]

[serial 1189]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1186]

[serial 1190]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1186]
done reducing composite actions
step:  121
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1188]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1186]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1192]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1189]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1186]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1194]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1190]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1186]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1195]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1192]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]

[serial 1194]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]

[serial 1195]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190]

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
Done reducing atomic actions
step:  122
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1192]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1197]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1192]

This Proof Obligation:

[serial 1194]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1198]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1194]

This Proof Obligation:

[serial 1195]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1199]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1195]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]

[serial 1197]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1192]

[serial 1198]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1194]

[serial 1199]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1195]
Done applying laws
step:  123
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1197]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1192]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1198]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1194]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1199]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1195]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
Done trying to apply axioms
step:  124
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1200]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]

[serial 1200]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193]
step:  125
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1203]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1196]

This Proof Obligation:

[serial 1200]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1205]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << EB()
   or not SB() >>
What for:    normalization of [serial 1200]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1203]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1196]

[serial 1205]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << EB()
   or not SB() >>
What for:    normalization of [serial 1200]
Done Normalizing
step:  126
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1208]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1191]

This Proof Obligation:

[serial 1203]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1196]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1209]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1203]

This Proof Obligation:

[serial 1205]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << EB()
   or not SB() >>
What for:    normalization of [serial 1200]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1210]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1205]
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After "substitute" remaining 
Obligations:

[serial 1208]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1191]

[serial 1209]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1203]

[serial 1210]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1205]
Done substituting Assertion labels.
step:  127
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  128
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1208]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1191]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1212]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1208]

This Proof Obligation:

[serial 1209]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1203]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1214]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1209]

This Proof Obligation:

[serial 1210]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1205]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1216]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1210]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1212]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1208]

[serial 1214]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1209]

[serial 1216]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1210]
Done Normalizing
step:  129
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1214]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1209]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1220]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1214]

This Proof Obligation:

[serial 1216]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1210]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1221]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1216]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1212]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1208]

[serial 1220]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1214]

[serial 1221]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1216]
Done applying laws
step:  130
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1212]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1208]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1220]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1214]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1221]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1216]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1161]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  131
#[serial 1161] <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
step:  132
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1161]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1222]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1161]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1222]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1161]
Done applying laws
step:  133
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1222]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1161]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1224]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1222]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1224]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1222]
Done Normalizing
step:  134
****reduce****

Reducing Concurrent Computation of:

[serial 1224]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1222]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1226]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1224]

[serial 1227]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1224]

[serial 1228]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1224]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1226]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1224]

[serial 1227]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1224]

[serial 1228]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1224]
done reducing composite actions
step:  135
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1226]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1224]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]

The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1230]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226]
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1227]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1224]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1232]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1228]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1224]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1233]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]

[serial 1230]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226]

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]

[serial 1232]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227]

[serial 1233]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228]

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
Done reducing atomic actions
step:  136
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1230]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1235]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1230]

This Proof Obligation:

[serial 1232]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1236]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1232]

This Proof Obligation:

[serial 1233]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1237]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1233]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]

[serial 1235]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1230]

[serial 1236]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1232]

[serial 1237]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1233]
Done applying laws
step:  137
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1235]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1230]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1236]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1232]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1237]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1233]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
Done trying to apply axioms
step:  138
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1238]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1229]

This Proof Obligation:

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1239]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1231]

This Proof Obligation:

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1240]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1234]
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After "substitute" remaining 
Obligations:

[serial 1238]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1229]

[serial 1239]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1231]

[serial 1240]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1234]
Done substituting Assertion labels.
step:  139
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  140
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1238]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1229]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1242]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1238]

This Proof Obligation:

[serial 1239]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1231]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1244]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1239]

This Proof Obligation:

[serial 1240]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1234]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1242]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1238]

[serial 1244]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1239]

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Done Normalizing
step:  141
****guided-sub-equals****
guided substitution of equals "CTCS_Property::EB_Rate mpss" . . .
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided-sub-equals[CTCS_Property::EB_Rate mpss], no change. 
step:  142
****normalize****
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize", no change. 
step:  143
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1242]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1238]
Reasons solved:  
   Guided Substitution of Equals
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1244]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1239]
Reason solved:  Guided Substitution of Equals

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  144
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1244]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1239]
Reasons solved:  
   Guided Substitution of Equals
   DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied Guided Substitution of Equals DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1253]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  Guided Substitution of Equals DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Reason solved:  Guided Substitution of Equals

[serial 1253]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  Guided Substitution of Equals DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244]
step:  145
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1253]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  Guided Substitution of Equals DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1256]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1253]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Reason solved:  Guided Substitution of Equals

[serial 1256]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1253]
Done Normalizing
step:  146
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1256]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1253]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1258]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1256]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Reason solved:  Guided Substitution of Equals

[serial 1258]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1256]
step:  147
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1258]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1256]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1261]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1258]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Reason solved:  Guided Substitution of Equals

[serial 1261]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1258]
Done Normalizing
step:  148
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Reasons solved:  
   Guided Substitution of Equals
   Associativity: (b.c).a = a.b.c
Has applied law "Guided Substitution of Equals Associativity: (b.c).a = a.b.c " to get:

[serial 1263]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1246]

This Proof Obligation:

[serial 1261]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1258]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1264]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1261]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1263]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1246]

[serial 1264]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1261]
Done applying laws
step:  149
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1263]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1246]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1264]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1261]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1162]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  150
#[serial 1162] <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
step:  151
****reduce****

Reducing Concurrent Computation of:

[serial 1162]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1265]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1162]

[serial 1266]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1162]

[serial 1267]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1162]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1265]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1162]

[serial 1266]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1162]

[serial 1267]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1162]
done reducing composite actions
step:  152
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1265]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1162]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1268]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1265]

The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1269]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1265]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1266]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1162]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1270]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [114] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1266]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1271]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1266]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1267]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1162]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1272]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1267]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1273]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1267]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1268]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1265]

[serial 1269]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1265]

[serial 1270]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [114] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1266]

[serial 1271]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1266]

[serial 1272]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1267]

[serial 1273]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1267]
Done reducing atomic actions
step:  153
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1268]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1265]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1274]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1268]

This Proof Obligation:

[serial 1269]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1265]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1275]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1269]

This Proof Obligation:

[serial 1270]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [114] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1266]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1276]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [114] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1270]

This Proof Obligation:

[serial 1271]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1266]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1277]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1271]

This Proof Obligation:

[serial 1272]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1267]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1278]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1272]

This Proof Obligation:

[serial 1273]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1267]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1279]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1273]

This Proof Obligation:

[serial 1275]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1269]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1280]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1275]

This Proof Obligation:

[serial 1277]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1271]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1281]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1277]

This Proof Obligation:

[serial 1278]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1272]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1282]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1278]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1274]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1268]

[serial 1276]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [114] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1270]

[serial 1279]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1273]

[serial 1280]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1275]

[serial 1281]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1277]

[serial 1282]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1278]
Done applying laws
step:  154
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1274]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1268]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1284]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1274]

This Proof Obligation:

[serial 1276]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [114] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1270]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1286]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not EB() >>
What for:    normalization of [serial 1276]

This Proof Obligation:

[serial 1279]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1273]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1288]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1279]

This Proof Obligation:

[serial 1280]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1275]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1290]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1280]

This Proof Obligation:

[serial 1281]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1277]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1292]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1281]

This Proof Obligation:

[serial 1282]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1278]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1294]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1282]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1284]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1274]

[serial 1286]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not EB() >>
What for:    normalization of [serial 1276]

[serial 1288]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1279]

[serial 1290]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1280]

[serial 1292]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1281]

[serial 1294]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1282]
Done Normalizing
step:  155
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1290]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1280]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1292]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1281]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1294]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1282]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1284]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1274]

[serial 1286]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not EB() >>
What for:    normalization of [serial 1276]

[serial 1288]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1279]
Done trying to apply axioms
step:  156
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1284]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1274]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1301]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1284]

This Proof Obligation:

[serial 1286]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not EB() >>
What for:    normalization of [serial 1276]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1302]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1286]

This Proof Obligation:

[serial 1288]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1279]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1303]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1288]
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After "substitute" remaining 
Obligations:

[serial 1301]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1284]

[serial 1302]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1286]

[serial 1303]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1288]
Done substituting Assertion labels.
step:  157
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  158
****guided-sub-equals****
guided substitution of equals "CTCS_Property::EB_Rate mpss" . . .
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided-sub-equals[CTCS_Property::EB_Rate mpss], no change. 
step:  159
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1301]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1284]
Reasons solved:  
   Guided Substitution of Equals
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1305]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1301]

This Proof Obligation:

[serial 1302]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1286]
Reasons solved:  
   Guided Substitution of Equals
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1307]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1302]

This Proof Obligation:

[serial 1303]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1288]
Reasons solved:  
   Guided Substitution of Equals
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1309]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1303]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1305]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1301]

[serial 1307]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1302]

[serial 1309]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1303]
Done Normalizing
step:  160
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1305]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1301]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1313]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1305]

This Proof Obligation:

[serial 1307]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1302]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1314]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1307]

This Proof Obligation:

[serial 1309]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1303]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1315]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309]
. . . Substituting <= with not < [3570 minutes 47 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1313]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1305]

[serial 1314]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1307]

[serial 1315]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309]
Done replacing a<=b with (not b<a)
step:  161
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1313]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1305]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1317]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1313]

This Proof Obligation:

[serial 1314]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1307]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1319]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1314]

This Proof Obligation:

[serial 1315]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1321]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1315]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1317]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1313]

[serial 1319]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1314]

[serial 1321]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1315]
Done Normalizing
step:  162
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1317]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1313]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1325]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1317]

This Proof Obligation:

[serial 1319]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1314]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1326]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1319]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1321]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1315]

[serial 1325]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1317]

[serial 1326]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1319]
step:  163
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1325]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1317]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1329]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1325]

This Proof Obligation:

[serial 1326]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1319]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1331]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1326]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1321]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1315]

[serial 1329]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1325]

[serial 1331]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1326]
Done Normalizing
step:  164
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1331]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1326]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1321]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1315]

[serial 1329]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1325]
Done trying to apply axioms
step:  165
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1321]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1315]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1334]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1321]

This Proof Obligation:

[serial 1329]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1325]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1335]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1329]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1334]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1321]

[serial 1335]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1329]
Done applying laws
step:  166
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1335]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1329]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1336]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]

[serial 1337]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]

[serial 1338]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]
. . . done splitting postcondition  [3570 minutes 47 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1334]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1321]

[serial 1336]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]

[serial 1337]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]

[serial 1338]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]
Done splitting postcondition
step:  167
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1334]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1321]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1336]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1337]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1338]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]
Done trying to apply axioms
step:  168
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1338]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1340]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1338]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1340]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1338]
Done Normalizing
step:  169
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1340]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1338]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1163]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  170
#[serial 1163] <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
step:  171
****reduce****

Reducing Concurrent Computation of:

[serial 1163]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1342]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1163]

[serial 1343]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1163]

[serial 1344]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1163]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1342]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1163]

[serial 1343]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1163]

[serial 1344]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1163]
done reducing composite actions
step:  172
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1342]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1163]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1345]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1342]

The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1346]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1342]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1343]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1163]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1347]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [119] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1343]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1348]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1343]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1344]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1163]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1349]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1344]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1350]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1344]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1345]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1342]

[serial 1346]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1342]

[serial 1347]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [119] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1343]

[serial 1348]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1343]

[serial 1349]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1344]

[serial 1350]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1344]
Done reducing atomic actions
step:  173
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1345]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1342]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1351]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1345]

This Proof Obligation:

[serial 1346]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1342]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1352]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1346]

This Proof Obligation:

[serial 1347]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [119] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1343]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1353]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [119] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1347]

This Proof Obligation:

[serial 1348]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1343]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1354]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1348]

This Proof Obligation:

[serial 1349]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1344]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1355]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1349]

This Proof Obligation:

[serial 1350]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1344]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1356]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1350]

This Proof Obligation:

[serial 1352]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1346]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1357]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1352]

This Proof Obligation:

[serial 1354]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1348]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1358]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1354]

This Proof Obligation:

[serial 1355]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1349]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1359]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1355]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1351]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1345]

[serial 1353]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [119] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1347]

[serial 1356]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1350]

[serial 1357]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1352]

[serial 1358]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1354]

[serial 1359]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1355]
Done applying laws
step:  174
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1351]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1345]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1361]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1351]

This Proof Obligation:

[serial 1353]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [119] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1347]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1363]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not EB() >>
What for:    normalization of [serial 1353]

This Proof Obligation:

[serial 1356]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1350]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1365]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1356]

This Proof Obligation:

[serial 1357]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1352]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1367]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1357]

This Proof Obligation:

[serial 1358]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1354]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1369]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1358]

This Proof Obligation:

[serial 1359]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1355]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1371]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1359]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1361]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1351]

[serial 1363]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not EB() >>
What for:    normalization of [serial 1353]

[serial 1365]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1356]

[serial 1367]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1357]

[serial 1369]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1358]

[serial 1371]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1359]
Done Normalizing
step:  175
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1367]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1357]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1369]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1358]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1371]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1359]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1361]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1351]

[serial 1363]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not EB() >>
What for:    normalization of [serial 1353]

[serial 1365]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1356]
Done trying to apply axioms
step:  176
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1361]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1351]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1378]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1361]

This Proof Obligation:

[serial 1363]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not EB() >>
What for:    normalization of [serial 1353]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1379]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1363]

This Proof Obligation:

[serial 1365]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1356]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1380]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1365]
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After "substitute" remaining 
Obligations:

[serial 1378]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1361]

[serial 1379]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1363]

[serial 1380]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1365]
Done substituting Assertion labels.
step:  177
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  178
****guided-sub-equals****
guided substitution of equals "CTCS_Property::EB_Rate mpss" . . .
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided-sub-equals[CTCS_Property::EB_Rate mpss], no change. 
step:  179
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1378]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1361]
Reasons solved:  
   Guided Substitution of Equals
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1382]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1378]

This Proof Obligation:

[serial 1379]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1363]
Reasons solved:  
   Guided Substitution of Equals
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1384]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1379]

This Proof Obligation:

[serial 1380]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1365]
Reasons solved:  
   Guided Substitution of Equals
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1386]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1380]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1382]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1378]

[serial 1384]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1379]

[serial 1386]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1380]
Done Normalizing
step:  180
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1382]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1378]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1390]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1382]

This Proof Obligation:

[serial 1384]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1379]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1391]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1384]

This Proof Obligation:

[serial 1386]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1380]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1392]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1386]
. . . Substituting <= with not < [3570 minutes 47 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1390]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1382]

[serial 1391]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1384]

[serial 1392]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1386]
Done replacing a<=b with (not b<a)
step:  181
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1390]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1382]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1394]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1390]

This Proof Obligation:

[serial 1391]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1384]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1396]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1391]

This Proof Obligation:

[serial 1392]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1386]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1398]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1392]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1394]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1390]

[serial 1396]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1391]

[serial 1398]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1392]
Done Normalizing
step:  182
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1394]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1390]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1402]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1394]

This Proof Obligation:

[serial 1396]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1391]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1403]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1396]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1398]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1392]

[serial 1402]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1394]

[serial 1403]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1396]
step:  183
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1402]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1394]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1406]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1402]

This Proof Obligation:

[serial 1403]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1396]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1408]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1403]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1398]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1392]

[serial 1406]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1402]

[serial 1408]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1403]
Done Normalizing
step:  184
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1408]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1403]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1398]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1392]

[serial 1406]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1402]
Done trying to apply axioms
step:  185
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1398]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1392]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1411]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1398]

This Proof Obligation:

[serial 1406]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1402]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1412]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1406]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1411]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1398]

[serial 1412]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1406]
Done applying laws
step:  186
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1412]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1406]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1413]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]

[serial 1414]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]

[serial 1415]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]
. . . done splitting postcondition  [3570 minutes 47 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1411]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1398]

[serial 1413]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]

[serial 1414]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]

[serial 1415]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]
Done splitting postcondition
step:  187
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1411]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1398]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1417]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1411]

This Proof Obligation:

[serial 1415]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1421]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1415]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1413]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]

[serial 1414]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]

[serial 1417]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1411]

[serial 1421]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1415]
Done Normalizing
step:  188
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1413]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1414]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1417]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1411]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1421]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1415]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1164]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  189
****guided-sub-equals****
guided substitution of equals "CTCS_Property::SB_Rate mpss" . . .
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided-sub-equals[CTCS_Property::SB_Rate mpss], no change. 
step:  190
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1164]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1425]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1164]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1425]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1164]
Done Normalizing
step:  191
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [3570 minutes 47 seconds ]
After applying axioms, no change. 
step:  192
#[serial 1164] <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
step:  193
****reduce****

Reducing Concurrent Computation of:

[serial 1425]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1164]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1427]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1425]

[serial 1428]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1425]

[serial 1429]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1425]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1427]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1425]

[serial 1428]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1425]

[serial 1429]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1425]
done reducing composite actions
step:  194
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1427]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1425]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1430]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1427]

This Proof Obligation:

[serial 1428]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1425]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1431]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1428]

This Proof Obligation:

[serial 1429]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1425]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1429]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1430]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1427]

[serial 1431]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1428]

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1429]
Done applying laws
step:  195
****normalize****
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize", no change. 
step:  196
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1430]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1427]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1436]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1430]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1437]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1430]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1431]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1428]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1431]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1439]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1431]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1429]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=xl)@now>> -> <<post>> for  <<pre>> ca!(xl) <<post>> to get:

[serial 1440]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1432]
looking through terms of
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]
no term was found that had expression e:
 xl
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1436]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1430]

[serial 1437]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1430]

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1431]

[serial 1439]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1431]

[serial 1440]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1432]
Done reducing atomic actions
step:  197
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1437]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1430]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1441]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1437]

This Proof Obligation:

[serial 1439]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1431]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1442]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1439]

This Proof Obligation:

[serial 1440]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1432]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1443]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1440]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1436]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1430]

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1431]

[serial 1441]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1437]

[serial 1442]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1439]

[serial 1443]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1440]
Done applying laws
step:  198
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1441]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1437]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1442]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1439]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1443]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1440]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1436]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1430]

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1431]
Done trying to apply axioms
step:  199
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1436]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1430]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1444]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1436]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1431]

[serial 1444]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1436]
step:  200
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1444]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1436]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1447]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << EB()
   or not SB() >>
What for:    normalization of [serial 1444]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1431]

[serial 1447]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << EB()
   or not SB() >>
What for:    normalization of [serial 1444]
Done Normalizing
step:  201
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1431]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1449]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1438]

This Proof Obligation:

[serial 1447]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << EB()
   or not SB() >>
What for:    normalization of [serial 1444]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1450]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1447]
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After "substitute" remaining 
Obligations:

[serial 1449]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1438]

[serial 1450]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1447]
Done substituting Assertion labels.
step:  202
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  203
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1449]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1438]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1452]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1449]

This Proof Obligation:

[serial 1450]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1447]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1454]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1450]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1452]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1449]

[serial 1454]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1450]
Done Normalizing
step:  204
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1454]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1450]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1457]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1454]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1452]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1449]

[serial 1457]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1454]
Done applying laws
step:  205
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1452]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1449]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1458]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1452]

This Proof Obligation:

[serial 1457]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1454]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1459]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1457]
. . . Substituting <= with not < [3570 minutes 47 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1458]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1452]

[serial 1459]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1457]
Done replacing a<=b with (not b<a)
step:  206
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1458]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1452]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1461]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1458]

This Proof Obligation:

[serial 1459]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1457]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1463]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1459]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1461]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1458]

[serial 1463]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1459]
Done Normalizing
step:  207
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1461]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1458]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1466]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1461]

This Proof Obligation:

[serial 1463]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1459]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1467]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1463]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1466]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1461]

[serial 1467]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1463]
step:  208
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1466]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1461]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1469]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1466]

This Proof Obligation:

[serial 1467]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1463]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1471]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1467]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1469]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1466]

[serial 1471]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1467]
Done Normalizing
step:  209
****guided-sub-equals****
guided substitution of equals "CTCS_Property::SB_Rate mpss" . . .
equality selected for substitution:  b = CTCS_Property::SB_Rate mpss
equality selected for substitution:  b = CTCS_Property::SB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided-sub-equals[CTCS_Property::SB_Rate mpss], no change. 
step:  210
****normalize****
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize", no change. 
step:  211
****axioms****
Applying Axioms . . .
AXIOM.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n


This Proof Obligation:

[serial 1471]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1467]
Reasons solved:  
   Guided Substitution of Equals
   Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
Has been solved by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1469]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1466]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  212
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  v < iSeg.v_n and iSeg.v_n < iSeg.v_e -> v < iSeg.v_e

This Proof Obligation:

[serial 1469]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1466]
Reasons solved:  
   Guided Substitution of Equals
   Transitivity: x<y and y<z -> x<z
Has applied Guided Substitution of Equals Transitivity: x<y and y<z -> x<z  to get:

[serial 1476]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Guided Substitution of Equals Transitivity: x<y and y<z -> x<z  [serial 1469]
. . . done adding transitive terms [3570 minutes 47 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 1476]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Guided Substitution of Equals Transitivity: x<y and y<z -> x<z  [serial 1469]
Done adding transitive relations
step:  213
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1476]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Guided Substitution of Equals Transitivity: x<y and y<z -> x<z  [serial 1469]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1477]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476]

[serial 1478]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476]
. . . done splitting postcondition  [3570 minutes 47 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1477]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476]

[serial 1478]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476]
Done splitting postcondition
step:  214
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1477]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1478]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1018]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  215
****guided-sub-equals****
guided substitution of equals "CTCS_Property::EB_Rate mpss" . . .
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided-sub-equals[CTCS_Property::EB_Rate mpss], no change. 
step:  216
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1018]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{};
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1480]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments
  and p < iSeg.e >>
S [128]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1018]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1480]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments
  and p < iSeg.e >>
S [128]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1018]
Done Normalizing
step:  217
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1480]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments
  and p < iSeg.e >>
S [128]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1018]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1019]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]  iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1]
    and ma = CMA >>
  i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  218
#[serial 1018]  <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{};
step:  219
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [3570 minutes 47 seconds ]
After applying axioms, no change. 
step:  220
#[serial 1019]  <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A};
step:  221
****reduce****
This proof obligation:

[serial 1019]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]  iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1]
    and ma = CMA >>
  i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1482]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]

[serial 1483]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]i := i + 1
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1019]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1482]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]

[serial 1483]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]i := i + 1
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1019]
done reducing composite actions
step:  222
****atomic****
applying atomic actions . . .
solving assignment on line 134
replacing "iSeg" with "nSeg"
makes:  << nSeg = CMA.seg[i + 1]
  and ma = CMA >>

This Proof Obligation:

[serial 1482]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1484]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]->
Q [135] << nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1482]
solving assignment on line 136
replacing "i" with "i + 1"
makes:  << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>

This Proof Obligation:

[serial 1483]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]i := i + 1
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1019]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1485]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]->
Q [61] << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1483]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1484]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]->
Q [135] << nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1482]

[serial 1485]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]->
Q [61] << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1483]
Done reducing atomic actions
step:  223
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1484]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]->
Q [135] << nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1482]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1487]: Threads::AutoBrake.i
P [59] << iSeg.e <= p
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [134]->
Q [135] << CMA = ma
  and CMA.seg[1 + i] = nSeg >>
What for:    normalization of [serial 1484]

This Proof Obligation:

[serial 1485]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]->
Q [61] << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1483]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1489]: Threads::AutoBrake.i
P [135] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
S [136]->
Q [61] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
What for:    normalization of [serial 1485]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1487]: Threads::AutoBrake.i
P [59] << iSeg.e <= p
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [134]->
Q [135] << CMA = ma
  and CMA.seg[1 + i] = nSeg >>
What for:    normalization of [serial 1484]

[serial 1489]: Threads::AutoBrake.i
P [135] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
S [136]->
Q [61] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
What for:    normalization of [serial 1485]
Done Normalizing
step:  224
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1487]: Threads::AutoBrake.i
P [59] << iSeg.e <= p
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [134]->
Q [135] << CMA = ma
  and CMA.seg[1 + i] = nSeg >>
What for:    normalization of [serial 1484]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1489]: Threads::AutoBrake.i
P [135] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
S [136]->
Q [61] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
What for:    normalization of [serial 1485]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1020]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]nSeg := ma.seg[i + 1]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  225
#[serial 1020]  <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A};
step:  226
****atomic****
applying atomic actions . . .
reduce asserted action
solving assignment on line 141
replacing "nSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{+ i 
     ^{QUANTITY 1}}}}}}"
makes:  << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>

This Proof Obligation:

[serial 1020]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]nSeg := ma.seg[i + 1]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A};
Reasons solved:  
   Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
   Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1492]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1020]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1492]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1020]
Done reducing atomic actions
step:  227
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1492]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1020]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1494]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = ma.seg[1 + i]
  and i < CMA.num_segments >>
What for:    normalization of [serial 1492]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1494]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = ma.seg[1 + i]
  and i < CMA.num_segments >>
What for:    normalization of [serial 1492]
Done Normalizing
step:  228
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1494]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = ma.seg[1 + i]
  and i < CMA.num_segments >>
What for:    normalization of [serial 1492]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1496]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]

[serial 1497]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]

[serial 1498]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]

[serial 1499]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
. . . done splitting postcondition  [3570 minutes 47 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1496]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]

[serial 1497]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]

[serial 1498]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]

[serial 1499]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Done splitting postcondition
step:  229
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1496]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1497]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1498]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]

[serial 1499]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Done trying to apply axioms
step:  230
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1498]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1500]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1498]
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1499]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1501]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1499]
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1500]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1498]

[serial 1501]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1499]
Done guided substituting an equals
step:  231
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1501]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1499]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1500]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1498]
Done trying to apply axioms
step:  232
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1500]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1498]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1502]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1500]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1502]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1500]
Done applying laws
step:  233
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1502]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1500]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1021]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]  r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  234
#[serial 1021]  <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A};
step:  235
****reduce****
This proof obligation:

[serial 1021]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]  r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1503]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1021]

[serial 1504]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1021]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1503]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1021]

[serial 1504]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1021]
done reducing composite actions
step:  236
****atomic****
applying atomic actions . . .
out event port r on line 146 does not have a BLESS::Assertion property AutoBrake.i; <<true>> used instead.

This Proof Obligation:

[serial 1503]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1021]
Has applied <<pre>> -> <<M(r)>> for <<pre>> r! <<post>> to get:

[serial 1505]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]->
Q [146] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1503]
Has applied <<pre and r@now>> -> <<post>> for <<pre>> r! <<post>> to get:

[serial 1506]: Threads::AutoBrake.i
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146]->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1503]
solving assignment on line 149
replacing "nSeg" with "
^{RECORD_TERM[segment] segment 
 ^{=> v_n 
  ^{QUANTITY 0 mps}} 
 ^{=> v_e 
  ^{QUANTITY 0 mps}} 
 ^{=> e 
  ^{ma 
   ^{. ea}}}}"
makes:  << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>

This Proof Obligation:

[serial 1504]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1021]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1507]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
What for:  applied wp for assignment [serial 1504]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1505]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]->
Q [146] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1503]

[serial 1506]: Threads::AutoBrake.i
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146]->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1503]

[serial 1507]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
What for:  applied wp for assignment [serial 1504]
Done reducing atomic actions
step:  237
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1505]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]->
Q [146] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1503]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1509]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1505]

This Proof Obligation:

[serial 1506]: Threads::AutoBrake.i
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146]->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1503]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Constants are always the same
Has been normalized to get:

[serial 1511]: Threads::AutoBrake.i
P [146] << true
  and ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1506]

This Proof Obligation:

[serial 1507]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
What for:  applied wp for assignment [serial 1504]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:    normalization of [serial 1507]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1509]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1505]

[serial 1511]: Threads::AutoBrake.i
P [146] << true
  and ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1506]

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:    normalization of [serial 1507]
Done Normalizing
step:  238
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1511]: Threads::AutoBrake.i
P [146] << true
  and ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1506]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1517]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1511]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1509]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1505]

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:    normalization of [serial 1507]

[serial 1517]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1511]
Done applying laws
step:  239
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:    normalization of [serial 1507]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1518]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1519]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1520]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

This Proof Obligation:

[serial 1517]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1511]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1522]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]

[serial 1523]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]

[serial 1524]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]
. . . done splitting postcondition  [3570 minutes 47 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1509]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1505]

[serial 1518]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1519]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1520]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1522]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]

[serial 1523]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]

[serial 1524]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]
Done splitting postcondition
step:  240
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1509]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1505]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1518]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1519]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1520]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1522]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]

[serial 1523]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]

[serial 1524]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]
Done trying to apply axioms
step:  241
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1522]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1527]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA = ma >>
What for:    normalization of [serial 1522]

This Proof Obligation:

[serial 1523]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1529]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:    normalization of [serial 1523]

This Proof Obligation:

[serial 1524]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1531]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1524]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1527]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA = ma >>
What for:    normalization of [serial 1522]

[serial 1529]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:    normalization of [serial 1523]

[serial 1531]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1524]
Done Normalizing
step:  242
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1527]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA = ma >>
What for:    normalization of [serial 1522]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1531]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1524]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]

[serial 1529]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:    normalization of [serial 1523]
Done trying to apply axioms
step:  243
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1529]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:    normalization of [serial 1523]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1535]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << ma.num_segments = i >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1529]
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Reason solved:  Guided Substitution of Equals

[serial 1535]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << ma.num_segments = i >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1529]
Done guided substituting an equals
step:  244
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1535]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << ma.num_segments = i >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1529]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1538]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << i = ma.num_segments >>
What for:    normalization of [serial 1535]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Reason solved:  Guided Substitution of Equals

[serial 1538]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << i = ma.num_segments >>
What for:    normalization of [serial 1535]
Done Normalizing
step:  245
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1538]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << i = ma.num_segments >>
What for:    normalization of [serial 1535]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  246
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1521]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Reasons solved:  
   Guided Substitution of Equals
   Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1540]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1521]
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1540]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1521]
Done substituting Assertion labels in postconditions.
step:  247
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1540]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1521]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1541]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1540]
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1541]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1540]
Done guided substituting an equals
step:  248
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1541]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1540]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1542]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1541]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1542]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1541]
Done applying laws
step:  249
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1542]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1541]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1022]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155]->
Q [72] << true >>
What for:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  250
#[serial 1022]  <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{};
step:  251
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1022]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155]->
Q [72] << true >>
What for:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{};
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1023]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [160]<< i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegmentMoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  252
#[serial 1023]  <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegmentMoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
step:  253
****reduce****

[serial 1543]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]

[serial 1544]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1543]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]

[serial 1544]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
done reducing composite actions
step:  254
****reduce****
This proof obligation:

[serial 1544]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
Reason solved:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
as <<P>> if (B1)-><<P1>>S1<<Q1>> [] (B2)-><<P2>>S2<<Q2>> [] . . . [] (Bn)-><<Pn>>Sn<<Qn>> fi <<Q>> 

was reduced to:

[serial 1545]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1544]

[serial 1546]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1544]

[serial 1547]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1544]

[serial 1548]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1544]

[serial 1549]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1544]

[serial 1550]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1544]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1543]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]

[serial 1545]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1544]

[serial 1546]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1544]

[serial 1547]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1544]

[serial 1548]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1544]

[serial 1549]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1544]

[serial 1550]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1544]
done reducing composite actions
step:  255
****reduce****
Reducing Existential Quantification of:

[serial 1546]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1544]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1551]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1546]
Reducing Existential Quantification of:

[serial 1547]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1544]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1552]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1547]
Reducing Existential Quantification of:

[serial 1548]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1544]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1553]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1548]
Reducing Existential Quantification of:

[serial 1549]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1544]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1554]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1549]
Reducing Existential Quantification of:

[serial 1550]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1544]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1555]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1550]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1543]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]

[serial 1545]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1544]

[serial 1551]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1546]

[serial 1552]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1547]

[serial 1553]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1548]

[serial 1554]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1549]

[serial 1555]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1550]
done reducing composite actions
step:  256
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1543]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1557]: Threads::AutoBrake.i
P [159] << p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:    normalization of [serial 1543]

This Proof Obligation:

[serial 1545]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1544]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1559]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1545]

This Proof Obligation:

[serial 1551]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1546]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1561]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1551]

This Proof Obligation:

[serial 1552]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1547]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1563]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1552]

This Proof Obligation:

[serial 1553]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1548]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1565]: Threads::AutoBrake.i
P [163] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1553]

This Proof Obligation:

[serial 1554]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1549]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1567]: Threads::AutoBrake.i
P [163] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1554]

This Proof Obligation:

[serial 1555]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1550]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1569]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1555]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1557]: Threads::AutoBrake.i
P [159] << p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:    normalization of [serial 1543]

[serial 1559]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1545]

[serial 1561]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1551]

[serial 1563]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1552]

[serial 1565]: Threads::AutoBrake.i
P [163] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1553]

[serial 1567]: Threads::AutoBrake.i
P [163] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1554]

[serial 1569]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1555]
Done Normalizing
step:  257
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1557]: Threads::AutoBrake.i
P [159] << p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:    normalization of [serial 1543]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1577]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]

This Proof Obligation:

[serial 1561]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1551]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1578]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]

This Proof Obligation:

[serial 1563]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1552]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1579]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1563]

This Proof Obligation:

[serial 1565]: Threads::AutoBrake.i
P [163] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1553]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1580]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1565]

This Proof Obligation:

[serial 1567]: Threads::AutoBrake.i
P [163] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1554]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1581]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1567]

This Proof Obligation:

[serial 1569]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1555]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1582]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1569]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1559]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1545]

[serial 1577]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]

[serial 1578]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]

[serial 1579]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1563]

[serial 1580]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1565]

[serial 1581]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1567]

[serial 1582]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1569]
Done applying laws
step:  258
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1577]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1583]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [3570 minutes 47 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1559]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1545]

[serial 1578]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]

[serial 1579]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1563]

[serial 1580]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1565]

[serial 1581]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1567]

[serial 1582]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1569]

[serial 1583]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  259
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1583]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1584]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Law of And-Simplification:  P and true is P [serial 1583]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1559]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1545]

[serial 1578]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]

[serial 1579]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1563]

[serial 1580]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1565]

[serial 1581]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1567]

[serial 1582]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1569]

[serial 1584]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Law of And-Simplification:  P and true is P [serial 1583]
Done applying laws
step:  260
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1584]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Law of And-Simplification:  P and true is P [serial 1583]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1559]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1545]

[serial 1578]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]

[serial 1579]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1563]

[serial 1580]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1565]

[serial 1581]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1567]

[serial 1582]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1569]
Done trying to apply axioms
step:  261
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  262
#Threads::AutoBrake.i
step:  263
#[serial 1512]   normalization of [serial 149
step:  264
****make-an****
Making obligation 34
Obligations:

[serial 1559]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1545]
Done making obligation 34
step:  265
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1559]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1545]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1585]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1559]
. . . Substituting <= with not < [3570 minutes 47 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1585]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1559]
Done replacing a<=b with (not b<a)
step:  266
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1585]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1559]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1587]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1585]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1587]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1585]
Done Normalizing
step:  267
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1587]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1585]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 1589]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1587]
. . . done putting into conjunctive normal form [3570 minutes 47 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1589]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1587]
Done making conjunctive normal forms.
step:  268
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1589]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1587]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1590]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1589]

This Proof Obligation:

[serial 1590]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1589]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1591]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1590]

This Proof Obligation:

[serial 1591]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1590]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1592]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1591]

This Proof Obligation:

[serial 1592]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1591]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1593]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1592]

This Proof Obligation:

[serial 1593]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1592]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1594]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1593]

This Proof Obligation:

[serial 1594]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1593]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1595]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1594]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1595]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1594]
Done applying laws
step:  269
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1595]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1594]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1597]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << true >>
What for:    normalization of [serial 1595]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1597]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << true >>
What for:    normalization of [serial 1595]
Done Normalizing
step:  270
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1597]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << true >>
What for:    normalization of [serial 1595]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1578]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  271
#[serial 1531] Associativity: (b.c).a = a.b.c [serial 1514]
step:  272
****reduce****

Reducing Concurrent Computation of:

[serial 1578]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1599]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1578]

[serial 1600]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1578]

[serial 1601]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1578]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1599]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1578]

[serial 1600]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1578]

[serial 1601]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1578]
done reducing composite actions
step:  273
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1599]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1578]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1602]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1599]

The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1603]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1599]
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1600]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1578]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1604]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1600]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1605]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1600]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1601]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1578]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1606]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1601]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1607]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1601]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1602]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1599]

[serial 1603]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1599]

[serial 1604]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1600]

[serial 1605]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1600]

[serial 1606]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1601]

[serial 1607]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1601]
Done reducing atomic actions
step:  274
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1603]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1599]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1608]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1603]

This Proof Obligation:

[serial 1605]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1600]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1609]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1605]

This Proof Obligation:

[serial 1606]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1601]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1610]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1606]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1602]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1599]

[serial 1604]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1600]

[serial 1607]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1601]

[serial 1608]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1603]

[serial 1609]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1605]

[serial 1610]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1606]
Done applying laws
step:  275
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1608]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1603]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1609]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1605]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1610]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1606]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1602]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1599]

[serial 1604]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1600]

[serial 1607]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1601]
Done trying to apply axioms
step:  276
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1602]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1599]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1611]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1602]

This Proof Obligation:

[serial 1604]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1600]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1612]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1604]

This Proof Obligation:

[serial 1607]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1601]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1613]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1607]
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After "substitute" remaining 
Obligations:

[serial 1611]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1602]

[serial 1612]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1604]

[serial 1613]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1607]
Done substituting Assertion labels.
step:  277
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  278
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1611]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1602]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1615]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1611]

This Proof Obligation:

[serial 1612]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1604]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1617]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1612]

This Proof Obligation:

[serial 1613]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1607]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1619]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1613]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1615]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1611]

[serial 1617]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1612]

[serial 1619]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1613]
Done Normalizing
step:  279
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1615]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1611]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1617]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1612]

[serial 1619]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1613]
Done trying to apply axioms
step:  280
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1617]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1612]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1623]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1617]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1619]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1613]

[serial 1623]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1617]
step:  281
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1623]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1617]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1626]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1623]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1619]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1613]

[serial 1626]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1623]
Done Normalizing
step:  282
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1626]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1623]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1628]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1626]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1619]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1613]

[serial 1628]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1626]
step:  283
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1628]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1626]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1631]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1628]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1619]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1613]

[serial 1631]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1628]
Done Normalizing
step:  284
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1619]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1613]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1633]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1619]

This Proof Obligation:

[serial 1631]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1628]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1634]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1631]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1633]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1619]

[serial 1634]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1631]
Done applying laws
step:  285
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1633]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1619]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1634]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1631]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1579]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1563]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  286
#[serial 1532] Associativity: (b.c).a = a.b.c [serial 1516]
step:  287
****reduce****

Reducing Concurrent Computation of:

[serial 1579]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1563]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1635]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1579]

[serial 1636]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1579]

[serial 1637]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1579]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1635]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1579]

[serial 1636]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1579]

[serial 1637]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1579]
done reducing composite actions
step:  288
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1635]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1579]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1638]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1635]

The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1639]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1635]
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1636]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1579]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1640]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1636]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1641]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1636]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1637]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1579]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1642]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = ( 0 mpss ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1637]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1643]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1637]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1638]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1635]

[serial 1639]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1635]

[serial 1640]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1636]

[serial 1641]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1636]

[serial 1642]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = ( 0 mpss ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1637]

[serial 1643]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1637]
Done reducing atomic actions
step:  289
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1638]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1635]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1645]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1638]

This Proof Obligation:

[serial 1639]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1635]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1647]: Threads::AutoBrake.i
P [168] << EB()@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1639]

This Proof Obligation:

[serial 1640]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1636]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1649]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1640]

This Proof Obligation:

[serial 1641]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1636]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1651]: Threads::AutoBrake.i
P [168] << ( not ( SB()
  and not EB() ) )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1641]

This Proof Obligation:

[serial 1642]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = ( 0 mpss ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1637]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1653]: Threads::AutoBrake.i
P [168] << ( ca = 0 mpss )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1642]

This Proof Obligation:

[serial 1643]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1637]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1655]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1643]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1645]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1638]

[serial 1647]: Threads::AutoBrake.i
P [168] << EB()@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1639]

[serial 1649]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1640]

[serial 1651]: Threads::AutoBrake.i
P [168] << ( not ( SB()
  and not EB() ) )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1641]

[serial 1653]: Threads::AutoBrake.i
P [168] << ( ca = 0 mpss )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1642]

[serial 1655]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1643]
Done Normalizing
step:  290
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1647]: Threads::AutoBrake.i
P [168] << EB()@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1639]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1662]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1647]

This Proof Obligation:

[serial 1651]: Threads::AutoBrake.i
P [168] << ( not ( SB()
  and not EB() ) )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1641]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1663]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1651]

This Proof Obligation:

[serial 1653]: Threads::AutoBrake.i
P [168] << ( ca = 0 mpss )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1642]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1664]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = 0 mpss )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1653]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1645]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1638]

[serial 1649]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1640]

[serial 1655]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1643]

[serial 1662]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1647]

[serial 1663]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1651]

[serial 1664]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = 0 mpss )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1653]
Done applying laws
step:  291
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1662]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1647]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1663]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1651]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1664]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = 0 mpss )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1653]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1645]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1638]

[serial 1649]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1640]

[serial 1655]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1643]
Done trying to apply axioms
step:  292
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1649]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1640]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1665]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1649]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1645]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1638]

[serial 1655]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1643]

[serial 1665]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1649]
step:  293
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1665]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1649]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1669]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << EB()
   or not SB() >>
What for:    normalization of [serial 1665]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1645]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1638]

[serial 1655]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1643]

[serial 1669]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << EB()
   or not SB() >>
What for:    normalization of [serial 1665]
Done Normalizing
step:  294
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1645]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1638]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1671]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1645]

This Proof Obligation:

[serial 1655]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1643]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1672]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1655]

This Proof Obligation:

[serial 1669]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << EB()
   or not SB() >>
What for:    normalization of [serial 1665]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1673]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [168] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1669]
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After "substitute" remaining 
Obligations:

[serial 1671]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1645]

[serial 1672]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1655]

[serial 1673]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [168] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1669]
Done substituting Assertion labels.
step:  295
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  296
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1671]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1645]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1675]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1671]

This Proof Obligation:

[serial 1672]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1655]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1677]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1672]

This Proof Obligation:

[serial 1673]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [168] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1669]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1679]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1673]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1675]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1671]

[serial 1677]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1672]

[serial 1679]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1673]
Done Normalizing
step:  297
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1677]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1672]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1683]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1677]

This Proof Obligation:

[serial 1679]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1673]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1684]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1679]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1675]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1671]

[serial 1683]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1677]

[serial 1684]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1679]
Done applying laws
step:  298
****guided-sub-equals****
guided substitution of equals "CTCS_Property::EB_Rate mpss" . . .
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided-sub-equals[CTCS_Property::EB_Rate mpss], no change. 
step:  299
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1683]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1677]
Reasons solved:  
   Guided Substitution of Equals
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1687]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1683]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1675]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1671]
Reason solved:  Guided Substitution of Equals

[serial 1684]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1679]
Reason solved:  Guided Substitution of Equals

[serial 1687]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1683]
Done Normalizing
step:  300
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1675]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1671]
Reasons solved:  
   Guided Substitution of Equals
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1684]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1679]
Reasons solved:  
   Guided Substitution of Equals
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1687]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1683]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1580]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1565]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  301
#[serial 1533] Associativity: (b.c).a = a.b.c [serial 1518]
step:  302
****reduce****

Reducing Concurrent Computation of:

[serial 1580]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1565]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1690]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1580]

[serial 1691]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1580]

[serial 1692]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1580]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1690]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1580]

[serial 1691]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1580]

[serial 1692]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1580]
done reducing composite actions
step:  303
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1690]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1580]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1693]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1690]

The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1694]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1690]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1691]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1580]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1695]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1691]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1696]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1691]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1692]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1580]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1697]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1692]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1698]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1692]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1693]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1690]

[serial 1694]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1690]

[serial 1695]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1691]

[serial 1696]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1691]

[serial 1697]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1692]

[serial 1698]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1692]
Done reducing atomic actions
step:  304
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1694]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1690]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1699]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1694]

This Proof Obligation:

[serial 1696]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1691]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1700]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1696]

This Proof Obligation:

[serial 1697]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1692]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1701]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1697]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1693]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1690]

[serial 1695]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1691]

[serial 1698]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1692]

[serial 1699]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1694]

[serial 1700]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1696]

[serial 1701]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1697]
Done applying laws
step:  305
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1699]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1694]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1700]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1696]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1701]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1697]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1693]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1690]

[serial 1695]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1691]

[serial 1698]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1692]
Done trying to apply axioms
step:  306
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1693]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1690]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1702]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1693]

This Proof Obligation:

[serial 1695]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1691]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1703]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [172] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1695]

This Proof Obligation:

[serial 1698]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1692]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1704]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1698]
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After "substitute" remaining 
Obligations:

[serial 1702]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1693]

[serial 1703]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [172] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1695]

[serial 1704]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1698]
Done substituting Assertion labels.
step:  307
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 47 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  308
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1702]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1693]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1706]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1702]

This Proof Obligation:

[serial 1703]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [172] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1695]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1708]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1703]

This Proof Obligation:

[serial 1704]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1698]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1710]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1704]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1706]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1702]

[serial 1708]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1703]

[serial 1710]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1704]
Done Normalizing
step:  309
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1706]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1702]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1714]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1706]

This Proof Obligation:

[serial 1708]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1703]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1715]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1708]

This Proof Obligation:

[serial 1710]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1704]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1716]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1710]
. . . Substituting <= with not < [3570 minutes 47 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1714]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1706]

[serial 1715]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1708]

[serial 1716]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1710]
Done replacing a<=b with (not b<a)
step:  310
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1714]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1706]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1718]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1714]

This Proof Obligation:

[serial 1715]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1708]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1720]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1715]

This Proof Obligation:

[serial 1716]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1710]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1716]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1718]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1714]

[serial 1720]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1715]

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1716]
Done Normalizing
step:  311
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1718]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1714]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1726]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1718]

This Proof Obligation:

[serial 1720]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1715]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1727]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1720]
. . . done applying DeMorgan's Law  [3570 minutes 47 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1716]

[serial 1726]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1718]

[serial 1727]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1720]
step:  312
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1726]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1718]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1730]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1726]

This Proof Obligation:

[serial 1727]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1720]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1732]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1727]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1716]

[serial 1730]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1726]

[serial 1732]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1727]
Done Normalizing
step:  313
****guided-sub-equals****
guided substitution of equals "CTCS_Property::EB_Rate mpss" . . .
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 47 seconds ]
After guided-sub-equals[CTCS_Property::EB_Rate mpss], no change. 
step:  314
****normalize****
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize", no change. 
step:  315
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1732]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1727]
Reasons solved:  
   Guided Substitution of Equals
   And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1716]
Reason solved:  Guided Substitution of Equals

[serial 1730]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1726]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  316
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1716]
Reasons solved:  
   Guided Substitution of Equals
   Associativity: (b.c).a = a.b.c
Has applied law "Guided Substitution of Equals Associativity: (b.c).a = a.b.c " to get:

[serial 1738]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1722]

This Proof Obligation:

[serial 1730]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1726]
Reasons solved:  
   Guided Substitution of Equals
   Associativity: (b.c).a = a.b.c
Has applied law "Guided Substitution of Equals Associativity: (b.c).a = a.b.c " to get:

[serial 1739]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1730]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1738]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1722]

[serial 1739]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1730]
Done applying laws
step:  317
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1739]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1730]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1740]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]

[serial 1741]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]

[serial 1742]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]
. . . done splitting postcondition  [3570 minutes 47 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1738]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1722]

[serial 1740]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]

[serial 1741]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]

[serial 1742]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]
Done splitting postcondition
step:  318
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1738]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1722]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1740]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1741]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1742]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]
Done trying to apply axioms
step:  319
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1742]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1744]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1742]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 47 seconds ]
After "normalize" remaining 
Obligations:

[serial 1744]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1742]
Done Normalizing
step:  320
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1744]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1742]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1581]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1567]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  321
#[serial 1534] Associativity: (b.c).a = a.b.c [serial 1520]
step:  322
****reduce****

Reducing Concurrent Computation of:

[serial 1581]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1567]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1746]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1581]

[serial 1747]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1581]

[serial 1748]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1581]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1746]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1581]

[serial 1747]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1581]

[serial 1748]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1581]
done reducing composite actions
step:  323
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1746]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1581]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1749]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1746]

The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1750]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1746]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1747]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1581]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1751]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1752]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1747]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1748]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1581]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1753]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1748]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1754]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1748]
. . . done applying atomic actions [3570 minutes 47 seconds ]
After "atomic" remaining 
Obligations:

[serial 1749]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1746]

[serial 1750]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1746]

[serial 1751]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]

[serial 1752]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1747]

[serial 1753]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1748]

[serial 1754]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1748]
Done reducing atomic actions
step:  324
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1750]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1746]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1755]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1750]

This Proof Obligation:

[serial 1752]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1747]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1756]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1752]

This Proof Obligation:

[serial 1753]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1748]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1757]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1753]
. . . done Applying Laws [3570 minutes 47 seconds ]
After "laws" remaining 
Obligations:

[serial 1749]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1746]

[serial 1751]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]

[serial 1754]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1748]

[serial 1755]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1750]

[serial 1756]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1752]

[serial 1757]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1753]
Done applying laws
step:  325
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1755]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1750]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1756]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1752]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1757]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1753]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 47 seconds ]
After "axioms" remaining 
Obligations:

[serial 1749]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1746]

[serial 1751]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]

[serial 1754]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1748]
Done trying to apply axioms
step:  326
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1749]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1746]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1758]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1749]

This Proof Obligation:

[serial 1751]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1759]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [177] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1751]

This Proof Obligation:

[serial 1754]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1748]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1760]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1754]
. . . done substituting assertions' for Labels [3570 minutes 48 seconds ]
After "substitute" remaining 
Obligations:

[serial 1758]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1749]

[serial 1759]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [177] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1751]

[serial 1760]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1754]
Done substituting Assertion labels.
step:  327
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 48 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  328
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1758]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1749]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1762]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1758]

This Proof Obligation:

[serial 1759]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [177] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1751]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1764]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1759]

This Proof Obligation:

[serial 1760]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1754]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1766]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1760]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1762]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1758]

[serial 1764]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1759]

[serial 1766]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1760]
Done Normalizing
step:  329
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1762]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1758]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1770]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1762]

This Proof Obligation:

[serial 1764]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1759]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1771]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1764]

This Proof Obligation:

[serial 1766]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1760]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1772]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1766]
. . . Substituting <= with not < [3570 minutes 48 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1770]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1762]

[serial 1771]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1764]

[serial 1772]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1766]
Done replacing a<=b with (not b<a)
step:  330
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1770]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1762]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1774]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1770]

This Proof Obligation:

[serial 1771]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1764]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1776]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1771]

This Proof Obligation:

[serial 1772]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1766]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1778]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1772]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1774]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1770]

[serial 1776]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1771]

[serial 1778]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1772]
Done Normalizing
step:  331
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1774]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1770]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1782]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1774]

This Proof Obligation:

[serial 1776]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1771]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1783]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1776]
. . . done applying DeMorgan's Law  [3570 minutes 48 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1778]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1772]

[serial 1782]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1774]

[serial 1783]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1776]
step:  332
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1782]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1774]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1786]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1782]

This Proof Obligation:

[serial 1783]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1776]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1788]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1783]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1778]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1772]

[serial 1786]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1782]

[serial 1788]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1783]
Done Normalizing
step:  333
****guided-sub-equals****
guided substitution of equals "CTCS_Property::EB_Rate mpss" . . .
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided-sub-equals[CTCS_Property::EB_Rate mpss], no change. 
step:  334
****normalize****
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize", no change. 
step:  335
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1788]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1783]
Reasons solved:  
   Guided Substitution of Equals
   And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1778]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1772]
Reason solved:  Guided Substitution of Equals

[serial 1786]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1782]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  336
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1778]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1772]
Reasons solved:  
   Guided Substitution of Equals
   Associativity: (b.c).a = a.b.c
Has applied law "Guided Substitution of Equals Associativity: (b.c).a = a.b.c " to get:

[serial 1794]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1778]

This Proof Obligation:

[serial 1786]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1782]
Reasons solved:  
   Guided Substitution of Equals
   Associativity: (b.c).a = a.b.c
Has applied law "Guided Substitution of Equals Associativity: (b.c).a = a.b.c " to get:

[serial 1795]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1786]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1794]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1778]

[serial 1795]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1786]
Done applying laws
step:  337
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1795]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1786]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1796]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]

[serial 1797]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]

[serial 1798]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]
. . . done splitting postcondition  [3570 minutes 48 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1794]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1778]

[serial 1796]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]

[serial 1797]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]

[serial 1798]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]
Done splitting postcondition
step:  338
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1794]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1778]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1796]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1797]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1798]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]
Done trying to apply axioms
step:  339
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1798]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1800]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1798]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1800]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1798]
Done Normalizing
step:  340
****guided-sub-equals****
guided substitution of equals "CTCS_Property::SB_Rate mpss" . . .
equality selected for substitution:  b = CTCS_Property::SB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided-sub-equals[CTCS_Property::SB_Rate mpss], no change. 
step:  341
****normalize****
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize", no change. 
step:  342
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1800]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1798]
Reasons solved:  
   Guided Substitution of Equals
   And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1582]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1569]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  343
#[serial 1535] Associativity: (b.c).a = a.b.c [serial 1522]
step:  344
****reduce****

Reducing Concurrent Computation of:

[serial 1582]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1569]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1803]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1582]

[serial 1804]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1582]

[serial 1805]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1582]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1803]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1582]

[serial 1804]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1582]

[serial 1805]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1582]
done reducing composite actions
step:  345
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1803]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1582]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1806]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1803]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1807]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1803]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1804]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1582]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1808]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1804]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1809]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1804]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1805]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1582]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=xl)@now>> -> <<post>> for  <<pre>> ca!(xl) <<post>> to get:

[serial 1810]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1805]
looking through terms of
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]
no term was found that had expression e:
 xl
. . . done applying atomic actions [3570 minutes 48 seconds ]
After "atomic" remaining 
Obligations:

[serial 1806]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1803]

[serial 1807]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1803]

[serial 1808]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1804]

[serial 1809]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1804]

[serial 1810]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1805]
Done reducing atomic actions
step:  346
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1807]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1803]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1811]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1807]

This Proof Obligation:

[serial 1809]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1804]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1812]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1809]

This Proof Obligation:

[serial 1810]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1805]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1813]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1810]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1806]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1803]

[serial 1808]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1804]

[serial 1811]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1807]

[serial 1812]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1809]

[serial 1813]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1810]
Done applying laws
step:  347
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1811]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1807]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1812]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1809]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1813]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1810]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1806]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1803]

[serial 1808]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1804]
Done trying to apply axioms
step:  348
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1806]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1803]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1814]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1806]
. . . done applying DeMorgan's Law  [3570 minutes 48 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1808]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1804]

[serial 1814]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1806]
step:  349
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1814]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1806]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1817]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << EB()
   or not SB() >>
What for:    normalization of [serial 1814]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1808]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1804]

[serial 1817]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << EB()
   or not SB() >>
What for:    normalization of [serial 1814]
Done Normalizing
step:  350
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1808]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1804]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1819]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1808]

This Proof Obligation:

[serial 1817]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << EB()
   or not SB() >>
What for:    normalization of [serial 1814]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1820]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1817]
. . . done substituting assertions' for Labels [3570 minutes 48 seconds ]
After "substitute" remaining 
Obligations:

[serial 1819]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1808]

[serial 1820]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1817]
Done substituting Assertion labels.
step:  351
****substitute postcondition****
Substituting Assertions for Labels . . .
. . . done substituting assertions' for Labels [3570 minutes 48 seconds ]
After substituting Assertion labels in postconditions, no change. 
step:  352
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1819]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1808]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1822]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1819]

This Proof Obligation:

[serial 1820]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1817]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1824]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1820]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1822]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1819]

[serial 1824]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1820]
Done Normalizing
step:  353
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1822]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1819]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1827]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1822]

This Proof Obligation:

[serial 1824]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1820]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1828]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1824]
. . . Substituting <= with not < [3570 minutes 48 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1827]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1822]

[serial 1828]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1824]
Done replacing a<=b with (not b<a)
step:  354
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1827]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1822]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1830]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1827]

This Proof Obligation:

[serial 1828]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1824]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1832]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1828]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1830]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1827]

[serial 1832]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1828]
Done Normalizing
step:  355
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1830]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1827]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1835]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1830]

This Proof Obligation:

[serial 1832]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1828]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1836]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1832]
. . . done applying DeMorgan's Law  [3570 minutes 48 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1835]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1830]

[serial 1836]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1832]
step:  356
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1836]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1832]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1837]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1836]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1835]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1830]

[serial 1837]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1836]
Done applying laws
step:  357
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1835]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1830]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1839]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1835]

This Proof Obligation:

[serial 1837]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1836]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1841]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1837]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1839]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1835]

[serial 1841]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1837]
Done Normalizing
step:  358
****guided-sub-equals****
guided substitution of equals "CTCS_Property::SB_Rate mpss" . . .
equality selected for substitution:  b = CTCS_Property::SB_Rate mpss
equality selected for substitution:  b = CTCS_Property::SB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided-sub-equals[CTCS_Property::SB_Rate mpss], no change. 
step:  359
****normalize****
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize", no change. 
step:  360
****axioms****
Applying Axioms . . .
AXIOM.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n


This Proof Obligation:

[serial 1841]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1837]
Reasons solved:  
   Guided Substitution of Equals
   Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
Has been solved by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1839]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1835]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  361
****guided-sub-equals****
guided substitution of equals "CTCS_Property::EB_Rate mpss" . . .
equality selected for substitution:  e = CTCS_Property::EB_Rate mpss
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided-sub-equals[CTCS_Property::EB_Rate mpss], no change. 
step:  362
****normalize****
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize", no change. 
step:  363
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1839]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1835]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
   Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1847]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1848]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
. . . done splitting postcondition  [3570 minutes 48 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1847]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1848]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Done splitting postcondition
step:  364
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1848]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1847]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Done trying to apply axioms
step:  365
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  v < iSeg.v_n and iSeg.v_n < iSeg.v_e -> v < iSeg.v_e

This Proof Obligation:

[serial 1847]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Reason solved:  Transitivity: x<y and y<z -> x<z
Has applied Transitivity: x<y and y<z -> x<z  to get:

[serial 1849]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1847]
. . . done adding transitive terms [3570 minutes 48 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 1849]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1847]
Done adding transitive relations
step:  366
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1849]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1847]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1024]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  367
#[serial 1024]  <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
step:  368
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1024]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1025]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and AXIOM_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  369
#[serial 1025]  <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A};
step:  370
****reduce****
This proof obligation:

[serial 1025]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and AXIOM_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1850]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65]->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]

[serial 1851]: Threads::AutoBrake.i
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
S [67]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  <<Q1>> -> <<Q>> in sequential composition for [serial 1025]

[serial 1852]: Threads::AutoBrake.i
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1025]

[serial 1853]: Threads::AutoBrake.i
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196]nSeg := next_ma.seg[1]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
What for:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1025]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1850]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65]->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]

[serial 1851]: Threads::AutoBrake.i
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
S [67]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  <<Q1>> -> <<Q>> in sequential composition for [serial 1025]

[serial 1852]: Threads::AutoBrake.i
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1025]

[serial 1853]: Threads::AutoBrake.i
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196]nSeg := next_ma.seg[1]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
What for:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1025]
done reducing composite actions
step:  371
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1850]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65]->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1855]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:    normalization of [serial 1850]

This Proof Obligation:

[serial 1851]: Threads::AutoBrake.i
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
S [67]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  <<Q1>> -> <<Q>> in sequential composition for [serial 1025]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1857]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1851]

This Proof Obligation:

[serial 1852]: Threads::AutoBrake.i
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1025]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1859]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1852]

This Proof Obligation:

[serial 1853]: Threads::AutoBrake.i
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196]nSeg := next_ma.seg[1]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
What for:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1025]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1861]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1853]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1855]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:    normalization of [serial 1850]

[serial 1857]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1851]

[serial 1859]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1852]

[serial 1861]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1853]
Done Normalizing
step:  372
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1855]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:    normalization of [serial 1850]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1866]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [3570 minutes 48 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1857]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1851]

[serial 1859]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1852]

[serial 1861]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1853]

[serial 1866]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  373
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1866]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1867]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1866]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1857]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1851]

[serial 1859]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1852]

[serial 1861]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1853]

[serial 1867]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1866]
Done applying laws
step:  374
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1867]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1866]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1857]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1851]

[serial 1859]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1852]

[serial 1861]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1853]
Done trying to apply axioms
step:  375
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  376
#Threads::AutoBrake.i
step:  377
#[serial 1784]   normalization of [serial 177
step:  378
****make-an****
Making obligation 42
Obligations:

[serial 1857]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1851]
Done making obligation 42
step:  379
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1857]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1851]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1868]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]

[serial 1869]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]

[serial 1870]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]

[serial 1871]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [68] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]

[serial 1872]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << NEXT_MA.seg[1] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
. . . done splitting postcondition  [3570 minutes 48 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1868]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]

[serial 1869]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]

[serial 1870]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]

[serial 1871]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [68] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]

[serial 1872]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << NEXT_MA.seg[1] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Done splitting postcondition
step:  380
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1868]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1869]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1871]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [68] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1872]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << NEXT_MA.seg[1] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1870]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Done trying to apply axioms
step:  381
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  CMA.num_segments = i

This Proof Obligation:

[serial 1870]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "
^{CMA 
 ^{. num_segments}}"
 to get:

[serial 1873]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1870]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1873]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1870]
Done guided substituting an equals
step:  382
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1873]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1870]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1859]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1852]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  383
#[serial 1786]   normalization of [serial 1779]
step:  384
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1859]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1852]
Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(m_a)>> -> <<post>> for <<pre>> m_a?(next_ma) <<post>> to get:

[serial 1874]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1859]
. . . done applying atomic actions [3570 minutes 48 seconds ]
After "atomic" remaining 
Obligations:

[serial 1874]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1859]
Done reducing atomic actions
step:  385
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1874]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1859]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1876]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1874]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1876]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1874]
Done Normalizing
step:  386
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1876]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1874]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1878]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]

[serial 1879]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]

[serial 1880]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]

[serial 1881]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
. . . done splitting postcondition  [3570 minutes 48 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1878]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]

[serial 1879]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]

[serial 1880]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]

[serial 1881]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Done splitting postcondition
step:  387
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1878]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1882]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1878]

This Proof Obligation:

[serial 1879]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1883]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Associativity: (b.c).a = a.b.c [serial 1879]

This Proof Obligation:

[serial 1880]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1884]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Associativity: (b.c).a = a.b.c [serial 1880]

This Proof Obligation:

[serial 1881]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1885]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1881]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1882]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1878]

[serial 1883]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Associativity: (b.c).a = a.b.c [serial 1879]

[serial 1884]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Associativity: (b.c).a = a.b.c [serial 1880]

[serial 1885]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1881]
Done applying laws
step:  388
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1882]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1878]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1883]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Associativity: (b.c).a = a.b.c [serial 1879]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1884]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Associativity: (b.c).a = a.b.c [serial 1880]

[serial 1885]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1881]
Done trying to apply axioms
step:  389
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1884]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Associativity: (b.c).a = a.b.c [serial 1880]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1886]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1884]

This Proof Obligation:

[serial 1885]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1881]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1887]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1885]
. . . done substituting assertions' for Labels [3570 minutes 48 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1886]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1884]

[serial 1887]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1885]
Done substituting Assertion labels in preconditions
step:  390
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1886]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1884]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1889]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1886]

This Proof Obligation:

[serial 1887]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1885]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1891]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1887]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1889]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1886]

[serial 1891]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1887]
Done Normalizing
step:  391
****guided-sub-equals****
guided substitution of equals "NEXT_MA" . . .
equality selected for substitution:  NEXT_MA = RMA
equality selected for substitution:  NEXT_MA = RMA

This Proof Obligation:

[serial 1891]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1887]
Reason solved:  Guided Substitution of Equals
Has substituted 
"NEXT_MA" with its = "RMA"
 to get:

[serial 1894]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << RMA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1891]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1889]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1886]
Reason solved:  Guided Substitution of Equals

[serial 1894]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << RMA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1891]
Done guided substituting an equals
step:  392
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1894]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << RMA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1891]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1889]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1886]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  393
****guided-sub-equals****
guided substitution of equals "
^{CMA 
 ^{. num_segments}}" . . .
equality selected for substitution:  CMA.num_segments = i

This Proof Obligation:

[serial 1889]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1886]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
Has substituted 
"
^{CMA 
 ^{. num_segments}}" with its = "i"
 to get:

[serial 1895]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1889]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1895]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1889]
Done guided substituting an equals
step:  394
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1895]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1889]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1861]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1853]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  395
#[serial 1788]   normalization of [serial 1780]
step:  396
****atomic****
applying atomic actions . . .
solving assignment on line 196
replacing "nSeg" with "
^{next_ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 1}}}}}"
makes:  << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>

This Proof Obligation:

[serial 1861]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1853]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1896]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  applied wp for assignment [serial 1861]
. . . done applying atomic actions [3570 minutes 48 seconds ]
After "atomic" remaining 
Obligations:

[serial 1896]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  applied wp for assignment [serial 1861]
Done reducing atomic actions
step:  397
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1896]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  applied wp for assignment [serial 1861]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1897]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]

[serial 1898]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]

[serial 1899]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]

[serial 1900]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]

[serial 1901]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
. . . done splitting postcondition  [3570 minutes 48 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1897]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]

[serial 1898]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]

[serial 1899]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]

[serial 1900]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]

[serial 1901]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Done splitting postcondition
step:  398
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1897]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1898]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1899]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1900]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1901]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Done trying to apply axioms
step:  399
****guided-sub-equals****
guided substitution of equals "NEXT_MA" . . .
equality selected for substitution:  NEXT_MA = next_ma

This Proof Obligation:

[serial 1901]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Reason solved:  Guided Substitution of Equals
Has substituted 
"NEXT_MA" with its = "next_ma"
 to get:

[serial 1902]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << next_ma.seg[1] = next_ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1901]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1902]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << next_ma.seg[1] = next_ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1901]
Done guided substituting an equals
step:  400
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1902]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << next_ma.seg[1] = next_ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1901]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1903]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1902]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1903]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1902]
Done applying laws
step:  401
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1903]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1902]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1026]: Threads::AutoBrake.i
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  402
#[serial 1026]  <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{};
step:  403
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1026]: Threads::AutoBrake.i
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{};
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1904]: Threads::AutoBrake.i
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1026]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1904]: Threads::AutoBrake.i
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1026]
Done applying laws
step:  404
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1904]: Threads::AutoBrake.i
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1026]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1027]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  405
#[serial 1027]  <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{};
step:  406
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1027]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{};
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1028]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]  << AXIOM_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  407
#[serial 1028]  <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A};
step:  408
****reduce****
This proof obligation:

[serial 1028]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]  << AXIOM_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P3>> S3 <<Q3>>
 
was reduced to:

[serial 1905]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]

[serial 1906]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q3>> -> <<Q>> in sequential composition for [serial 1028]

[serial 1907]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028]

[serial 1908]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1
Q [214] << i = 1
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]

[serial 1909]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]

[serial 1910]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1905]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]

[serial 1906]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q3>> -> <<Q>> in sequential composition for [serial 1028]

[serial 1907]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028]

[serial 1908]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1
Q [214] << i = 1
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]

[serial 1909]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]

[serial 1910]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028]
done reducing composite actions
step:  409
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  410
#Threads::AutoBrake.i
step:  411
#[serial 1832] <<P>> -> <<P1>> in sequential composition for [serial 102
step:  412
****make-an****
Making obligation 48
Obligations:

[serial 1905]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Done making obligation 48
step:  413
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1905]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1911]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << true
  and next_ma = NEXT_MA >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [3570 minutes 48 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1911]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << true
  and next_ma = NEXT_MA >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  414
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1911]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << true
  and next_ma = NEXT_MA >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1912]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << ( next_ma = NEXT_MA ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1911]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1912]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << ( next_ma = NEXT_MA ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1911]
Done applying laws
step:  415
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1912]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << ( next_ma = NEXT_MA ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1911]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1914]: Threads::AutoBrake.i
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [210] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1912]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1914]: Threads::AutoBrake.i
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [210] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1912]
Done Normalizing
step:  416
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1914]: Threads::AutoBrake.i
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [210] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1912]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1906]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q3>> -> <<Q>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  417
#[serial 1833] <<Q3>> -> <<Q>> in sequential composition for [serial 1028]
step:  418
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1906]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q3>> -> <<Q>> in sequential composition for [serial 1028]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1916]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ( 1 < ma.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1906]
. . . done substituting assertions' for Labels [3570 minutes 48 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1916]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ( 1 < ma.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1906]
Done substituting Assertion labels in preconditions
step:  419
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1916]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ( 1 < ma.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1906]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1918]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1916]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1918]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1916]
Done Normalizing
step:  420
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1918]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1916]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1920]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]

[serial 1921]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]

[serial 1922]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]

[serial 1923]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
. . . done splitting postcondition  [3570 minutes 48 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1920]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]

[serial 1921]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]

[serial 1922]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]

[serial 1923]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Done splitting postcondition
step:  421
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1920]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1921]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1922]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1923]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Done trying to apply axioms
step:  422
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1923]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1924]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1923]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1924]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1923]
Done guided substituting an equals
step:  423
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1924]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1923]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1925]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1924]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1925]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1924]
Done guided substituting an equals
step:  424
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1925]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1924]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1927]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1925]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1927]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1925]
Done Normalizing
step:  425
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1927]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1925]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1907]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  426
#[serial 1834] <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028]
step:  427
****atomic****
applying atomic actions . . .
solving assignment on line 211
replacing "ma" with "next_ma"
makes:  << next_ma = CMA >>

This Proof Obligation:

[serial 1907]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
What for:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1929]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  applied wp for assignment [serial 1907]
. . . done applying atomic actions [3570 minutes 48 seconds ]
After "atomic" remaining 
Obligations:

[serial 1929]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  applied wp for assignment [serial 1907]
Done reducing atomic actions
step:  428
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1929]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  applied wp for assignment [serial 1907]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1930]: Threads::AutoBrake.i
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1929]
. . . done substituting assertions' for Labels [3570 minutes 48 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1930]: Threads::AutoBrake.i
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1929]
Done substituting Assertion labels in preconditions
step:  429
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1930]: Threads::AutoBrake.i
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1929]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1932]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << CMA = next_ma >>
What for:    normalization of [serial 1930]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1932]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << CMA = next_ma >>
What for:    normalization of [serial 1930]
Done Normalizing
step:  430
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = NEXT_MA

This Proof Obligation:

[serial 1932]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << CMA = next_ma >>
What for:    normalization of [serial 1930]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "NEXT_MA"
 to get:

[serial 1934]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << NEXT_MA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1932]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1934]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << NEXT_MA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1932]
Done guided substituting an equals
step:  431
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1934]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << NEXT_MA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1932]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1908]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1
Q [214] << i = 1
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  432
#[serial 1835] <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
step:  433
****atomic****
applying atomic actions . . .
solving assignment on line 213
replacing "i" with "1"
makes:  << ( 1 ) = 1
  and ma = CMA >>

This Proof Obligation:

[serial 1908]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1
Q [214] << i = 1
  and ma = CMA >>
What for:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1935]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]->
Q [214] << ( 1 ) = 1
  and ma = CMA >>
What for:  applied wp for assignment [serial 1908]
. . . done applying atomic actions [3570 minutes 48 seconds ]
After "atomic" remaining 
Obligations:

[serial 1935]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]->
Q [214] << ( 1 ) = 1
  and ma = CMA >>
What for:  applied wp for assignment [serial 1908]
Done reducing atomic actions
step:  434
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1935]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]->
Q [214] << ( 1 ) = 1
  and ma = CMA >>
What for:  applied wp for assignment [serial 1908]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1937]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1935]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1937]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1935]
Done Normalizing
step:  435
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1937]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1935]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1939]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1937]

This Proof Obligation:

[serial 1939]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1937]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1940]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1939]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1940]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1939]
Done applying laws
step:  436
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1940]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1939]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1942]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma >>
What for:    normalization of [serial 1940]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1942]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma >>
What for:    normalization of [serial 1940]
Done Normalizing
step:  437
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1942]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma >>
What for:    normalization of [serial 1940]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1909]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  438
#[serial 1836] <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
step:  439
****atomic****
applying atomic actions . . .
solving assignment on line 215
replacing "iSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 1}}}}}"
makes:  << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>

This Proof Obligation:

[serial 1909]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1944]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>
What for:  applied wp for assignment [serial 1909]
. . . done applying atomic actions [3570 minutes 48 seconds ]
After "atomic" remaining 
Obligations:

[serial 1944]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>
What for:  applied wp for assignment [serial 1909]
Done reducing atomic actions
step:  440
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1944]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>
What for:  applied wp for assignment [serial 1909]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1945]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]

[serial 1946]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]

[serial 1947]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
. . . done splitting postcondition  [3570 minutes 48 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1945]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]

[serial 1946]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]

[serial 1947]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Done splitting postcondition
step:  441
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1945]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1946]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1947]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Done trying to apply axioms
step:  442
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  ma = CMA

This Proof Obligation:

[serial 1947]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1948]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1947]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1948]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1947]
Done guided substituting an equals
step:  443
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1948]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1947]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1949]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[( 1 )] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1948]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1949]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[( 1 )] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1948]
Done guided substituting an equals
step:  444
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1949]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[( 1 )] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1948]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1951]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1949]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1951]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1949]
Done Normalizing
step:  445
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1951]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1949]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1953]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1951]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1953]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1951]
Done applying laws
step:  446
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1953]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1951]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1910]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  447
#[serial 1837] <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028]
step:  448
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1910]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1954]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [3570 minutes 48 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1954]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  449
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1954]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1955]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1954]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1955]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1954]
Done applying laws
step:  450
****atomic****
applying atomic actions . . .
solving assignment on line 217
replacing "nSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 2}}}}}"
makes:  << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>

This Proof Obligation:

[serial 1955]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1954]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1956]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
What for:  applied wp for assignment [serial 1955]
. . . done applying atomic actions [3570 minutes 48 seconds ]
After "atomic" remaining 
Obligations:

[serial 1956]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
What for:  applied wp for assignment [serial 1955]
Done reducing atomic actions
step:  451
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1956]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
What for:  applied wp for assignment [serial 1955]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1957]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]

[serial 1958]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]

[serial 1959]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << iSeg = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]

[serial 1960]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
. . . done splitting postcondition  [3570 minutes 48 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1957]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]

[serial 1958]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]

[serial 1959]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << iSeg = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]

[serial 1960]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Done splitting postcondition
step:  452
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1957]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1958]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1959]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << iSeg = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:

[serial 1960]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Done trying to apply axioms
step:  453
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1960]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1961]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1960]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1961]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1960]
Done guided substituting an equals
step:  454
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1961]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1960]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1963]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << CMA.seg[2] = ma.seg[2] >>
What for:    normalization of [serial 1961]
. . . done Normalizing Unsolved Proof Obligations [3570 minutes 48 seconds ]
After "normalize" remaining 
Obligations:

[serial 1963]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << CMA.seg[2] = ma.seg[2] >>
What for:    normalization of [serial 1961]
Done Normalizing
step:  455
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1963]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << CMA.seg[2] = ma.seg[2] >>
What for:    normalization of [serial 1961]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1965]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << ma.seg[2] = ma.seg[2] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1963]
. . . done guided substitution of equals  [3570 minutes 48 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1965]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << ma.seg[2] = ma.seg[2] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1963]
Done guided substituting an equals
step:  456
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1965]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << ma.seg[2] = ma.seg[2] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1963]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1966]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1965]
. . . done Applying Laws [3570 minutes 48 seconds ]
After "laws" remaining 
Obligations:

[serial 1966]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1965]
Done applying laws
step:  457
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1966]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1965]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1029]: driver.xl -> motor.xl
P [1] << xl = OPERATOR_XL >>
S [2]->
Q [1] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  458
#[serial 1029] Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
step:  459
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1029]: driver.xl -> motor.xl
P [1] << xl = OPERATOR_XL >>
S [2]->
Q [1] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1030]: sensor.p -> controller.control.p
P [1] << p = POSITION >>
S [2]->
Q [1] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  460
#[serial 1030] Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
step:  461
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1030]: sensor.p -> controller.control.p
P [1] << p = POSITION >>
S [2]->
Q [1] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1031]: sensor.v -> controller.control.v
P [1] << v = VELOCITY >>
S [2]->
Q [1] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  462
#[serial 1031] Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
step:  463
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1031]: sensor.v -> controller.control.v
P [1] << v = VELOCITY >>
S [2]->
Q [1] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1032]: controller.control.sb -> sbrake.brake
P [1] << SB()
  and not EB() >>
S [2]->
Q [1] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  464
#[serial 1032] Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
step:  465
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1032]: controller.control.sb -> sbrake.brake
P [1] << SB()
  and not EB() >>
S [2]->
Q [1] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1033]: controller.control.eb -> ebrake.brake
P [1] << EB() >>
S [2]->
Q [1] << EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  466
#[serial 1033] Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
step:  467
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1033]: controller.control.eb -> ebrake.brake
P [1] << EB() >>
S [2]->
Q [1] << EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1034]: rbc.ma -> train.controller.control.m_a
P [1] << ma_m_a = RMA >>
S [2]->
Q [1] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  468
#[serial 1034] Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
step:  469
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1034]: rbc.ma -> train.controller.control.m_a
P [1] << ma_m_a = RMA >>
S [2]->
Q [1] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1035]: CTCS::MovementAuthority.i.ma
P [27] << ma = RMA >>
S [19]->
Q [14] << ma = RMA >>
What for:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  470
#[serial 1035] Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
step:  471
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1035]: CTCS::MovementAuthority.i.ma
P [27] << ma = RMA >>
S [19]->
Q [14] << ma = RMA >>
What for:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1036]: Train::Train.i.auth
P [14] << ma_m_a = RMA >>
S [73]->
Q [94] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  472
#[serial 1036] Composition of Subcomponents via Directional Connection Train::Train.i.auth:
step:  473
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1036]: Train::Train.i.auth
P [14] << ma_m_a = RMA >>
S [73]->
Q [94] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1037]: Train::Train.i.pos
P [32] << p = POSITION >>
S [74]->
Q [89] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  474
#[serial 1037] Composition of Subcomponents via Directional Connection Train::Train.i.pos:
step:  475
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1037]: Train::Train.i.pos
P [32] << p = POSITION >>
S [74]->
Q [89] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1038]: Train::Train.i.vel
P [34] << v = VELOCITY >>
S [75]->
Q [91] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  476
#[serial 1038] Composition of Subcomponents via Directional Connection Train::Train.i.vel:
step:  477
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1038]: Train::Train.i.vel
P [34] << v = VELOCITY >>
S [75]->
Q [91] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1039]: Train::Train.i.dxl
P [59] << xl = OPERATOR_XL >>
S [76]->
Q [23] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  478
#[serial 1039] Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
step:  479
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1039]: Train::Train.i.dxl
P [59] << xl = OPERATOR_XL >>
S [76]->
Q [23] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1040]: Train::Train.i.cpsb
P [85] << SB()
  and not EB() >>
S [77]->
Q [44] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  480
#[serial 1040] Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
step:  481
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1040]: Train::Train.i.cpsb
P [85] << SB()
  and not EB() >>
S [77]->
Q [44] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1041]: Train::Train.i.cpeb
P [87] << EB() >>
S [78]->
Q [51] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  482
#[serial 1041] Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
step:  483
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1041]: Train::Train.i.cpeb
P [87] << EB() >>
S [78]->
Q [51] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1042]: Train::ControllerProcess.i.conn_s
P [89] << p = POSITION >>
S [103]->
Q [19] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  484
#[serial 1042] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
step:  485
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1042]: Train::ControllerProcess.i.conn_s
P [89] << p = POSITION >>
S [103]->
Q [19] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1043]: Train::ControllerProcess.i.conn_v
P [91] << v = VELOCITY >>
S [104]->
Q [21] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  486
#[serial 1043] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
step:  487
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1043]: Train::ControllerProcess.i.conn_v
P [91] << v = VELOCITY >>
S [104]->
Q [21] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1044]: Train::ControllerProcess.i.conn_ma
P [94] << m_a = RMA >>
S [106]->
Q [17] << m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  488
#[serial 1044] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
step:  489
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1044]: Train::ControllerProcess.i.conn_ma
P [94] << m_a = RMA >>
S [106]->
Q [17] << m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1045]: Train::ControllerProcess.i.conn_sb
P [12] << SB()
  and not EB() >>
S [108]->
Q [85] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  490
#[serial 1045] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_xl:
step:  491
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1045]: Train::ControllerProcess.i.conn_sb
P [12] << SB()
  and not EB() >>
S [108]->
Q [85] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1046]: Train::ControllerProcess.i.conn_eb
P [14] << EB() >>
S [109]->
Q [87] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  492
#[serial 1046] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
step:  493
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1046]: Train::ControllerProcess.i.conn_eb
P [14] << EB() >>
S [109]->
Q [87] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [3570 minutes 48 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
There are no more unsolved proof obligations.
All proof obligations have been solved.  Q.E.D.
opening proof file "/Applications/osate2/Eclipse.app/Contents/MacOS/proof.txt" Wed Apr 26 14:28:58 CDT 2023
Theorem (1)                               [serial 1003] 
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (2)                               [serial 1004] 
P [54] << true >>
S [39] ->
Q [39] << true >>
Why created:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (3)                               [serial 1005] 
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (4)                               [serial 1048] 
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [39] ->
Q [39] << true >>
Why created:    normalization of [serial 1006]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (5)                               [serial 1006] 
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 4:
Theorem (4) [serial 1048] used for:
    normalization of [serial 1006] 


Theorem (6)                               [serial 1054] 
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59] ->
Q [59] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1053]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (7)                               [serial 1053] 
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59] ->
Q [59] << ( not ( p < iSeg.e ) )
   or p < iSeg.e >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 6:
Theorem (6) [serial 1054] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1053] 


Theorem (8)                               [serial 1051] 
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59] ->
Q [59] << iSeg.e <= p
   or p < iSeg.e >>
Why created:    normalization of [serial 1007]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 7:
Theorem (7) [serial 1053] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051] 


Theorem (9)                               [serial 1007] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [59] ->
Q [59] << ( p < iSeg.e )
   or ( p >= iSeg.e ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 8:
Theorem (8) [serial 1051] used for:
    normalization of [serial 1007] 


Theorem (10)                               [serial 1055] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65] ->
Q [65] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1008]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (11)                               [serial 1008] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65] ->
Q [65] << ( not m_a'fresh )
   or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 10:
Theorem (10) [serial 1055] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1008] 


Theorem (12)                               [serial 1009] 
P [53] << true >>
S [53] ->
Q [53] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (13)                               [serial 1059] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61] ->
Q [61] << true >>
Why created:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (14)                               [serial 1057] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61] ->
Q [61] << i = ma.num_segments
   or i < ma.num_segments
   or ma.num_segments < i >>
Why created:    normalization of [serial 1010]
Solved by:  Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 13:
Theorem (13) [serial 1059] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057] 


Theorem (15)                               [serial 1010] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61] ->
Q [61] << ( i < ma.num_segments )
   or ( i = ma.num_segments )
   or ( i > ma.num_segments ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 14:
Theorem (14) [serial 1057] used for:
    normalization of [serial 1010] 


Theorem (16)                               [serial 1060] 
P [55] << true >>
S [55] ->
Q [55] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1011]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (17)                               [serial 1011] 
P [55] << true >>
S [55] ->
Q [55] << ( not m_a'fresh )
   or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 16:
Theorem (16) [serial 1060] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1011] 


Theorem (18)                               [serial 1065] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1064]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (19)                               [serial 1064] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << ( not ( p < ma.ea ) )
   or p < ma.ea >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 18:
Theorem (18) [serial 1065] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1064] 


Theorem (20)                               [serial 1062] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << ma.ea <= p
   or p < ma.ea >>
Why created:    normalization of [serial 1012]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 19:
Theorem (19) [serial 1064] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062] 


Theorem (21)                               [serial 1012] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70] ->
Q [70] << ( p < ma.ea )
   or ( p >= ma.ea ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 20:
Theorem (20) [serial 1062] used for:
    normalization of [serial 1012] 


Theorem (22)                               [serial 1067] 
P [53] << true >>
S [76] ->
Q [76] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1066]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (23)                               [serial 1068] 
P [76] << ( true )
  and true@now >>
S [76] ->
Q [54] << true >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (24)                               [serial 1066] 
P [53] << true >>
S [76] r!
Q [54] << true >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 22 23:
Theorem (22) [serial 1067] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1066] 
Theorem (23) [serial 1068] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066] 


Theorem (25)                               [serial 1013] 
P [53] << true >>
S [76] r!
Q [54] << true >>
Why created:   <<M(Start)>> A <<M(WaitFirstMA)>> for GoStart-[ ]->WaitFirstMA{A};
Solved by:  Introduction of Existential Quantification
and theorem 24:
Theorem (24) [serial 1066] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013] 


Theorem (26)                               [serial 1014] 
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [78] ->
Q [55] << true >>
Why created:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMAWaitFirstMA-[x]->CheckFirstMA{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (27)                               [serial 1015] 
P [82] << not m_a'fresh >>
S [81] ->
Q [54] << true >>
Why created:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYetCheckFirstMA-[x]->WaitFirstMA{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (28)                               [serial 1075] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << true >>
Why created:   add user-defined axioms to postcondition
Solved by:  True Conclusion Schema (tc): P->true


Theorem (29)                               [serial 1075] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << true >>
Why created:   add user-defined axioms to postcondition
Solved by:  True Conclusion Schema (tc): P->true


Theorem (30)                               [serial 1069] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << AXIOM_CMA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 29 29:
Theorem (29) [serial 1075] used for:
   add user-defined axioms to postcondition 
Theorem (29) [serial 1075] used for:
   add user-defined axioms to postcondition 


Theorem (31)                               [serial 1096] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (32)                               [serial 1097] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (33)                               [serial 1098] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA.seg[1 + i] = nSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (34)                               [serial 1109] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57] ->
Q [57] << 1 < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (35)                               [serial 1107] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57] ->
Q [57] << 1 < ma.num_segments >>
Why created:    normalization of [serial 1105]
Solved by:  Guided Substitution of Equals
and theorem 34:
Theorem (34) [serial 1109] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107] 


Theorem (36)                               [serial 1105] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57] ->
Q [57] << ( 1 ) < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 35:
Theorem (35) [serial 1107] used for:
    normalization of [serial 1105] 


Theorem (37)                               [serial 1103] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57] ->
Q [57] << i < ma.num_segments >>
Why created:    normalization of [serial 1101]
Solved by:  Guided Substitution of Equals
and theorem 36:
Theorem (36) [serial 1105] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103] 


Theorem (38)                               [serial 1101] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57] ->
Q [57] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 37:
Theorem (37) [serial 1103] used for:
    normalization of [serial 1101] 


Theorem (39)                               [serial 1100] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1099]
Solved by:  Guided Substitution of Equals
and theorem 38:
Theorem (38) [serial 1101] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100] 


Theorem (40)                               [serial 1099] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  Substitution of Assertion Labels
and theorem 39:
Theorem (39) [serial 1100] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1099] 


Theorem (41)                               [serial 1081] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1070]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 31 32 33 40:
Theorem (31) [serial 1096] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 
Theorem (32) [serial 1097] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 
Theorem (33) [serial 1098] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 
Theorem (40) [serial 1099] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 


Theorem (42)                               [serial 1070] 
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<Q3>> -> <<Q>> in sequential composition for [serial 1016]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 41:
Theorem (41) [serial 1081] used for:
    normalization of [serial 1070] 


Theorem (43)                               [serial 1115] 
P [87] << CMA = RMA
  and RMA = ma >>
S [87] ->
Q [88] << RMA = ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (44)                               [serial 1113] 
P [87] << CMA = RMA
  and RMA = ma >>
S [87] ->
Q [88] << CMA = ma >>
Why created:    normalization of [serial 1111]
Solved by:  Guided Substitution of Equals
and theorem 43:
Theorem (43) [serial 1115] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113] 


Theorem (45)                               [serial 1111] 
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87] ->
Q [88] << CMA = ma >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1110]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 44:
Theorem (44) [serial 1113] used for:
    normalization of [serial 1111] 


Theorem (46)                               [serial 1110] 
P [87] << ( AXIOM_CMA_IS_RMA() )
  and ma = RMA >>
S [87] ->
Q [88] << CMA = ma >>
Why created:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083]
Solved by:  Substitution of Assertion Labels
and theorem 45:
Theorem (45) [serial 1111] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1110] 


Theorem (47)                               [serial 1083] 
P [86] << AXIOM_CMA_IS_RMA() >>
S [87] m_a?(ma)
Q [88] << CMA = ma >>
Why created:    normalization of [serial 1071]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 46:
Theorem (46) [serial 1110] used for:
  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083] 


Theorem (48)                               [serial 1071] 
P [86] << AXIOM_CMA_IS_RMA() >>
S [87] m_a?(ma)
Q [88] << ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 47:
Theorem (47) [serial 1083] used for:
    normalization of [serial 1071] 


Theorem (49)                               [serial 1123] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma >>
Why created:    normalization of [serial 1121]
Solved by:  Identity (id):  P->P is tautology


Theorem (50)                               [serial 1121] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << ( CMA = ma ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1120]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 49:
Theorem (49) [serial 1123] used for:
    normalization of [serial 1121] 


Theorem (51)                               [serial 1120] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1118]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 50:
Theorem (50) [serial 1121] used for:
  Law of And-Simplification:  P and true is P [serial 1120] 


Theorem (52)                               [serial 1118] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma
  and 1 = 1 >>
Why created:    normalization of [serial 1116]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 51:
Theorem (51) [serial 1120] used for:
  Equality Law (idistr):  a=a <-> true [serial 1118] 


Theorem (53)                               [serial 1116] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma
  and ( 1 ) = 1 >>
Why created:  applied wp for assignment [serial 1085]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 52:
Theorem (52) [serial 1118] used for:
    normalization of [serial 1116] 


Theorem (54)                               [serial 1085] 
P [88] << CMA = ma >>
S [89] i := 1
Q [90] << CMA = ma
  and i = 1 >>
Why created:    normalization of [serial 1072]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 53:
Theorem (53) [serial 1116] used for:
  applied wp for assignment [serial 1085] 


Theorem (55)                               [serial 1072] 
P [88] << ma = CMA >>
S [89] i := 1
Q [90] << i = 1
  and ma = CMA >>
Why created:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 54:
Theorem (54) [serial 1085] used for:
    normalization of [serial 1072] 


Theorem (56)                               [serial 1126] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (57)                               [serial 1134] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1132]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (58)                               [serial 1132] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[1] = ma.seg[1] >>
Why created:    normalization of [serial 1130]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 57:
Theorem (57) [serial 1134] used for:
  Equality Law (idistr):  a=a <-> true [serial 1132] 


Theorem (59)                               [serial 1130] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 58:
Theorem (58) [serial 1132] used for:
    normalization of [serial 1130] 


Theorem (60)                               [serial 1129] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[i] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Solved by:  Guided Substitution of Equals
and theorem 59:
Theorem (59) [serial 1130] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129] 


Theorem (61)                               [serial 1127] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA.seg[i] = ma.seg[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  Guided Substitution of Equals
and theorem 60:
Theorem (60) [serial 1129] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127] 


Theorem (62)                               [serial 1128] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (63)                               [serial 1125] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
Why created:  applied wp for assignment [serial 1088]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 56 61 62:
Theorem (56) [serial 1126] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (61) [serial 1127] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (62) [serial 1128] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 


Theorem (64)                               [serial 1088] 
P [90] << CMA = ma
  and i = 1 >>
S [91] iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
Why created:    normalization of [serial 1078]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 63:
Theorem (63) [serial 1125] used for:
  applied wp for assignment [serial 1088] 


Theorem (65)                               [serial 1078] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1076]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 64:
Theorem (64) [serial 1088] used for:
    normalization of [serial 1078] 


Theorem (66)                               [serial 1076] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 65:
Theorem (65) [serial 1078] used for:
  Law of And-Simplification:  P and true is P [serial 1076] 


Theorem (67)                               [serial 1126] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (68)                               [serial 1134] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1132]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (69)                               [serial 1132] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[1] = ma.seg[1] >>
Why created:    normalization of [serial 1130]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 68:
Theorem (68) [serial 1134] used for:
  Equality Law (idistr):  a=a <-> true [serial 1132] 


Theorem (70)                               [serial 1130] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 69:
Theorem (69) [serial 1132] used for:
    normalization of [serial 1130] 


Theorem (71)                               [serial 1129] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[i] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Solved by:  Guided Substitution of Equals
and theorem 70:
Theorem (70) [serial 1130] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129] 


Theorem (72)                               [serial 1127] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA.seg[i] = ma.seg[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  Guided Substitution of Equals
and theorem 71:
Theorem (71) [serial 1129] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127] 


Theorem (73)                               [serial 1128] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (74)                               [serial 1125] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
Why created:  applied wp for assignment [serial 1088]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 67 72 73:
Theorem (67) [serial 1126] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (72) [serial 1127] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (73) [serial 1128] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 


Theorem (75)                               [serial 1088] 
P [90] << CMA = ma
  and i = 1 >>
S [91] iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
Why created:    normalization of [serial 1078]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 74:
Theorem (74) [serial 1125] used for:
  applied wp for assignment [serial 1088] 


Theorem (76)                               [serial 1078] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1076]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 75:
Theorem (75) [serial 1088] used for:
    normalization of [serial 1078] 


Theorem (77)                               [serial 1076] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 76:
Theorem (76) [serial 1078] used for:
  Law of And-Simplification:  P and true is P [serial 1076] 


Theorem (78)                               [serial 1073] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 77 77:
Theorem (77) [serial 1076] used for:
   add user-defined axioms to postcondition 
Theorem (77) [serial 1076] used for:
   add user-defined axioms to postcondition 


Theorem (79)                               [serial 1150] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << CMA.seg[i] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (80)                               [serial 1148] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << CMA.seg[1] = iSeg >>
Why created:    normalization of [serial 1146]
Solved by:  Guided Substitution of Equals
and theorem 79:
Theorem (79) [serial 1150] used for:
  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148] 


Theorem (81)                               [serial 1146] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << iSeg = CMA.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 80:
Theorem (80) [serial 1148] used for:
    normalization of [serial 1146] 


Theorem (82)                               [serial 1144] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << iSeg = ma.seg[1] >>
Why created:    normalization of [serial 1142]
Solved by:  Guided Substitution of Equals
and theorem 81:
Theorem (81) [serial 1146] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144] 


Theorem (83)                               [serial 1142] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << ( ma.seg[1] = iSeg ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1141]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 82:
Theorem (82) [serial 1144] used for:
    normalization of [serial 1142] 


Theorem (84)                               [serial 1141] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1140]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 83:
Theorem (83) [serial 1142] used for:
  Law of And-Simplification:  P and true is P [serial 1141] 


Theorem (85)                               [serial 1140] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
Why created:  applied wp for assignment [serial 1139]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 84:
Theorem (84) [serial 1141] used for:
  Equality Law (idistr):  a=a <-> true [serial 1140] 


Theorem (86)                               [serial 1139] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 85:
Theorem (85) [serial 1140] used for:
  applied wp for assignment [serial 1139] 


Theorem (87)                               [serial 1137] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
Why created:    normalization of [serial 1135]
Solved by:  Guided Substitution of Equals
and theorem 86:
Theorem (86) [serial 1139] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137] 


Theorem (88)                               [serial 1135] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 87:
Theorem (87) [serial 1137] used for:
    normalization of [serial 1135] 


Theorem (89)                               [serial 1090] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
Why created:    normalization of [serial 1079]
Solved by:  Guided Substitution of Equals
and theorem 88:
Theorem (88) [serial 1135] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090] 


Theorem (90)                               [serial 1079] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1077]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 89:
Theorem (89) [serial 1090] used for:
    normalization of [serial 1079] 


Theorem (91)                               [serial 1077] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 90:
Theorem (90) [serial 1079] used for:
  Law of And-Simplification:  P and true is P [serial 1077] 


Theorem (92)                               [serial 1150] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << CMA.seg[i] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (93)                               [serial 1148] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << CMA.seg[1] = iSeg >>
Why created:    normalization of [serial 1146]
Solved by:  Guided Substitution of Equals
and theorem 92:
Theorem (92) [serial 1150] used for:
  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148] 


Theorem (94)                               [serial 1146] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << iSeg = CMA.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 93:
Theorem (93) [serial 1148] used for:
    normalization of [serial 1146] 


Theorem (95)                               [serial 1144] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << iSeg = ma.seg[1] >>
Why created:    normalization of [serial 1142]
Solved by:  Guided Substitution of Equals
and theorem 94:
Theorem (94) [serial 1146] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144] 


Theorem (96)                               [serial 1142] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << ( ma.seg[1] = iSeg ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1141]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 95:
Theorem (95) [serial 1144] used for:
    normalization of [serial 1142] 


Theorem (97)                               [serial 1141] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1140]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 96:
Theorem (96) [serial 1142] used for:
  Law of And-Simplification:  P and true is P [serial 1141] 


Theorem (98)                               [serial 1140] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
Why created:  applied wp for assignment [serial 1139]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 97:
Theorem (97) [serial 1141] used for:
  Equality Law (idistr):  a=a <-> true [serial 1140] 


Theorem (99)                               [serial 1139] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 98:
Theorem (98) [serial 1140] used for:
  applied wp for assignment [serial 1139] 


Theorem (100)                               [serial 1137] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
Why created:    normalization of [serial 1135]
Solved by:  Guided Substitution of Equals
and theorem 99:
Theorem (99) [serial 1139] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137] 


Theorem (101)                               [serial 1135] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 100:
Theorem (100) [serial 1137] used for:
    normalization of [serial 1135] 


Theorem (102)                               [serial 1090] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
Why created:    normalization of [serial 1079]
Solved by:  Guided Substitution of Equals
and theorem 101:
Theorem (101) [serial 1135] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090] 


Theorem (103)                               [serial 1079] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1077]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 102:
Theorem (102) [serial 1090] used for:
    normalization of [serial 1079] 


Theorem (104)                               [serial 1077] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 103:
Theorem (103) [serial 1079] used for:
  Law of And-Simplification:  P and true is P [serial 1077] 


Theorem (105)                               [serial 1074] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
Why created:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 104 104:
Theorem (104) [serial 1077] used for:
   add user-defined axioms to postcondition 
Theorem (104) [serial 1077] used for:
   add user-defined axioms to postcondition 


Theorem (106)                               [serial 1016] 
P [85] << m_a'fresh >>
S [86]   << AXIOM_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and AXIOM_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 30 42 48 55 78 105:
Theorem (30) [serial 1069] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1016] 
Theorem (42) [serial 1070] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1016] 
Theorem (48) [serial 1071] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016] 
Theorem (55) [serial 1072] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016] 
Theorem (78) [serial 1073] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016] 
Theorem (105) [serial 1074] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1016] 


Theorem (107)                               [serial 1166] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Law of And-Simplification:  P and true is P [serial 1165]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (108)                               [serial 1165] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 107:
Theorem (107) [serial 1166] used for:
  Law of And-Simplification:  P and true is P [serial 1165] 


Theorem (109)                               [serial 1166] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Law of And-Simplification:  P and true is P [serial 1165]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (110)                               [serial 1165] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 109:
Theorem (109) [serial 1166] used for:
  Law of And-Simplification:  P and true is P [serial 1165] 


Theorem (111)                               [serial 1152] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 110 110:
Theorem (110) [serial 1165] used for:
   add user-defined axioms to postcondition 
Theorem (110) [serial 1165] used for:
   add user-defined axioms to postcondition 


Theorem (112)                               [serial 1182] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << true >>
Why created:    normalization of [serial 1180]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (113)                               [serial 1180] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1179]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 112:
Theorem (112) [serial 1182] used for:
    normalization of [serial 1180] 


Theorem (114)                               [serial 1179] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1178]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 113:
Theorem (113) [serial 1180] used for:
  Law of And-Simplification:  P and P is P [serial 1179] 


Theorem (115)                               [serial 1178] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1177]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 114:
Theorem (114) [serial 1179] used for:
  Law of And-Simplification:  P and P is P [serial 1178] 


Theorem (116)                               [serial 1177] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1176]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 115:
Theorem (115) [serial 1178] used for:
  Law of And-Simplification:  P and P is P [serial 1177] 


Theorem (117)                               [serial 1176] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1175]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 116:
Theorem (116) [serial 1177] used for:
  Law of And-Simplification:  P and P is P [serial 1176] 


Theorem (118)                               [serial 1175] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1174]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 117:
Theorem (117) [serial 1176] used for:
  Law of And-Simplification:  P and P is P [serial 1175] 


Theorem (119)                               [serial 1174] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 118:
Theorem (118) [serial 1175] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1174] 


Theorem (120)                               [serial 1172] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1170]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 119:
Theorem (119) [serial 1174] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172] 


Theorem (121)                               [serial 1170] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 120:
Theorem (120) [serial 1172] used for:
    normalization of [serial 1170] 


Theorem (122)                               [serial 1168] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1154]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 121:
Theorem (121) [serial 1170] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168] 


Theorem (123)                               [serial 1154] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105] ->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 122:
Theorem (122) [serial 1168] used for:
    normalization of [serial 1154] 


Theorem (124)                               [serial 1212] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1208]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (125)                               [serial 1208] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107] ->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1191]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 124:
Theorem (124) [serial 1212] used for:
    normalization of [serial 1208] 


Theorem (126)                               [serial 1191] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]
Solved by:  Substitution of Assertion Labels
and theorem 125:
Theorem (125) [serial 1208] used for:
  Substituted assertions' predicates for labels  [serial 1191] 


Theorem (127)                               [serial 1197] 
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1192]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (128)                               [serial 1192] 
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 127:
Theorem (127) [serial 1197] used for:
  Associativity: (b.c).a = a.b.c [serial 1192] 


Theorem (129)                               [serial 1188] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1186]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 126 128:
Theorem (126) [serial 1191] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188] 
Theorem (128) [serial 1192] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188] 


Theorem (130)                               [serial 1221] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [107] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1216]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (131)                               [serial 1216] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [107] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1210]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 130:
Theorem (130) [serial 1221] used for:
  Associativity: (b.c).a = a.b.c [serial 1216] 


Theorem (132)                               [serial 1210] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107] ->
Q [107] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1205]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 131:
Theorem (131) [serial 1216] used for:
    normalization of [serial 1210] 


Theorem (133)                               [serial 1205] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [107] << EB()
   or not SB() >>
Why created:    normalization of [serial 1200]
Solved by:  Substitution of Assertion Labels
and theorem 132:
Theorem (132) [serial 1210] used for:
  Substituted assertions' predicates for labels  [serial 1205] 


Theorem (134)                               [serial 1200] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [107] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 133:
Theorem (133) [serial 1205] used for:
    normalization of [serial 1200] 


Theorem (135)                               [serial 1193] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [107] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 134:
Theorem (134) [serial 1200] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193] 


Theorem (136)                               [serial 1198] 
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1194]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (137)                               [serial 1194] 
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 136:
Theorem (136) [serial 1198] used for:
  Associativity: (b.c).a = a.b.c [serial 1194] 


Theorem (138)                               [serial 1189] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1186]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 135 137:
Theorem (135) [serial 1193] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189] 
Theorem (137) [serial 1194] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189] 


Theorem (139)                               [serial 1199] 
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1195]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (140)                               [serial 1195] 
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 139:
Theorem (139) [serial 1199] used for:
  Associativity: (b.c).a = a.b.c [serial 1195] 


Theorem (141)                               [serial 1220] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1214]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (142)                               [serial 1214] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1209]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 141:
Theorem (141) [serial 1220] used for:
  Associativity: (b.c).a = a.b.c [serial 1214] 


Theorem (143)                               [serial 1209] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107] ->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1203]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 142:
Theorem (142) [serial 1214] used for:
    normalization of [serial 1209] 


Theorem (144)                               [serial 1203] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1196]
Solved by:  Substitution of Assertion Labels
and theorem 143:
Theorem (143) [serial 1209] used for:
  Substituted assertions' predicates for labels  [serial 1203] 


Theorem (145)                               [serial 1196] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 144:
Theorem (144) [serial 1203] used for:
    normalization of [serial 1196] 


Theorem (146)                               [serial 1190] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1186]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 140 145:
Theorem (140) [serial 1195] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190] 
Theorem (145) [serial 1196] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190] 


Theorem (147)                               [serial 1186] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1184]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 129 138 146:
Theorem (129) [serial 1188] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1186] 
Theorem (138) [serial 1189] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1186] 
Theorem (146) [serial 1190] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1186] 


Theorem (148)                               [serial 1184] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1160]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 147:
Theorem (147) [serial 1186] used for:
    normalization of [serial 1184] 


Theorem (149)                               [serial 1160] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 148:
Theorem (148) [serial 1184] used for:
  Associativity: (b.c).a = a.b.c [serial 1160] 


Theorem (150)                               [serial 1155] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 149:
Theorem (149) [serial 1160] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1155] 


Theorem (151)                               [serial 1242] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1238]
Solved by:  Guided Substitution of Equals
  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (152)                               [serial 1238] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110] ->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1229]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 151:
Theorem (151) [serial 1242] used for:
    normalization of [serial 1238] 


Theorem (153)                               [serial 1229] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]
Solved by:  Substitution of Assertion Labels
and theorem 152:
Theorem (152) [serial 1238] used for:
  Substituted assertions' predicates for labels  [serial 1229] 


Theorem (154)                               [serial 1235] 
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1230]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (155)                               [serial 1230] 
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 154:
Theorem (154) [serial 1235] used for:
  Associativity: (b.c).a = a.b.c [serial 1230] 


Theorem (156)                               [serial 1226] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1224]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 153 155:
Theorem (153) [serial 1229] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226] 
Theorem (155) [serial 1230] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226] 


Theorem (157)                               [serial 1264] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1261]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (158)                               [serial 1261] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1258]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 157:
Theorem (157) [serial 1264] used for:
  Associativity: (b.c).a = a.b.c [serial 1261] 


Theorem (159)                               [serial 1258] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1256]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 158:
Theorem (158) [serial 1261] used for:
    normalization of [serial 1258] 


Theorem (160)                               [serial 1256] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1253]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 159:
Theorem (159) [serial 1258] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1256] 


Theorem (161)                               [serial 1253] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
Why created:  Guided Substitution of Equals DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 160:
Theorem (160) [serial 1256] used for:
    normalization of [serial 1253] 


Theorem (162)                               [serial 1244] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:    normalization of [serial 1239]
Solved by:  Guided Substitution of Equals
  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 161:
Theorem (161) [serial 1253] used for:
  Guided Substitution of Equals DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244] 


Theorem (163)                               [serial 1239] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110] ->
Q [110] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1231]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 162:
Theorem (162) [serial 1244] used for:
    normalization of [serial 1239] 


Theorem (164)                               [serial 1231] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] ->
Q [110] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]
Solved by:  Substitution of Assertion Labels
and theorem 163:
Theorem (163) [serial 1239] used for:
  Substituted assertions' predicates for labels  [serial 1231] 


Theorem (165)                               [serial 1236] 
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1232]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (166)                               [serial 1232] 
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 165:
Theorem (165) [serial 1236] used for:
  Associativity: (b.c).a = a.b.c [serial 1232] 


Theorem (167)                               [serial 1227] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1224]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 164 166:
Theorem (164) [serial 1231] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227] 
Theorem (166) [serial 1232] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227] 


Theorem (168)                               [serial 1237] 
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1233]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (169)                               [serial 1233] 
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 168:
Theorem (168) [serial 1237] used for:
  Associativity: (b.c).a = a.b.c [serial 1233] 


Theorem (170)                               [serial 1263] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1246]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (171)                               [serial 1246] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1240]
Solved by:  Guided Substitution of Equals
  Associativity: (b.c).a = a.b.c
and theorem 170:
Theorem (170) [serial 1263] used for:
  Associativity: (b.c).a = a.b.c [serial 1246] 


Theorem (172)                               [serial 1240] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110] ->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1234]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 171:
Theorem (171) [serial 1246] used for:
    normalization of [serial 1240] 


Theorem (173)                               [serial 1234] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
Solved by:  Substitution of Assertion Labels
and theorem 172:
Theorem (172) [serial 1240] used for:
  Substituted assertions' predicates for labels  [serial 1234] 


Theorem (174)                               [serial 1228] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1224]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 169 173:
Theorem (169) [serial 1233] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228] 
Theorem (173) [serial 1234] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228] 


Theorem (175)                               [serial 1224] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1222]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 156 167 174:
Theorem (156) [serial 1226] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1224] 
Theorem (167) [serial 1227] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1224] 
Theorem (174) [serial 1228] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1224] 


Theorem (176)                               [serial 1222] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1161]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 175:
Theorem (175) [serial 1224] used for:
    normalization of [serial 1222] 


Theorem (177)                               [serial 1161] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 176:
Theorem (176) [serial 1222] used for:
  Associativity: (b.c).a = a.b.c [serial 1161] 


Theorem (178)                               [serial 1156] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 177:
Theorem (177) [serial 1161] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1156] 


Theorem (179)                               [serial 1336] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (180)                               [serial 1337] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (181)                               [serial 1340] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1338]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (182)                               [serial 1338] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 181:
Theorem (181) [serial 1340] used for:
    normalization of [serial 1338] 


Theorem (183)                               [serial 1335] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1329]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 179 180 182:
Theorem (179) [serial 1336] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335] 
Theorem (180) [serial 1337] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335] 
Theorem (182) [serial 1338] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1335] 


Theorem (184)                               [serial 1329] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1325]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 183:
Theorem (183) [serial 1335] used for:
  Associativity: (b.c).a = a.b.c [serial 1329] 


Theorem (185)                               [serial 1325] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1317]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 184:
Theorem (184) [serial 1329] used for:
    normalization of [serial 1325] 


Theorem (186)                               [serial 1317] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1313]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 185:
Theorem (185) [serial 1325] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1317] 


Theorem (187)                               [serial 1313] 
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1305]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 186:
Theorem (186) [serial 1317] used for:
    normalization of [serial 1313] 


Theorem (188)                               [serial 1305] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1301]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 187:
Theorem (187) [serial 1313] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1305] 


Theorem (189)                               [serial 1301] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1284]
Solved by:  Guided Substitution of Equals
  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 188:
Theorem (188) [serial 1305] used for:
    normalization of [serial 1301] 


Theorem (190)                               [serial 1284] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << SB()
  and not EB() >>
Why created:    normalization of [serial 1274]
Solved by:  Substitution of Assertion Labels
and theorem 189:
Theorem (189) [serial 1301] used for:
  Substituted assertions' predicates for labels  [serial 1284] 


Theorem (191)                               [serial 1274] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114] ->
Q [12] << SB()
  and not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1268]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 190:
Theorem (190) [serial 1284] used for:
    normalization of [serial 1274] 


Theorem (192)                               [serial 1268] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1265]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 191:
Theorem (191) [serial 1274] used for:
  Associativity: (b.c).a = a.b.c [serial 1268] 


Theorem (193)                               [serial 1290] 
P [114] << iSeg.v_n <= v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1280]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (194)                               [serial 1280] 
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1275]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 193:
Theorem (193) [serial 1290] used for:
    normalization of [serial 1280] 


Theorem (195)                               [serial 1275] 
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1269]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 194:
Theorem (194) [serial 1280] used for:
  Associativity: (b.c).a = a.b.c [serial 1275] 


Theorem (196)                               [serial 1269] 
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1265]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 195:
Theorem (195) [serial 1275] used for:
  Associativity: (b.c).a = a.b.c [serial 1269] 


Theorem (197)                               [serial 1265] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1162]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 192 196:
Theorem (192) [serial 1268] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1265] 
Theorem (196) [serial 1269] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1265] 


Theorem (198)                               [serial 1331] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1326]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (199)                               [serial 1326] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1319]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 198:
Theorem (198) [serial 1331] used for:
    normalization of [serial 1326] 


Theorem (200)                               [serial 1319] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1314]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 199:
Theorem (199) [serial 1326] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1319] 


Theorem (201)                               [serial 1314] 
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1307]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 200:
Theorem (200) [serial 1319] used for:
    normalization of [serial 1314] 


Theorem (202)                               [serial 1307] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1302]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 201:
Theorem (201) [serial 1314] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1307] 


Theorem (203)                               [serial 1302] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1286]
Solved by:  Guided Substitution of Equals
  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 202:
Theorem (202) [serial 1307] used for:
    normalization of [serial 1302] 


Theorem (204)                               [serial 1286] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not EB() >>
Why created:    normalization of [serial 1276]
Solved by:  Substitution of Assertion Labels
and theorem 203:
Theorem (203) [serial 1302] used for:
  Substituted assertions' predicates for labels  [serial 1286] 


Theorem (205)                               [serial 1276] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114] ->
Q [114] << not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1270]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 204:
Theorem (204) [serial 1286] used for:
    normalization of [serial 1276] 


Theorem (206)                               [serial 1270] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] ->
Q [114] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1266]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 205:
Theorem (205) [serial 1276] used for:
  Associativity: (b.c).a = a.b.c [serial 1270] 


Theorem (207)                               [serial 1292] 
P [114] << iSeg.v_n <= v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1281]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (208)                               [serial 1281] 
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1277]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 207:
Theorem (207) [serial 1292] used for:
    normalization of [serial 1281] 


Theorem (209)                               [serial 1277] 
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1271]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 208:
Theorem (208) [serial 1281] used for:
  Associativity: (b.c).a = a.b.c [serial 1277] 


Theorem (210)                               [serial 1271] 
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1266]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 209:
Theorem (209) [serial 1277] used for:
  Associativity: (b.c).a = a.b.c [serial 1271] 


Theorem (211)                               [serial 1266] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1162]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 206 210:
Theorem (206) [serial 1270] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1266] 
Theorem (210) [serial 1271] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1266] 


Theorem (212)                               [serial 1294] 
P [114] << iSeg.v_n <= v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1282]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (213)                               [serial 1282] 
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1278]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 212:
Theorem (212) [serial 1294] used for:
    normalization of [serial 1282] 


Theorem (214)                               [serial 1278] 
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1272]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 213:
Theorem (213) [serial 1282] used for:
  Associativity: (b.c).a = a.b.c [serial 1278] 


Theorem (215)                               [serial 1272] 
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1267]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 214:
Theorem (214) [serial 1278] used for:
  Associativity: (b.c).a = a.b.c [serial 1272] 


Theorem (216)                               [serial 1334] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1321]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (217)                               [serial 1321] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1315]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 216:
Theorem (216) [serial 1334] used for:
  Associativity: (b.c).a = a.b.c [serial 1321] 


Theorem (218)                               [serial 1315] 
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 217:
Theorem (217) [serial 1321] used for:
    normalization of [serial 1315] 


Theorem (219)                               [serial 1309] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1303]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 218:
Theorem (218) [serial 1315] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309] 


Theorem (220)                               [serial 1303] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1288]
Solved by:  Guided Substitution of Equals
  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 219:
Theorem (219) [serial 1309] used for:
    normalization of [serial 1303] 


Theorem (221)                               [serial 1288] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1279]
Solved by:  Substitution of Assertion Labels
and theorem 220:
Theorem (220) [serial 1303] used for:
  Substituted assertions' predicates for labels  [serial 1288] 


Theorem (222)                               [serial 1279] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1273]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 221:
Theorem (221) [serial 1288] used for:
    normalization of [serial 1279] 


Theorem (223)                               [serial 1273] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1267]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 222:
Theorem (222) [serial 1279] used for:
  Associativity: (b.c).a = a.b.c [serial 1273] 


Theorem (224)                               [serial 1267] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1162]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 215 223:
Theorem (215) [serial 1272] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1267] 
Theorem (223) [serial 1273] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1267] 


Theorem (225)                               [serial 1162] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 197 211 224:
Theorem (197) [serial 1265] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1162] 
Theorem (211) [serial 1266] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1162] 
Theorem (224) [serial 1267] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1162] 


Theorem (226)                               [serial 1157] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 225:
Theorem (225) [serial 1162] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1157] 


Theorem (227)                               [serial 1413] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (228)                               [serial 1414] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (229)                               [serial 1421] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1415]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (230)                               [serial 1415] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 229:
Theorem (229) [serial 1421] used for:
    normalization of [serial 1415] 


Theorem (231)                               [serial 1412] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1406]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 227 228 230:
Theorem (227) [serial 1413] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412] 
Theorem (228) [serial 1414] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412] 
Theorem (230) [serial 1415] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1412] 


Theorem (232)                               [serial 1406] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1402]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 231:
Theorem (231) [serial 1412] used for:
  Associativity: (b.c).a = a.b.c [serial 1406] 


Theorem (233)                               [serial 1402] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1394]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 232:
Theorem (232) [serial 1406] used for:
    normalization of [serial 1402] 


Theorem (234)                               [serial 1394] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1390]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 233:
Theorem (233) [serial 1402] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1394] 


Theorem (235)                               [serial 1390] 
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1382]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 234:
Theorem (234) [serial 1394] used for:
    normalization of [serial 1390] 


Theorem (236)                               [serial 1382] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1378]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 235:
Theorem (235) [serial 1390] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1382] 


Theorem (237)                               [serial 1378] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1361]
Solved by:  Guided Substitution of Equals
  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 236:
Theorem (236) [serial 1382] used for:
    normalization of [serial 1378] 


Theorem (238)                               [serial 1361] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << SB()
  and not EB() >>
Why created:    normalization of [serial 1351]
Solved by:  Substitution of Assertion Labels
and theorem 237:
Theorem (237) [serial 1378] used for:
  Substituted assertions' predicates for labels  [serial 1361] 


Theorem (239)                               [serial 1351] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119] ->
Q [12] << SB()
  and not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1345]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 238:
Theorem (238) [serial 1361] used for:
    normalization of [serial 1351] 


Theorem (240)                               [serial 1345] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1342]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 239:
Theorem (239) [serial 1351] used for:
  Associativity: (b.c).a = a.b.c [serial 1345] 


Theorem (241)                               [serial 1367] 
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1357]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (242)                               [serial 1357] 
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1352]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 241:
Theorem (241) [serial 1367] used for:
    normalization of [serial 1357] 


Theorem (243)                               [serial 1352] 
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1346]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 242:
Theorem (242) [serial 1357] used for:
  Associativity: (b.c).a = a.b.c [serial 1352] 


Theorem (244)                               [serial 1346] 
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1342]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 243:
Theorem (243) [serial 1352] used for:
  Associativity: (b.c).a = a.b.c [serial 1346] 


Theorem (245)                               [serial 1342] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1163]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 240 244:
Theorem (240) [serial 1345] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1342] 
Theorem (244) [serial 1346] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1342] 


Theorem (246)                               [serial 1408] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1403]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (247)                               [serial 1403] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1396]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 246:
Theorem (246) [serial 1408] used for:
    normalization of [serial 1403] 


Theorem (248)                               [serial 1396] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1391]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 247:
Theorem (247) [serial 1403] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1396] 


Theorem (249)                               [serial 1391] 
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1384]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 248:
Theorem (248) [serial 1396] used for:
    normalization of [serial 1391] 


Theorem (250)                               [serial 1384] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1379]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 249:
Theorem (249) [serial 1391] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1384] 


Theorem (251)                               [serial 1379] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1363]
Solved by:  Guided Substitution of Equals
  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 250:
Theorem (250) [serial 1384] used for:
    normalization of [serial 1379] 


Theorem (252)                               [serial 1363] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not EB() >>
Why created:    normalization of [serial 1353]
Solved by:  Substitution of Assertion Labels
and theorem 251:
Theorem (251) [serial 1379] used for:
  Substituted assertions' predicates for labels  [serial 1363] 


Theorem (253)                               [serial 1353] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119] ->
Q [119] << not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1347]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 252:
Theorem (252) [serial 1363] used for:
    normalization of [serial 1353] 


Theorem (254)                               [serial 1347] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] ->
Q [119] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1343]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 253:
Theorem (253) [serial 1353] used for:
  Associativity: (b.c).a = a.b.c [serial 1347] 


Theorem (255)                               [serial 1369] 
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1358]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (256)                               [serial 1358] 
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1354]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 255:
Theorem (255) [serial 1369] used for:
    normalization of [serial 1358] 


Theorem (257)                               [serial 1354] 
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1348]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 256:
Theorem (256) [serial 1358] used for:
  Associativity: (b.c).a = a.b.c [serial 1354] 


Theorem (258)                               [serial 1348] 
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1343]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 257:
Theorem (257) [serial 1354] used for:
  Associativity: (b.c).a = a.b.c [serial 1348] 


Theorem (259)                               [serial 1343] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1163]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 254 258:
Theorem (254) [serial 1347] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1343] 
Theorem (258) [serial 1348] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1343] 


Theorem (260)                               [serial 1371] 
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1359]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (261)                               [serial 1359] 
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1355]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 260:
Theorem (260) [serial 1371] used for:
    normalization of [serial 1359] 


Theorem (262)                               [serial 1355] 
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1349]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 261:
Theorem (261) [serial 1359] used for:
  Associativity: (b.c).a = a.b.c [serial 1355] 


Theorem (263)                               [serial 1349] 
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1344]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 262:
Theorem (262) [serial 1355] used for:
  Associativity: (b.c).a = a.b.c [serial 1349] 


Theorem (264)                               [serial 1417] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1411]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (265)                               [serial 1411] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1398]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 264:
Theorem (264) [serial 1417] used for:
    normalization of [serial 1411] 


Theorem (266)                               [serial 1398] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1392]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 265:
Theorem (265) [serial 1411] used for:
  Associativity: (b.c).a = a.b.c [serial 1398] 


Theorem (267)                               [serial 1392] 
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1386]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 266:
Theorem (266) [serial 1398] used for:
    normalization of [serial 1392] 


Theorem (268)                               [serial 1386] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1380]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 267:
Theorem (267) [serial 1392] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1386] 


Theorem (269)                               [serial 1380] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1365]
Solved by:  Guided Substitution of Equals
  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 268:
Theorem (268) [serial 1386] used for:
    normalization of [serial 1380] 


Theorem (270)                               [serial 1365] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1356]
Solved by:  Substitution of Assertion Labels
and theorem 269:
Theorem (269) [serial 1380] used for:
  Substituted assertions' predicates for labels  [serial 1365] 


Theorem (271)                               [serial 1356] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1350]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 270:
Theorem (270) [serial 1365] used for:
    normalization of [serial 1356] 


Theorem (272)                               [serial 1350] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1344]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 271:
Theorem (271) [serial 1356] used for:
  Associativity: (b.c).a = a.b.c [serial 1350] 


Theorem (273)                               [serial 1344] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1163]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 263 272:
Theorem (263) [serial 1349] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1344] 
Theorem (272) [serial 1350] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1344] 


Theorem (274)                               [serial 1163] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 245 259 273:
Theorem (245) [serial 1342] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1163] 
Theorem (259) [serial 1343] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1163] 
Theorem (273) [serial 1344] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1163] 


Theorem (275)                               [serial 1158] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B3>> S3 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 274:
Theorem (274) [serial 1163] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1158] 


Theorem (276)                               [serial 1471] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1467]
Solved by:  Guided Substitution of Equals
  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (277)                               [serial 1467] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1463]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 276:
Theorem (276) [serial 1471] used for:
    normalization of [serial 1467] 


Theorem (278)                               [serial 1463] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1459]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 277:
Theorem (277) [serial 1467] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1463] 


Theorem (279)                               [serial 1459] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1457]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 278:
Theorem (278) [serial 1463] used for:
    normalization of [serial 1459] 


Theorem (280)                               [serial 1457] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1454]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 279:
Theorem (279) [serial 1459] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1457] 


Theorem (281)                               [serial 1454] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1450]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 280:
Theorem (280) [serial 1457] used for:
  Associativity: (b.c).a = a.b.c [serial 1454] 


Theorem (282)                               [serial 1450] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1447]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 281:
Theorem (281) [serial 1454] used for:
    normalization of [serial 1450] 


Theorem (283)                               [serial 1447] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << EB()
   or not SB() >>
Why created:    normalization of [serial 1444]
Solved by:  Substitution of Assertion Labels
and theorem 282:
Theorem (282) [serial 1450] used for:
  Substituted assertions' predicates for labels  [serial 1447] 


Theorem (284)                               [serial 1444] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1436]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 283:
Theorem (283) [serial 1447] used for:
    normalization of [serial 1444] 


Theorem (285)                               [serial 1436] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1430]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 284:
Theorem (284) [serial 1444] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1436] 


Theorem (286)                               [serial 1441] 
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1437]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (287)                               [serial 1437] 
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1430]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 286:
Theorem (286) [serial 1441] used for:
  Associativity: (b.c).a = a.b.c [serial 1437] 


Theorem (288)                               [serial 1430] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1427]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 285 287:
Theorem (285) [serial 1436] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1430] 
Theorem (287) [serial 1437] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1430] 


Theorem (289)                               [serial 1427] 
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124] sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1425]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 288:
Theorem (288) [serial 1430] used for:
  Associativity: (b.c).a = a.b.c [serial 1427] 


Theorem (290)                               [serial 1477] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (291)                               [serial 1478] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (292)                               [serial 1476] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124] ->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Guided Substitution of Equals Transitivity: x<y and y<z -> x<z  [serial 1469]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 290 291:
Theorem (290) [serial 1477] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476] 
Theorem (291) [serial 1478] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1476] 


Theorem (293)                               [serial 1469] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1466]
Solved by:  Guided Substitution of Equals
  Transitivity: x<y and y<z -> x<z
and theorem 292:
Theorem (292) [serial 1476] used for:
  Guided Substitution of Equals Transitivity: x<y and y<z -> x<z  [serial 1469] 


Theorem (294)                               [serial 1466] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1461]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 293:
Theorem (293) [serial 1469] used for:
    normalization of [serial 1466] 


Theorem (295)                               [serial 1461] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1458]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 294:
Theorem (294) [serial 1466] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1461] 


Theorem (296)                               [serial 1458] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1452]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 295:
Theorem (295) [serial 1461] used for:
    normalization of [serial 1458] 


Theorem (297)                               [serial 1452] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1449]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 296:
Theorem (296) [serial 1458] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1452] 


Theorem (298)                               [serial 1449] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1438]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 297:
Theorem (297) [serial 1452] used for:
    normalization of [serial 1449] 


Theorem (299)                               [serial 1438] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1431]
Solved by:  Substitution of Assertion Labels
and theorem 298:
Theorem (298) [serial 1449] used for:
  Substituted assertions' predicates for labels  [serial 1438] 


Theorem (300)                               [serial 1442] 
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1439]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (301)                               [serial 1439] 
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1431]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 300:
Theorem (300) [serial 1442] used for:
  Associativity: (b.c).a = a.b.c [serial 1439] 


Theorem (302)                               [serial 1431] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1428]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 299 301:
Theorem (299) [serial 1438] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1431] 
Theorem (301) [serial 1439] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1431] 


Theorem (303)                               [serial 1428] 
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124] eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1425]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 302:
Theorem (302) [serial 1431] used for:
  Associativity: (b.c).a = a.b.c [serial 1428] 


Theorem (304)                               [serial 1443] 
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1440]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (305)                               [serial 1440] 
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1432]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 304:
Theorem (304) [serial 1443] used for:
  Associativity: (b.c).a = a.b.c [serial 1440] 


Theorem (306)                               [serial 1432] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1429]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorem 305:
Theorem (305) [serial 1440] used for:
  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1432] 


Theorem (307)                               [serial 1429] 
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124] ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1425]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 306:
Theorem (306) [serial 1432] used for:
  Associativity: (b.c).a = a.b.c [serial 1429] 


Theorem (308)                               [serial 1425] 
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1164]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 289 303 307:
Theorem (289) [serial 1427] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1425] 
Theorem (303) [serial 1428] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1425] 
Theorem (307) [serial 1429] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1425] 


Theorem (309)                               [serial 1164] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 308:
Theorem (308) [serial 1425] used for:
    normalization of [serial 1164] 


Theorem (310)                               [serial 1159] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]   {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B4>> S4 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 309:
Theorem (309) [serial 1164] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1159] 


Theorem (311)                               [serial 1153] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]   if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 123 150 178 226 275 310:
Theorem (123) [serial 1154] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153] 
Theorem (150) [serial 1155] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1153] 
Theorem (178) [serial 1156] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1153] 
Theorem (226) [serial 1157] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1153] 
Theorem (275) [serial 1158] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1153] 
Theorem (310) [serial 1159] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1153] 


Theorem (312)                               [serial 1151] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1017]
Solved by:  Introduction of Existential Quantification
and theorems 111 311:
Theorem (111) [serial 1152] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151] 
Theorem (311) [serial 1153] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151] 


Theorem (313)                               [serial 1017] 
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A};
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 312:
Theorem (312) [serial 1151] used for:
  Associativity: (b.c).a = a.b.c [serial 1017] 


Theorem (314)                               [serial 1480] 
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments
  and p < iSeg.e >>
S [128] ->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1018]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (315)                               [serial 1018] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{};
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 314:
Theorem (314) [serial 1480] used for:
    normalization of [serial 1018] 


Theorem (316)                               [serial 1487] 
P [59] << iSeg.e <= p
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [134] ->
Q [135] << CMA = ma
  and CMA.seg[1 + i] = nSeg >>
Why created:    normalization of [serial 1484]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (317)                               [serial 1484] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134] ->
Q [135] << nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1482]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 316:
Theorem (316) [serial 1487] used for:
    normalization of [serial 1484] 


Theorem (318)                               [serial 1482] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134] iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 317:
Theorem (317) [serial 1484] used for:
  applied wp for assignment [serial 1482] 


Theorem (319)                               [serial 1489] 
P [135] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
S [136] ->
Q [61] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
Why created:    normalization of [serial 1485]
Solved by:  Identity (id):  P->P is tautology


Theorem (320)                               [serial 1485] 
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136] ->
Q [61] << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1483]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 319:
Theorem (319) [serial 1489] used for:
    normalization of [serial 1485] 


Theorem (321)                               [serial 1483] 
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136] i := i + 1
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1019]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 320:
Theorem (320) [serial 1485] used for:
  applied wp for assignment [serial 1483] 


Theorem (322)                               [serial 1019] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]   iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1]
    and ma = CMA >>
  i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 318 321:
Theorem (318) [serial 1482] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019] 
Theorem (321) [serial 1483] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1019] 


Theorem (323)                               [serial 1496] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (324)                               [serial 1497] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (325)                               [serial 1502] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1500]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (326)                               [serial 1500] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1498]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 325:
Theorem (325) [serial 1502] used for:
  Equality Law (idistr):  a=a <-> true [serial 1500] 


Theorem (327)                               [serial 1498] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Solved by:  Guided Substitution of Equals
and theorem 326:
Theorem (326) [serial 1500] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1498] 


Theorem (328)                               [serial 1501] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1499]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (329)                               [serial 1499] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << i < CMA.num_segments >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494]
Solved by:  Guided Substitution of Equals
and theorem 328:
Theorem (328) [serial 1501] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1499] 


Theorem (330)                               [serial 1494] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = ma.seg[1 + i]
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1492]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 323 324 327 329:
Theorem (323) [serial 1496] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494] 
Theorem (324) [serial 1497] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494] 
Theorem (327) [serial 1498] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494] 
Theorem (329) [serial 1499] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1494] 


Theorem (331)                               [serial 1492] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1020]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 330:
Theorem (330) [serial 1494] used for:
    normalization of [serial 1492] 


Theorem (332)                               [serial 1020] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141] nSeg := ma.seg[i + 1]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 331:
Theorem (331) [serial 1492] used for:
  applied wp for assignment [serial 1020] 


Theorem (333)                               [serial 1509] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [146] << true >>
Why created:    normalization of [serial 1505]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (334)                               [serial 1505] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146] ->
Q [146] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1503]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 333:
Theorem (333) [serial 1509] used for:
    normalization of [serial 1505] 


Theorem (335)                               [serial 1527] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << CMA = ma >>
Why created:    normalization of [serial 1522]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (336)                               [serial 1522] 
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146] ->
Q [147] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 335:
Theorem (335) [serial 1527] used for:
    normalization of [serial 1522] 


Theorem (337)                               [serial 1538] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << i = ma.num_segments >>
Why created:    normalization of [serial 1535]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (338)                               [serial 1535] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << ma.num_segments = i >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1529]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 337:
Theorem (337) [serial 1538] used for:
    normalization of [serial 1535] 


Theorem (339)                               [serial 1529] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << CMA.num_segments = i >>
Why created:    normalization of [serial 1523]
Solved by:  Guided Substitution of Equals
and theorem 338:
Theorem (338) [serial 1535] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1529] 


Theorem (340)                               [serial 1523] 
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146] ->
Q [147] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 339:
Theorem (339) [serial 1529] used for:
    normalization of [serial 1523] 


Theorem (341)                               [serial 1531] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1524]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (342)                               [serial 1524] 
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146] ->
Q [147] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 341:
Theorem (341) [serial 1531] used for:
    normalization of [serial 1524] 


Theorem (343)                               [serial 1517] 
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146] ->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:  Law of And-Simplification:  P and true is P [serial 1511]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 336 340 342:
Theorem (336) [serial 1522] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517] 
Theorem (340) [serial 1523] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517] 
Theorem (342) [serial 1524] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1517] 


Theorem (344)                               [serial 1511] 
P [146] << true
  and ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) >>
S [146] ->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1506]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 343:
Theorem (343) [serial 1517] used for:
  Law of And-Simplification:  P and true is P [serial 1511] 


Theorem (345)                               [serial 1506] 
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146] ->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1503]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 344:
Theorem (344) [serial 1511] used for:
    normalization of [serial 1506] 


Theorem (346)                               [serial 1503] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146] r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1021]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 334 345:
Theorem (334) [serial 1505] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1503] 
Theorem (345) [serial 1506] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1503] 


Theorem (347)                               [serial 1518] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (348)                               [serial 1519] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (349)                               [serial 1520] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (350)                               [serial 1542] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1541]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (351)                               [serial 1541] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1540]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 350:
Theorem (350) [serial 1542] used for:
  Equality Law (idistr):  a=a <-> true [serial 1541] 


Theorem (352)                               [serial 1540] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1521]
Solved by:  Guided Substitution of Equals
and theorem 351:
Theorem (351) [serial 1541] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1540] 


Theorem (353)                               [serial 1521] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513]
Solved by:  Guided Substitution of Equals
  Substitution of Assertion Labels
and theorem 352:
Theorem (352) [serial 1540] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1521] 


Theorem (354)                               [serial 1513] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
Why created:    normalization of [serial 1507]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 347 348 349 353:
Theorem (347) [serial 1518] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513] 
Theorem (348) [serial 1519] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513] 
Theorem (349) [serial 1520] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513] 
Theorem (353) [serial 1521] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1513] 


Theorem (355)                               [serial 1507] 
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149] ->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1504]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 354:
Theorem (354) [serial 1513] used for:
    normalization of [serial 1507] 


Theorem (356)                               [serial 1504] 
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149] nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1021]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 355:
Theorem (355) [serial 1507] used for:
  applied wp for assignment [serial 1504] 


Theorem (357)                               [serial 1021] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]   r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 346 356:
Theorem (346) [serial 1503] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1021] 
Theorem (356) [serial 1504] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1021] 


Theorem (358)                               [serial 1022] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155] ->
Q [72] << true >>
Why created:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (359)                               [serial 1584] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1583]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (360)                               [serial 1583] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 359:
Theorem (359) [serial 1584] used for:
  Law of And-Simplification:  P and true is P [serial 1583] 


Theorem (361)                               [serial 1584] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1583]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (362)                               [serial 1583] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 361:
Theorem (361) [serial 1584] used for:
  Law of And-Simplification:  P and true is P [serial 1583] 


Theorem (363)                               [serial 1577] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1557]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 362 362:
Theorem (362) [serial 1583] used for:
   add user-defined axioms to postcondition 
Theorem (362) [serial 1583] used for:
   add user-defined axioms to postcondition 


Theorem (364)                               [serial 1557] 
P [159] << p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:    normalization of [serial 1543]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 363:
Theorem (363) [serial 1577] used for:
  Associativity: (b.c).a = a.b.c [serial 1557] 


Theorem (365)                               [serial 1543] 
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 364:
Theorem (364) [serial 1557] used for:
    normalization of [serial 1543] 


Theorem (366)                               [serial 1597] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << true >>
Why created:    normalization of [serial 1595]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (367)                               [serial 1595] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1594]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 366:
Theorem (366) [serial 1597] used for:
    normalization of [serial 1595] 


Theorem (368)                               [serial 1594] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1593]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 367:
Theorem (367) [serial 1595] used for:
  Law of And-Simplification:  P and P is P [serial 1594] 


Theorem (369)                               [serial 1593] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1592]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 368:
Theorem (368) [serial 1594] used for:
  Law of And-Simplification:  P and P is P [serial 1593] 


Theorem (370)                               [serial 1592] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1591]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 369:
Theorem (369) [serial 1593] used for:
  Law of And-Simplification:  P and P is P [serial 1592] 


Theorem (371)                               [serial 1591] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1590]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 370:
Theorem (370) [serial 1592] used for:
  Law of And-Simplification:  P and P is P [serial 1591] 


Theorem (372)                               [serial 1590] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1589]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 371:
Theorem (371) [serial 1591] used for:
  Law of And-Simplification:  P and P is P [serial 1590] 


Theorem (373)                               [serial 1589] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1587]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 372:
Theorem (372) [serial 1590] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1589] 


Theorem (374)                               [serial 1587] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1585]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 373:
Theorem (373) [serial 1589] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1587] 


Theorem (375)                               [serial 1585] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1559]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 374:
Theorem (374) [serial 1587] used for:
    normalization of [serial 1585] 


Theorem (376)                               [serial 1559] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1545]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 375:
Theorem (375) [serial 1585] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1559] 


Theorem (377)                               [serial 1545] 
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1544]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 376:
Theorem (376) [serial 1559] used for:
    normalization of [serial 1545] 


Theorem (378)                               [serial 1615] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1611]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (379)                               [serial 1611] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165] ->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1602]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 378:
Theorem (378) [serial 1615] used for:
    normalization of [serial 1611] 


Theorem (380)                               [serial 1602] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1599]
Solved by:  Substitution of Assertion Labels
and theorem 379:
Theorem (379) [serial 1611] used for:
  Substituted assertions' predicates for labels  [serial 1602] 


Theorem (381)                               [serial 1608] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1603]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (382)                               [serial 1603] 
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1599]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 381:
Theorem (381) [serial 1608] used for:
  Associativity: (b.c).a = a.b.c [serial 1603] 


Theorem (383)                               [serial 1599] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1578]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 380 382:
Theorem (380) [serial 1602] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1599] 
Theorem (382) [serial 1603] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1599] 


Theorem (384)                               [serial 1634] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1631]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (385)                               [serial 1631] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1628]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 384:
Theorem (384) [serial 1634] used for:
  Associativity: (b.c).a = a.b.c [serial 1631] 


Theorem (386)                               [serial 1628] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1626]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 385:
Theorem (385) [serial 1631] used for:
    normalization of [serial 1628] 


Theorem (387)                               [serial 1626] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1623]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 386:
Theorem (386) [serial 1628] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1626] 


Theorem (388)                               [serial 1623] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1617]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 387:
Theorem (387) [serial 1626] used for:
    normalization of [serial 1623] 


Theorem (389)                               [serial 1617] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:    normalization of [serial 1612]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 388:
Theorem (388) [serial 1623] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1617] 


Theorem (390)                               [serial 1612] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165] ->
Q [165] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1604]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 389:
Theorem (389) [serial 1617] used for:
    normalization of [serial 1612] 


Theorem (391)                               [serial 1604] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] ->
Q [165] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1600]
Solved by:  Substitution of Assertion Labels
and theorem 390:
Theorem (390) [serial 1612] used for:
  Substituted assertions' predicates for labels  [serial 1604] 


Theorem (392)                               [serial 1609] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1605]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (393)                               [serial 1605] 
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1600]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 392:
Theorem (392) [serial 1609] used for:
  Associativity: (b.c).a = a.b.c [serial 1605] 


Theorem (394)                               [serial 1600] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1578]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 391 393:
Theorem (391) [serial 1604] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1600] 
Theorem (393) [serial 1605] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1600] 


Theorem (395)                               [serial 1610] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = ( 0 mpss ) )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1606]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (396)                               [serial 1606] 
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = ( 0 mpss ) )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1601]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 395:
Theorem (395) [serial 1610] used for:
  Associativity: (b.c).a = a.b.c [serial 1606] 


Theorem (397)                               [serial 1633] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1619]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (398)                               [serial 1619] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1613]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 397:
Theorem (397) [serial 1633] used for:
  Associativity: (b.c).a = a.b.c [serial 1619] 


Theorem (399)                               [serial 1613] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165] ->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1607]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 398:
Theorem (398) [serial 1619] used for:
    normalization of [serial 1613] 


Theorem (400)                               [serial 1607] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1601]
Solved by:  Substitution of Assertion Labels
and theorem 399:
Theorem (399) [serial 1613] used for:
  Substituted assertions' predicates for labels  [serial 1607] 


Theorem (401)                               [serial 1601] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1578]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 396 400:
Theorem (396) [serial 1606] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1601] 
Theorem (400) [serial 1607] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1601] 


Theorem (402)                               [serial 1578] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1561]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 383 394 401:
Theorem (383) [serial 1599] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1578] 
Theorem (394) [serial 1600] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1578] 
Theorem (401) [serial 1601] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1578] 


Theorem (403)                               [serial 1561] 
P [163] << iSeg.v_e <= v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1551]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 402:
Theorem (402) [serial 1578] used for:
  Associativity: (b.c).a = a.b.c [serial 1561] 


Theorem (404)                               [serial 1551] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1546]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 403:
Theorem (403) [serial 1561] used for:
    normalization of [serial 1551] 


Theorem (405)                               [serial 1546] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1544]
Solved by:  Introduction of Existential Quantification
and theorem 404:
Theorem (404) [serial 1551] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1546] 


Theorem (406)                               [serial 1675] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1671]
Solved by:  Guided Substitution of Equals
  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (407)                               [serial 1671] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168] ->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1645]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 406:
Theorem (406) [serial 1675] used for:
    normalization of [serial 1671] 


Theorem (408)                               [serial 1645] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [14] << EB() >>
Why created:    normalization of [serial 1638]
Solved by:  Substitution of Assertion Labels
and theorem 407:
Theorem (407) [serial 1671] used for:
  Substituted assertions' predicates for labels  [serial 1645] 


Theorem (409)                               [serial 1638] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1635]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 408:
Theorem (408) [serial 1645] used for:
    normalization of [serial 1638] 


Theorem (410)                               [serial 1662] 
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and EB()@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1647]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (411)                               [serial 1647] 
P [168] << EB()@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1639]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 410:
Theorem (410) [serial 1662] used for:
  Associativity: (b.c).a = a.b.c [serial 1647] 


Theorem (412)                               [serial 1639] 
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1635]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 411:
Theorem (411) [serial 1647] used for:
    normalization of [serial 1639] 


Theorem (413)                               [serial 1635] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1579]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 409 412:
Theorem (409) [serial 1638] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1635] 
Theorem (412) [serial 1639] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1635] 


Theorem (414)                               [serial 1684] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1679]
Solved by:  Guided Substitution of Equals
  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (415)                               [serial 1679] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [168] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1673]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 414:
Theorem (414) [serial 1684] used for:
  Associativity: (b.c).a = a.b.c [serial 1679] 


Theorem (416)                               [serial 1673] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168] ->
Q [168] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1669]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 415:
Theorem (415) [serial 1679] used for:
    normalization of [serial 1673] 


Theorem (417)                               [serial 1669] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [168] << EB()
   or not SB() >>
Why created:    normalization of [serial 1665]
Solved by:  Substitution of Assertion Labels
and theorem 416:
Theorem (416) [serial 1673] used for:
  Substituted assertions' predicates for labels  [serial 1669] 


Theorem (418)                               [serial 1665] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [168] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1649]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 417:
Theorem (417) [serial 1669] used for:
    normalization of [serial 1665] 


Theorem (419)                               [serial 1649] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:    normalization of [serial 1640]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 418:
Theorem (418) [serial 1665] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1649] 


Theorem (420)                               [serial 1640] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] ->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1636]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 419:
Theorem (419) [serial 1649] used for:
    normalization of [serial 1640] 


Theorem (421)                               [serial 1663] 
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1651]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (422)                               [serial 1651] 
P [168] << ( not ( SB()
  and not EB() ) )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1641]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 421:
Theorem (421) [serial 1663] used for:
  Associativity: (b.c).a = a.b.c [serial 1651] 


Theorem (423)                               [serial 1641] 
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1636]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 422:
Theorem (422) [serial 1651] used for:
    normalization of [serial 1641] 


Theorem (424)                               [serial 1636] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1579]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 420 423:
Theorem (420) [serial 1640] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1636] 
Theorem (423) [serial 1641] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1636] 


Theorem (425)                               [serial 1664] 
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = 0 mpss )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1653]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (426)                               [serial 1653] 
P [168] << ( ca = 0 mpss )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1642]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 425:
Theorem (425) [serial 1664] used for:
  Associativity: (b.c).a = a.b.c [serial 1653] 


Theorem (427)                               [serial 1642] 
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = ( 0 mpss ) )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1637]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 426:
Theorem (426) [serial 1653] used for:
    normalization of [serial 1642] 


Theorem (428)                               [serial 1687] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [33] << iSeg.v_e <= v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1683]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (429)                               [serial 1683] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1677]
Solved by:  Guided Substitution of Equals
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 428:
Theorem (428) [serial 1687] used for:
    normalization of [serial 1683] 


Theorem (430)                               [serial 1677] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1672]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 429:
Theorem (429) [serial 1683] used for:
  Associativity: (b.c).a = a.b.c [serial 1677] 


Theorem (431)                               [serial 1672] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168] ->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1655]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 430:
Theorem (430) [serial 1677] used for:
    normalization of [serial 1672] 


Theorem (432)                               [serial 1655] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1643]
Solved by:  Substitution of Assertion Labels
and theorem 431:
Theorem (431) [serial 1672] used for:
  Substituted assertions' predicates for labels  [serial 1655] 


Theorem (433)                               [serial 1643] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1637]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 432:
Theorem (432) [serial 1655] used for:
    normalization of [serial 1643] 


Theorem (434)                               [serial 1637] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1579]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 427 433:
Theorem (427) [serial 1642] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1637] 
Theorem (433) [serial 1643] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1637] 


Theorem (435)                               [serial 1579] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1563]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 413 424 434:
Theorem (413) [serial 1635] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1579] 
Theorem (424) [serial 1636] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1579] 
Theorem (434) [serial 1637] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1579] 


Theorem (436)                               [serial 1563] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1552]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 435:
Theorem (435) [serial 1579] used for:
  Associativity: (b.c).a = a.b.c [serial 1563] 


Theorem (437)                               [serial 1552] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1547]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 436:
Theorem (436) [serial 1563] used for:
    normalization of [serial 1552] 


Theorem (438)                               [serial 1547] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1544]
Solved by:  Introduction of Existential Quantification
and theorem 437:
Theorem (437) [serial 1552] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1547] 


Theorem (439)                               [serial 1740] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (440)                               [serial 1741] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (441)                               [serial 1744] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1742]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (442)                               [serial 1742] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 441:
Theorem (441) [serial 1744] used for:
    normalization of [serial 1742] 


Theorem (443)                               [serial 1739] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1730]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 439 440 442:
Theorem (439) [serial 1740] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739] 
Theorem (440) [serial 1741] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739] 
Theorem (442) [serial 1742] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1739] 


Theorem (444)                               [serial 1730] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1726]
Solved by:  Guided Substitution of Equals
  Associativity: (b.c).a = a.b.c
and theorem 443:
Theorem (443) [serial 1739] used for:
  Associativity: (b.c).a = a.b.c [serial 1730] 


Theorem (445)                               [serial 1726] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1718]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 444:
Theorem (444) [serial 1730] used for:
    normalization of [serial 1726] 


Theorem (446)                               [serial 1718] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1714]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 445:
Theorem (445) [serial 1726] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1718] 


Theorem (447)                               [serial 1714] 
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1706]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 446:
Theorem (446) [serial 1718] used for:
    normalization of [serial 1714] 


Theorem (448)                               [serial 1706] 
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1702]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 447:
Theorem (447) [serial 1714] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1706] 


Theorem (449)                               [serial 1702] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172] ->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1693]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 448:
Theorem (448) [serial 1706] used for:
    normalization of [serial 1702] 


Theorem (450)                               [serial 1693] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1690]
Solved by:  Substitution of Assertion Labels
and theorem 449:
Theorem (449) [serial 1702] used for:
  Substituted assertions' predicates for labels  [serial 1693] 


Theorem (451)                               [serial 1699] 
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1694]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (452)                               [serial 1694] 
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1690]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 451:
Theorem (451) [serial 1699] used for:
  Associativity: (b.c).a = a.b.c [serial 1694] 


Theorem (453)                               [serial 1690] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1580]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 450 452:
Theorem (450) [serial 1693] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1690] 
Theorem (452) [serial 1694] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1690] 


Theorem (454)                               [serial 1732] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1727]
Solved by:  Guided Substitution of Equals
  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (455)                               [serial 1727] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1720]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 454:
Theorem (454) [serial 1732] used for:
    normalization of [serial 1727] 


Theorem (456)                               [serial 1720] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1715]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 455:
Theorem (455) [serial 1727] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1720] 


Theorem (457)                               [serial 1715] 
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1708]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 456:
Theorem (456) [serial 1720] used for:
    normalization of [serial 1715] 


Theorem (458)                               [serial 1708] 
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1703]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 457:
Theorem (457) [serial 1715] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1708] 


Theorem (459)                               [serial 1703] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172] ->
Q [172] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1695]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 458:
Theorem (458) [serial 1708] used for:
    normalization of [serial 1703] 


Theorem (460)                               [serial 1695] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] ->
Q [172] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1691]
Solved by:  Substitution of Assertion Labels
and theorem 459:
Theorem (459) [serial 1703] used for:
  Substituted assertions' predicates for labels  [serial 1695] 


Theorem (461)                               [serial 1700] 
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1696]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (462)                               [serial 1696] 
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1691]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 461:
Theorem (461) [serial 1700] used for:
  Associativity: (b.c).a = a.b.c [serial 1696] 


Theorem (463)                               [serial 1691] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1580]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 460 462:
Theorem (460) [serial 1695] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1691] 
Theorem (462) [serial 1696] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1691] 


Theorem (464)                               [serial 1701] 
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1697]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (465)                               [serial 1697] 
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1692]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 464:
Theorem (464) [serial 1701] used for:
  Associativity: (b.c).a = a.b.c [serial 1697] 


Theorem (466)                               [serial 1738] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1722]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (467)                               [serial 1722] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1716]
Solved by:  Guided Substitution of Equals
  Associativity: (b.c).a = a.b.c
and theorem 466:
Theorem (466) [serial 1738] used for:
  Associativity: (b.c).a = a.b.c [serial 1722] 


Theorem (468)                               [serial 1716] 
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1710]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 467:
Theorem (467) [serial 1722] used for:
    normalization of [serial 1716] 


Theorem (469)                               [serial 1710] 
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1704]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 468:
Theorem (468) [serial 1716] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1710] 


Theorem (470)                               [serial 1704] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172] ->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1698]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 469:
Theorem (469) [serial 1710] used for:
    normalization of [serial 1704] 


Theorem (471)                               [serial 1698] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1692]
Solved by:  Substitution of Assertion Labels
and theorem 470:
Theorem (470) [serial 1704] used for:
  Substituted assertions' predicates for labels  [serial 1698] 


Theorem (472)                               [serial 1692] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1580]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 465 471:
Theorem (465) [serial 1697] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1692] 
Theorem (471) [serial 1698] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1692] 


Theorem (473)                               [serial 1580] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1565]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 453 463 472:
Theorem (453) [serial 1690] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1580] 
Theorem (463) [serial 1691] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1580] 
Theorem (472) [serial 1692] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1580] 


Theorem (474)                               [serial 1565] 
P [163] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1553]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 473:
Theorem (473) [serial 1580] used for:
  Associativity: (b.c).a = a.b.c [serial 1565] 


Theorem (475)                               [serial 1553] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1548]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 474:
Theorem (474) [serial 1565] used for:
    normalization of [serial 1553] 


Theorem (476)                               [serial 1548] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1544]
Solved by:  Introduction of Existential Quantification
and theorem 475:
Theorem (475) [serial 1553] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1548] 


Theorem (477)                               [serial 1796] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (478)                               [serial 1797] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (479)                               [serial 1800] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1798]
Solved by:  Guided Substitution of Equals
  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (480)                               [serial 1798] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 479:
Theorem (479) [serial 1800] used for:
    normalization of [serial 1798] 


Theorem (481)                               [serial 1795] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1786]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 477 478 480:
Theorem (477) [serial 1796] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795] 
Theorem (478) [serial 1797] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795] 
Theorem (480) [serial 1798] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1795] 


Theorem (482)                               [serial 1786] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1782]
Solved by:  Guided Substitution of Equals
  Associativity: (b.c).a = a.b.c
and theorem 481:
Theorem (481) [serial 1795] used for:
  Associativity: (b.c).a = a.b.c [serial 1786] 


Theorem (483)                               [serial 1782] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1774]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 482:
Theorem (482) [serial 1786] used for:
    normalization of [serial 1782] 


Theorem (484)                               [serial 1774] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1770]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 483:
Theorem (483) [serial 1782] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1774] 


Theorem (485)                               [serial 1770] 
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1762]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 484:
Theorem (484) [serial 1774] used for:
    normalization of [serial 1770] 


Theorem (486)                               [serial 1762] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1758]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 485:
Theorem (485) [serial 1770] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1762] 


Theorem (487)                               [serial 1758] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177] ->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1749]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 486:
Theorem (486) [serial 1762] used for:
    normalization of [serial 1758] 


Theorem (488)                               [serial 1749] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1746]
Solved by:  Substitution of Assertion Labels
and theorem 487:
Theorem (487) [serial 1758] used for:
  Substituted assertions' predicates for labels  [serial 1749] 


Theorem (489)                               [serial 1755] 
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1750]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (490)                               [serial 1750] 
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1746]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 489:
Theorem (489) [serial 1755] used for:
  Associativity: (b.c).a = a.b.c [serial 1750] 


Theorem (491)                               [serial 1746] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1581]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 488 490:
Theorem (488) [serial 1749] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1746] 
Theorem (490) [serial 1750] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1746] 


Theorem (492)                               [serial 1788] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1783]
Solved by:  Guided Substitution of Equals
  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (493)                               [serial 1783] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1776]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 492:
Theorem (492) [serial 1788] used for:
    normalization of [serial 1783] 


Theorem (494)                               [serial 1776] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1771]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 493:
Theorem (493) [serial 1783] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1776] 


Theorem (495)                               [serial 1771] 
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1764]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 494:
Theorem (494) [serial 1776] used for:
    normalization of [serial 1771] 


Theorem (496)                               [serial 1764] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1759]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 495:
Theorem (495) [serial 1771] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1764] 


Theorem (497)                               [serial 1759] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177] ->
Q [177] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1751]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 496:
Theorem (496) [serial 1764] used for:
    normalization of [serial 1759] 


Theorem (498)                               [serial 1751] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] ->
Q [177] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747]
Solved by:  Substitution of Assertion Labels
and theorem 497:
Theorem (497) [serial 1759] used for:
  Substituted assertions' predicates for labels  [serial 1751] 


Theorem (499)                               [serial 1756] 
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1752]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (500)                               [serial 1752] 
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1747]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 499:
Theorem (499) [serial 1756] used for:
  Associativity: (b.c).a = a.b.c [serial 1752] 


Theorem (501)                               [serial 1747] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1581]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 498 500:
Theorem (498) [serial 1751] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1747] 
Theorem (500) [serial 1752] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1747] 


Theorem (502)                               [serial 1757] 
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1753]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (503)                               [serial 1753] 
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1748]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 502:
Theorem (502) [serial 1757] used for:
  Associativity: (b.c).a = a.b.c [serial 1753] 


Theorem (504)                               [serial 1794] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1778]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (505)                               [serial 1778] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1772]
Solved by:  Guided Substitution of Equals
  Associativity: (b.c).a = a.b.c
and theorem 504:
Theorem (504) [serial 1794] used for:
  Associativity: (b.c).a = a.b.c [serial 1778] 


Theorem (506)                               [serial 1772] 
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1766]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 505:
Theorem (505) [serial 1778] used for:
    normalization of [serial 1772] 


Theorem (507)                               [serial 1766] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1760]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 506:
Theorem (506) [serial 1772] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1766] 


Theorem (508)                               [serial 1760] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177] ->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1754]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 507:
Theorem (507) [serial 1766] used for:
    normalization of [serial 1760] 


Theorem (509)                               [serial 1754] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1748]
Solved by:  Substitution of Assertion Labels
and theorem 508:
Theorem (508) [serial 1760] used for:
  Substituted assertions' predicates for labels  [serial 1754] 


Theorem (510)                               [serial 1748] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1581]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 503 509:
Theorem (503) [serial 1753] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1748] 
Theorem (509) [serial 1754] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1748] 


Theorem (511)                               [serial 1581] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1567]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 491 501 510:
Theorem (491) [serial 1746] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1581] 
Theorem (501) [serial 1747] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1581] 
Theorem (510) [serial 1748] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1581] 


Theorem (512)                               [serial 1567] 
P [163] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1554]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 511:
Theorem (511) [serial 1581] used for:
  Associativity: (b.c).a = a.b.c [serial 1567] 


Theorem (513)                               [serial 1554] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1549]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 512:
Theorem (512) [serial 1567] used for:
    normalization of [serial 1554] 


Theorem (514)                               [serial 1549] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B3>> S3 <<Q>> in alternative for [serial 1544]
Solved by:  Introduction of Existential Quantification
and theorem 513:
Theorem (513) [serial 1554] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1549] 


Theorem (515)                               [serial 1841] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1837]
Solved by:  Guided Substitution of Equals
  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (516)                               [serial 1837] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1836]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 515:
Theorem (515) [serial 1841] used for:
    normalization of [serial 1837] 


Theorem (517)                               [serial 1836] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1832]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 516:
Theorem (516) [serial 1837] used for:
  Associativity: (b.c).a = a.b.c [serial 1836] 


Theorem (518)                               [serial 1832] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1828]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 517:
Theorem (517) [serial 1836] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1832] 


Theorem (519)                               [serial 1828] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1824]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 518:
Theorem (518) [serial 1832] used for:
    normalization of [serial 1828] 


Theorem (520)                               [serial 1824] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1820]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 519:
Theorem (519) [serial 1828] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1824] 


Theorem (521)                               [serial 1820] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1817]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 520:
Theorem (520) [serial 1824] used for:
    normalization of [serial 1820] 


Theorem (522)                               [serial 1817] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << EB()
   or not SB() >>
Why created:    normalization of [serial 1814]
Solved by:  Substitution of Assertion Labels
and theorem 521:
Theorem (521) [serial 1820] used for:
  Substituted assertions' predicates for labels  [serial 1817] 


Theorem (523)                               [serial 1814] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1806]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 522:
Theorem (522) [serial 1817] used for:
    normalization of [serial 1814] 


Theorem (524)                               [serial 1806] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1803]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 523:
Theorem (523) [serial 1814] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1806] 


Theorem (525)                               [serial 1811] 
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1807]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (526)                               [serial 1807] 
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1803]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 525:
Theorem (525) [serial 1811] used for:
  Associativity: (b.c).a = a.b.c [serial 1807] 


Theorem (527)                               [serial 1803] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1582]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 524 526:
Theorem (524) [serial 1806] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1803] 
Theorem (526) [serial 1807] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1803] 


Theorem (528)                               [serial 1849] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [182] ->
Q [86] << v < iSeg.v_e >>
Why created:  Transitivity: x<y and y<z -> x<z  [serial 1847]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (529)                               [serial 1847] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Solved by:  Transitivity: x<y and y<z -> x<z
and theorem 528:
Theorem (528) [serial 1849] used for:
  Transitivity: x<y and y<z -> x<z  [serial 1847] 


Theorem (530)                               [serial 1848] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (531)                               [serial 1839] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1835]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 529 530:
Theorem (529) [serial 1847] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839] 
Theorem (530) [serial 1848] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839] 


Theorem (532)                               [serial 1835] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1830]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 531:
Theorem (531) [serial 1839] used for:
    normalization of [serial 1835] 


Theorem (533)                               [serial 1830] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1827]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 532:
Theorem (532) [serial 1835] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1830] 


Theorem (534)                               [serial 1827] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1822]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 533:
Theorem (533) [serial 1830] used for:
    normalization of [serial 1827] 


Theorem (535)                               [serial 1822] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1819]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 534:
Theorem (534) [serial 1827] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1822] 


Theorem (536)                               [serial 1819] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1808]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 535:
Theorem (535) [serial 1822] used for:
    normalization of [serial 1819] 


Theorem (537)                               [serial 1808] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1804]
Solved by:  Substitution of Assertion Labels
and theorem 536:
Theorem (536) [serial 1819] used for:
  Substituted assertions' predicates for labels  [serial 1808] 


Theorem (538)                               [serial 1812] 
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1809]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (539)                               [serial 1809] 
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1804]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 538:
Theorem (538) [serial 1812] used for:
  Associativity: (b.c).a = a.b.c [serial 1809] 


Theorem (540)                               [serial 1804] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1582]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 537 539:
Theorem (537) [serial 1808] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1804] 
Theorem (539) [serial 1809] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1804] 


Theorem (541)                               [serial 1813] 
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1810]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (542)                               [serial 1810] 
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1805]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 541:
Theorem (541) [serial 1813] used for:
  Associativity: (b.c).a = a.b.c [serial 1810] 


Theorem (543)                               [serial 1805] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1582]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorem 542:
Theorem (542) [serial 1810] used for:
  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1805] 


Theorem (544)                               [serial 1582] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1569]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 527 540 543:
Theorem (527) [serial 1803] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1582] 
Theorem (540) [serial 1804] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1582] 
Theorem (543) [serial 1805] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1582] 


Theorem (545)                               [serial 1569] 
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1555]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 544:
Theorem (544) [serial 1582] used for:
  Associativity: (b.c).a = a.b.c [serial 1569] 


Theorem (546)                               [serial 1555] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1550]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 545:
Theorem (545) [serial 1569] used for:
    normalization of [serial 1555] 


Theorem (547)                               [serial 1550] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]   {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B4>> S4 <<Q>> in alternative for [serial 1544]
Solved by:  Introduction of Existential Quantification
and theorem 546:
Theorem (546) [serial 1555] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1550] 


Theorem (548)                               [serial 1544] 
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]   if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 377 405 438 476 514 547:
Theorem (377) [serial 1545] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1544] 
Theorem (405) [serial 1546] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1544] 
Theorem (438) [serial 1547] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1544] 
Theorem (476) [serial 1548] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1544] 
Theorem (514) [serial 1549] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1544] 
Theorem (547) [serial 1550] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1544] 


Theorem (549)                               [serial 1023] 
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegmentMoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
Solved by:  Introduction of Existential Quantification
and theorems 365 548:
Theorem (365) [serial 1543] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023] 
Theorem (548) [serial 1544] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023] 


Theorem (550)                               [serial 1024] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186] ->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (551)                               [serial 1867] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:  Law of And-Simplification:  P and true is P [serial 1866]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (552)                               [serial 1866] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 551:
Theorem (551) [serial 1867] used for:
  Law of And-Simplification:  P and true is P [serial 1866] 


Theorem (553)                               [serial 1867] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:  Law of And-Simplification:  P and true is P [serial 1866]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (554)                               [serial 1866] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 553:
Theorem (553) [serial 1867] used for:
  Law of And-Simplification:  P and true is P [serial 1866] 


Theorem (555)                               [serial 1855] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
Why created:    normalization of [serial 1850]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 554 554:
Theorem (554) [serial 1866] used for:
   add user-defined axioms to postcondition 
Theorem (554) [serial 1866] used for:
   add user-defined axioms to postcondition 


Theorem (556)                               [serial 1850] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65] ->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 555:
Theorem (555) [serial 1855] used for:
    normalization of [serial 1850] 


Theorem (557)                               [serial 1868] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (558)                               [serial 1869] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (559)                               [serial 1873] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1870]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (560)                               [serial 1870] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Solved by:  Guided Substitution of Equals
and theorem 559:
Theorem (559) [serial 1873] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1870] 


Theorem (561)                               [serial 1871] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [68] << NEXT_MA = next_ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (562)                               [serial 1872] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << NEXT_MA.seg[1] = nSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (563)                               [serial 1857] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
Why created:    normalization of [serial 1851]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 557 558 560 561 562:
Theorem (557) [serial 1868] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857] 
Theorem (558) [serial 1869] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857] 
Theorem (560) [serial 1870] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857] 
Theorem (561) [serial 1871] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857] 
Theorem (562) [serial 1872] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1857] 


Theorem (564)                               [serial 1851] 
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
S [67] ->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:  <<Q1>> -> <<Q>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 563:
Theorem (563) [serial 1857] used for:
    normalization of [serial 1851] 


Theorem (565)                               [serial 1882] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA = ma >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1878]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (566)                               [serial 1878] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [195] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 565:
Theorem (565) [serial 1882] used for:
  Associativity: (b.c).a = a.b.c [serial 1878] 


Theorem (567)                               [serial 1883] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193] ->
Q [194] << CMA.num_segments = i >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1879]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (568)                               [serial 1879] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [194] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 567:
Theorem (567) [serial 1883] used for:
  Associativity: (b.c).a = a.b.c [serial 1879] 


Theorem (569)                               [serial 1895] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[i] = iSeg >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1889]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (570)                               [serial 1889] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    normalization of [serial 1886]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
and theorem 569:
Theorem (569) [serial 1895] used for:
  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1889] 


Theorem (571)                               [serial 1886] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1884]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 570:
Theorem (570) [serial 1889] used for:
    normalization of [serial 1886] 


Theorem (572)                               [serial 1884] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1880]
Solved by:  Substitution of Assertion Labels
and theorem 571:
Theorem (571) [serial 1886] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1884] 


Theorem (573)                               [serial 1880] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 572:
Theorem (572) [serial 1884] used for:
  Associativity: (b.c).a = a.b.c [serial 1880] 


Theorem (574)                               [serial 1894] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193] ->
Q [194] << RMA = next_ma >>
Why created:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1891]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (575)                               [serial 1891] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:    normalization of [serial 1887]
Solved by:  Guided Substitution of Equals
and theorem 574:
Theorem (574) [serial 1894] used for:
  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1891] 


Theorem (576)                               [serial 1887] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1885]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 575:
Theorem (575) [serial 1891] used for:
    normalization of [serial 1887] 


Theorem (577)                               [serial 1885] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1881]
Solved by:  Substitution of Assertion Labels
and theorem 576:
Theorem (576) [serial 1887] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1885] 


Theorem (578)                               [serial 1881] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 577:
Theorem (577) [serial 1885] used for:
  Associativity: (b.c).a = a.b.c [serial 1881] 


Theorem (579)                               [serial 1876] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1874]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 566 568 573 578:
Theorem (566) [serial 1878] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876] 
Theorem (568) [serial 1879] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876] 
Theorem (573) [serial 1880] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876] 
Theorem (578) [serial 1881] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876] 


Theorem (580)                               [serial 1874] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193] ->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1859]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 579:
Theorem (579) [serial 1876] used for:
    normalization of [serial 1874] 


Theorem (581)                               [serial 1859] 
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193] m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1852]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 580:
Theorem (580) [serial 1874] used for:
  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1859] 


Theorem (582)                               [serial 1852] 
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193] m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 581:
Theorem (581) [serial 1859] used for:
    normalization of [serial 1852] 


Theorem (583)                               [serial 1897] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [198] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (584)                               [serial 1898] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (585)                               [serial 1899] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (586)                               [serial 1900] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << NEXT_MA = next_ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (587)                               [serial 1903] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1902]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (588)                               [serial 1902] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << next_ma.seg[1] = next_ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1901]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 587:
Theorem (587) [serial 1903] used for:
  Equality Law (idistr):  a=a <-> true [serial 1902] 


Theorem (589)                               [serial 1901] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896]
Solved by:  Guided Substitution of Equals
and theorem 588:
Theorem (588) [serial 1902] used for:
  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1901] 


Theorem (590)                               [serial 1896] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>
Why created:  applied wp for assignment [serial 1861]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 583 584 585 586 589:
Theorem (583) [serial 1897] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896] 
Theorem (584) [serial 1898] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896] 
Theorem (585) [serial 1899] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896] 
Theorem (586) [serial 1900] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896] 
Theorem (589) [serial 1901] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1896] 


Theorem (591)                               [serial 1861] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
Why created:    normalization of [serial 1853]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 590:
Theorem (590) [serial 1896] used for:
  applied wp for assignment [serial 1861] 


Theorem (592)                               [serial 1853] 
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196] nSeg := next_ma.seg[1]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
Why created:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 591:
Theorem (591) [serial 1861] used for:
    normalization of [serial 1853] 


Theorem (593)                               [serial 1025] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]   << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and AXIOM_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 556 564 582 592:
Theorem (556) [serial 1850] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1025] 
Theorem (564) [serial 1851] used for:
  <<Q1>> -> <<Q>> in sequential composition for [serial 1025] 
Theorem (582) [serial 1852] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1025] 
Theorem (592) [serial 1853] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1025] 


Theorem (594)                               [serial 1904] 
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202] ->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1026]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (595)                               [serial 1026] 
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202] ->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{};
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 594:
Theorem (594) [serial 1904] used for:
  Associativity: (b.c).a = a.b.c [serial 1026] 


Theorem (596)                               [serial 1027] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205] ->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{};
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (597)                               [serial 1914] 
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [210] << NEXT_MA = next_ma >>
Why created:    normalization of [serial 1912]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (598)                               [serial 1912] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << ( next_ma = NEXT_MA ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1911]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 597:
Theorem (597) [serial 1914] used for:
    normalization of [serial 1912] 


Theorem (599)                               [serial 1911] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 598:
Theorem (598) [serial 1912] used for:
  Law of And-Simplification:  P and true is P [serial 1911] 


Theorem (600)                               [serial 1914] 
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [210] << NEXT_MA = next_ma >>
Why created:    normalization of [serial 1912]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (601)                               [serial 1912] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << ( next_ma = NEXT_MA ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1911]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 600:
Theorem (600) [serial 1914] used for:
    normalization of [serial 1912] 


Theorem (602)                               [serial 1911] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 601:
Theorem (601) [serial 1912] used for:
  Law of And-Simplification:  P and true is P [serial 1911] 


Theorem (603)                               [serial 1905] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 602 602:
Theorem (602) [serial 1911] used for:
   add user-defined axioms to postcondition 
Theorem (602) [serial 1911] used for:
   add user-defined axioms to postcondition 


Theorem (604)                               [serial 1920] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (605)                               [serial 1921] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (606)                               [serial 1922] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << CMA.seg[1 + i] = nSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (607)                               [serial 1927] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << 1 < ma.num_segments >>
Why created:    normalization of [serial 1925]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (608)                               [serial 1925] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << ( 1 ) < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1924]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 607:
Theorem (607) [serial 1927] used for:
    normalization of [serial 1925] 


Theorem (609)                               [serial 1924] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << ( 1 ) < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1923]
Solved by:  Guided Substitution of Equals
and theorem 608:
Theorem (608) [serial 1925] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1924] 


Theorem (610)                               [serial 1923] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
Solved by:  Guided Substitution of Equals
and theorem 609:
Theorem (609) [serial 1924] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1923] 


Theorem (611)                               [serial 1918] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1916]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 604 605 606 610:
Theorem (604) [serial 1920] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918] 
Theorem (605) [serial 1921] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918] 
Theorem (606) [serial 1922] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918] 
Theorem (610) [serial 1923] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918] 


Theorem (612)                               [serial 1916] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ( 1 < ma.num_segments ) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1906]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 611:
Theorem (611) [serial 1918] used for:
    normalization of [serial 1916] 


Theorem (613)                               [serial 1906] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<Q3>> -> <<Q>> in sequential composition for [serial 1028]
Solved by:  Substitution of Assertion Labels
and theorem 612:
Theorem (612) [serial 1916] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1906] 


Theorem (614)                               [serial 1934] 
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211] ->
Q [212] << NEXT_MA = next_ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1932]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (615)                               [serial 1932] 
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211] ->
Q [212] << CMA = next_ma >>
Why created:    normalization of [serial 1930]
Solved by:  Guided Substitution of Equals
and theorem 614:
Theorem (614) [serial 1934] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1932] 


Theorem (616)                               [serial 1930] 
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211] ->
Q [212] << next_ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1929]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 615:
Theorem (615) [serial 1932] used for:
    normalization of [serial 1930] 


Theorem (617)                               [serial 1929] 
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211] ->
Q [212] << next_ma = CMA >>
Why created:  applied wp for assignment [serial 1907]
Solved by:  Substitution of Assertion Labels
and theorem 616:
Theorem (616) [serial 1930] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1929] 


Theorem (618)                               [serial 1907] 
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211] ma := next_ma
Q [212] << ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 617:
Theorem (617) [serial 1929] used for:
  applied wp for assignment [serial 1907] 


Theorem (619)                               [serial 1942] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << CMA = ma >>
Why created:    normalization of [serial 1940]
Solved by:  Identity (id):  P->P is tautology


Theorem (620)                               [serial 1940] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << ( CMA = ma ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1939]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 619:
Theorem (619) [serial 1942] used for:
    normalization of [serial 1940] 


Theorem (621)                               [serial 1939] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << CMA = ma
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1937]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 620:
Theorem (620) [serial 1940] used for:
  Law of And-Simplification:  P and true is P [serial 1939] 


Theorem (622)                               [serial 1937] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << CMA = ma
  and 1 = 1 >>
Why created:    normalization of [serial 1935]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 621:
Theorem (621) [serial 1939] used for:
  Equality Law (idistr):  a=a <-> true [serial 1937] 


Theorem (623)                               [serial 1935] 
P [212] << ma = CMA >>
S [213] ->
Q [214] << ( 1 ) = 1
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1908]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 622:
Theorem (622) [serial 1937] used for:
    normalization of [serial 1935] 


Theorem (624)                               [serial 1908] 
P [212] << ma = CMA >>
S [213] i := 1
Q [214] << i = 1
  and ma = CMA >>
Why created:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 623:
Theorem (623) [serial 1935] used for:
  applied wp for assignment [serial 1908] 


Theorem (625)                               [serial 1945] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (626)                               [serial 1946] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << ma = CMA >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (627)                               [serial 1953] 
P [214] << CMA = ma
  and i = 1 >>
S [215] ->
Q [216] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1951]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (628)                               [serial 1951] 
P [214] << CMA = ma
  and i = 1 >>
S [215] ->
Q [216] << ma.seg[1] = ma.seg[1] >>
Why created:    normalization of [serial 1949]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 627:
Theorem (627) [serial 1953] used for:
  Equality Law (idistr):  a=a <-> true [serial 1951] 


Theorem (629)                               [serial 1949] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1] = ma.seg[( 1 )] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1948]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 628:
Theorem (628) [serial 1951] used for:
    normalization of [serial 1949] 


Theorem (630)                               [serial 1948] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1] = ma.seg[i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1947]
Solved by:  Guided Substitution of Equals
and theorem 629:
Theorem (629) [serial 1949] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1948] 


Theorem (631)                               [serial 1947] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1] = CMA.seg[i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Solved by:  Guided Substitution of Equals
and theorem 630:
Theorem (630) [serial 1948] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1947] 


Theorem (632)                               [serial 1944] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>
Why created:  applied wp for assignment [serial 1909]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 625 626 631:
Theorem (625) [serial 1945] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944] 
Theorem (626) [serial 1946] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944] 
Theorem (631) [serial 1947] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944] 


Theorem (633)                               [serial 1909] 
P [214] << i = 1
  and ma = CMA >>
S [215] iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 632:
Theorem (632) [serial 1944] used for:
  applied wp for assignment [serial 1909] 


Theorem (634)                               [serial 1957] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (635)                               [serial 1958] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma = CMA >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (636)                               [serial 1959] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << iSeg = CMA.seg[i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (637)                               [serial 1966] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1965]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (638)                               [serial 1965] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << ma.seg[2] = ma.seg[2] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1963]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 637:
Theorem (637) [serial 1966] used for:
  Equality Law (idistr):  a=a <-> true [serial 1965] 


Theorem (639)                               [serial 1963] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << CMA.seg[2] = ma.seg[2] >>
Why created:    normalization of [serial 1961]
Solved by:  Guided Substitution of Equals
and theorem 638:
Theorem (638) [serial 1965] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1963] 


Theorem (640)                               [serial 1961] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1960]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 639:
Theorem (639) [serial 1963] used for:
    normalization of [serial 1961] 


Theorem (641)                               [serial 1960] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  Guided Substitution of Equals
and theorem 640:
Theorem (640) [serial 1961] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1960] 


Theorem (642)                               [serial 1956] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
Why created:  applied wp for assignment [serial 1955]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 634 635 636 641:
Theorem (634) [serial 1957] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (635) [serial 1958] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (636) [serial 1959] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (641) [serial 1960] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 


Theorem (643)                               [serial 1955] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1954]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 642:
Theorem (642) [serial 1956] used for:
  applied wp for assignment [serial 1955] 


Theorem (644)                               [serial 1954] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 643:
Theorem (643) [serial 1955] used for:
  Law of And-Simplification:  P and true is P [serial 1954] 


Theorem (645)                               [serial 1957] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (646)                               [serial 1958] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma = CMA >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (647)                               [serial 1959] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << iSeg = CMA.seg[i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (648)                               [serial 1966] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1965]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (649)                               [serial 1965] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << ma.seg[2] = ma.seg[2] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1963]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 648:
Theorem (648) [serial 1966] used for:
  Equality Law (idistr):  a=a <-> true [serial 1965] 


Theorem (650)                               [serial 1963] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << CMA.seg[2] = ma.seg[2] >>
Why created:    normalization of [serial 1961]
Solved by:  Guided Substitution of Equals
and theorem 649:
Theorem (649) [serial 1965] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1963] 


Theorem (651)                               [serial 1961] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1960]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 650:
Theorem (650) [serial 1963] used for:
    normalization of [serial 1961] 


Theorem (652)                               [serial 1960] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  Guided Substitution of Equals
and theorem 651:
Theorem (651) [serial 1961] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1960] 


Theorem (653)                               [serial 1956] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
Why created:  applied wp for assignment [serial 1955]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 645 646 647 652:
Theorem (645) [serial 1957] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (646) [serial 1958] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (647) [serial 1959] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (652) [serial 1960] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 


Theorem (654)                               [serial 1955] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1954]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 653:
Theorem (653) [serial 1956] used for:
  applied wp for assignment [serial 1955] 


Theorem (655)                               [serial 1954] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 654:
Theorem (654) [serial 1955] used for:
  Law of And-Simplification:  P and true is P [serial 1954] 


Theorem (656)                               [serial 1910] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
Why created:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 655 655:
Theorem (655) [serial 1954] used for:
   add user-defined axioms to postcondition 
Theorem (655) [serial 1954] used for:
   add user-defined axioms to postcondition 


Theorem (657)                               [serial 1028] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]   << AXIOM_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 603 613 618 624 633 656:
Theorem (603) [serial 1905] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1028] 
Theorem (613) [serial 1906] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1028] 
Theorem (618) [serial 1907] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028] 
Theorem (624) [serial 1908] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028] 
Theorem (633) [serial 1909] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028] 
Theorem (656) [serial 1910] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028] 


Theorem (658)                               [serial 1002] 
P [33] <<   >>
S [39] ->
Q [33] << AutoBrake.i proof obligations >>
Why created:  Initial proof obligations for AutoBrake.i
Solved by:  Component verification conditions
and theorems 1 2 3 5 9 11 12 15 17 21 25 26 27 106 313 315 322 332 357 358 549 550 593 595 596 657:
Theorem (1) [serial 1003] used for:
  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition. 
Theorem (2) [serial 1004] used for:
  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition. 
Theorem (3) [serial 1005] used for:
  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition. 
Theorem (5) [serial 1006] used for:
  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition. 
Theorem (9) [serial 1007] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>> 
Theorem (11) [serial 1008] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (12) [serial 1009] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>> 
Theorem (15) [serial 1010] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (17) [serial 1011] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>> 
Theorem (21) [serial 1012] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>> 
Theorem (25) [serial 1013] used for:
   <<M(Start)>> A <<M(WaitFirstMA)>> for GoStart-[ ]->WaitFirstMA{A}; 
Theorem (26) [serial 1014] used for:
   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMAWaitFirstMA-[x]->CheckFirstMA{}; 
Theorem (27) [serial 1015] used for:
   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYetCheckFirstMA-[x]->WaitFirstMA{}; 
Theorem (106) [serial 1016] used for:
   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A}; 
Theorem (313) [serial 1017] used for:
   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A}; 
Theorem (315) [serial 1018] used for:
   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{}; 
Theorem (322) [serial 1019] used for:
   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A}; 
Theorem (332) [serial 1020] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A}; 
Theorem (357) [serial 1021] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A}; 
Theorem (358) [serial 1022] used for:
   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{}; 
Theorem (549) [serial 1023] used for:
   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegmentMoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A}; 
Theorem (550) [serial 1024] used for:
   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{}; 
Theorem (593) [serial 1025] used for:
   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A}; 
Theorem (595) [serial 1026] used for:
   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{}; 
Theorem (596) [serial 1027] used for:
   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{}; 
Theorem (657) [serial 1028] used for:
   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A}; 


Theorem (659)                               [serial 1029] 
P [1] << xl = OPERATOR_XL >>
S [2] ->
Q [1] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
Solved by:  Identity (id):  P->P is tautology


Theorem (660)                               [serial 1030] 
P [1] << p = POSITION >>
S [2] ->
Q [1] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
Solved by:  Identity (id):  P->P is tautology


Theorem (661)                               [serial 1031] 
P [1] << v = VELOCITY >>
S [2] ->
Q [1] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
Solved by:  Identity (id):  P->P is tautology


Theorem (662)                               [serial 1032] 
P [1] << SB()
  and not EB() >>
S [2] ->
Q [1] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (663)                               [serial 1033] 
P [1] << EB() >>
S [2] ->
Q [1] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (664)                               [serial 1034] 
P [1] << ma_m_a = RMA >>
S [2] ->
Q [1] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
Solved by:  Identity (id):  P->P is tautology


Theorem (665)                               [serial 1035] 
P [27] << ma = RMA >>
S [19] ->
Q [14] << ma = RMA >>
Why created:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
Solved by:  Identity (id):  P->P is tautology


Theorem (666)                               [serial 1036] 
P [14] << ma_m_a = RMA >>
S [73] ->
Q [94] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
Solved by:  Identity (id):  P->P is tautology


Theorem (667)                               [serial 1037] 
P [32] << p = POSITION >>
S [74] ->
Q [89] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
Solved by:  Identity (id):  P->P is tautology


Theorem (668)                               [serial 1038] 
P [34] << v = VELOCITY >>
S [75] ->
Q [91] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
Solved by:  Identity (id):  P->P is tautology


Theorem (669)                               [serial 1039] 
P [59] << xl = OPERATOR_XL >>
S [76] ->
Q [23] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
Solved by:  Identity (id):  P->P is tautology


Theorem (670)                               [serial 1040] 
P [85] << SB()
  and not EB() >>
S [77] ->
Q [44] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (671)                               [serial 1041] 
P [87] << EB() >>
S [78] ->
Q [51] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (672)                               [serial 1042] 
P [89] << p = POSITION >>
S [103] ->
Q [19] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
Solved by:  Identity (id):  P->P is tautology


Theorem (673)                               [serial 1043] 
P [91] << v = VELOCITY >>
S [104] ->
Q [21] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
Solved by:  Identity (id):  P->P is tautology


Theorem (674)                               [serial 1044] 
P [94] << m_a = RMA >>
S [106] ->
Q [17] << m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
Solved by:  Identity (id):  P->P is tautology


Theorem (675)                               [serial 1045] 
P [12] << SB()
  and not EB() >>
S [108] ->
Q [85] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
Solved by:  Identity (id):  P->P is tautology


Theorem (676)                               [serial 1046] 
P [14] << EB() >>
S [109] ->
Q [87] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
Solved by:  Identity (id):  P->P is tautology


Theorem (677)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
and theorems 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676:
Theorem (658) [serial 1002] used for:
  Initial proof obligations for AutoBrake.i 
Theorem (659) [serial 1029] used for:
  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl 
Theorem (660) [serial 1030] used for:
  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p 
Theorem (661) [serial 1031] used for:
  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v 
Theorem (662) [serial 1032] used for:
  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake 
Theorem (663) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake 
Theorem (664) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a 
Theorem (665) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma 
Theorem (666) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a 
Theorem (667) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p 
Theorem (668) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v 
Theorem (669) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl 
Theorem (670) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake 
Theorem (671) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake 
Theorem (672) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p 
Theorem (673) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v 
Theorem (674) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a 
Theorem (675) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb 
Theorem (676) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb 


showing tree: Derivations
closing proof.txt file 
proof duration:  3570 minutes 49 seconds 

