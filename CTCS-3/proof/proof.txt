This file, proof.txt, was produced the BLESS Proof Assistant v3.1.5
  at Wed Apr 12 10:47:47 CDT 2023 by brianlarson

Theorem (1)                               [serial 1003] 
P [78] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
S [52] ->
Q [52] << true >>
by True Conclusion Schema (tc): P->true


Theorem (2)                               [serial 1004] 
P [69] << true >>
S [52] ->
Q [52] << true >>
by True Conclusion Schema (tc): P->true


Theorem (3)                               [serial 1005] 
P [72] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
S [52] ->
Q [52] << true >>
by True Conclusion Schema (tc): P->true


Theorem (4)                               [serial 1006] 
P [82] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA >>
S [52] ->
Q [52] << true >>
by True Conclusion Schema (tc): P->true


Theorem (5)                               [serial 1047] 
P [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
S [74] ->
Q [74] << true >>
by True Conclusion Schema (tc): P->true


Theorem (6)                               [serial 1046] 
P [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
S [74] ->
Q [74] << ( not ( p < iSeg.e ) )
  or p < iSeg.e >>
by Law of Excluded Middle: P or not P is tautology
and theorem 5:
Theorem (5) [serial 1047] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1046]
 


Theorem (7)                               [serial 1044] 
P [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
S [74] ->
Q [74] << iSeg.e <= p
  or p < iSeg.e >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 6:
Theorem (6) [serial 1046] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1044]
 


Theorem (8)                               [serial 1007] 
P [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
S [74] ->
Q [74] << ( p < iSeg.e )
  or ( p >= iSeg.e ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 7:
Theorem (7) [serial 1044] used for:
    normalization of [serial 1007]
 


Theorem (9)                               [serial 1048] 
P [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
S [80] ->
Q [80] << true >>
by True Conclusion Schema (tc): P->true


Theorem (10)                               [serial 1008] 
P [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
S [80] ->
Q [80] << ( not m_a'fresh )
  or m_a'fresh >>
by Law of Excluded Middle: P or not P is tautology
and theorem 9:
Theorem (9) [serial 1048] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1008]
 


Theorem (11)                               [serial 1009] 
P [68] << true >>
S [68] ->
Q [68] << true >>
by True Conclusion Schema (tc): P->true


Theorem (12)                               [serial 1052] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg >>
S [76] ->
Q [76] << true >>
by True Conclusion Schema (tc): P->true


Theorem (13)                               [serial 1050] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg >>
S [76] ->
Q [76] << i = ma.num_segments
  or i < ma.num_segments
  or ma.num_segments < i >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 12:
Theorem (12) [serial 1052] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1050]
 


Theorem (14)                               [serial 1010] 
P [76] << iSeg = CMA.seg[i]
   and ma = CMA >>
S [76] ->
Q [76] << ( i < ma.num_segments )
  or ( i = ma.num_segments )
  or ( i > ma.num_segments ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 13:
Theorem (13) [serial 1050] used for:
    normalization of [serial 1010]
 


Theorem (15)                               [serial 1053] 
P [70] << true >>
S [70] ->
Q [70] << true >>
by True Conclusion Schema (tc): P->true


Theorem (16)                               [serial 1011] 
P [70] << true >>
S [70] ->
Q [70] << ( not m_a'fresh )
  or m_a'fresh >>
by Law of Excluded Middle: P or not P is tautology
and theorem 15:
Theorem (15) [serial 1053] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1011]
 


Theorem (17)                               [serial 1058] 
P [84] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [84] ->
Q [84] << true >>
by True Conclusion Schema (tc): P->true


Theorem (18)                               [serial 1057] 
P [84] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [84] ->
Q [84] << ( not ( p < ma.ea ) )
  or p < ma.ea >>
by Law of Excluded Middle: P or not P is tautology
and theorem 17:
Theorem (17) [serial 1058] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1057]
 


Theorem (19)                               [serial 1055] 
P [84] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [84] ->
Q [84] << ma.ea <= p
  or p < ma.ea >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 18:
Theorem (18) [serial 1057] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1055]
 


Theorem (20)                               [serial 1012] 
P [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA >>
S [84] ->
Q [84] << ( p < ma.ea )
  or ( p >= ma.ea ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 19:
Theorem (19) [serial 1055] used for:
    normalization of [serial 1012]
 


Theorem (21)                               [serial 1059] 
P [68] << true >>
S [91] ->
Q [91] << true >>
by True Conclusion Schema (tc): P->true


Theorem (22)                               [serial 1060] 
P [91] << ( true )
   and true@now >>
S [91] ->
Q [69] << true >>
by True Conclusion Schema (tc): P->true


Theorem (23)                               [serial 1013] 
P [68] << true >>
S [91] r!
Q [69] << true >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 21 22:
Theorem (21) [serial 1059] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1013]
 
Theorem (22) [serial 1060] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1013]
 


Theorem (24)                               [serial 1014] 
P [94] << ( true )
   and ( p@now )
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [94] ->
Q [70] << true >>
by True Conclusion Schema (tc): P->true


Theorem (25)                               [serial 1015] 
P [97] << not m_a'fresh >>
S [96] ->
Q [69] << true >>
by True Conclusion Schema (tc): P->true


Theorem (26)                               [serial 1067] 
P [100] << m_a'fresh >>
S [100] ->
Q [101] << true >>
by True Conclusion Schema (tc): P->true


Theorem (27)                               [serial 1067] 
P [100] << m_a'fresh >>
S [100] ->
Q [101] << true >>
by True Conclusion Schema (tc): P->true


Theorem (28)                               [serial 1061] 
P [100] << m_a'fresh >>
S [100] ->
Q [101] << AXIOM_CMA_IS_RMA() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 27 27:
Theorem (27) [serial 1067] used for:
   add user-defined axioms to postcondition
 
Theorem (27) [serial 1067] used for:
   add user-defined axioms to postcondition
 


Theorem (29)                               [serial 1088] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : CMA) >>
S [72] ->
Q [72] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (30)                               [serial 1089] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : CMA) >>
S [72] ->
Q [72] << CMA.seg[i] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (31)                               [serial 1090] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : CMA) >>
S [72] ->
Q [72] << CMA.seg[1 + i] = nSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (32)                               [serial 1099] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << 1 < ma.num_segments >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (33)                               [serial 1097] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << ( 1 ) < ma.num_segments >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 32:
Theorem (32) [serial 1099] used for:
    normalization of [serial 1097]
 


Theorem (34)                               [serial 1095] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << i < ma.num_segments >>
by Guided Substitution of Equals
and theorem 33:
Theorem (33) [serial 1097] used for:
  Guided Substitution of Equals
 replacing "i" with its = "( 1 )" in its postcondition [serial 1095]
 


Theorem (35)                               [serial 1093] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and ( 1 < ma.num_segments ) >>
S [72] ->
Q [72] << i < ma.num_segments >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 34:
Theorem (34) [serial 1095] used for:
    normalization of [serial 1093]
 


Theorem (36)                               [serial 1092] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and ( 1 < ma.num_segments ) >>
S [72] ->
Q [72] << i < CMA.num_segments >>
by Guided Substitution of Equals
and theorem 35:
Theorem (35) [serial 1093] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1092]
 


Theorem (37)                               [serial 1091] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : CMA) >>
S [72] ->
Q [72] << i < CMA.num_segments >>
by Substitution of Assertion Labels
and theorem 36:
Theorem (36) [serial 1092] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1091]
 


Theorem (38)                               [serial 1073] 
P [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : CMA) >>
S [72] ->
Q [72] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 29 30 31 37:
Theorem (29) [serial 1088] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1073]
 
Theorem (30) [serial 1089] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1073]
 
Theorem (31) [serial 1090] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1073]
 
Theorem (37) [serial 1091] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1073]
 


Theorem (39)                               [serial 1062] 
P [109] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_NUM_SEG(ma : CMA) >>
S [72] ->
Q [72] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 38:
Theorem (38) [serial 1073] used for:
    normalization of [serial 1062]
 


Theorem (40)                               [serial 1106] 
P [102] << CMA = RMA
   and RMA = ma >>
S [102] ->
Q [103] << RMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (41)                               [serial 1104] 
P [102] << CMA = RMA
   and RMA = ma >>
S [102] ->
Q [103] << CMA = ma >>
by Guided Substitution of Equals
and theorem 40:
Theorem (40) [serial 1106] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "RMA" in its postcondition [serial 1104]
 


Theorem (42)                               [serial 1102] 
P [102] << ( ( CMA = RMA ) )
   and ma = RMA >>
S [102] ->
Q [103] << CMA = ma >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 41:
Theorem (41) [serial 1104] used for:
    normalization of [serial 1102]
 


Theorem (43)                               [serial 1101] 
P [102] << ( AXIOM_CMA_IS_RMA() )
   and ma = RMA >>
S [102] ->
Q [103] << CMA = ma >>
by Substitution of Assertion Labels
and theorem 42:
Theorem (42) [serial 1102] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1101]
 


Theorem (44)                               [serial 1075] 
P [101] << AXIOM_CMA_IS_RMA() >>
S [102] m_a?(ma)
Q [103] << CMA = ma >>
by Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
and theorem 43:
Theorem (43) [serial 1101] used for:
  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1075]
 


Theorem (45)                               [serial 1063] 
P [101] << AXIOM_CMA_IS_RMA() >>
S [102] m_a?(ma)
Q [103] << ma = CMA >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorem 44:
Theorem (44) [serial 1075] used for:
    normalization of [serial 1063]
 


Theorem (46)                               [serial 1114] 
P [103] << CMA = ma >>
S [104] ->
Q [105] << CMA = ma >>
by Identity (id):  P->P is tautology


Theorem (47)                               [serial 1112] 
P [103] << CMA = ma >>
S [104] ->
Q [105] << ( CMA = ma ) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 46:
Theorem (46) [serial 1114] used for:
    normalization of [serial 1112]
 


Theorem (48)                               [serial 1111] 
P [103] << CMA = ma >>
S [104] ->
Q [105] << CMA = ma
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 47:
Theorem (47) [serial 1112] used for:
  Law of And-Simplification:  P and true is P [serial 1111]
 


Theorem (49)                               [serial 1109] 
P [103] << CMA = ma >>
S [104] ->
Q [105] << CMA = ma
   and 1 = 1 >>
by Equality Law (idistr):  a=a <-> true
and theorem 48:
Theorem (48) [serial 1111] used for:
  Equality Law (idistr):  a=a <-> true [serial 1109]
 


Theorem (50)                               [serial 1107] 
P [103] << CMA = ma >>
S [104] ->
Q [105] << CMA = ma
   and ( 1 ) = 1 >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 49:
Theorem (49) [serial 1109] used for:
    normalization of [serial 1107]
 


Theorem (51)                               [serial 1077] 
P [103] << CMA = ma >>
S [104] i := 1
Q [105] << CMA = ma
   and i = 1 >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 50:
Theorem (50) [serial 1107] used for:
  applied wp for assignment [serial 1077]
 


Theorem (52)                               [serial 1064] 
P [103] << ma = CMA >>
S [104] i := 1
Q [105] << i = 1
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 51:
Theorem (51) [serial 1077] used for:
    normalization of [serial 1064]
 


Theorem (53)                               [serial 1117] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (54)                               [serial 1125] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << true >>
by True Conclusion Schema (tc): P->true


Theorem (55)                               [serial 1123] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << ma.seg[1] = ma.seg[1] >>
by Equality Law (idistr):  a=a <-> true
and theorem 54:
Theorem (54) [serial 1125] used for:
  Equality Law (idistr):  a=a <-> true [serial 1123]
 


Theorem (56)                               [serial 1121] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << ma.seg[( 1 )] = ma.seg[1] >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 55:
Theorem (55) [serial 1123] used for:
    normalization of [serial 1121]
 


Theorem (57)                               [serial 1120] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << ma.seg[i] = ma.seg[1] >>
by Guided Substitution of Equals
and theorem 56:
Theorem (56) [serial 1121] used for:
  Guided Substitution of Equals
 replacing "i" with its = "( 1 )" in its postcondition [serial 1120]
 


Theorem (58)                               [serial 1118] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << CMA.seg[i] = ma.seg[1] >>
by Guided Substitution of Equals
and theorem 57:
Theorem (57) [serial 1120] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1118]
 


Theorem (59)                               [serial 1119] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << i = 1 >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (60)                               [serial 1116] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << CMA = ma
   and CMA.seg[i] = ma.seg[1]
   and i = 1 >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 53 58 59:
Theorem (53) [serial 1117] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1116]
 
Theorem (58) [serial 1118] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1116]
 
Theorem (59) [serial 1119] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1116]
 


Theorem (61)                               [serial 1080] 
P [105] << CMA = ma
   and i = 1 >>
S [106] iSeg := ma.seg[1]
Q [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1 >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 60:
Theorem (60) [serial 1116] used for:
  applied wp for assignment [serial 1080]
 


Theorem (62)                               [serial 1070] 
P [105] << i = 1
   and ma = CMA >>
S [106] iSeg := ma.seg[1]
Q [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 61:
Theorem (61) [serial 1080] used for:
    normalization of [serial 1070]
 


Theorem (63)                               [serial 1068] 
P [105] << i = 1
   and ma = CMA >>
S [106] iSeg := ma.seg[1]
Q [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 62:
Theorem (62) [serial 1070] used for:
  Law of And-Simplification:  P and true is P [serial 1068]
 


Theorem (64)                               [serial 1117] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (65)                               [serial 1125] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << true >>
by True Conclusion Schema (tc): P->true


Theorem (66)                               [serial 1123] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << ma.seg[1] = ma.seg[1] >>
by Equality Law (idistr):  a=a <-> true
and theorem 65:
Theorem (65) [serial 1125] used for:
  Equality Law (idistr):  a=a <-> true [serial 1123]
 


Theorem (67)                               [serial 1121] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << ma.seg[( 1 )] = ma.seg[1] >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 66:
Theorem (66) [serial 1123] used for:
    normalization of [serial 1121]
 


Theorem (68)                               [serial 1120] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << ma.seg[i] = ma.seg[1] >>
by Guided Substitution of Equals
and theorem 67:
Theorem (67) [serial 1121] used for:
  Guided Substitution of Equals
 replacing "i" with its = "( 1 )" in its postcondition [serial 1120]
 


Theorem (69)                               [serial 1118] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << CMA.seg[i] = ma.seg[1] >>
by Guided Substitution of Equals
and theorem 68:
Theorem (68) [serial 1120] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1118]
 


Theorem (70)                               [serial 1119] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << i = 1 >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (71)                               [serial 1116] 
P [105] << CMA = ma
   and i = 1 >>
S [106] ->
Q [107] << CMA = ma
   and CMA.seg[i] = ma.seg[1]
   and i = 1 >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 64 69 70:
Theorem (64) [serial 1117] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1116]
 
Theorem (69) [serial 1118] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1116]
 
Theorem (70) [serial 1119] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1116]
 


Theorem (72)                               [serial 1080] 
P [105] << CMA = ma
   and i = 1 >>
S [106] iSeg := ma.seg[1]
Q [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1 >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 71:
Theorem (71) [serial 1116] used for:
  applied wp for assignment [serial 1080]
 


Theorem (73)                               [serial 1070] 
P [105] << i = 1
   and ma = CMA >>
S [106] iSeg := ma.seg[1]
Q [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 72:
Theorem (72) [serial 1080] used for:
    normalization of [serial 1070]
 


Theorem (74)                               [serial 1068] 
P [105] << i = 1
   and ma = CMA >>
S [106] iSeg := ma.seg[1]
Q [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 73:
Theorem (73) [serial 1070] used for:
  Law of And-Simplification:  P and true is P [serial 1068]
 


Theorem (75)                               [serial 1065] 
P [105] << i = 1
   and ma = CMA >>
S [106] iSeg := ma.seg[1]
Q [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and AXIOM_NUM_SEG(ma : ma) >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 74 74:
Theorem (74) [serial 1068] used for:
   add user-defined axioms to postcondition
 
Theorem (74) [serial 1068] used for:
   add user-defined axioms to postcondition
 


Theorem (76)                               [serial 1141] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << CMA.seg[i] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (77)                               [serial 1139] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << CMA.seg[1] = iSeg >>
by Guided Substitution of Equals
and theorem 76:
Theorem (76) [serial 1141] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 1}" with its = "i" in its postcondition [serial 1139]
 


Theorem (78)                               [serial 1137] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << iSeg = CMA.seg[1] >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorem 77:
Theorem (77) [serial 1139] used for:
    normalization of [serial 1137]
 


Theorem (79)                               [serial 1135] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << iSeg = ma.seg[1] >>
by Guided Substitution of Equals
and theorem 78:
Theorem (78) [serial 1137] used for:
  Guided Substitution of Equals
 replacing "ma" with its = "CMA" in its postcondition [serial 1135]
 


Theorem (80)                               [serial 1133] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << ( ma.seg[1] = iSeg ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 79:
Theorem (79) [serial 1135] used for:
    normalization of [serial 1133]
 


Theorem (81)                               [serial 1132] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << true
   and ma.seg[1] = iSeg
   and true
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 80:
Theorem (80) [serial 1133] used for:
  Law of And-Simplification:  P and true is P [serial 1132]
 


Theorem (82)                               [serial 1131] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << ma = ma
   and ma.seg[1] = iSeg
   and ma.seg[2] = ma.seg[2]
   and 1 = 1 >>
by Equality Law (idistr):  a=a <-> true
and theorem 81:
Theorem (81) [serial 1132] used for:
  Equality Law (idistr):  a=a <-> true [serial 1131]
 


Theorem (83)                               [serial 1130] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << ma = ma
   and ma.seg[1] = iSeg
   and ma.seg[2] = nSeg
   and 1 = 1 >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 82:
Theorem (82) [serial 1131] used for:
  applied wp for assignment [serial 1130]
 


Theorem (84)                               [serial 1128] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << CMA = ma
   and CMA.seg[1] = iSeg
   and CMA.seg[2] = nSeg
   and 1 = 1 >>
by Guided Substitution of Equals
and theorem 83:
Theorem (83) [serial 1130] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1128]
 


Theorem (85)                               [serial 1126] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << CMA = ma
   and CMA.seg[( 1 )] = iSeg
   and CMA.seg[1 + ( 1 )] = nSeg
   and ( 1 ) = 1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 84:
Theorem (84) [serial 1128] used for:
    normalization of [serial 1126]
 


Theorem (86)                               [serial 1082] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1 >>
by Guided Substitution of Equals
and theorem 85:
Theorem (85) [serial 1126] used for:
  Guided Substitution of Equals
 replacing "i" with its = "( 1 )" in its postcondition [serial 1082]
 


Theorem (87)                               [serial 1071] 
P [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1] >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 86:
Theorem (86) [serial 1082] used for:
    normalization of [serial 1071]
 


Theorem (88)                               [serial 1069] 
P [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 87:
Theorem (87) [serial 1071] used for:
  Law of And-Simplification:  P and true is P [serial 1069]
 


Theorem (89)                               [serial 1141] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << CMA.seg[i] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (90)                               [serial 1139] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << CMA.seg[1] = iSeg >>
by Guided Substitution of Equals
and theorem 89:
Theorem (89) [serial 1141] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 1}" with its = "i" in its postcondition [serial 1139]
 


Theorem (91)                               [serial 1137] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << iSeg = CMA.seg[1] >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorem 90:
Theorem (90) [serial 1139] used for:
    normalization of [serial 1137]
 


Theorem (92)                               [serial 1135] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << iSeg = ma.seg[1] >>
by Guided Substitution of Equals
and theorem 91:
Theorem (91) [serial 1137] used for:
  Guided Substitution of Equals
 replacing "ma" with its = "CMA" in its postcondition [serial 1135]
 


Theorem (93)                               [serial 1133] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << ( ma.seg[1] = iSeg ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 92:
Theorem (92) [serial 1135] used for:
    normalization of [serial 1133]
 


Theorem (94)                               [serial 1132] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << true
   and ma.seg[1] = iSeg
   and true
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 93:
Theorem (93) [serial 1133] used for:
  Law of And-Simplification:  P and true is P [serial 1132]
 


Theorem (95)                               [serial 1131] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] ->
Q [109] << ma = ma
   and ma.seg[1] = iSeg
   and ma.seg[2] = ma.seg[2]
   and 1 = 1 >>
by Equality Law (idistr):  a=a <-> true
and theorem 94:
Theorem (94) [serial 1132] used for:
  Equality Law (idistr):  a=a <-> true [serial 1131]
 


Theorem (96)                               [serial 1130] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << ma = ma
   and ma.seg[1] = iSeg
   and ma.seg[2] = nSeg
   and 1 = 1 >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 95:
Theorem (95) [serial 1131] used for:
  applied wp for assignment [serial 1130]
 


Theorem (97)                               [serial 1128] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << CMA = ma
   and CMA.seg[1] = iSeg
   and CMA.seg[2] = nSeg
   and 1 = 1 >>
by Guided Substitution of Equals
and theorem 96:
Theorem (96) [serial 1130] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1128]
 


Theorem (98)                               [serial 1126] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << CMA = ma
   and CMA.seg[( 1 )] = iSeg
   and CMA.seg[1 + ( 1 )] = nSeg
   and ( 1 ) = 1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 97:
Theorem (97) [serial 1128] used for:
    normalization of [serial 1126]
 


Theorem (99)                               [serial 1082] 
P [107] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1 >>
by Guided Substitution of Equals
and theorem 98:
Theorem (98) [serial 1126] used for:
  Guided Substitution of Equals
 replacing "i" with its = "( 1 )" in its postcondition [serial 1082]
 


Theorem (100)                               [serial 1071] 
P [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1] >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 99:
Theorem (99) [serial 1082] used for:
    normalization of [serial 1071]
 


Theorem (101)                               [serial 1069] 
P [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 100:
Theorem (100) [serial 1071] used for:
  Law of And-Simplification:  P and true is P [serial 1069]
 


Theorem (102)                               [serial 1066] 
P [107] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and AXIOM_NUM_SEG(ma : ma) >>
S [108] nSeg := ma.seg[2]
Q [109] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_NUM_SEG(ma : CMA) >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 101 101:
Theorem (101) [serial 1069] used for:
   add user-defined axioms to postcondition
 
Theorem (101) [serial 1069] used for:
   add user-defined axioms to postcondition
 


Theorem (103)                               [serial 1016] 
P [100] << m_a'fresh >>
S [101] << AXIOM_CMA_IS_RMA() >>
m_a?(ma)
;
<< ma = CMA >>
i := 1
;
<< i = 1
     and ma = CMA >>
iSeg := ma.seg[1]
;
<< i = 1
     and ma = CMA
     and iSeg = CMA.seg[i]
     and AXIOM_NUM_SEG(ma : ma) >>
nSeg := ma.seg[2]
<< i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_NUM_SEG(ma : CMA) >>
Q [72] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 28 39 45 52 75 102:
Theorem (28) [serial 1061] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1016]
 
Theorem (39) [serial 1062] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1016]
 
Theorem (45) [serial 1063] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]
 
Theorem (52) [serial 1064] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
 
Theorem (75) [serial 1065] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]
 
Theorem (102) [serial 1066] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1016]
 


Theorem (104)                               [serial 1207] 
P [115] << p@now
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  )
   and i < CMA.num_segments >>
S [115] ->
Q [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (105)                               [serial 1206] 
P [115] << p@now
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  )
   and i < CMA.num_segments >>
S [115] ->
Q [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and true
   and true
   and i < CMA.num_segments >>
by Law of And-Simplification:  P and true is P
and theorem 104:
Theorem (104) [serial 1207] used for:
  Law of And-Simplification:  P and true is P [serial 1206]
 


Theorem (106)                               [serial 1207] 
P [115] << p@now
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  )
   and i < CMA.num_segments >>
S [115] ->
Q [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (107)                               [serial 1206] 
P [115] << p@now
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  )
   and i < CMA.num_segments >>
S [115] ->
Q [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and true
   and true
   and i < CMA.num_segments >>
by Law of And-Simplification:  P and true is P
and theorem 106:
Theorem (106) [serial 1207] used for:
  Law of And-Simplification:  P and true is P [serial 1206]
 


Theorem (108)                               [serial 1179] 
P [115] << p@now
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  )
   and i < CMA.num_segments >>
S [115] ->
Q [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 107 107:
Theorem (107) [serial 1206] used for:
   add user-defined axioms to postcondition
 
Theorem (107) [serial 1206] used for:
   add user-defined axioms to postcondition
 


Theorem (109)                               [serial 1171] 
P [115] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments
   and p@now
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [115] ->
Q [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 108:
Theorem (108) [serial 1179] used for:
    normalization of [serial 1171]
 


Theorem (110)                               [serial 1151] 
P [115] << p@now
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  )
   and ( CMA = ma
         and CMA.seg[i] = iSeg
         and CMA.seg[1 + i] = nSeg
         and i < CMA.num_segments ) >>
S [115] ->
Q [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 109:
Theorem (109) [serial 1171] used for:
  Associativity: (b.c).a = a.b.c [serial 1151]
 


Theorem (111)                               [serial 1142] 
P [115] << ( i < CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = CMA.seg[i + 1]
     and ma = CMA )
   and ( p@now )
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [115] ->
Q [116] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_B()
   and AXIOM_E()
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 110:
Theorem (110) [serial 1151] used for:
    normalization of [serial 1142]
 


Theorem (112)                               [serial 1203] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << true >>
by True Conclusion Schema (tc): P->true


Theorem (113)                               [serial 1201] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << ( true ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 112:
Theorem (112) [serial 1203] used for:
    normalization of [serial 1201]
 


Theorem (114)                               [serial 1200] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 113:
Theorem (113) [serial 1201] used for:
  Law of And-Simplification:  P and P is P [serial 1200]
 


Theorem (115)                               [serial 1199] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << ( true )
   and ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 114:
Theorem (114) [serial 1200] used for:
  Law of And-Simplification:  P and P is P [serial 1199]
 


Theorem (116)                               [serial 1198] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 115:
Theorem (115) [serial 1199] used for:
  Law of And-Simplification:  P and P is P [serial 1198]
 


Theorem (117)                               [serial 1197] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 116:
Theorem (116) [serial 1198] used for:
  Law of And-Simplification:  P and P is P [serial 1197]
 


Theorem (118)                               [serial 1196] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 117:
Theorem (117) [serial 1197] used for:
  Law of And-Simplification:  P and P is P [serial 1196]
 


Theorem (119)                               [serial 1195] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << ( ( not ( v < iSeg.v_n ) )
     or ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
     or v < iSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( v < iSeg.v_e
     or ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
     or v < iSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
     or v < iSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( ( not ( v < iSeg.v_n ) )
     or v < iSeg.v_e
     or v < iSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( v < iSeg.v_e
     or v < iSeg.v_e
     or v < iSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_e
     or v < iSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( ( not ( v < iSeg.v_n ) )
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( v < iSeg.v_e
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( ( not ( v < iSeg.v_n ) )
     or ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( v < iSeg.v_e
     or ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( ( not ( v < iSeg.v_n ) )
     or v < iSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( v < iSeg.v_e
     or v < iSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( ( not ( v < iSeg.v_n ) )
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( v < iSeg.v_e
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or ( not ( v < iSeg.v_e ) )
     or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) ) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 118:
Theorem (118) [serial 1196] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1195]
 


Theorem (120)                               [serial 1194] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << ( not ( v < iSeg.v_e ) )
  or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
  or ( ( not ( v < iSeg.v_n ) )
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( v < iSeg.v_n
       and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) >>
by Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 119:
Theorem (119) [serial 1195] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1194]
 


Theorem (121)                               [serial 1153] 
P [116] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [118] ->
Q [118] << iSeg.v_e <= v
  or e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
  or ( iSeg.v_n <= v
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( v < iSeg.v_n
       and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 120:
Theorem (120) [serial 1194] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1153]
 


Theorem (122)                               [serial 1144] 
P [116] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_B()
   and AXIOM_E()
   and ma = CMA >>
S [118] ->
Q [118] << ( v >= iSeg.v_e )
  or ( v * v + 2 * e * p >= ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e )
  or ( v >= iSeg.v_n
       and v < iSeg.v_e
       and v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e )
  or ( v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e
       and v < iSeg.v_e
       and ( v * v + 2 * b * p >= ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ) )
  or ( v < iSeg.v_n
       and ( v * v + 2 * b * p < ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 121:
Theorem (121) [serial 1153] used for:
    normalization of [serial 1144]
 


Theorem (123)                               [serial 1214] 
P [118] << iSeg.v_e <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [119] ->
Q [14] << iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v >>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (124)                               [serial 1212] 
P [118] << iSeg.v_e <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [119] ->
Q [14] << ( ( v >= iSeg.v_e
  or ( v * v + 2 * #CTCS_Property::EB_Rate * p ) >= ( nSeg.v_e * nSeg.v_e + 
2 * #CTCS_Property::EB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 123:
Theorem (123) [serial 1214] used for:
    normalization of [serial 1212]
 


Theorem (125)                               [serial 1211] 
P [118] << iSeg.v_e <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [119] ->
Q [14] << ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 124:
Theorem (124) [serial 1212] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1211]
 


Theorem (126)                               [serial 1208] 
P [118] << iSeg.v_e <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [119] ->
Q [14] << EB() >>
by Substitution of Assertion Labels
and theorem 125:
Theorem (125) [serial 1211] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1208]
 


Theorem (127)                               [serial 1210] 
P [119] << iSeg.v_e <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and EB()@now >>
S [119] ->
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (128)                               [serial 1209] 
P [119] << ( iSeg.v_e <= v
     and CMA = ma
     and CMA.seg[i] = iSeg
     and CMA.seg[1 + i] = nSeg
     and AXIOM_B()
     and AXIOM_E()
     and i < CMA.num_segments )
   and EB()@now >>
S [119] ->
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 127:
Theorem (127) [serial 1210] used for:
  Associativity: (b.c).a = a.b.c [serial 1209]
 


Theorem (129)                               [serial 1181] 
P [118] << iSeg.v_e <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [119] eb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 126 128:
Theorem (126) [serial 1208] used for:
  applied port output <<pre>> -> <<M[eb]>> [serial 1181]
 
Theorem (128) [serial 1209] used for:
  applied port output <<pre and M[eb]@now>> -> <<post>> [serial 1181]
 


Theorem (130)                               [serial 1172] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and iSeg.v_e <= v >>
S [119] eb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 129:
Theorem (129) [serial 1181] used for:
    normalization of [serial 1172]
 


Theorem (131)                               [serial 1155] 
P [118] << iSeg.v_e <= v
   and ( CMA = ma
         and CMA.seg[i] = iSeg
         and CMA.seg[1 + i] = nSeg
         and AXIOM_B()
         and AXIOM_E()
         and i < CMA.num_segments ) >>
S [119] eb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 130:
Theorem (130) [serial 1172] used for:
  Associativity: (b.c).a = a.b.c [serial 1155]
 


Theorem (132)                               [serial 1145] 
P [118] << ( i < CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = CMA.seg[i + 1]
     and AXIOM_B()
     and AXIOM_E()
     and ma = CMA )
   and ( v >= iSeg.v_e ) >>
S [119] eb!
Q [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 131:
Theorem (131) [serial 1155] used for:
    normalization of [serial 1145]
 


Theorem (133)                               [serial 1230] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments >>
S [121] ->
Q [14] << iSeg.v_e <= v
  or e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v >>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (134)                               [serial 1228] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments >>
S [121] ->
Q [14] << iSeg.v_e <= v
  or iSeg.e * 2 * e + nSeg.v_e * nSeg.v_e <= p * 2 * e + v * v >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
and theorem 133:
Theorem (133) [serial 1230] used for:
    normalization of [serial 1228]
 


Theorem (135)                               [serial 1226] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments >>
S [121] ->
Q [14] << iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v >>
by Guided Substitution of Equals
and theorem 134:
Theorem (134) [serial 1228] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 
 ^{# 
  ^{:: CTCS_Property EB_Rate}}}" with its = "e" in its postcondition [serial 1226]
 


Theorem (136)                               [serial 1224] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and i < CMA.num_segments >>
S [121] ->
Q [14] << iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 135:
Theorem (135) [serial 1226] used for:
    normalization of [serial 1224]
 


Theorem (137)                               [serial 1222] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [121] ->
Q [14] << iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v >>
by Substitution of Assertion Labels
and theorem 136:
Theorem (136) [serial 1224] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1222]
 


Theorem (138)                               [serial 1220] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [121] ->
Q [14] << ( ( v >= iSeg.v_e
  or ( v * v + 2 * #CTCS_Property::EB_Rate * p ) >= ( nSeg.v_e * nSeg.v_e + 
2 * #CTCS_Property::EB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 137:
Theorem (137) [serial 1222] used for:
    normalization of [serial 1220]
 


Theorem (139)                               [serial 1219] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [121] ->
Q [14] << ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 138:
Theorem (138) [serial 1220] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1219]
 


Theorem (140)                               [serial 1216] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [121] ->
Q [14] << EB() >>
by Substitution of Assertion Labels
and theorem 139:
Theorem (139) [serial 1219] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1216]
 


Theorem (141)                               [serial 1218] 
P [121] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and EB()@now >>
S [121] ->
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (142)                               [serial 1217] 
P [121] << ( e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
     and CMA = ma
     and CMA.seg[i] = iSeg
     and CMA.seg[1 + i] = nSeg
     and AXIOM_B()
     and AXIOM_E()
     and i < CMA.num_segments )
   and EB()@now >>
S [121] ->
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 141:
Theorem (141) [serial 1218] used for:
  Associativity: (b.c).a = a.b.c [serial 1217]
 


Theorem (143)                               [serial 1183] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [121] eb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 140 142:
Theorem (140) [serial 1216] used for:
  applied port output <<pre>> -> <<M[eb]>> [serial 1183]
 
Theorem (142) [serial 1217] used for:
  applied port output <<pre and M[eb]@now>> -> <<post>> [serial 1183]
 


Theorem (144)                               [serial 1173] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v >>
S [121] eb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 143:
Theorem (143) [serial 1183] used for:
    normalization of [serial 1173]
 


Theorem (145)                               [serial 1157] 
P [118] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and ( CMA = ma
         and CMA.seg[i] = iSeg
         and CMA.seg[1 + i] = nSeg
         and AXIOM_B()
         and AXIOM_E()
         and i < CMA.num_segments ) >>
S [121] eb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 144:
Theorem (144) [serial 1173] used for:
  Associativity: (b.c).a = a.b.c [serial 1157]
 


Theorem (146)                               [serial 1146] 
P [118] << ( i < CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = CMA.seg[i + 1]
     and AXIOM_B()
     and AXIOM_E()
     and ma = CMA )
   and ( v * v + 2 * e * p >= ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e ) >>
S [121] eb!
Q [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 145:
Theorem (145) [serial 1157] used for:
    normalization of [serial 1146]
 


Theorem (147)                               [serial 1240] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << iSeg.v_n <= v
  or iSeg.e * 2 * #CTCS_Property::SB_Rate + nSeg.v_n * nSeg.v_n <= p * 2 * 
#CTCS_Property::SB_Rate + v * v >>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (148)                               [serial 1238] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << ( ( v >= iSeg.v_n
  or ( v * v + 2 * #CTCS_Property::SB_Rate * p ) >= ( nSeg.v_n * nSeg.v_n + 
2 * #CTCS_Property::SB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 147:
Theorem (147) [serial 1240] used for:
    normalization of [serial 1238]
 


Theorem (149)                               [serial 1237] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << ( BRAKE(pos : p, v_l : iSeg.v_n, next_v_l : nSeg.v_n, br : #CTCS_Property::SB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 148:
Theorem (148) [serial 1238] used for:
  Substituted assertions' predicates for labels  [serial 1237]
 


Theorem (150)                               [serial 1235] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << SB() >>
by Substitution of Assertion Labels
and theorem 149:
Theorem (149) [serial 1237] used for:
  Substituted assertions' predicates for labels  [serial 1235]
 


Theorem (151)                               [serial 1254] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and not ( v < iSeg.v_n )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (152)                               [serial 1252] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and not ( v < iSeg.v_n )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << v < iSeg.v_e
   and p * 2 * e + v * v < iSeg.e * 2 * e + nSeg.v_e * nSeg.v_e >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
and theorem 151:
Theorem (151) [serial 1254] used for:
    normalization of [serial 1252]
 


Theorem (153)                               [serial 1250] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and not ( v < iSeg.v_n )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << v < iSeg.v_e
   and p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
   nSeg.v_e * nSeg.v_e >>
by Guided Substitution of Equals
and theorem 152:
Theorem (152) [serial 1252] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 
 ^{# 
  ^{:: CTCS_Property EB_Rate}}}" with its = "e" in its postcondition [serial 1250]
 


Theorem (154)                               [serial 1248] 
P [118] << ( not ( v < iSeg.v_n ) )
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << ( not ( ( not ( v < iSeg.v_e ) ) )
     and not ( ( not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 
     2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e ) ) ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Complement
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 153:
Theorem (153) [serial 1250] used for:
    normalization of [serial 1248]
 


Theorem (155)                               [serial 1247] 
P [118] << ( not ( v < iSeg.v_n ) )
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
  or ( not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
nSeg.v_e * nSeg.v_e ) ) ) >>
by DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 154:
Theorem (154) [serial 1248] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B) [serial 1247]
 


Theorem (156)                               [serial 1245] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << not ( iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v ) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 155:
Theorem (155) [serial 1247] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1245]
 


Theorem (157)                               [serial 1243] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << not ( ( v >= iSeg.v_e
  or ( v * v + 2 * #CTCS_Property::EB_Rate * p ) >= ( nSeg.v_e * nSeg.v_e + 
2 * #CTCS_Property::EB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 156:
Theorem (156) [serial 1245] used for:
    normalization of [serial 1243]
 


Theorem (158)                               [serial 1242] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << not ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 157:
Theorem (157) [serial 1243] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1242]
 


Theorem (159)                               [serial 1236] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << not EB() >>
by Substitution of Assertion Labels
and theorem 158:
Theorem (158) [serial 1242] used for:
  Substituted assertions' predicates for labels  [serial 1236]
 


Theorem (160)                               [serial 1232] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] ->
Q [12] << SB()
   and not EB() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 150 159:
Theorem (150) [serial 1235] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1232]
 
Theorem (159) [serial 1236] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1232]
 


Theorem (161)                               [serial 1234] 
P [123] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and ( SB()
         and not EB() )@now >>
S [123] ->
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (162)                               [serial 1233] 
P [123] << ( iSeg.v_n <= v
     and CMA = ma
     and CMA.seg[i] = iSeg
     and CMA.seg[1 + i] = nSeg
     and AXIOM_B()
     and AXIOM_E()
     and i < CMA.num_segments
     and v < iSeg.v_e
     and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
   and ( SB()
         and not EB() )@now >>
S [123] ->
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 161:
Theorem (161) [serial 1234] used for:
  Associativity: (b.c).a = a.b.c [serial 1233]
 


Theorem (163)                               [serial 1185] 
P [118] << iSeg.v_n <= v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [123] sb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 160 162:
Theorem (160) [serial 1232] used for:
  applied port output <<pre>> -> <<M[sb]>> [serial 1185]
 
Theorem (162) [serial 1233] used for:
  applied port output <<pre and M[sb]@now>> -> <<post>> [serial 1185]
 


Theorem (164)                               [serial 1174] 
P [118] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [123] sb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 163:
Theorem (163) [serial 1185] used for:
    normalization of [serial 1174]
 


Theorem (165)                               [serial 1159] 
P [118] << ( iSeg.v_n <= v
     and v < iSeg.v_e
     and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
   and ( CMA = ma
         and CMA.seg[i] = iSeg
         and CMA.seg[1 + i] = nSeg
         and AXIOM_B()
         and AXIOM_E()
         and i < CMA.num_segments ) >>
S [123] sb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 164:
Theorem (164) [serial 1174] used for:
  Associativity: (b.c).a = a.b.c [serial 1159]
 


Theorem (166)                               [serial 1147] 
P [118] << ( i < CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = CMA.seg[i + 1]
     and AXIOM_B()
     and AXIOM_E()
     and ma = CMA )
   and ( v >= iSeg.v_n
         and v < iSeg.v_e
         and v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e ) >>
S [123] sb!
Q [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 165:
Theorem (165) [serial 1159] used for:
    normalization of [serial 1147]
 


Theorem (167)                               [serial 1269] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << iSeg.v_n <= v
  or b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v >>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (168)                               [serial 1267] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << iSeg.v_n <= v
  or iSeg.e * 2 * b + nSeg.v_n * nSeg.v_n <= p * 2 * b + v * v >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
and theorem 167:
Theorem (167) [serial 1269] used for:
    normalization of [serial 1267]
 


Theorem (169)                               [serial 1265] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << iSeg.v_n <= v
  or iSeg.e * 2 * #CTCS_Property::SB_Rate + nSeg.v_n * nSeg.v_n <= p * 2 * 
#CTCS_Property::SB_Rate + v * v >>
by Guided Substitution of Equals
and theorem 168:
Theorem (168) [serial 1267] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 
 ^{# 
  ^{:: CTCS_Property SB_Rate}}}" with its = "b" in its postcondition [serial 1265]
 


Theorem (170)                               [serial 1263] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << ( ( v >= iSeg.v_n
  or ( v * v + 2 * #CTCS_Property::SB_Rate * p ) >= ( nSeg.v_n * nSeg.v_n + 
2 * #CTCS_Property::SB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 169:
Theorem (169) [serial 1265] used for:
    normalization of [serial 1263]
 


Theorem (171)                               [serial 1262] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << ( ( v >= iSeg.v_n
  or ( v * v + 2 * #CTCS_Property::SB_Rate * p ) >= ( nSeg.v_n * nSeg.v_n + 
2 * #CTCS_Property::SB_Rate * iSeg.e ) ) ) >>
by Substitution of Assertion Labels
and theorem 170:
Theorem (170) [serial 1263] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1262]
 


Theorem (172)                               [serial 1261] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << ( BRAKE(pos : p, v_l : iSeg.v_n, next_v_l : nSeg.v_n, br : #CTCS_Property::SB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 171:
Theorem (171) [serial 1262] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1261]
 


Theorem (173)                               [serial 1259] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << SB() >>
by Substitution of Assertion Labels
and theorem 172:
Theorem (172) [serial 1261] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1259]
 


Theorem (174)                               [serial 1286] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (175)                               [serial 1284] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << v < iSeg.v_e
   and p * 2 * e + v * v < iSeg.e * 2 * e + nSeg.v_e * nSeg.v_e >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
and theorem 174:
Theorem (174) [serial 1286] used for:
    normalization of [serial 1284]
 


Theorem (176)                               [serial 1282] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << v < iSeg.v_e
   and p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
   nSeg.v_e * nSeg.v_e >>
by Guided Substitution of Equals
and theorem 175:
Theorem (175) [serial 1284] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 
 ^{# 
  ^{:: CTCS_Property EB_Rate}}}" with its = "e" in its postcondition [serial 1282]
 


Theorem (177)                               [serial 1280] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
     and not ( not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 
     2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e ) ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Complement
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 176:
Theorem (176) [serial 1282] used for:
    normalization of [serial 1280]
 


Theorem (178)                               [serial 1278] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << not ( not ( v < iSeg.v_e )
  or not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
nSeg.v_e * nSeg.v_e ) ) >>
by DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 177:
Theorem (177) [serial 1280] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B) [serial 1278]
 


Theorem (179)                               [serial 1276] 
P [118] << ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
  or ( not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
nSeg.v_e * nSeg.v_e ) ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 178:
Theorem (178) [serial 1278] used for:
    normalization of [serial 1276]
 


Theorem (180)                               [serial 1274] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << not ( iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v ) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 179:
Theorem (179) [serial 1276] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1274]
 


Theorem (181)                               [serial 1272] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << not ( ( v >= iSeg.v_e
  or ( v * v + 2 * #CTCS_Property::EB_Rate * p ) >= ( nSeg.v_e * nSeg.v_e + 
2 * #CTCS_Property::EB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 180:
Theorem (180) [serial 1274] used for:
    normalization of [serial 1272]
 


Theorem (182)                               [serial 1271] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << not ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 181:
Theorem (181) [serial 1272] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1271]
 


Theorem (183)                               [serial 1260] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << not EB() >>
by Substitution of Assertion Labels
and theorem 182:
Theorem (182) [serial 1271] used for:
  Substituted assertions' predicates for labels  [serial 1260]
 


Theorem (184)                               [serial 1256] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] ->
Q [12] << SB()
   and not EB() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 173 183:
Theorem (173) [serial 1259] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1256]
 
Theorem (183) [serial 1260] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1256]
 


Theorem (185)                               [serial 1258] 
P [126] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and ( SB()
         and not EB() )@now >>
S [126] ->
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (186)                               [serial 1257] 
P [126] << ( b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
     and CMA = ma
     and CMA.seg[i] = iSeg
     and CMA.seg[1 + i] = nSeg
     and AXIOM_B()
     and AXIOM_E()
     and i < CMA.num_segments
     and v < iSeg.v_e
     and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
   and ( SB()
         and not EB() )@now >>
S [126] ->
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 185:
Theorem (185) [serial 1258] used for:
  Associativity: (b.c).a = a.b.c [serial 1257]
 


Theorem (187)                               [serial 1187] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [126] sb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 184 186:
Theorem (184) [serial 1256] used for:
  applied port output <<pre>> -> <<M[sb]>> [serial 1187]
 
Theorem (186) [serial 1257] used for:
  applied port output <<pre and M[sb]@now>> -> <<post>> [serial 1187]
 


Theorem (188)                               [serial 1175] 
P [118] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments >>
S [126] sb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 187:
Theorem (187) [serial 1187] used for:
    normalization of [serial 1175]
 


Theorem (189)                               [serial 1161] 
P [118] << ( b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
     and v < iSeg.v_e
     and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
   and ( CMA = ma
         and CMA.seg[i] = iSeg
         and CMA.seg[1 + i] = nSeg
         and AXIOM_B()
         and AXIOM_E()
         and i < CMA.num_segments ) >>
S [126] sb!
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 188:
Theorem (188) [serial 1175] used for:
  Associativity: (b.c).a = a.b.c [serial 1161]
 


Theorem (190)                               [serial 1148] 
P [118] << ( i < CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = CMA.seg[i + 1]
     and AXIOM_B()
     and AXIOM_E()
     and ma = CMA )
   and ( v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e
         and v < iSeg.v_e
         and ( v * v + 2 * b * p >= ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ) ) >>
S [126] sb!
Q [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 189:
Theorem (189) [serial 1161] used for:
    normalization of [serial 1148]
 


Theorem (191)                               [serial 1205] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_n
   and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n >>
S [128] ->
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (192)                               [serial 1176] 
P [118] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and AXIOM_B()
   and AXIOM_E()
   and i < CMA.num_segments
   and v < iSeg.v_n
   and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n >>
S [128] skip
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>> (bl.skip)
and theorem 191:
Theorem (191) [serial 1205] used for:
    <<P>> -> <<Q>>
  for [serial 1176]
 


Theorem (193)                               [serial 1163] 
P [118] << ( CMA = ma
     and CMA.seg[i] = iSeg
     and CMA.seg[1 + i] = nSeg
     and AXIOM_B()
     and AXIOM_E()
     and i < CMA.num_segments )
   and ( v < iSeg.v_n
         and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) >>
S [128] skip
Q [74] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Associativity: (b.c).a = a.b.c
and theorem 192:
Theorem (192) [serial 1176] used for:
  Associativity: (b.c).a = a.b.c [serial 1163]
 


Theorem (194)                               [serial 1149] 
P [118] << ( i < CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = CMA.seg[i + 1]
     and AXIOM_B()
     and AXIOM_E()
     and ma = CMA )
   and ( v < iSeg.v_n
         and ( v * v + 2 * b * p < ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ) ) >>
S [128] skip
Q [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 193:
Theorem (193) [serial 1163] used for:
    normalization of [serial 1149]
 


Theorem (195)                               [serial 1143] 
P [116] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_B()
   and AXIOM_E()
   and ma = CMA >>
S [118] if 
(v >= iSeg.v_e)~> 
  eb! 
[]
(v * v + 2 * e * p >= ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e)~> 
  eb! 
[]
(v >= iSeg.v_n
    and v < iSeg.v_e
    and v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e)~> 
  sb! 
[]
(v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e
    and v < iSeg.v_e
    and ( v * v + 2 * b * p >= ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ))~> 
  sb! 
[]
(v < iSeg.v_n
    and ( v * v + 2 * b * p < ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ))~> 
  skip 
fi
Q [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 122 132 146 166 190 194:
Theorem (122) [serial 1144] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1143]
 
Theorem (132) [serial 1145] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1143]
 
Theorem (146) [serial 1146] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1143]
 
Theorem (166) [serial 1147] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1143]
 
Theorem (190) [serial 1148] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1143]
 
Theorem (194) [serial 1149] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1143]
 


Theorem (196)                               [serial 1017] 
P [115] << ( i < CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = CMA.seg[i + 1]
     and ma = CMA )
   and ( p@now )
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [116] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_B()
   and AXIOM_E()
   and ma = CMA >>
if 
(v >= iSeg.v_e)~> 
  eb! 
[]
(v * v + 2 * e * p >= ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e)~> 
  eb! 
[]
(v >= iSeg.v_n
    and v < iSeg.v_e
    and v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e)~> 
  sb! 
[]
(v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e
    and v < iSeg.v_e
    and ( v * v + 2 * b * p >= ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ))~> 
  sb! 
[]
(v < iSeg.v_n
    and ( v * v + 2 * b * p < ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ))~> 
  skip 
fi
Q [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Introduction of Existential Quantification (bl.aapre)
and theorems 111 195:
Theorem (111) [serial 1142] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1017]
 
Theorem (195) [serial 1143] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1017]
 


Theorem (197)                               [serial 1018] 
P [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA
   and ( p < iSeg.e ) >>
S [132] ->
Q [72] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (198)                               [serial 1293] 
P [74] << iSeg.e <= p
   and CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
S [139] ->
Q [140] << CMA = ma
   and CMA.seg[1 + i] = nSeg >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (199)                               [serial 1290] 
P [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA
   and ( p >= iSeg.e ) >>
S [139] ->
Q [140] << nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 198:
Theorem (198) [serial 1293] used for:
    normalization of [serial 1290]
 


Theorem (200)                               [serial 1288] 
P [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA
   and ( p >= iSeg.e ) >>
S [139] iSeg := nSeg
Q [140] << iSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 199:
Theorem (199) [serial 1290] used for:
  applied wp for assignment [serial 1288]
 


Theorem (201)                               [serial 1295] 
P [140] << CMA = ma
   and CMA.seg[1 + i] = iSeg >>
S [141] ->
Q [76] << CMA = ma
   and CMA.seg[1 + i] = iSeg >>
by Identity (id):  P->P is tautology


Theorem (202)                               [serial 1291] 
P [140] << iSeg = CMA.seg[i + 1]
   and ma = CMA >>
S [141] ->
Q [76] << iSeg = CMA.seg[( i + 1 )]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 201:
Theorem (201) [serial 1295] used for:
    normalization of [serial 1291]
 


Theorem (203)                               [serial 1289] 
P [140] << iSeg = CMA.seg[i + 1]
   and ma = CMA >>
S [141] i := i + 1
Q [76] << iSeg = CMA.seg[i]
   and ma = CMA >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 202:
Theorem (202) [serial 1291] used for:
  applied wp for assignment [serial 1289]
 


Theorem (204)                               [serial 1019] 
P [74] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA
   and ( p >= iSeg.e ) >>
S [139] iSeg := nSeg
;
<< iSeg = CMA.seg[i + 1]
     and ma = CMA >>
i := i + 1
Q [76] << iSeg = CMA.seg[i]
   and ma = CMA >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 200 203:
Theorem (200) [serial 1288] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]
 
Theorem (203) [serial 1289] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1019]
 


Theorem (205)                               [serial 1302] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg
   and i < ma.num_segments >>
S [147] ->
Q [72] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (206)                               [serial 1303] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg
   and i < ma.num_segments >>
S [147] ->
Q [72] << CMA.seg[i] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (207)                               [serial 1308] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg
   and i < ma.num_segments >>
S [147] ->
Q [72] << true >>
by True Conclusion Schema (tc): P->true


Theorem (208)                               [serial 1306] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg
   and i < ma.num_segments >>
S [147] ->
Q [72] << ma.seg[1 + i] = ma.seg[1 + i] >>
by Equality Law (idistr):  a=a <-> true
and theorem 207:
Theorem (207) [serial 1308] used for:
  Equality Law (idistr):  a=a <-> true [serial 1306]
 


Theorem (209)                               [serial 1304] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg
   and i < ma.num_segments >>
S [147] ->
Q [72] << CMA.seg[1 + i] = ma.seg[1 + i] >>
by Guided Substitution of Equals
and theorem 208:
Theorem (208) [serial 1306] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1304]
 


Theorem (210)                               [serial 1307] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg
   and i < ma.num_segments >>
S [147] ->
Q [72] << i < ma.num_segments >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (211)                               [serial 1305] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg
   and i < ma.num_segments >>
S [147] ->
Q [72] << i < CMA.num_segments >>
by Guided Substitution of Equals
and theorem 210:
Theorem (210) [serial 1307] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1305]
 


Theorem (212)                               [serial 1300] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg
   and i < ma.num_segments >>
S [147] ->
Q [72] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = ma.seg[1 + i]
   and i < CMA.num_segments >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 205 206 209 211:
Theorem (205) [serial 1302] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1300]
 
Theorem (206) [serial 1303] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1300]
 
Theorem (209) [serial 1304] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1300]
 
Theorem (211) [serial 1305] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1300]
 


Theorem (213)                               [serial 1298] 
P [76] << iSeg = CMA.seg[i]
   and ma = CMA
   and ( i < ma.num_segments ) >>
S [147] ->
Q [72] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and ma.seg[i + 1] = CMA.seg[i + 1]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 212:
Theorem (212) [serial 1300] used for:
    normalization of [serial 1298]
 


Theorem (214)                               [serial 1020] 
P [76] << iSeg = CMA.seg[i]
   and ma = CMA
   and ( i < ma.num_segments ) >>
S [147] nSeg := ma.seg[i + 1]
Q [72] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 213:
Theorem (213) [serial 1298] used for:
  applied wp for assignment [serial 1020]
 


Theorem (215)                               [serial 1315] 
P [76] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = ma.num_segments >>
S [153] ->
Q [153] << true >>
by True Conclusion Schema (tc): P->true


Theorem (216)                               [serial 1311] 
P [76] << iSeg = CMA.seg[i]
   and ma = CMA
   and ( i = ma.num_segments ) >>
S [153] ->
Q [153] << true >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 215:
Theorem (215) [serial 1315] used for:
    normalization of [serial 1311]
 


Theorem (217)                               [serial 1333] 
P [153] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = ma.num_segments >>
S [153] ->
Q [154] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (218)                               [serial 1328] 
P [153] << ( ( CMA = ma
       and CMA.seg[i] = iSeg
       and i = ma.num_segments ) ) >>
S [153] ->
Q [154] << CMA = ma >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 217:
Theorem (217) [serial 1333] used for:
    normalization of [serial 1328]
 


Theorem (219)                               [serial 1344] 
P [153] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = ma.num_segments >>
S [153] ->
Q [154] << i = ma.num_segments >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (220)                               [serial 1341] 
P [153] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = ma.num_segments >>
S [153] ->
Q [154] << ma.num_segments = i >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorem 219:
Theorem (219) [serial 1344] used for:
    normalization of [serial 1341]
 


Theorem (221)                               [serial 1335] 
P [153] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = ma.num_segments >>
S [153] ->
Q [154] << CMA.num_segments = i >>
by Guided Substitution of Equals
and theorem 220:
Theorem (220) [serial 1341] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1335]
 


Theorem (222)                               [serial 1329] 
P [153] << ( ( CMA = ma
       and CMA.seg[i] = iSeg
       and i = ma.num_segments ) ) >>
S [153] ->
Q [154] << CMA.num_segments = i >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 221:
Theorem (221) [serial 1335] used for:
    normalization of [serial 1329]
 


Theorem (223)                               [serial 1337] 
P [153] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = ma.num_segments >>
S [153] ->
Q [154] << CMA.seg[i] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (224)                               [serial 1330] 
P [153] << ( ( CMA = ma
       and CMA.seg[i] = iSeg
       and i = ma.num_segments ) ) >>
S [153] ->
Q [154] << CMA.seg[i] = iSeg >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 223:
Theorem (223) [serial 1337] used for:
    normalization of [serial 1330]
 


Theorem (225)                               [serial 1323] 
P [153] << ( ( CMA = ma
       and CMA.seg[i] = iSeg
       and i = ma.num_segments ) ) >>
S [153] ->
Q [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 218 222 224:
Theorem (218) [serial 1328] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1323]
 
Theorem (222) [serial 1329] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1323]
 
Theorem (224) [serial 1330] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1323]
 


Theorem (226)                               [serial 1317] 
P [153] << true
   and ( CMA = ma
         and CMA.seg[i] = iSeg
         and i = ma.num_segments ) >>
S [153] ->
Q [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
by Law of And-Simplification:  P and true is P
and theorem 225:
Theorem (225) [serial 1323] used for:
  Law of And-Simplification:  P and true is P [serial 1317]
 


Theorem (227)                               [serial 1312] 
P [153] << ( iSeg = CMA.seg[i]
     and ma = CMA
     and ( i = ma.num_segments ) )
   and true@now >>
S [153] ->
Q [154] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Constants are always the same
and theorem 226:
Theorem (226) [serial 1317] used for:
    normalization of [serial 1312]
 


Theorem (228)                               [serial 1309] 
P [76] << iSeg = CMA.seg[i]
   and ma = CMA
   and ( i = ma.num_segments ) >>
S [153] r!
Q [154] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and ma = CMA >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 216 227:
Theorem (216) [serial 1311] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1309]
 
Theorem (227) [serial 1312] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1309]
 


Theorem (229)                               [serial 1324] 
P [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
S [156] ->
Q [78] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (230)                               [serial 1325] 
P [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
S [156] ->
Q [78] << CMA.num_segments = i >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (231)                               [serial 1326] 
P [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
S [156] ->
Q [78] << CMA.seg[i] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (232)                               [serial 1348] 
P [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
S [156] ->
Q [78] << true >>
by True Conclusion Schema (tc): P->true


Theorem (233)                               [serial 1347] 
P [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
S [156] ->
Q [78] << ( [segment: v_n->0 kph; v_e->0 kph; e->ma.ea; m->trainModes'FS;] ) = [segment: 
v_n->0 kph; v_e->0 kph; e->ma.ea; m->trainModes'FS;] >>
by Equality Law (idistr):  a=a <-> true
and theorem 232:
Theorem (232) [serial 1348] used for:
  Equality Law (idistr):  a=a <-> true [serial 1347]
 


Theorem (234)                               [serial 1346] 
P [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
S [156] ->
Q [78] << ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] ) = [segment: 
v_n->0 kph; v_e->0 kph; e->ma.ea; m->trainModes'FS;] >>
by Guided Substitution of Equals
and theorem 233:
Theorem (233) [serial 1347] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1346]
 


Theorem (235)                               [serial 1327] 
P [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
S [156] ->
Q [78] << NULL_SEGMENT() = [segment: v_n->0 kph; v_e->0 kph; e->ma.ea; m->trainModes'FS;] >>
by Substitution of Assertion Labels
and theorem 234:
Theorem (234) [serial 1346] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1327]
 


Theorem (236)                               [serial 1319] 
P [154] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
S [156] ->
Q [78] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NULL_SEGMENT() = [segment: v_n->0 kph; v_e->0 kph; e->ma.ea; m->trainModes'FS;] >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 229 230 231 235:
Theorem (229) [serial 1324] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1319]
 
Theorem (230) [serial 1325] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1319]
 
Theorem (231) [serial 1326] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1319]
 
Theorem (235) [serial 1327] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1319]
 


Theorem (237)                               [serial 1313] 
P [154] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and ma = CMA >>
S [156] ->
Q [78] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and ( [segment: v_n->0 kph; v_e->0 kph; e->ma.ea; m->trainModes'FS;] ) = NULL_SEGMENT()
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 236:
Theorem (236) [serial 1319] used for:
    normalization of [serial 1313]
 


Theorem (238)                               [serial 1310] 
P [154] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and ma = CMA >>
S [156] nSeg := [segment: v_n->0 kph; v_e->0 kph; e->ma.ea; m->trainModes'FS;]
Q [78] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 237:
Theorem (237) [serial 1313] used for:
  applied wp for assignment [serial 1310]
 


Theorem (239)                               [serial 1021] 
P [76] << iSeg = CMA.seg[i]
   and ma = CMA
   and ( i = ma.num_segments ) >>
S [153] r!
;
<< i = CMA.num_segments
     and iSeg = CMA.seg[i]
     and ma = CMA >>
nSeg := [segment: v_n->0 kph; v_e->0 kph; e->ma.ea; m->trainModes'FS;]
Q [78] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 228 238:
Theorem (228) [serial 1309] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1021]
 
Theorem (238) [serial 1310] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1021]
 


Theorem (240)                               [serial 1022] 
P [76] << iSeg = CMA.seg[i]
   and ma = CMA
   and ( i > ma.num_segments ) >>
S [163] ->
Q [86] << true >>
by True Conclusion Schema (tc): P->true


Theorem (241)                               [serial 1385] 
P [167] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and p@now
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [167] ->
Q [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (242)                               [serial 1384] 
P [167] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and p@now
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [167] ->
Q [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and true
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 241:
Theorem (241) [serial 1385] used for:
  Law of And-Simplification:  P and true is P [serial 1384]
 


Theorem (243)                               [serial 1385] 
P [167] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and p@now
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [167] ->
Q [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (244)                               [serial 1384] 
P [167] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and p@now
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [167] ->
Q [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and true
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 243:
Theorem (243) [serial 1385] used for:
  Law of And-Simplification:  P and true is P [serial 1384]
 


Theorem (245)                               [serial 1378] 
P [167] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and p@now
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [167] ->
Q [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 244 244:
Theorem (244) [serial 1384] used for:
   add user-defined axioms to postcondition
 
Theorem (244) [serial 1384] used for:
   add user-defined axioms to postcondition
 


Theorem (246)                               [serial 1358] 
P [167] << p@now
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  )
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and nSeg = NULL_SEGMENT() ) >>
S [167] ->
Q [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
by Associativity: (b.c).a = a.b.c
and theorem 245:
Theorem (245) [serial 1378] used for:
  Associativity: (b.c).a = a.b.c [serial 1358]
 


Theorem (247)                               [serial 1349] 
P [167] << ( i = CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = NULL_SEGMENT()
     and ma = CMA )
   and ( p@now )
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [167] ->
Q [168] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA
   and AXIOM_B()
   and AXIOM_E() >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 246:
Theorem (246) [serial 1358] used for:
    normalization of [serial 1349]
 


Theorem (248)                               [serial 1398] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << true >>
by True Conclusion Schema (tc): P->true


Theorem (249)                               [serial 1396] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << ( true ) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 248:
Theorem (248) [serial 1398] used for:
    normalization of [serial 1396]
 


Theorem (250)                               [serial 1395] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 249:
Theorem (249) [serial 1396] used for:
  Law of And-Simplification:  P and P is P [serial 1395]
 


Theorem (251)                               [serial 1394] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << ( true )
   and ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 250:
Theorem (250) [serial 1395] used for:
  Law of And-Simplification:  P and P is P [serial 1394]
 


Theorem (252)                               [serial 1393] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 251:
Theorem (251) [serial 1394] used for:
  Law of And-Simplification:  P and P is P [serial 1393]
 


Theorem (253)                               [serial 1392] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 252:
Theorem (252) [serial 1393] used for:
  Law of And-Simplification:  P and P is P [serial 1392]
 


Theorem (254)                               [serial 1391] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true )
   and ( true ) >>
by Law of And-Simplification:  P and P is P
and theorem 253:
Theorem (253) [serial 1392] used for:
  Law of And-Simplification:  P and P is P [serial 1391]
 


Theorem (255)                               [serial 1390] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << ( not ( v < iSeg.v_n )
     or not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
     or v < iSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( v < iSeg.v_e
     or not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
     or v < iSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
     or v < iSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( not ( v < iSeg.v_n )
     or v < iSeg.v_e
     or v < iSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( v < iSeg.v_e
     or v < iSeg.v_e
     or v < iSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_e
     or v < iSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( not ( v < iSeg.v_n )
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( v < iSeg.v_e
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( not ( v < iSeg.v_n )
     or not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( v < iSeg.v_e
     or not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( not ( v < iSeg.v_n )
     or v < iSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( v < iSeg.v_e
     or v < iSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or v < iSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( not ( v < iSeg.v_n )
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( v < iSeg.v_e
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
   and ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     or b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n
     or not ( v < iSeg.v_e )
     or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) ) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 254:
Theorem (254) [serial 1391] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1390]
 


Theorem (256)                               [serial 1388] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << not ( v < iSeg.v_e )
  or not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( not ( v < iSeg.v_n )
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( v < iSeg.v_n
       and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) >>
by Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 255:
Theorem (255) [serial 1390] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1388]
 


Theorem (257)                               [serial 1386] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << ( not ( v < iSeg.v_e ) )
  or ( not ( e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e ) )
  or ( ( not ( v < iSeg.v_n ) )
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( v < iSeg.v_n
       and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 256:
Theorem (256) [serial 1388] used for:
    normalization of [serial 1386]
 


Theorem (258)                               [serial 1360] 
P [168] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << iSeg.v_e <= v
  or e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
  or ( iSeg.v_n <= v
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
       and v < iSeg.v_e
       and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
  or ( v < iSeg.v_n
       and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 257:
Theorem (257) [serial 1386] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1360]
 


Theorem (259)                               [serial 1351] 
P [168] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA
   and AXIOM_B()
   and AXIOM_E() >>
S [170] ->
Q [170] << ( v >= iSeg.v_e )
  or ( v * v + 2 * e * p >= ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e )
  or ( v >= iSeg.v_n
       and v < iSeg.v_e
       and v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e )
  or ( v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e
       and v < iSeg.v_e
       and ( v * v + 2 * b * p >= ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ) )
  or ( v < iSeg.v_n
       and ( v * v + 2 * b * p < ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 258:
Theorem (258) [serial 1360] used for:
    normalization of [serial 1351]
 


Theorem (260)                               [serial 1406] 
P [170] << iSeg.v_e <= v
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] >>
S [171] ->
Q [14] << iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v >>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (261)                               [serial 1404] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and iSeg.v_e <= v >>
S [171] ->
Q [14] << ( ( v >= iSeg.v_e
  or ( v * v + 2 * #CTCS_Property::EB_Rate * p ) >= ( nSeg.v_e * nSeg.v_e + 
2 * #CTCS_Property::EB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 260:
Theorem (260) [serial 1406] used for:
    normalization of [serial 1404]
 


Theorem (262)                               [serial 1403] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and iSeg.v_e <= v >>
S [171] ->
Q [14] << ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 261:
Theorem (261) [serial 1404] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1403]
 


Theorem (263)                               [serial 1400] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E()
   and iSeg.v_e <= v >>
S [171] ->
Q [14] << EB() >>
by Substitution of Assertion Labels
and theorem 262:
Theorem (262) [serial 1403] used for:
  Substituted assertions' predicates for labels  [serial 1400]
 


Theorem (264)                               [serial 1402] 
P [171] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E()
   and iSeg.v_e <= v
   and EB()@now >>
S [171] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (265)                               [serial 1401] 
P [171] << ( CMA = ma
     and CMA.num_segments = i
     and CMA.seg[i] = iSeg
     and nSeg = NULL_SEGMENT()
     and AXIOM_B()
     and AXIOM_E()
     and iSeg.v_e <= v )
   and EB()@now >>
S [171] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Associativity: (b.c).a = a.b.c
and theorem 264:
Theorem (264) [serial 1402] used for:
  Associativity: (b.c).a = a.b.c [serial 1401]
 


Theorem (266)                               [serial 1379] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E()
   and iSeg.v_e <= v >>
S [171] eb!
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 263 265:
Theorem (263) [serial 1400] used for:
  applied port output <<pre>> -> <<M[eb]>> [serial 1379]
 
Theorem (265) [serial 1401] used for:
  applied port output <<pre and M[eb]@now>> -> <<post>> [serial 1379]
 


Theorem (267)                               [serial 1362] 
P [170] << iSeg.v_e <= v
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and nSeg = NULL_SEGMENT()
         and AXIOM_B()
         and AXIOM_E() ) >>
S [171] eb!
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Associativity: (b.c).a = a.b.c
and theorem 266:
Theorem (266) [serial 1379] used for:
  Associativity: (b.c).a = a.b.c [serial 1362]
 


Theorem (268)                               [serial 1352] 
P [170] << ( i = CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = NULL_SEGMENT()
     and ma = CMA
     and AXIOM_B()
     and AXIOM_E() )
   and ( v >= iSeg.v_e ) >>
S [171] eb!
Q [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 267:
Theorem (267) [serial 1362] used for:
    normalization of [serial 1352]
 


Theorem (269)                               [serial 1422] 
P [170] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] >>
S [173] ->
Q [14] << iSeg.v_e <= v
  or e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v >>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (270)                               [serial 1419] 
P [170] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] >>
S [173] ->
Q [14] << iSeg.v_e <= v
  or iSeg.e * 2 * e + nSeg.v_e * nSeg.v_e <= p * 2 * e + v * v >>
by Normalization
  Normalization Axiom:
    Reflexivity of Multiplication: a*b=b*a
and theorem 269:
Theorem (269) [serial 1422] used for:
    normalization of [serial 1419]
 


Theorem (271)                               [serial 1416] 
P [170] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] >>
S [173] ->
Q [14] << iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v >>
by Guided Substitution of Equals
and theorem 270:
Theorem (270) [serial 1419] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 
 ^{# 
  ^{:: CTCS_Property EB_Rate}}}" with its = "e" in its postcondition [serial 1416]
 


Theorem (272)                               [serial 1412] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v >>
S [173] ->
Q [14] << ( ( v >= iSeg.v_e
  or ( v * v + 2 * #CTCS_Property::EB_Rate * p ) >= ( nSeg.v_e * nSeg.v_e + 
2 * #CTCS_Property::EB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 271:
Theorem (271) [serial 1416] used for:
    normalization of [serial 1412]
 


Theorem (273)                               [serial 1410] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate )
   and e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v >>
S [173] ->
Q [14] << ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 272:
Theorem (272) [serial 1412] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1410]
 


Theorem (274)                               [serial 1408] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E()
   and e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v >>
S [173] ->
Q [14] << EB() >>
by Substitution of Assertion Labels
and theorem 273:
Theorem (273) [serial 1410] used for:
  Substituted assertions' predicates for labels  [serial 1408]
 


Theorem (275)                               [serial 1424] 
P [173] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) )@now >>
S [173] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (276)                               [serial 1414] 
P [173] << ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) )@now
   and ( e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
         and CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and b = #CTCS_Property::SB_Rate
         and e = #CTCS_Property::EB_Rate
         and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] ) >>
S [173] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] >>
by Associativity: (b.c).a = a.b.c
and theorem 275:
Theorem (275) [serial 1424] used for:
  Associativity: (b.c).a = a.b.c [serial 1414]
 


Theorem (277)                               [serial 1411] 
P [173] << ( CMA = ma
     and CMA.num_segments = i
     and CMA.seg[i] = iSeg
     and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
     and ( b = #CTCS_Property::SB_Rate )
     and ( e = #CTCS_Property::EB_Rate )
     and e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v )
   and ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) )@now >>
S [173] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 276:
Theorem (276) [serial 1414] used for:
    normalization of [serial 1411]
 


Theorem (278)                               [serial 1409] 
P [173] << ( CMA = ma
     and CMA.num_segments = i
     and CMA.seg[i] = iSeg
     and nSeg = NULL_SEGMENT()
     and AXIOM_B()
     and AXIOM_E()
     and e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v )
   and EB()@now >>
S [173] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Substitution of Assertion Labels
and theorem 277:
Theorem (277) [serial 1411] used for:
  Substituted assertions' predicates for labels  [serial 1409]
 


Theorem (279)                               [serial 1380] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E()
   and e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v >>
S [173] eb!
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 274 278:
Theorem (274) [serial 1408] used for:
  applied port output <<pre>> -> <<M[eb]>> [serial 1380]
 
Theorem (278) [serial 1409] used for:
  applied port output <<pre and M[eb]@now>> -> <<post>> [serial 1380]
 


Theorem (280)                               [serial 1364] 
P [170] << e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e <= e * p * 2 + v * v
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and nSeg = NULL_SEGMENT()
         and AXIOM_B()
         and AXIOM_E() ) >>
S [173] eb!
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Associativity: (b.c).a = a.b.c
and theorem 279:
Theorem (279) [serial 1380] used for:
  Associativity: (b.c).a = a.b.c [serial 1364]
 


Theorem (281)                               [serial 1353] 
P [170] << ( i = CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = NULL_SEGMENT()
     and ma = CMA
     and AXIOM_B()
     and AXIOM_E() )
   and ( v * v + 2 * e * p >= ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e ) >>
S [173] eb!
Q [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 280:
Theorem (280) [serial 1364] used for:
    normalization of [serial 1353]
 


Theorem (282)                               [serial 1433] 
P [170] << iSeg.v_n <= v
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [12] << iSeg.v_n <= v
  or iSeg.e * 2 * #CTCS_Property::SB_Rate + nSeg.v_n * nSeg.v_n <= p * 2 * 
#CTCS_Property::SB_Rate + v * v >>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (283)                               [serial 1431] 
P [170] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate ) >>
S [175] ->
Q [12] << ( ( v >= iSeg.v_n
  or ( v * v + 2 * #CTCS_Property::SB_Rate * p ) >= ( nSeg.v_n * nSeg.v_n + 
2 * #CTCS_Property::SB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 282:
Theorem (282) [serial 1433] used for:
    normalization of [serial 1431]
 


Theorem (284)                               [serial 1430] 
P [170] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate ) >>
S [175] ->
Q [12] << ( BRAKE(pos : p, v_l : iSeg.v_n, next_v_l : nSeg.v_n, br : #CTCS_Property::SB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 283:
Theorem (283) [serial 1431] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1430]
 


Theorem (285)                               [serial 1428] 
P [170] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [175] ->
Q [12] << SB() >>
by Substitution of Assertion Labels
and theorem 284:
Theorem (284) [serial 1430] used for:
  Substituted assertions' predicates for labels  [serial 1428]
 


Theorem (286)                               [serial 1448] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( v < iSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [74] << v < iSeg.v_e >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (287)                               [serial 1452] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( v < iSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [74] << e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (288)                               [serial 1450] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( v < iSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [74] << p * 2 * e + v * v < iSeg.e * 2 * e + nSeg.v_e * nSeg.v_e >>
by Normalization
  Normalization Axiom:
    Reflexivity of Multiplication: a*b=b*a
and theorem 287:
Theorem (287) [serial 1452] used for:
    normalization of [serial 1450]
 


Theorem (289)                               [serial 1449] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( v < iSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [74] << p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
nSeg.v_e * nSeg.v_e >>
by Guided Substitution of Equals
and theorem 288:
Theorem (288) [serial 1450] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 
 ^{# 
  ^{:: CTCS_Property EB_Rate}}}" with its = "e" in its postcondition [serial 1449]
 


Theorem (290)                               [serial 1446] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( v < iSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [12] << v < iSeg.v_e
   and p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
   nSeg.v_e * nSeg.v_e >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 286 289:
Theorem (286) [serial 1448] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1446]
 
Theorem (289) [serial 1449] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1446]
 


Theorem (291)                               [serial 1444] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( v < iSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
     and not ( not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 
     2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e ) ) ) >>
by Normalization
  Normalization Axioms:
    Complement
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 290:
Theorem (290) [serial 1446] used for:
    normalization of [serial 1444]
 


Theorem (292)                               [serial 1442] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( v < iSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [12] << not ( not ( v < iSeg.v_e )
  or not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
nSeg.v_e * nSeg.v_e ) ) >>
by DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 291:
Theorem (291) [serial 1444] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B) [serial 1442]
 


Theorem (293)                               [serial 1440] 
P [170] << ( not ( v < iSeg.v_n ) )
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
  or ( not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
nSeg.v_e * nSeg.v_e ) ) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 292:
Theorem (292) [serial 1442] used for:
    normalization of [serial 1440]
 


Theorem (294)                               [serial 1438] 
P [170] << iSeg.v_n <= v
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [175] ->
Q [12] << not ( iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v ) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 293:
Theorem (293) [serial 1440] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1438]
 


Theorem (295)                               [serial 1436] 
P [170] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate ) >>
S [175] ->
Q [12] << not ( ( v >= iSeg.v_e
  or ( v * v + 2 * #CTCS_Property::EB_Rate * p ) >= ( nSeg.v_e * nSeg.v_e + 
2 * #CTCS_Property::EB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 294:
Theorem (294) [serial 1438] used for:
    normalization of [serial 1436]
 


Theorem (296)                               [serial 1435] 
P [170] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate ) >>
S [175] ->
Q [12] << not ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 295:
Theorem (295) [serial 1436] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1435]
 


Theorem (297)                               [serial 1429] 
P [170] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [175] ->
Q [12] << not EB() >>
by Substitution of Assertion Labels
and theorem 296:
Theorem (296) [serial 1435] used for:
  Substituted assertions' predicates for labels  [serial 1429]
 


Theorem (298)                               [serial 1425] 
P [170] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [175] ->
Q [12] << SB()
   and not EB() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 285 297:
Theorem (285) [serial 1428] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1425]
 
Theorem (297) [serial 1429] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1425]
 


Theorem (299)                               [serial 1427] 
P [175] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E()
   and ( SB()
         and not EB() )@now >>
S [175] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (300)                               [serial 1426] 
P [175] << ( iSeg.v_n <= v
     and v < iSeg.v_e
     and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     and CMA = ma
     and CMA.num_segments = i
     and CMA.seg[i] = iSeg
     and nSeg = NULL_SEGMENT()
     and AXIOM_B()
     and AXIOM_E() )
   and ( SB()
         and not EB() )@now >>
S [175] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Associativity: (b.c).a = a.b.c
and theorem 299:
Theorem (299) [serial 1427] used for:
  Associativity: (b.c).a = a.b.c [serial 1426]
 


Theorem (301)                               [serial 1381] 
P [170] << iSeg.v_n <= v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [175] sb!
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 298 300:
Theorem (298) [serial 1425] used for:
  applied port output <<pre>> -> <<M[sb]>> [serial 1381]
 
Theorem (300) [serial 1426] used for:
  applied port output <<pre and M[sb]@now>> -> <<post>> [serial 1381]
 


Theorem (302)                               [serial 1366] 
P [170] << ( iSeg.v_n <= v
     and v < iSeg.v_e
     and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and nSeg = NULL_SEGMENT()
         and AXIOM_B()
         and AXIOM_E() ) >>
S [175] sb!
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Associativity: (b.c).a = a.b.c
and theorem 301:
Theorem (301) [serial 1381] used for:
  Associativity: (b.c).a = a.b.c [serial 1366]
 


Theorem (303)                               [serial 1354] 
P [170] << ( i = CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = NULL_SEGMENT()
     and ma = CMA
     and AXIOM_B()
     and AXIOM_E() )
   and ( v >= iSeg.v_n
         and v < iSeg.v_e
         and v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e ) >>
S [175] sb!
Q [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 302:
Theorem (302) [serial 1366] used for:
    normalization of [serial 1354]
 


Theorem (304)                               [serial 1463] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [178] ->
Q [12] << iSeg.v_n <= v
  or b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v >>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (305)                               [serial 1461] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate ) >>
S [178] ->
Q [12] << ( ( v >= iSeg.v_n
  or ( v * v + 2 * b * p ) >= ( nSeg.v_n * nSeg.v_n + 2 * b * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 304:
Theorem (304) [serial 1463] used for:
    normalization of [serial 1461]
 


Theorem (306)                               [serial 1460] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate ) >>
S [178] ->
Q [12] << ( ( v >= iSeg.v_n
  or ( v * v + 2 * #CTCS_Property::SB_Rate * p ) >= ( nSeg.v_n * nSeg.v_n + 
2 * #CTCS_Property::SB_Rate * iSeg.e ) ) ) >>
by Guided Substitution of Equals
and theorem 305:
Theorem (305) [serial 1461] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 
 ^{# 
  ^{:: CTCS_Property SB_Rate}}}" with its = "b" in its postcondition [serial 1460]
 


Theorem (307)                               [serial 1459] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate ) >>
S [178] ->
Q [12] << ( BRAKE(pos : p, v_l : iSeg.v_n, next_v_l : nSeg.v_n, br : #CTCS_Property::SB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 306:
Theorem (306) [serial 1460] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1459]
 


Theorem (308)                               [serial 1457] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [178] ->
Q [12] << SB() >>
by Substitution of Assertion Labels
and theorem 307:
Theorem (307) [serial 1459] used for:
  Substituted assertions' predicates for labels  [serial 1457]
 


Theorem (309)                               [serial 1480] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [178] ->
Q [12] << v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (310)                               [serial 1478] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [178] ->
Q [12] << v < iSeg.v_e
   and p * 2 * e + v * v < iSeg.e * 2 * e + nSeg.v_e * nSeg.v_e >>
by Normalization
  Normalization Axiom:
    Reflexivity of Multiplication: a*b=b*a
and theorem 309:
Theorem (309) [serial 1480] used for:
    normalization of [serial 1478]
 


Theorem (311)                               [serial 1476] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [178] ->
Q [12] << v < iSeg.v_e
   and p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
   nSeg.v_e * nSeg.v_e >>
by Guided Substitution of Equals
and theorem 310:
Theorem (310) [serial 1478] used for:
  Guided Substitution of Equals
 replacing "
^{QUANTITY 
 ^{# 
  ^{:: CTCS_Property EB_Rate}}}" with its = "e" in its postcondition [serial 1476]
 


Theorem (312)                               [serial 1474] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [178] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
     and not ( not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 
     2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e ) ) ) >>
by Normalization
  Normalization Axioms:
    Complement
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 311:
Theorem (311) [serial 1476] used for:
    normalization of [serial 1474]
 


Theorem (313)                               [serial 1472] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n )
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [178] ->
Q [12] << not ( not ( v < iSeg.v_e )
  or not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
nSeg.v_e * nSeg.v_e ) ) >>
by DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 312:
Theorem (312) [serial 1474] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B) [serial 1472]
 


Theorem (314)                               [serial 1470] 
P [170] << ( not ( b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) )
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [178] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
  or ( not ( p * 2 * #CTCS_Property::EB_Rate + v * v < iSeg.e * 2 * #CTCS_Property::EB_Rate + 
nSeg.v_e * nSeg.v_e ) ) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 313:
Theorem (313) [serial 1472] used for:
    normalization of [serial 1470]
 


Theorem (315)                               [serial 1468] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and b = #CTCS_Property::SB_Rate
   and e = #CTCS_Property::EB_Rate
   and nSeg = [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;]
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e >>
S [178] ->
Q [12] << not ( iSeg.v_e <= v
  or iSeg.e * 2 * #CTCS_Property::EB_Rate + nSeg.v_e * nSeg.v_e <= p * 2 * 
#CTCS_Property::EB_Rate + v * v ) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 314:
Theorem (314) [serial 1470] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1468]
 


Theorem (316)                               [serial 1466] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate ) >>
S [178] ->
Q [12] << not ( ( v >= iSeg.v_e
  or ( v * v + 2 * #CTCS_Property::EB_Rate * p ) >= ( nSeg.v_e * nSeg.v_e + 
2 * #CTCS_Property::EB_Rate * iSeg.e ) ) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 315:
Theorem (315) [serial 1468] used for:
    normalization of [serial 1466]
 


Theorem (317)                               [serial 1465] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = ( [segment: v_n->0 kph; v_e->0 kph; e->CMA.ea; m->trainModes'FS;] )
   and ( b = #CTCS_Property::SB_Rate )
   and ( e = #CTCS_Property::EB_Rate ) >>
S [178] ->
Q [12] << not ( BRAKE(pos : p, v_l : iSeg.v_e, next_v_l : nSeg.v_e, br : #CTCS_Property::EB_Rate, cv : v, e : iSeg.e) ) >>
by Substitution of Assertion Labels
and theorem 316:
Theorem (316) [serial 1466] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1465]
 


Theorem (318)                               [serial 1458] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [178] ->
Q [12] << not EB() >>
by Substitution of Assertion Labels
and theorem 317:
Theorem (317) [serial 1465] used for:
  Substituted assertions' predicates for labels  [serial 1458]
 


Theorem (319)                               [serial 1454] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [178] ->
Q [12] << SB()
   and not EB() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 308 318:
Theorem (308) [serial 1457] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1454]
 
Theorem (318) [serial 1458] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1454]
 


Theorem (320)                               [serial 1456] 
P [178] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E()
   and ( SB()
         and not EB() )@now >>
S [178] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (321)                               [serial 1455] 
P [178] << ( b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
     and v < iSeg.v_e
     and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
     and CMA = ma
     and CMA.num_segments = i
     and CMA.seg[i] = iSeg
     and nSeg = NULL_SEGMENT()
     and AXIOM_B()
     and AXIOM_E() )
   and ( SB()
         and not EB() )@now >>
S [178] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Associativity: (b.c).a = a.b.c
and theorem 320:
Theorem (320) [serial 1456] used for:
  Associativity: (b.c).a = a.b.c [serial 1455]
 


Theorem (322)                               [serial 1382] 
P [170] << b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
   and v < iSeg.v_e
   and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E() >>
S [178] sb!
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 319 321:
Theorem (319) [serial 1454] used for:
  applied port output <<pre>> -> <<M[sb]>> [serial 1382]
 
Theorem (321) [serial 1455] used for:
  applied port output <<pre and M[sb]@now>> -> <<post>> [serial 1382]
 


Theorem (323)                               [serial 1368] 
P [170] << ( b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n <= b * p * 2 + v * v
     and v < iSeg.v_e
     and e * p * 2 + v * v < e * iSeg.e * 2 + nSeg.v_e * nSeg.v_e )
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and nSeg = NULL_SEGMENT()
         and AXIOM_B()
         and AXIOM_E() ) >>
S [178] sb!
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Associativity: (b.c).a = a.b.c
and theorem 322:
Theorem (322) [serial 1382] used for:
  Associativity: (b.c).a = a.b.c [serial 1368]
 


Theorem (324)                               [serial 1355] 
P [170] << ( i = CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = NULL_SEGMENT()
     and ma = CMA
     and AXIOM_B()
     and AXIOM_E() )
   and ( v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e
         and v < iSeg.v_e
         and ( v * v + 2 * b * p >= ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ) ) >>
S [178] sb!
Q [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 323:
Theorem (323) [serial 1368] used for:
    normalization of [serial 1355]
 


Theorem (325)                               [serial 1482] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E()
   and v < iSeg.v_n
   and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n >>
S [180] ->
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (326)                               [serial 1383] 
P [170] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and AXIOM_B()
   and AXIOM_E()
   and v < iSeg.v_n
   and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n >>
S [180] skip
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>> (bl.skip)
and theorem 325:
Theorem (325) [serial 1482] used for:
    <<P>> -> <<Q>>
  for [serial 1383]
 


Theorem (327)                               [serial 1370] 
P [170] << ( CMA = ma
     and CMA.num_segments = i
     and CMA.seg[i] = iSeg
     and nSeg = NULL_SEGMENT()
     and AXIOM_B()
     and AXIOM_E() )
   and ( v < iSeg.v_n
         and b * p * 2 + v * v < b * iSeg.e * 2 + nSeg.v_n * nSeg.v_n ) >>
S [180] skip
Q [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT() >>
by Associativity: (b.c).a = a.b.c
and theorem 326:
Theorem (326) [serial 1383] used for:
  Associativity: (b.c).a = a.b.c [serial 1370]
 


Theorem (328)                               [serial 1356] 
P [170] << ( i = CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = NULL_SEGMENT()
     and ma = CMA
     and AXIOM_B()
     and AXIOM_E() )
   and ( v < iSeg.v_n
         and ( v * v + 2 * b * p < ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ) ) >>
S [180] skip
Q [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 327:
Theorem (327) [serial 1370] used for:
    normalization of [serial 1356]
 


Theorem (329)                               [serial 1350] 
P [168] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA
   and AXIOM_B()
   and AXIOM_E() >>
S [170] if 
(v >= iSeg.v_e)~> 
  eb! 
[]
(v * v + 2 * e * p >= ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e)~> 
  eb! 
[]
(v >= iSeg.v_n
    and v < iSeg.v_e
    and v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e)~> 
  sb! 
[]
(v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e
    and v < iSeg.v_e
    and ( v * v + 2 * b * p >= ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ))~> 
  sb! 
[]
(v < iSeg.v_n
    and ( v * v + 2 * b * p < ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ))~> 
  skip 
fi
Q [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 259 268 281 303 324 328:
Theorem (259) [serial 1351] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1350]
 
Theorem (268) [serial 1352] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1350]
 
Theorem (281) [serial 1353] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1350]
 
Theorem (303) [serial 1354] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1350]
 
Theorem (324) [serial 1355] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1350]
 
Theorem (328) [serial 1356] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1350]
 


Theorem (330)                               [serial 1023] 
P [167] << ( i = CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = NULL_SEGMENT()
     and ma = CMA )
   and ( p@now )
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [168] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA
   and AXIOM_B()
   and AXIOM_E() >>
if 
(v >= iSeg.v_e)~> 
  eb! 
[]
(v * v + 2 * e * p >= ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e)~> 
  eb! 
[]
(v >= iSeg.v_n
    and v < iSeg.v_e
    and v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e)~> 
  sb! 
[]
(v * v + 2 * e * p < ( nSeg.v_e * nSeg.v_e ) + 2 * e * iSeg.e
    and v < iSeg.v_e
    and ( v * v + 2 * b * p >= ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ))~> 
  sb! 
[]
(v < iSeg.v_n
    and ( v * v + 2 * b * p < ( nSeg.v_n * nSeg.v_n ) + 2 * b * iSeg.e ))~> 
  skip 
fi
Q [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by Introduction of Existential Quantification (bl.aapre)
and theorems 247 329:
Theorem (247) [serial 1349] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]
 
Theorem (329) [serial 1350] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
 


Theorem (331)                               [serial 1024] 
P [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA
   and ( not m_a'fresh ) >>
S [184] ->
Q [78] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (332)                               [serial 1500] 
P [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and m_a'fresh >>
S [80] ->
Q [190] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (333)                               [serial 1499] 
P [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and m_a'fresh >>
S [80] ->
Q [190] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 332:
Theorem (332) [serial 1500] used for:
  Law of And-Simplification:  P and true is P [serial 1499]
 


Theorem (334)                               [serial 1500] 
P [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and m_a'fresh >>
S [80] ->
Q [190] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (335)                               [serial 1499] 
P [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and m_a'fresh >>
S [80] ->
Q [190] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 334:
Theorem (334) [serial 1500] used for:
  Law of And-Simplification:  P and true is P [serial 1499]
 


Theorem (336)                               [serial 1488] 
P [80] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and nSeg = NULL_SEGMENT()
   and m_a'fresh >>
S [80] ->
Q [190] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and AXIOM_NEXT_MA_IS_RMA() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 335 335:
Theorem (335) [serial 1499] used for:
   add user-defined axioms to postcondition
 
Theorem (335) [serial 1499] used for:
   add user-defined axioms to postcondition
 


Theorem (337)                               [serial 1483] 
P [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA
   and ( m_a'fresh ) >>
S [80] ->
Q [190] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and ma = CMA
   and AXIOM_NEXT_MA_IS_RMA() >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 336:
Theorem (336) [serial 1488] used for:
    normalization of [serial 1483]
 


Theorem (338)                               [serial 1501] 
P [195] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [82] ->
Q [82] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (339)                               [serial 1502] 
P [195] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [82] ->
Q [82] << CMA.num_segments = i >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (340)                               [serial 1506] 
P [195] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [82] ->
Q [82] << CMA.seg[CMA.num_segments] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (341)                               [serial 1503] 
P [195] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [82] ->
Q [82] << CMA.seg[i] = iSeg >>
by Guided Substitution of Equals
and theorem 340:
Theorem (340) [serial 1506] used for:
  Guided Substitution of Equals
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1503]
 


Theorem (342)                               [serial 1504] 
P [195] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [82] ->
Q [82] << NEXT_MA = next_ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (343)                               [serial 1505] 
P [195] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [82] ->
Q [82] << NEXT_MA.seg[1] = nSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (344)                               [serial 1490] 
P [195] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [82] ->
Q [82] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 338 339 341 342 343:
Theorem (338) [serial 1501] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1490]
 
Theorem (339) [serial 1502] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1490]
 
Theorem (341) [serial 1503] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1490]
 
Theorem (342) [serial 1504] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1490]
 
Theorem (343) [serial 1505] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1490]
 


Theorem (345)                               [serial 1484] 
P [195] << i = CMA.num_segments
   and next_ma = NEXT_MA
   and iSeg = CMA.seg[CMA.num_segments]
   and ma = CMA
   and nSeg = NEXT_MA.seg[1] >>
S [82] ->
Q [82] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 344:
Theorem (344) [serial 1490] used for:
    normalization of [serial 1484]
 


Theorem (346)                               [serial 1515] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and AXIOM_NEXT_MA_IS_RMA()
   and RMA = next_ma >>
S [192] ->
Q [193] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (347)                               [serial 1511] 
P [192] << RMA = next_ma
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and AXIOM_NEXT_MA_IS_RMA() ) >>
S [192] ->
Q [193] << CMA = ma >>
by Associativity: (b.c).a = a.b.c
and theorem 346:
Theorem (346) [serial 1515] used for:
  Associativity: (b.c).a = a.b.c [serial 1511]
 


Theorem (348)                               [serial 1516] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and AXIOM_NEXT_MA_IS_RMA()
   and RMA = next_ma >>
S [192] ->
Q [193] << CMA.num_segments = i >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (349)                               [serial 1512] 
P [192] << RMA = next_ma
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and AXIOM_NEXT_MA_IS_RMA() ) >>
S [192] ->
Q [193] << CMA.num_segments = i >>
by Associativity: (b.c).a = a.b.c
and theorem 348:
Theorem (348) [serial 1516] used for:
  Associativity: (b.c).a = a.b.c [serial 1512]
 


Theorem (350)                               [serial 1528] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = RMA
   and RMA = next_ma >>
S [192] ->
Q [193] << CMA.seg[i] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (351)                               [serial 1522] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = RMA
   and RMA = next_ma >>
S [192] ->
Q [193] << CMA.seg[CMA.num_segments] = iSeg >>
by Guided Substitution of Equals
and theorem 350:
Theorem (350) [serial 1528] used for:
  Guided Substitution of Equals
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1522]
 


Theorem (352)                               [serial 1519] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and ( NEXT_MA = RMA )
   and RMA = next_ma >>
S [192] ->
Q [193] << CMA.seg[CMA.num_segments] = iSeg >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 351:
Theorem (351) [serial 1522] used for:
    normalization of [serial 1519]
 


Theorem (353)                               [serial 1517] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and AXIOM_NEXT_MA_IS_RMA()
   and RMA = next_ma >>
S [192] ->
Q [193] << CMA.seg[CMA.num_segments] = iSeg >>
by Substitution of Assertion Labels
and theorem 352:
Theorem (352) [serial 1519] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1517]
 


Theorem (354)                               [serial 1513] 
P [192] << RMA = next_ma
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and AXIOM_NEXT_MA_IS_RMA() ) >>
S [192] ->
Q [193] << CMA.seg[CMA.num_segments] = iSeg >>
by Associativity: (b.c).a = a.b.c
and theorem 353:
Theorem (353) [serial 1517] used for:
  Associativity: (b.c).a = a.b.c [serial 1513]
 


Theorem (355)                               [serial 1527] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = RMA
   and RMA = next_ma >>
S [192] ->
Q [193] << RMA = next_ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (356)                               [serial 1524] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = RMA
   and RMA = next_ma >>
S [192] ->
Q [193] << NEXT_MA = next_ma >>
by Guided Substitution of Equals
and theorem 355:
Theorem (355) [serial 1527] used for:
  Guided Substitution of Equals
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1524]
 


Theorem (357)                               [serial 1520] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and ( NEXT_MA = RMA )
   and RMA = next_ma >>
S [192] ->
Q [193] << NEXT_MA = next_ma >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 356:
Theorem (356) [serial 1524] used for:
    normalization of [serial 1520]
 


Theorem (358)                               [serial 1518] 
P [192] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and AXIOM_NEXT_MA_IS_RMA()
   and RMA = next_ma >>
S [192] ->
Q [193] << NEXT_MA = next_ma >>
by Substitution of Assertion Labels
and theorem 357:
Theorem (357) [serial 1520] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1518]
 


Theorem (359)                               [serial 1514] 
P [192] << RMA = next_ma
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and AXIOM_NEXT_MA_IS_RMA() ) >>
S [192] ->
Q [193] << NEXT_MA = next_ma >>
by Associativity: (b.c).a = a.b.c
and theorem 358:
Theorem (358) [serial 1518] used for:
  Associativity: (b.c).a = a.b.c [serial 1514]
 


Theorem (360)                               [serial 1509] 
P [192] << RMA = next_ma
   and ( CMA = ma
         and CMA.num_segments = i
         and CMA.seg[i] = iSeg
         and AXIOM_NEXT_MA_IS_RMA() ) >>
S [192] ->
Q [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 347 349 354 359:
Theorem (347) [serial 1511] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
 
Theorem (349) [serial 1512] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
 
Theorem (354) [serial 1513] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
 
Theorem (359) [serial 1514] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
 


Theorem (361)                               [serial 1507] 
P [192] << ( CMA = ma
     and CMA.num_segments = i
     and CMA.seg[i] = iSeg
     and AXIOM_NEXT_MA_IS_RMA() )
   and next_ma = RMA >>
S [192] ->
Q [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 360:
Theorem (360) [serial 1509] used for:
    normalization of [serial 1507]
 


Theorem (362)                               [serial 1492] 
P [190] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and AXIOM_NEXT_MA_IS_RMA() >>
S [192] m_a?(next_ma)
Q [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
by Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
and theorem 361:
Theorem (361) [serial 1507] used for:
  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1492]
 


Theorem (363)                               [serial 1485] 
P [190] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and ma = CMA
   and AXIOM_NEXT_MA_IS_RMA() >>
S [192] m_a?(next_ma)
Q [193] << i = CMA.num_segments
   and next_ma = NEXT_MA
   and iSeg = CMA.seg[CMA.num_segments]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 362:
Theorem (362) [serial 1492] used for:
    normalization of [serial 1485]
 


Theorem (364)                               [serial 1530] 
P [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
S [194] ->
Q [195] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (365)                               [serial 1531] 
P [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
S [194] ->
Q [195] << CMA.num_segments = i >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (366)                               [serial 1532] 
P [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
S [194] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (367)                               [serial 1533] 
P [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
S [194] ->
Q [195] << NEXT_MA = next_ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (368)                               [serial 1536] 
P [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
S [194] ->
Q [196] << true >>
by True Conclusion Schema (tc): P->true


Theorem (369)                               [serial 1535] 
P [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
S [194] ->
Q [196] << next_ma.seg[1] = next_ma.seg[1] >>
by Equality Law (idistr):  a=a <-> true
and theorem 368:
Theorem (368) [serial 1536] used for:
  Equality Law (idistr):  a=a <-> true [serial 1535]
 


Theorem (370)                               [serial 1534] 
P [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
S [194] ->
Q [196] << NEXT_MA.seg[1] = next_ma.seg[1] >>
by Guided Substitution of Equals
and theorem 369:
Theorem (369) [serial 1535] used for:
  Guided Substitution of Equals
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1534]
 


Theorem (371)                               [serial 1529] 
P [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
S [194] ->
Q [195] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = next_ma.seg[1] >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 364 365 366 367 370:
Theorem (364) [serial 1530] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1529]
 
Theorem (365) [serial 1531] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1529]
 
Theorem (366) [serial 1532] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1529]
 
Theorem (367) [serial 1533] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1529]
 
Theorem (370) [serial 1534] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1529]
 


Theorem (372)                               [serial 1494] 
P [193] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma >>
S [194] nSeg := next_ma.seg[1]
Q [195] << CMA = ma
   and CMA.num_segments = i
   and CMA.seg[CMA.num_segments] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 371:
Theorem (371) [serial 1529] used for:
  applied wp for assignment [serial 1494]
 


Theorem (373)                               [serial 1486] 
P [193] << i = CMA.num_segments
   and next_ma = NEXT_MA
   and iSeg = CMA.seg[CMA.num_segments]
   and ma = CMA >>
S [194] nSeg := next_ma.seg[1]
Q [195] << i = CMA.num_segments
   and next_ma = NEXT_MA
   and iSeg = CMA.seg[CMA.num_segments]
   and ma = CMA
   and nSeg = NEXT_MA.seg[1] >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 372:
Theorem (372) [serial 1494] used for:
    normalization of [serial 1486]
 


Theorem (374)                               [serial 1025] 
P [80] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NULL_SEGMENT()
   and ma = CMA
   and ( m_a'fresh ) >>
S [190] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and ma = CMA
   and AXIOM_NEXT_MA_IS_RMA() >>
m_a?(next_ma)
;
<< i = CMA.num_segments
     and next_ma = NEXT_MA
     and iSeg = CMA.seg[CMA.num_segments]
     and ma = CMA >>
nSeg := next_ma.seg[1]
<< i = CMA.num_segments
   and next_ma = NEXT_MA
   and iSeg = CMA.seg[CMA.num_segments]
   and ma = CMA
   and nSeg = NEXT_MA.seg[1] >>
Q [82] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 337 345 363 373:
Theorem (337) [serial 1483] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1025]
 
Theorem (345) [serial 1484] used for:
  <<Q1>> -> <<Q>> in sequential composition for [serial 1025]
 
Theorem (363) [serial 1485] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1025]
 
Theorem (373) [serial 1486] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1025]
 


Theorem (375)                               [serial 1537] 
P [200] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA
   and ( p@now )
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [199] ->
Q [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (376)                               [serial 1026] 
P [200] << ( i = CMA.num_segments
     and iSeg = CMA.seg[i]
     and nSeg = NEXT_MA.seg[1]
     and ma = CMA
     and next_ma = NEXT_MA )
   and ( p@now )
   and not ( exists u ~ time
     in tops ,, now 
     that p@u  ) >>
S [199] ->
Q [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA >>
by Associativity: (b.c).a = a.b.c
and theorem 375:
Theorem (375) [serial 1537] used for:
  Associativity: (b.c).a = a.b.c [serial 1026]
 


Theorem (377)                               [serial 1027] 
P [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA
   and ( p < ma.ea ) >>
S [202] ->
Q [82] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (378)                               [serial 1547] 
P [84] << ma.ea <= p
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [84] ->
Q [207] << NEXT_MA = next_ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (379)                               [serial 1545] 
P [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA
   and ( p >= ma.ea ) >>
S [84] ->
Q [207] << ( next_ma = NEXT_MA ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 378:
Theorem (378) [serial 1547] used for:
    normalization of [serial 1545]
 


Theorem (380)                               [serial 1544] 
P [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA
   and ( p >= ma.ea ) >>
S [84] ->
Q [207] << true
   and next_ma = NEXT_MA >>
by Law of And-Simplification:  P and true is P
and theorem 379:
Theorem (379) [serial 1545] used for:
  Law of And-Simplification:  P and true is P [serial 1544]
 


Theorem (381)                               [serial 1547] 
P [84] << ma.ea <= p
   and CMA = ma
   and CMA.num_segments = i
   and CMA.seg[i] = iSeg
   and NEXT_MA = next_ma
   and NEXT_MA.seg[1] = nSeg >>
S [84] ->
Q [207] << NEXT_MA = next_ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (382)                               [serial 1545] 
P [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA
   and ( p >= ma.ea ) >>
S [84] ->
Q [207] << ( next_ma = NEXT_MA ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 381:
Theorem (381) [serial 1547] used for:
    normalization of [serial 1545]
 


Theorem (383)                               [serial 1544] 
P [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA
   and ( p >= ma.ea ) >>
S [84] ->
Q [207] << true
   and next_ma = NEXT_MA >>
by Law of And-Simplification:  P and true is P
and theorem 382:
Theorem (382) [serial 1545] used for:
  Law of And-Simplification:  P and true is P [serial 1544]
 


Theorem (384)                               [serial 1538] 
P [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA
   and ( p >= ma.ea ) >>
S [84] ->
Q [207] << AXIOM_CMA_IS_NEXT_MA()
   and next_ma = NEXT_MA >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 383 383:
Theorem (383) [serial 1544] used for:
   add user-defined axioms to postcondition
 
Theorem (383) [serial 1544] used for:
   add user-defined axioms to postcondition
 


Theorem (385)                               [serial 1553] 
P [215] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << CMA = ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (386)                               [serial 1554] 
P [215] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << CMA.seg[i] = iSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (387)                               [serial 1555] 
P [215] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << CMA.seg[1 + i] = nSeg >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (388)                               [serial 1560] 
P [215] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << 1 < ma.num_segments >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (389)                               [serial 1558] 
P [215] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << ( 1 ) < ma.num_segments >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 388:
Theorem (388) [serial 1560] used for:
    normalization of [serial 1558]
 


Theorem (390)                               [serial 1557] 
P [215] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << ( 1 ) < CMA.num_segments >>
by Guided Substitution of Equals
and theorem 389:
Theorem (389) [serial 1558] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1557]
 


Theorem (391)                               [serial 1556] 
P [215] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << i < CMA.num_segments >>
by Guided Substitution of Equals
and theorem 390:
Theorem (390) [serial 1557] used for:
  Guided Substitution of Equals
 replacing "i" with its = "( 1 )" in its postcondition [serial 1556]
 


Theorem (392)                               [serial 1551] 
P [215] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i = 1
   and 1 < ma.num_segments >>
S [72] ->
Q [72] << CMA = ma
   and CMA.seg[i] = iSeg
   and CMA.seg[1 + i] = nSeg
   and i < CMA.num_segments >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 385 386 387 391:
Theorem (385) [serial 1553] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1551]
 
Theorem (386) [serial 1554] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1551]
 
Theorem (387) [serial 1555] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1551]
 
Theorem (391) [serial 1556] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1551]
 


Theorem (393)                               [serial 1549] 
P [215] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ( 1 < ma.num_segments ) >>
S [72] ->
Q [72] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 392:
Theorem (392) [serial 1551] used for:
    normalization of [serial 1549]
 


Theorem (394)                               [serial 1539] 
P [215] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_NUM_SEG(ma : ma) >>
S [72] ->
Q [72] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Substitution of Assertion Labels
and theorem 393:
Theorem (393) [serial 1549] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1539]
 


Theorem (395)                               [serial 1567] 
P [207] << CMA = NEXT_MA
   and NEXT_MA = next_ma >>
S [208] ->
Q [209] << NEXT_MA = next_ma >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (396)                               [serial 1565] 
P [207] << CMA = NEXT_MA
   and NEXT_MA = next_ma >>
S [208] ->
Q [209] << CMA = next_ma >>
by Guided Substitution of Equals
and theorem 395:
Theorem (395) [serial 1567] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1565]
 


Theorem (397)                               [serial 1563] 
P [207] << ( CMA = NEXT_MA )
   and next_ma = NEXT_MA >>
S [208] ->
Q [209] << next_ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 396:
Theorem (396) [serial 1565] used for:
    normalization of [serial 1563]
 


Theorem (398)                               [serial 1562] 
P [207] << AXIOM_CMA_IS_NEXT_MA()
   and next_ma = NEXT_MA >>
S [208] ->
Q [209] << next_ma = CMA >>
by Substitution of Assertion Labels
and theorem 397:
Theorem (397) [serial 1563] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1562]
 


Theorem (399)                               [serial 1540] 
P [207] << AXIOM_CMA_IS_NEXT_MA()
   and next_ma = NEXT_MA >>
S [208] ma := next_ma
Q [209] << ma = CMA >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 398:
Theorem (398) [serial 1562] used for:
  applied wp for assignment [serial 1540]
 


Theorem (400)                               [serial 1575] 
P [209] << CMA = ma >>
S [210] ->
Q [211] << CMA = ma >>
by Identity (id):  P->P is tautology


Theorem (401)                               [serial 1573] 
P [209] << CMA = ma >>
S [210] ->
Q [211] << ( CMA = ma ) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 400:
Theorem (400) [serial 1575] used for:
    normalization of [serial 1573]
 


Theorem (402)                               [serial 1572] 
P [209] << CMA = ma >>
S [210] ->
Q [211] << CMA = ma
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 401:
Theorem (401) [serial 1573] used for:
  Law of And-Simplification:  P and true is P [serial 1572]
 


Theorem (403)                               [serial 1570] 
P [209] << CMA = ma >>
S [210] ->
Q [211] << CMA = ma
   and 1 = 1 >>
by Equality Law (idistr):  a=a <-> true
and theorem 402:
Theorem (402) [serial 1572] used for:
  Equality Law (idistr):  a=a <-> true [serial 1570]
 


Theorem (404)                               [serial 1568] 
P [209] << ma = CMA >>
S [210] ->
Q [211] << ( 1 ) = 1
   and ma = CMA >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 403:
Theorem (403) [serial 1570] used for:
    normalization of [serial 1568]
 


Theorem (405)                               [serial 1541] 
P [209] << ma = CMA >>
S [210] i := 1
Q [211] << i = 1
   and ma = CMA >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 404:
Theorem (404) [serial 1568] used for:
  applied wp for assignment [serial 1541]
 


Theorem (406)                               [serial 1578] 
P [211] << i = 1
   and ma = CMA >>
S [212] ->
Q [213] << i = 1 >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (407)                               [serial 1579] 
P [211] << i = 1
   and ma = CMA >>
S [212] ->
Q [213] << ma = CMA >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (408)                               [serial 1586] 
P [211] << CMA = ma
   and i = 1 >>
S [212] ->
Q [213] << true >>
by True Conclusion Schema (tc): P->true


Theorem (409)                               [serial 1584] 
P [211] << CMA = ma
   and i = 1 >>
S [212] ->
Q [213] << ma.seg[1] = ma.seg[1] >>
by Equality Law (idistr):  a=a <-> true
and theorem 408:
Theorem (408) [serial 1586] used for:
  Equality Law (idistr):  a=a <-> true [serial 1584]
 


Theorem (410)                               [serial 1582] 
P [211] << i = 1
   and ma = CMA >>
S [212] ->
Q [213] << ma.seg[1] = ma.seg[( 1 )] >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 409:
Theorem (409) [serial 1584] used for:
    normalization of [serial 1582]
 


Theorem (411)                               [serial 1581] 
P [211] << i = 1
   and ma = CMA >>
S [212] ->
Q [213] << ma.seg[1] = ma.seg[i] >>
by Guided Substitution of Equals
and theorem 410:
Theorem (410) [serial 1582] used for:
  Guided Substitution of Equals
 replacing "i" with its = "( 1 )" in its postcondition [serial 1581]
 


Theorem (412)                               [serial 1580] 
P [211] << i = 1
   and ma = CMA >>
S [212] ->
Q [213] << ma.seg[1] = CMA.seg[i] >>
by Guided Substitution of Equals
and theorem 411:
Theorem (411) [serial 1581] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1580]
 


Theorem (413)                               [serial 1577] 
P [211] << i = 1
   and ma = CMA >>
S [212] ->
Q [213] << i = 1
   and ma = CMA
   and ma.seg[1] = CMA.seg[i] >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 406 407 412:
Theorem (406) [serial 1578] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1577]
 
Theorem (407) [serial 1579] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1577]
 
Theorem (412) [serial 1580] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1577]
 


Theorem (414)                               [serial 1542] 
P [211] << i = 1
   and ma = CMA >>
S [212] iSeg := ma.seg[1]
Q [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 413:
Theorem (413) [serial 1577] used for:
  applied wp for assignment [serial 1542]
 


Theorem (415)                               [serial 1590] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << i = 1 >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (416)                               [serial 1591] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << ma = CMA >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (417)                               [serial 1592] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << iSeg = CMA.seg[i] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (418)                               [serial 1599] 
P [213] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1 >>
S [214] ->
Q [215] << true >>
by True Conclusion Schema (tc): P->true


Theorem (419)                               [serial 1598] 
P [213] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1 >>
S [214] ->
Q [215] << ma.seg[2] = ma.seg[2] >>
by Equality Law (idistr):  a=a <-> true
and theorem 418:
Theorem (418) [serial 1599] used for:
  Equality Law (idistr):  a=a <-> true [serial 1598]
 


Theorem (420)                               [serial 1596] 
P [213] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1 >>
S [214] ->
Q [215] << CMA.seg[2] = ma.seg[2] >>
by Guided Substitution of Equals
and theorem 419:
Theorem (419) [serial 1598] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1596]
 


Theorem (421)                               [serial 1594] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 420:
Theorem (420) [serial 1596] used for:
    normalization of [serial 1594]
 


Theorem (422)                               [serial 1593] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << ma.seg[2] = CMA.seg[i + 1] >>
by Guided Substitution of Equals
and theorem 421:
Theorem (421) [serial 1594] used for:
  Guided Substitution of Equals
 replacing "i" with its = "( 1 )" in its postcondition [serial 1593]
 


Theorem (423)                               [serial 1589] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and ma.seg[2] = CMA.seg[i + 1] >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 415 416 417 422:
Theorem (415) [serial 1590] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1589]
 
Theorem (416) [serial 1591] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1589]
 
Theorem (417) [serial 1592] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1589]
 
Theorem (422) [serial 1593] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1589]
 


Theorem (424)                               [serial 1588] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] nSeg := ma.seg[2]
Q [215] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 423:
Theorem (423) [serial 1589] used for:
  applied wp for assignment [serial 1588]
 


Theorem (425)                               [serial 1587] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] nSeg := ma.seg[2]
Q [215] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 424:
Theorem (424) [serial 1588] used for:
  Law of And-Simplification:  P and true is P [serial 1587]
 


Theorem (426)                               [serial 1590] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << i = 1 >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (427)                               [serial 1591] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << ma = CMA >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (428)                               [serial 1592] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << iSeg = CMA.seg[i] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (429)                               [serial 1599] 
P [213] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1 >>
S [214] ->
Q [215] << true >>
by True Conclusion Schema (tc): P->true


Theorem (430)                               [serial 1598] 
P [213] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1 >>
S [214] ->
Q [215] << ma.seg[2] = ma.seg[2] >>
by Equality Law (idistr):  a=a <-> true
and theorem 429:
Theorem (429) [serial 1599] used for:
  Equality Law (idistr):  a=a <-> true [serial 1598]
 


Theorem (431)                               [serial 1596] 
P [213] << CMA = ma
   and CMA.seg[i] = iSeg
   and i = 1 >>
S [214] ->
Q [215] << CMA.seg[2] = ma.seg[2] >>
by Guided Substitution of Equals
and theorem 430:
Theorem (430) [serial 1598] used for:
  Guided Substitution of Equals
 replacing "CMA" with its = "ma" in its postcondition [serial 1596]
 


Theorem (432)                               [serial 1594] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 431:
Theorem (431) [serial 1596] used for:
    normalization of [serial 1594]
 


Theorem (433)                               [serial 1593] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << ma.seg[2] = CMA.seg[i + 1] >>
by Guided Substitution of Equals
and theorem 432:
Theorem (432) [serial 1594] used for:
  Guided Substitution of Equals
 replacing "i" with its = "( 1 )" in its postcondition [serial 1593]
 


Theorem (434)                               [serial 1589] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] ->
Q [215] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and ma.seg[2] = CMA.seg[i + 1] >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 426 427 428 433:
Theorem (426) [serial 1590] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1589]
 
Theorem (427) [serial 1591] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1589]
 
Theorem (428) [serial 1592] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1589]
 
Theorem (433) [serial 1593] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1589]
 


Theorem (435)                               [serial 1588] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] nSeg := ma.seg[2]
Q [215] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 434:
Theorem (434) [serial 1589] used for:
  applied wp for assignment [serial 1588]
 


Theorem (436)                               [serial 1587] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] nSeg := ma.seg[2]
Q [215] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and true >>
by Law of And-Simplification:  P and true is P
and theorem 435:
Theorem (435) [serial 1588] used for:
  Law of And-Simplification:  P and true is P [serial 1587]
 


Theorem (437)                               [serial 1543] 
P [213] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i] >>
S [214] nSeg := ma.seg[2]
Q [215] << i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_NUM_SEG(ma : ma) >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 436 436:
Theorem (436) [serial 1587] used for:
   add user-defined axioms to postcondition
 
Theorem (436) [serial 1587] used for:
   add user-defined axioms to postcondition
 


Theorem (438)                               [serial 1028] 
P [84] << i = CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = NEXT_MA.seg[1]
   and ma = CMA
   and next_ma = NEXT_MA
   and ( p >= ma.ea ) >>
S [207] << AXIOM_CMA_IS_NEXT_MA()
   and next_ma = NEXT_MA >>
ma := next_ma
;
<< ma = CMA >>
i := 1
;
<< i = 1
     and ma = CMA >>
iSeg := ma.seg[1]
;
<< i = 1
     and ma = CMA
     and iSeg = CMA.seg[i] >>
nSeg := ma.seg[2]
<< i = 1
   and ma = CMA
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and AXIOM_NUM_SEG(ma : ma) >>
Q [72] << i < CMA.num_segments
   and iSeg = CMA.seg[i]
   and nSeg = CMA.seg[i + 1]
   and ma = CMA >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 384 394 399 405 414 437:
Theorem (384) [serial 1538] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1028]
 
Theorem (394) [serial 1539] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1028]
 
Theorem (399) [serial 1540] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028]
 
Theorem (405) [serial 1541] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
 
Theorem (414) [serial 1542] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
 
Theorem (437) [serial 1543] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028]
 


Theorem (439)                               [serial 1002] 
P [33] <<   >>
S [52] ->
Q [33] << AutoBrake.i proof obligations >>
by Initial Thread Obligations
and theorems 1 2 3 4 8 10 11 14 16 20 23 24 25 103 196 197 204 214 239 240 330 331 374 376 377 438:
Theorem (1) [serial 1003] used for:
  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
 
Theorem (2) [serial 1004] used for:
  <<M(GetFirstMA)>> -> <<I>> from invariant I when complete state GetFirstMA has Assertion <<M(GetFirstMA)>> in its definition.
 
Theorem (3) [serial 1005] used for:
  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
 
Theorem (4) [serial 1006] used for:
  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
 
Theorem (8) [serial 1007] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
 
Theorem (10) [serial 1008] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
 
Theorem (11) [serial 1009] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
 
Theorem (14) [serial 1010] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
 
Theorem (16) [serial 1011] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
 
Theorem (20) [serial 1012] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
 
Theorem (23) [serial 1013] used for:
   <<M(Start)>> A <<M(GetFirstMA)>> for GoStart-[ ]->GetFirstMA{A};
 
Theorem (24) [serial 1014] used for:
   <<M(GetFirstMA) and x>> -> <<M(CheckFirstMA)>> for GetFirstMAGetFirstMA-[x]->CheckFirstMA{};
 
Theorem (25) [serial 1015] used for:
   <<M(CheckFirstMA) and x>> -> <<M(GetFirstMA)>> for NotYetCheckFirstMA-[x]->GetFirstMA{};
 
Theorem (103) [serial 1016] used for:
   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A};
 
Theorem (196) [serial 1017] used for:
   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A};
 
Theorem (197) [serial 1018] used for:
   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{};
 
Theorem (204) [serial 1019] used for:
   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A};
 
Theorem (214) [serial 1020] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A};
 
Theorem (239) [serial 1021] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A};
 
Theorem (240) [serial 1022] used for:
   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{};
 
Theorem (330) [serial 1023] used for:
   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegmentMoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
 
Theorem (331) [serial 1024] used for:
   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
 
Theorem (374) [serial 1025] used for:
   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A};
 
Theorem (376) [serial 1026] used for:
   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{};
 
Theorem (377) [serial 1027] used for:
   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{};
 
Theorem (438) [serial 1028] used for:
   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A};
 


Theorem (440)                               [serial 1029] 
P [1] << p = POSITION >>
S [2] ->
Q [1] << p = POSITION >>
by Identity (id):  P->P is tautology


Theorem (441)                               [serial 1030] 
P [1] << v = VELOCITY >>
S [2] ->
Q [1] << v = VELOCITY >>
by Identity (id):  P->P is tautology


Theorem (442)                               [serial 1031] 
P [1] << ma_m_a = RMA >>
S [2] ->
Q [1] << ma_m_a = RMA >>
by Identity (id):  P->P is tautology


Theorem (443)                               [serial 1032] 
P [28] << ma = RMA >>
S [20] ->
Q [14] << ma = RMA >>
by Identity (id):  P->P is tautology


Theorem (444)                               [serial 1033] 
P [14] << ma_m_a = RMA >>
S [62] ->
Q [84] << ma_m_a = RMA >>
by Identity (id):  P->P is tautology


Theorem (445)                               [serial 1034] 
P [27] << p = POSITION >>
S [63] ->
Q [79] << p = POSITION >>
by Identity (id):  P->P is tautology


Theorem (446)                               [serial 1035] 
P [29] << v = VELOCITY >>
S [64] ->
Q [81] << v = VELOCITY >>
by Identity (id):  P->P is tautology


Theorem (447)                               [serial 1036] 
P [79] << p = POSITION >>
S [93] ->
Q [21] << p = POSITION >>
by Identity (id):  P->P is tautology


Theorem (448)                               [serial 1037] 
P [81] << v = VELOCITY >>
S [94] ->
Q [23] << v = VELOCITY >>
by Identity (id):  P->P is tautology


Theorem (449)                               [serial 1038] 
P [16] << ca = TRAIN_XL() >>
S [95] ->
Q [77] << ca = TRAIN_XL() >>
by Identity (id):  P->P is tautology


Theorem (450)                               [serial 1039] 
P [84] << m_a = RMA >>
S [97] ->
Q [19] << m_a = RMA >>
by Identity (id):  P->P is tautology


Theorem (451)                               [serial 1040] 
P [86] << xl = OPERATOR_XL >>
S [98] ->
Q [25] << xl = OPERATOR_XL >>
by Identity (id):  P->P is tautology


Theorem (452)                               [serial 1041] 
P [12] << SB()
   and not EB() >>
S [99] ->
Q [73] << SB()
   and not EB() >>
by Identity (id):  P->P is tautology


Theorem (453)                               [serial 1042] 
P [14] << EB() >>
S [100] ->
Q [75] << EB() >>
by Identity (id):  P->P is tautology


Theorem (454)                               [serial 1001] 
P    
^{ASSERTION[0] dummy}
S     
Q    
^{ASSERTION[0] dummy}
by Initial Thread Obligations
and theorems 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453:
Theorem (439) [serial 1002] used for:
  Initial proof obligations for AutoBrake.i
 
Theorem (440) [serial 1029] used for:
  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
 
Theorem (441) [serial 1030] used for:
  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
 
Theorem (442) [serial 1031] used for:
  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
 
Theorem (443) [serial 1032] used for:
  Composition of Subcomponents via Directional Connection CTCS::MA.i.ma:
 ma -> ma
 
Theorem (444) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
 
Theorem (445) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
 
Theorem (446) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
 
Theorem (447) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
 
Theorem (448) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
 
Theorem (449) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_a:
 ca -> ca
 
Theorem (450) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
 
Theorem (451) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_xl:
 xl -> xl
 
Theorem (452) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
 
Theorem (453) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
 


closing proof.txt file 