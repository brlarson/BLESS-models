This file, proof.txt, was produced the BLESS Proof Assistant v3.2.0
  at Mon Apr 24 01:55:58 CDT 2023 by brianlarson

Theorem (1)                               [serial 1003] 
P [66] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [41] ->
Q [41] << true >>
Why created:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (2)                               [serial 1004] 
P [57] << true >>
S [41] ->
Q [41] << true >>
Why created:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (3)                               [serial 1005] 
P [60] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [41] ->
Q [41] << true >>
Why created:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (4)                               [serial 1048] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [41] ->
Q [41] << true >>
Why created:    normalization of [serial 1006]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (5)                               [serial 1006] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [41] ->
Q [41] << true >>
Why created:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 4:
Theorem (4) [serial 1048] used for:
    normalization of [serial 1006] 


Theorem (6)                               [serial 1054] 
P [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [62] ->
Q [62] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1053]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (7)                               [serial 1053] 
P [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [62] ->
Q [62] << ( not ( p < iSeg.e ) )
   or p < iSeg.e >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 6:
Theorem (6) [serial 1054] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1053] 


Theorem (8)                               [serial 1051] 
P [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [62] ->
Q [62] << iSeg.e <= p
   or p < iSeg.e >>
Why created:    normalization of [serial 1007]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 7:
Theorem (7) [serial 1053] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051] 


Theorem (9)                               [serial 1007] 
P [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [62] ->
Q [62] << ( p < iSeg.e )
   or ( p >= iSeg.e ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 8:
Theorem (8) [serial 1051] used for:
    normalization of [serial 1007] 


Theorem (10)                               [serial 1055] 
P [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [68] ->
Q [68] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1008]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (11)                               [serial 1008] 
P [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [68] ->
Q [68] << ( not m_a'fresh )
   or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 10:
Theorem (10) [serial 1055] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1008] 


Theorem (12)                               [serial 1009] 
P [56] << true >>
S [56] ->
Q [56] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (13)                               [serial 1059] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [64] ->
Q [64] << true >>
Why created:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (14)                               [serial 1057] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [64] ->
Q [64] << i = ma.num_segments
   or i < ma.num_segments
   or ma.num_segments < i >>
Why created:    normalization of [serial 1010]
Solved by:  Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 13:
Theorem (13) [serial 1059] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057] 


Theorem (15)                               [serial 1010] 
P [64] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [64] ->
Q [64] << ( i < ma.num_segments )
   or ( i = ma.num_segments )
   or ( i > ma.num_segments ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 14:
Theorem (14) [serial 1057] used for:
    normalization of [serial 1010] 


Theorem (16)                               [serial 1060] 
P [58] << true >>
S [58] ->
Q [58] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1011]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (17)                               [serial 1011] 
P [58] << true >>
S [58] ->
Q [58] << ( not m_a'fresh )
   or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 16:
Theorem (16) [serial 1060] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1011] 


Theorem (18)                               [serial 1065] 
P [72] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [72] ->
Q [72] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1064]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (19)                               [serial 1064] 
P [72] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [72] ->
Q [72] << ( not ( p < ma.ea ) )
   or p < ma.ea >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 18:
Theorem (18) [serial 1065] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1064] 


Theorem (20)                               [serial 1062] 
P [72] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [72] ->
Q [72] << ma.ea <= p
   or p < ma.ea >>
Why created:    normalization of [serial 1012]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 19:
Theorem (19) [serial 1064] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062] 


Theorem (21)                               [serial 1012] 
P [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [72] ->
Q [72] << ( p < ma.ea )
   or ( p >= ma.ea ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 20:
Theorem (20) [serial 1062] used for:
    normalization of [serial 1012] 


Theorem (22)                               [serial 1067] 
P [56] << true >>
S [77] ->
Q [77] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1066]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (23)                               [serial 1068] 
P [77] << ( true )
  and true@now >>
S [77] ->
Q [57] << true >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (24)                               [serial 1066] 
P [56] << true >>
S [77] r!
Q [57] << true >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 22 23:
Theorem (22) [serial 1067] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1066] 
Theorem (23) [serial 1068] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066] 


Theorem (25)                               [serial 1013] 
P [56] << true >>
S [77] r!
Q [57] << true >>
Why created:   <<M(Start)>> A <<M(WaitFirstMA)>> for GoStart-[ ]->WaitFirstMA{A};
Solved by:  Introduction of Existential Quantification
and theorem 24:
Theorem (24) [serial 1066] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013] 


Theorem (26)                               [serial 1014] 
P [80] << ( true )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [79] ->
Q [58] << true >>
Why created:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMAWaitFirstMA-[x]->CheckFirstMA{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (27)                               [serial 1015] 
P [83] << not m_a'fresh >>
S [82] ->
Q [57] << true >>
Why created:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYetCheckFirstMA-[x]->WaitFirstMA{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (28)                               [serial 1075] 
P [86] << m_a'fresh >>
S [86] ->
Q [87] << true >>
Why created:   add user-defined axioms to postcondition
Solved by:  True Conclusion Schema (tc): P->true


Theorem (29)                               [serial 1075] 
P [86] << m_a'fresh >>
S [86] ->
Q [87] << true >>
Why created:   add user-defined axioms to postcondition
Solved by:  True Conclusion Schema (tc): P->true


Theorem (30)                               [serial 1069] 
P [86] << m_a'fresh >>
S [86] ->
Q [87] << AXIOM_CMA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 29 29:
Theorem (29) [serial 1075] used for:
   add user-defined axioms to postcondition 
Theorem (29) [serial 1075] used for:
   add user-defined axioms to postcondition 


Theorem (31)                               [serial 1096] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [60] ->
Q [60] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (32)                               [serial 1097] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [60] ->
Q [60] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (33)                               [serial 1098] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [60] ->
Q [60] << CMA.seg[1 + i] = nSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (34)                               [serial 1109] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [60] ->
Q [60] << 1 < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (35)                               [serial 1107] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [60] ->
Q [60] << 1 < ma.num_segments >>
Why created:    normalization of [serial 1105]
Solved by:  Guided Substitution of Equals
and theorem 34:
Theorem (34) [serial 1109] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107] 


Theorem (36)                               [serial 1105] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [60] ->
Q [60] << ( 1 ) < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 35:
Theorem (35) [serial 1107] used for:
    normalization of [serial 1105] 


Theorem (37)                               [serial 1103] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [60] ->
Q [60] << i < ma.num_segments >>
Why created:    normalization of [serial 1101]
Solved by:  Guided Substitution of Equals
and theorem 36:
Theorem (36) [serial 1105] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103] 


Theorem (38)                               [serial 1101] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [60] ->
Q [60] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 37:
Theorem (37) [serial 1103] used for:
    normalization of [serial 1101] 


Theorem (39)                               [serial 1100] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [60] ->
Q [60] << i < CMA.num_segments >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1099]
Solved by:  Guided Substitution of Equals
and theorem 38:
Theorem (38) [serial 1101] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100] 


Theorem (40)                               [serial 1099] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [60] ->
Q [60] << i < CMA.num_segments >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  Substitution of Assertion Labels
and theorem 39:
Theorem (39) [serial 1100] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1099] 


Theorem (41)                               [serial 1081] 
P [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [60] ->
Q [60] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1070]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 31 32 33 40:
Theorem (31) [serial 1096] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 
Theorem (32) [serial 1097] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 
Theorem (33) [serial 1098] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 
Theorem (40) [serial 1099] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 


Theorem (42)                               [serial 1070] 
P [96] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [60] ->
Q [60] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<Q3>> -> <<Q>> in sequential composition for [serial 1016]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 41:
Theorem (41) [serial 1081] used for:
    normalization of [serial 1070] 


Theorem (43)                               [serial 1115] 
P [88] << CMA = RMA
  and RMA = ma >>
S [88] ->
Q [89] << RMA = ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (44)                               [serial 1113] 
P [88] << CMA = RMA
  and RMA = ma >>
S [88] ->
Q [89] << CMA = ma >>
Why created:    normalization of [serial 1111]
Solved by:  Guided Substitution of Equals
and theorem 43:
Theorem (43) [serial 1115] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113] 


Theorem (45)                               [serial 1111] 
P [88] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [88] ->
Q [89] << CMA = ma >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1110]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 44:
Theorem (44) [serial 1113] used for:
    normalization of [serial 1111] 


Theorem (46)                               [serial 1110] 
P [88] << ( AXIOM_CMA_IS_RMA() )
  and ma = RMA >>
S [88] ->
Q [89] << CMA = ma >>
Why created:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083]
Solved by:  Substitution of Assertion Labels
and theorem 45:
Theorem (45) [serial 1111] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1110] 


Theorem (47)                               [serial 1083] 
P [87] << AXIOM_CMA_IS_RMA() >>
S [88] m_a?(ma)
Q [89] << CMA = ma >>
Why created:    normalization of [serial 1071]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 46:
Theorem (46) [serial 1110] used for:
  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083] 


Theorem (48)                               [serial 1071] 
P [87] << AXIOM_CMA_IS_RMA() >>
S [88] m_a?(ma)
Q [89] << ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 47:
Theorem (47) [serial 1083] used for:
    normalization of [serial 1071] 


Theorem (49)                               [serial 1123] 
P [89] << CMA = ma >>
S [90] ->
Q [91] << CMA = ma >>
Why created:    normalization of [serial 1121]
Solved by:  Identity (id):  P->P is tautology


Theorem (50)                               [serial 1121] 
P [89] << CMA = ma >>
S [90] ->
Q [91] << ( CMA = ma ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1120]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 49:
Theorem (49) [serial 1123] used for:
    normalization of [serial 1121] 


Theorem (51)                               [serial 1120] 
P [89] << CMA = ma >>
S [90] ->
Q [91] << CMA = ma
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1118]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 50:
Theorem (50) [serial 1121] used for:
  Law of And-Simplification:  P and true is P [serial 1120] 


Theorem (52)                               [serial 1118] 
P [89] << CMA = ma >>
S [90] ->
Q [91] << CMA = ma
  and 1 = 1 >>
Why created:    normalization of [serial 1116]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 51:
Theorem (51) [serial 1120] used for:
  Equality Law (idistr):  a=a <-> true [serial 1118] 


Theorem (53)                               [serial 1116] 
P [89] << CMA = ma >>
S [90] ->
Q [91] << CMA = ma
  and ( 1 ) = 1 >>
Why created:  applied wp for assignment [serial 1085]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 52:
Theorem (52) [serial 1118] used for:
    normalization of [serial 1116] 


Theorem (54)                               [serial 1085] 
P [89] << CMA = ma >>
S [90] i := 1
Q [91] << CMA = ma
  and i = 1 >>
Why created:    normalization of [serial 1072]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 53:
Theorem (53) [serial 1116] used for:
  applied wp for assignment [serial 1085] 


Theorem (55)                               [serial 1072] 
P [89] << ma = CMA >>
S [90] i := 1
Q [91] << i = 1
  and ma = CMA >>
Why created:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 54:
Theorem (54) [serial 1085] used for:
    normalization of [serial 1072] 


Theorem (56)                               [serial 1126] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (57)                               [serial 1134] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1132]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (58)                               [serial 1132] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << ma.seg[1] = ma.seg[1] >>
Why created:    normalization of [serial 1130]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 57:
Theorem (57) [serial 1134] used for:
  Equality Law (idistr):  a=a <-> true [serial 1132] 


Theorem (59)                               [serial 1130] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << ma.seg[( 1 )] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 58:
Theorem (58) [serial 1132] used for:
    normalization of [serial 1130] 


Theorem (60)                               [serial 1129] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << ma.seg[i] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Solved by:  Guided Substitution of Equals
and theorem 59:
Theorem (59) [serial 1130] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129] 


Theorem (61)                               [serial 1127] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << CMA.seg[i] = ma.seg[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  Guided Substitution of Equals
and theorem 60:
Theorem (60) [serial 1129] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127] 


Theorem (62)                               [serial 1128] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (63)                               [serial 1125] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
Why created:  applied wp for assignment [serial 1088]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 56 61 62:
Theorem (56) [serial 1126] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (61) [serial 1127] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (62) [serial 1128] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 


Theorem (64)                               [serial 1088] 
P [91] << CMA = ma
  and i = 1 >>
S [92] iSeg := ma.seg[1]
Q [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
Why created:    normalization of [serial 1078]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 63:
Theorem (63) [serial 1125] used for:
  applied wp for assignment [serial 1088] 


Theorem (65)                               [serial 1078] 
P [91] << i = 1
  and ma = CMA >>
S [92] iSeg := ma.seg[1]
Q [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1076]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 64:
Theorem (64) [serial 1088] used for:
    normalization of [serial 1078] 


Theorem (66)                               [serial 1076] 
P [91] << i = 1
  and ma = CMA >>
S [92] iSeg := ma.seg[1]
Q [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 65:
Theorem (65) [serial 1078] used for:
  Law of And-Simplification:  P and true is P [serial 1076] 


Theorem (67)                               [serial 1126] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (68)                               [serial 1134] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1132]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (69)                               [serial 1132] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << ma.seg[1] = ma.seg[1] >>
Why created:    normalization of [serial 1130]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 68:
Theorem (68) [serial 1134] used for:
  Equality Law (idistr):  a=a <-> true [serial 1132] 


Theorem (70)                               [serial 1130] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << ma.seg[( 1 )] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 69:
Theorem (69) [serial 1132] used for:
    normalization of [serial 1130] 


Theorem (71)                               [serial 1129] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << ma.seg[i] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Solved by:  Guided Substitution of Equals
and theorem 70:
Theorem (70) [serial 1130] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129] 


Theorem (72)                               [serial 1127] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << CMA.seg[i] = ma.seg[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  Guided Substitution of Equals
and theorem 71:
Theorem (71) [serial 1129] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127] 


Theorem (73)                               [serial 1128] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (74)                               [serial 1125] 
P [91] << CMA = ma
  and i = 1 >>
S [92] ->
Q [93] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
Why created:  applied wp for assignment [serial 1088]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 67 72 73:
Theorem (67) [serial 1126] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (72) [serial 1127] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (73) [serial 1128] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 


Theorem (75)                               [serial 1088] 
P [91] << CMA = ma
  and i = 1 >>
S [92] iSeg := ma.seg[1]
Q [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
Why created:    normalization of [serial 1078]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 74:
Theorem (74) [serial 1125] used for:
  applied wp for assignment [serial 1088] 


Theorem (76)                               [serial 1078] 
P [91] << i = 1
  and ma = CMA >>
S [92] iSeg := ma.seg[1]
Q [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1076]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 75:
Theorem (75) [serial 1088] used for:
    normalization of [serial 1078] 


Theorem (77)                               [serial 1076] 
P [91] << i = 1
  and ma = CMA >>
S [92] iSeg := ma.seg[1]
Q [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 76:
Theorem (76) [serial 1078] used for:
  Law of And-Simplification:  P and true is P [serial 1076] 


Theorem (78)                               [serial 1073] 
P [91] << i = 1
  and ma = CMA >>
S [92] iSeg := ma.seg[1]
Q [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 77 77:
Theorem (77) [serial 1076] used for:
   add user-defined axioms to postcondition 
Theorem (77) [serial 1076] used for:
   add user-defined axioms to postcondition 


Theorem (79)                               [serial 1150] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << CMA.seg[i] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (80)                               [serial 1148] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << CMA.seg[1] = iSeg >>
Why created:    normalization of [serial 1146]
Solved by:  Guided Substitution of Equals
and theorem 79:
Theorem (79) [serial 1150] used for:
  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148] 


Theorem (81)                               [serial 1146] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << iSeg = CMA.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 80:
Theorem (80) [serial 1148] used for:
    normalization of [serial 1146] 


Theorem (82)                               [serial 1144] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << iSeg = ma.seg[1] >>
Why created:    normalization of [serial 1142]
Solved by:  Guided Substitution of Equals
and theorem 81:
Theorem (81) [serial 1146] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144] 


Theorem (83)                               [serial 1142] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << ( ma.seg[1] = iSeg ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1141]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 82:
Theorem (82) [serial 1144] used for:
    normalization of [serial 1142] 


Theorem (84)                               [serial 1141] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1140]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 83:
Theorem (83) [serial 1142] used for:
  Law of And-Simplification:  P and true is P [serial 1141] 


Theorem (85)                               [serial 1140] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
Why created:  applied wp for assignment [serial 1139]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 84:
Theorem (84) [serial 1141] used for:
  Equality Law (idistr):  a=a <-> true [serial 1140] 


Theorem (86)                               [serial 1139] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 85:
Theorem (85) [serial 1140] used for:
  applied wp for assignment [serial 1139] 


Theorem (87)                               [serial 1137] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
Why created:    normalization of [serial 1135]
Solved by:  Guided Substitution of Equals
and theorem 86:
Theorem (86) [serial 1139] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137] 


Theorem (88)                               [serial 1135] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 87:
Theorem (87) [serial 1137] used for:
    normalization of [serial 1135] 


Theorem (89)                               [serial 1090] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
Why created:    normalization of [serial 1079]
Solved by:  Guided Substitution of Equals
and theorem 88:
Theorem (88) [serial 1135] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090] 


Theorem (90)                               [serial 1079] 
P [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1077]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 89:
Theorem (89) [serial 1090] used for:
    normalization of [serial 1079] 


Theorem (91)                               [serial 1077] 
P [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 90:
Theorem (90) [serial 1079] used for:
  Law of And-Simplification:  P and true is P [serial 1077] 


Theorem (92)                               [serial 1150] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << CMA.seg[i] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (93)                               [serial 1148] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << CMA.seg[1] = iSeg >>
Why created:    normalization of [serial 1146]
Solved by:  Guided Substitution of Equals
and theorem 92:
Theorem (92) [serial 1150] used for:
  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148] 


Theorem (94)                               [serial 1146] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << iSeg = CMA.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 93:
Theorem (93) [serial 1148] used for:
    normalization of [serial 1146] 


Theorem (95)                               [serial 1144] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << iSeg = ma.seg[1] >>
Why created:    normalization of [serial 1142]
Solved by:  Guided Substitution of Equals
and theorem 94:
Theorem (94) [serial 1146] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144] 


Theorem (96)                               [serial 1142] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << ( ma.seg[1] = iSeg ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1141]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 95:
Theorem (95) [serial 1144] used for:
    normalization of [serial 1142] 


Theorem (97)                               [serial 1141] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1140]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 96:
Theorem (96) [serial 1142] used for:
  Law of And-Simplification:  P and true is P [serial 1141] 


Theorem (98)                               [serial 1140] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] ->
Q [96] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
Why created:  applied wp for assignment [serial 1139]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 97:
Theorem (97) [serial 1141] used for:
  Equality Law (idistr):  a=a <-> true [serial 1140] 


Theorem (99)                               [serial 1139] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 98:
Theorem (98) [serial 1140] used for:
  applied wp for assignment [serial 1139] 


Theorem (100)                               [serial 1137] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
Why created:    normalization of [serial 1135]
Solved by:  Guided Substitution of Equals
and theorem 99:
Theorem (99) [serial 1139] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137] 


Theorem (101)                               [serial 1135] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 100:
Theorem (100) [serial 1137] used for:
    normalization of [serial 1135] 


Theorem (102)                               [serial 1090] 
P [93] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
Why created:    normalization of [serial 1079]
Solved by:  Guided Substitution of Equals
and theorem 101:
Theorem (101) [serial 1135] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090] 


Theorem (103)                               [serial 1079] 
P [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1077]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 102:
Theorem (102) [serial 1090] used for:
    normalization of [serial 1079] 


Theorem (104)                               [serial 1077] 
P [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 103:
Theorem (103) [serial 1079] used for:
  Law of And-Simplification:  P and true is P [serial 1077] 


Theorem (105)                               [serial 1074] 
P [93] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [95] nSeg := ma.seg[2]
Q [96] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
Why created:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 104 104:
Theorem (104) [serial 1077] used for:
   add user-defined axioms to postcondition 
Theorem (104) [serial 1077] used for:
   add user-defined axioms to postcondition 


Theorem (106)                               [serial 1016] 
P [86] << m_a'fresh >>
S [87]   << AXIOM_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and AXIOM_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : CMA) >> 
Q [60] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 30 42 48 55 78 105:
Theorem (30) [serial 1069] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1016] 
Theorem (42) [serial 1070] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1016] 
Theorem (48) [serial 1071] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016] 
Theorem (55) [serial 1072] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016] 
Theorem (78) [serial 1073] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016] 
Theorem (105) [serial 1074] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1016] 


Theorem (107)                               [serial 1166] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101] ->
Q [102] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Law of And-Simplification:  P and true is P [serial 1165]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (108)                               [serial 1165] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101] ->
Q [102] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 107:
Theorem (107) [serial 1166] used for:
  Law of And-Simplification:  P and true is P [serial 1165] 


Theorem (109)                               [serial 1166] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101] ->
Q [102] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Law of And-Simplification:  P and true is P [serial 1165]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (110)                               [serial 1165] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101] ->
Q [102] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 109:
Theorem (109) [serial 1166] used for:
  Law of And-Simplification:  P and true is P [serial 1165] 


Theorem (111)                               [serial 1152] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101] ->
Q [102] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 110 110:
Theorem (110) [serial 1165] used for:
   add user-defined axioms to postcondition 
Theorem (110) [serial 1165] used for:
   add user-defined axioms to postcondition 


Theorem (112)                               [serial 1182] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << true >>
Why created:    normalization of [serial 1180]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (113)                               [serial 1180] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1179]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 112:
Theorem (112) [serial 1182] used for:
    normalization of [serial 1180] 


Theorem (114)                               [serial 1179] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1178]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 113:
Theorem (113) [serial 1180] used for:
  Law of And-Simplification:  P and P is P [serial 1179] 


Theorem (115)                               [serial 1178] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1177]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 114:
Theorem (114) [serial 1179] used for:
  Law of And-Simplification:  P and P is P [serial 1178] 


Theorem (116)                               [serial 1177] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1176]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 115:
Theorem (115) [serial 1178] used for:
  Law of And-Simplification:  P and P is P [serial 1177] 


Theorem (117)                               [serial 1176] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1175]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 116:
Theorem (116) [serial 1177] used for:
  Law of And-Simplification:  P and P is P [serial 1176] 


Theorem (118)                               [serial 1175] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1174]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 117:
Theorem (117) [serial 1176] used for:
  Law of And-Simplification:  P and P is P [serial 1175] 


Theorem (119)                               [serial 1174] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 118:
Theorem (118) [serial 1175] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1174] 


Theorem (120)                               [serial 1172] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1170]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 119:
Theorem (119) [serial 1174] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172] 


Theorem (121)                               [serial 1170] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 120:
Theorem (120) [serial 1172] used for:
    normalization of [serial 1170] 


Theorem (122)                               [serial 1168] 
P [102] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [106] ->
Q [106] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1154]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 121:
Theorem (121) [serial 1170] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168] 


Theorem (123)                               [serial 1154] 
P [102] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [106] ->
Q [106] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 122:
Theorem (122) [serial 1168] used for:
    normalization of [serial 1154] 


Theorem (124)                               [serial 1215] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [108] ->
Q [14] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v >>
Why created:    normalization of [serial 1211]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (125)                               [serial 1211] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [108] ->
Q [14] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1208]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 124:
Theorem (124) [serial 1215] used for:
    normalization of [serial 1211] 


Theorem (126)                               [serial 1208] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [108] ->
Q [14] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1191]
Solved by:  Substitution of Assertion Labels
and theorem 125:
Theorem (125) [serial 1211] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1208] 


Theorem (127)                               [serial 1191] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]
Solved by:  Substitution of Assertion Labels
and theorem 126:
Theorem (126) [serial 1208] used for:
  Substituted assertions' predicates for labels  [serial 1191] 


Theorem (128)                               [serial 1197] 
P [108] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [108] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1192]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (129)                               [serial 1192] 
P [108] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [108] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 128:
Theorem (128) [serial 1197] used for:
  Associativity: (b.c).a = a.b.c [serial 1192] 


Theorem (130)                               [serial 1188] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108] eb!(true)
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1186]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 127 129:
Theorem (127) [serial 1191] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188] 
Theorem (129) [serial 1192] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188] 


Theorem (131)                               [serial 1224] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [108] ->
Q [108] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v
   or not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1219]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (132)                               [serial 1219] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [108] ->
Q [108] << not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v )
   or ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1213]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 131:
Theorem (131) [serial 1224] used for:
  Associativity: (b.c).a = a.b.c [serial 1219] 


Theorem (133)                               [serial 1213] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [108] ->
Q [108] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) )
   or not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1210]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 132:
Theorem (132) [serial 1219] used for:
    normalization of [serial 1213] 


Theorem (134)                               [serial 1210] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [108] ->
Q [108] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) )
   or not ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1205]
Solved by:  Substitution of Assertion Labels
and theorem 133:
Theorem (133) [serial 1213] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1210] 


Theorem (135)                               [serial 1205] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108] ->
Q [108] << EB()
   or not SB() >>
Why created:    normalization of [serial 1200]
Solved by:  Substitution of Assertion Labels
and theorem 134:
Theorem (134) [serial 1210] used for:
  Substituted assertions' predicates for labels  [serial 1205] 


Theorem (136)                               [serial 1200] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108] ->
Q [108] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 135:
Theorem (135) [serial 1205] used for:
    normalization of [serial 1200] 


Theorem (137)                               [serial 1193] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108] ->
Q [108] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 136:
Theorem (136) [serial 1200] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193] 


Theorem (138)                               [serial 1198] 
P [108] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [108] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1194]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (139)                               [serial 1194] 
P [108] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [108] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 138:
Theorem (138) [serial 1198] used for:
  Associativity: (b.c).a = a.b.c [serial 1194] 


Theorem (140)                               [serial 1189] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108] sb!(false)
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1186]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 137 139:
Theorem (137) [serial 1193] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189] 
Theorem (139) [serial 1194] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189] 


Theorem (141)                               [serial 1199] 
P [108] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [108] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1195]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (142)                               [serial 1195] 
P [108] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [108] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 141:
Theorem (141) [serial 1199] used for:
  Associativity: (b.c).a = a.b.c [serial 1195] 


Theorem (143)                               [serial 1223] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [108] ->
Q [33] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v
   or iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1217]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (144)                               [serial 1217] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [108] ->
Q [33] << ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1212]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 143:
Theorem (143) [serial 1223] used for:
  Associativity: (b.c).a = a.b.c [serial 1217] 


Theorem (145)                               [serial 1212] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [108] ->
Q [33] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1209]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 144:
Theorem (144) [serial 1217] used for:
    normalization of [serial 1212] 


Theorem (146)                               [serial 1209] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [108] ->
Q [33] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) )
   or ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1203]
Solved by:  Substitution of Assertion Labels
and theorem 145:
Theorem (145) [serial 1212] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1209] 


Theorem (147)                               [serial 1203] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1196]
Solved by:  Substitution of Assertion Labels
and theorem 146:
Theorem (146) [serial 1209] used for:
  Substituted assertions' predicates for labels  [serial 1203] 


Theorem (148)                               [serial 1196] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 147:
Theorem (147) [serial 1203] used for:
    normalization of [serial 1196] 


Theorem (149)                               [serial 1190] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108] ca!(0 mpss)
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1186]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 142 148:
Theorem (142) [serial 1195] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190] 
Theorem (148) [serial 1196] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190] 


Theorem (150)                               [serial 1186] 
P [106] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [108]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1184]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 130 140 149:
Theorem (130) [serial 1188] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1186] 
Theorem (140) [serial 1189] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1186] 
Theorem (149) [serial 1190] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1186] 


Theorem (151)                               [serial 1184] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [108]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1160]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 150:
Theorem (150) [serial 1186] used for:
    normalization of [serial 1184] 


Theorem (152)                               [serial 1160] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [108]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 151:
Theorem (151) [serial 1184] used for:
  Associativity: (b.c).a = a.b.c [serial 1160] 


Theorem (153)                               [serial 1155] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [108]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 152:
Theorem (152) [serial 1160] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1155] 


Theorem (154)                               [serial 1260] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1256]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (155)                               [serial 1256] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [14] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e <= v*v >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1248]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 154:
Theorem (154) [serial 1260] used for:
    normalization of [serial 1256] 


Theorem (156)                               [serial 1248] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [14] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v >>
Why created:    normalization of [serial 1244]
Solved by:  Guided Substitution of Equals
and theorem 155:
Theorem (155) [serial 1256] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1248] 


Theorem (157)                               [serial 1244] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [111] ->
Q [14] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1241]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 156:
Theorem (156) [serial 1248] used for:
    normalization of [serial 1244] 


Theorem (158)                               [serial 1241] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [111] ->
Q [14] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1232]
Solved by:  Substitution of Assertion Labels
and theorem 157:
Theorem (157) [serial 1244] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1241] 


Theorem (159)                               [serial 1232] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [111] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1229]
Solved by:  Substitution of Assertion Labels
and theorem 158:
Theorem (158) [serial 1241] used for:
  Substituted assertions' predicates for labels  [serial 1232] 


Theorem (160)                               [serial 1238] 
P [111] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [111] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1233]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (161)                               [serial 1233] 
P [111] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [111] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1229]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 160:
Theorem (160) [serial 1238] used for:
  Associativity: (b.c).a = a.b.c [serial 1233] 


Theorem (162)                               [serial 1229] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [111] eb!(true)
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1227]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 159 161:
Theorem (159) [serial 1232] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1229] 
Theorem (161) [serial 1233] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1229] 


Theorem (163)                               [serial 1279] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [111] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1276]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (164)                               [serial 1276] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [111] << ( not ( iSeg.v_n <= v )
  and not ( nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1273]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 163:
Theorem (163) [serial 1279] used for:
  Associativity: (b.c).a = a.b.c [serial 1276] 


Theorem (165)                               [serial 1273] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [111] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1271]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 164:
Theorem (164) [serial 1276] used for:
    normalization of [serial 1273] 


Theorem (166)                               [serial 1271] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [111] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1268]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 165:
Theorem (165) [serial 1273] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1271] 


Theorem (167)                               [serial 1268] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [111] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1262]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 166:
Theorem (166) [serial 1271] used for:
    normalization of [serial 1268] 


Theorem (168)                               [serial 1262] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [111] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) >>
Why created:    normalization of [serial 1257]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 167:
Theorem (167) [serial 1268] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1262] 


Theorem (169)                               [serial 1257] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [111] << not ( not ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e <= v*v )
  and ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1250]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 168:
Theorem (168) [serial 1262] used for:
    normalization of [serial 1257] 


Theorem (170)                               [serial 1250] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [111] << not ( not ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
  and ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) >>
Why created:    normalization of [serial 1245]
Solved by:  Guided Substitution of Equals
and theorem 169:
Theorem (169) [serial 1257] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1250] 


Theorem (171)                               [serial 1245] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [111] ->
Q [111] << not ( ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
  and not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1242]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 170:
Theorem (170) [serial 1250] used for:
    normalization of [serial 1245] 


Theorem (172)                               [serial 1242] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [111] ->
Q [111] << not ( ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
  and not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1234]
Solved by:  Substitution of Assertion Labels
and theorem 171:
Theorem (171) [serial 1245] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1242] 


Theorem (173)                               [serial 1234] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [111] ->
Q [111] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1230]
Solved by:  Substitution of Assertion Labels
and theorem 172:
Theorem (172) [serial 1242] used for:
  Substituted assertions' predicates for labels  [serial 1234] 


Theorem (174)                               [serial 1239] 
P [111] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [111] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1235]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (175)                               [serial 1235] 
P [111] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [111] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1230]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 174:
Theorem (174) [serial 1239] used for:
  Associativity: (b.c).a = a.b.c [serial 1235] 


Theorem (176)                               [serial 1230] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [111] sb!(false)
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1227]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 173 175:
Theorem (173) [serial 1234] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1230] 
Theorem (175) [serial 1235] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1230] 


Theorem (177)                               [serial 1240] 
P [111] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [111] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1236]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (178)                               [serial 1236] 
P [111] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [111] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1231]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 177:
Theorem (177) [serial 1240] used for:
  Associativity: (b.c).a = a.b.c [serial 1236] 


Theorem (179)                               [serial 1278] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1264]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (180)                               [serial 1264] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1258]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 179:
Theorem (179) [serial 1278] used for:
  Associativity: (b.c).a = a.b.c [serial 1264] 


Theorem (181)                               [serial 1258] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [33] << ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e <= v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1252]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 180:
Theorem (180) [serial 1264] used for:
    normalization of [serial 1258] 


Theorem (182)                               [serial 1252] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [111] ->
Q [33] << ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1246]
Solved by:  Guided Substitution of Equals
and theorem 181:
Theorem (181) [serial 1258] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1252] 


Theorem (183)                               [serial 1246] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [111] ->
Q [33] << ( ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1243]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 182:
Theorem (182) [serial 1252] used for:
    normalization of [serial 1246] 


Theorem (184)                               [serial 1243] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [111] ->
Q [33] << ( ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
   or ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1237]
Solved by:  Substitution of Assertion Labels
and theorem 183:
Theorem (183) [serial 1246] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1243] 


Theorem (185)                               [serial 1237] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [111] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1231]
Solved by:  Substitution of Assertion Labels
and theorem 184:
Theorem (184) [serial 1243] used for:
  Substituted assertions' predicates for labels  [serial 1237] 


Theorem (186)                               [serial 1231] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [111] ca!(0 mpss)
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1227]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 178 185:
Theorem (178) [serial 1236] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1231] 
Theorem (185) [serial 1237] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1231] 


Theorem (187)                               [serial 1227] 
P [106] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [111]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1225]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 162 176 186:
Theorem (162) [serial 1229] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1227] 
Theorem (176) [serial 1230] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1227] 
Theorem (186) [serial 1231] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1227] 


Theorem (188)                               [serial 1225] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [111]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1161]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 187:
Theorem (187) [serial 1227] used for:
    normalization of [serial 1225] 


Theorem (189)                               [serial 1161] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [111]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 188:
Theorem (188) [serial 1225] used for:
  Associativity: (b.c).a = a.b.c [serial 1161] 


Theorem (190)                               [serial 1156] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [111]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 189:
Theorem (189) [serial 1161] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1156] 


Theorem (191)                               [serial 1357] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1356]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (192)                               [serial 1358] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1356]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (193)                               [serial 1361] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:    normalization of [serial 1359]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (194)                               [serial 1359] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1356]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 193:
Theorem (193) [serial 1361] used for:
    normalization of [serial 1359] 


Theorem (195)                               [serial 1356] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1350]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 191 192 194:
Theorem (191) [serial 1357] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1356] 
Theorem (192) [serial 1358] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1356] 
Theorem (194) [serial 1359] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1356] 


Theorem (196)                               [serial 1350] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1346]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 195:
Theorem (195) [serial 1356] used for:
  Associativity: (b.c).a = a.b.c [serial 1350] 


Theorem (197)                               [serial 1346] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1338]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 196:
Theorem (196) [serial 1350] used for:
    normalization of [serial 1346] 


Theorem (198)                               [serial 1338] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1334]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 197:
Theorem (197) [serial 1346] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1338] 


Theorem (199)                               [serial 1334] 
P [106] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1326]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 198:
Theorem (198) [serial 1338] used for:
    normalization of [serial 1334] 


Theorem (200)                               [serial 1326] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1322]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 199:
Theorem (199) [serial 1334] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1326] 


Theorem (201)                               [serial 1322] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
  and not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1319]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 200:
Theorem (200) [serial 1326] used for:
    normalization of [serial 1322] 


Theorem (202)                               [serial 1319] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
  and not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1316]
Solved by:  Guided Substitution of Equals
and theorem 201:
Theorem (201) [serial 1322] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1319] 


Theorem (203)                               [serial 1316] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
  and not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1299]
Solved by:  Substitution of Assertion Labels
and theorem 202:
Theorem (202) [serial 1319] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1316] 


Theorem (204)                               [serial 1299] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [12] << SB()
  and not EB() >>
Why created:    normalization of [serial 1289]
Solved by:  Substitution of Assertion Labels
and theorem 203:
Theorem (203) [serial 1316] used for:
  Substituted assertions' predicates for labels  [serial 1299] 


Theorem (205)                               [serial 1289] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [115] ->
Q [12] << SB()
  and not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1283]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 204:
Theorem (204) [serial 1299] used for:
    normalization of [serial 1289] 


Theorem (206)                               [serial 1283] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [115] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1280]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 205:
Theorem (205) [serial 1289] used for:
  Associativity: (b.c).a = a.b.c [serial 1283] 


Theorem (207)                               [serial 1305] 
P [115] << iSeg.v_n <= v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1295]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (208)                               [serial 1295] 
P [115] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [115] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1290]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 207:
Theorem (207) [serial 1305] used for:
    normalization of [serial 1295] 


Theorem (209)                               [serial 1290] 
P [115] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [115] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1284]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 208:
Theorem (208) [serial 1295] used for:
  Associativity: (b.c).a = a.b.c [serial 1290] 


Theorem (210)                               [serial 1284] 
P [115] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [115] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1280]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 209:
Theorem (209) [serial 1290] used for:
  Associativity: (b.c).a = a.b.c [serial 1284] 


Theorem (211)                               [serial 1280] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [115] sb!(true)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1162]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 206 210:
Theorem (206) [serial 1283] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1280] 
Theorem (210) [serial 1284] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1280] 


Theorem (212)                               [serial 1352] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [115] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1347]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (213)                               [serial 1347] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [115] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1340]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 212:
Theorem (212) [serial 1352] used for:
    normalization of [serial 1347] 


Theorem (214)                               [serial 1340] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [115] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1335]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 213:
Theorem (213) [serial 1347] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1340] 


Theorem (215)                               [serial 1335] 
P [106] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [115] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1328]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 214:
Theorem (214) [serial 1340] used for:
    normalization of [serial 1335] 


Theorem (216)                               [serial 1328] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [115] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1323]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 215:
Theorem (215) [serial 1335] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1328] 


Theorem (217)                               [serial 1323] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [115] << not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1320]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 216:
Theorem (216) [serial 1328] used for:
    normalization of [serial 1323] 


Theorem (218)                               [serial 1320] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [115] << not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1317]
Solved by:  Guided Substitution of Equals
and theorem 217:
Theorem (217) [serial 1323] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1320] 


Theorem (219)                               [serial 1317] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [115] << not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1301]
Solved by:  Substitution of Assertion Labels
and theorem 218:
Theorem (218) [serial 1320] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1317] 


Theorem (220)                               [serial 1301] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [115] << not EB() >>
Why created:    normalization of [serial 1291]
Solved by:  Substitution of Assertion Labels
and theorem 219:
Theorem (219) [serial 1317] used for:
  Substituted assertions' predicates for labels  [serial 1301] 


Theorem (221)                               [serial 1291] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [115] ->
Q [115] << not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1285]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 220:
Theorem (220) [serial 1301] used for:
    normalization of [serial 1291] 


Theorem (222)                               [serial 1285] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [115] ->
Q [115] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1281]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 221:
Theorem (221) [serial 1291] used for:
  Associativity: (b.c).a = a.b.c [serial 1285] 


Theorem (223)                               [serial 1307] 
P [115] << iSeg.v_n <= v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1296]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (224)                               [serial 1296] 
P [115] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( not EB() )@now >>
S [115] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1292]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 223:
Theorem (223) [serial 1307] used for:
    normalization of [serial 1296] 


Theorem (225)                               [serial 1292] 
P [115] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [115] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1286]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 224:
Theorem (224) [serial 1296] used for:
  Associativity: (b.c).a = a.b.c [serial 1292] 


Theorem (226)                               [serial 1286] 
P [115] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [115] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1281]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 225:
Theorem (225) [serial 1292] used for:
  Associativity: (b.c).a = a.b.c [serial 1286] 


Theorem (227)                               [serial 1281] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [115] eb!(false)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1162]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 222 226:
Theorem (222) [serial 1285] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1281] 
Theorem (226) [serial 1286] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1281] 


Theorem (228)                               [serial 1309] 
P [115] << iSeg.v_n <= v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1297]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (229)                               [serial 1297] 
P [115] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [115] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1293]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 228:
Theorem (228) [serial 1309] used for:
    normalization of [serial 1297] 


Theorem (230)                               [serial 1293] 
P [115] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [115] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1287]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 229:
Theorem (229) [serial 1297] used for:
  Associativity: (b.c).a = a.b.c [serial 1293] 


Theorem (231)                               [serial 1287] 
P [115] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [115] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1282]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 230:
Theorem (230) [serial 1293] used for:
  Associativity: (b.c).a = a.b.c [serial 1287] 


Theorem (232)                               [serial 1355] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1342]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (233)                               [serial 1342] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1336]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 232:
Theorem (232) [serial 1355] used for:
  Associativity: (b.c).a = a.b.c [serial 1342] 


Theorem (234)                               [serial 1336] 
P [106] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1330]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 233:
Theorem (233) [serial 1342] used for:
    normalization of [serial 1336] 


Theorem (235)                               [serial 1330] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1324]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 234:
Theorem (234) [serial 1336] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1330] 


Theorem (236)                               [serial 1324] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [33] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1321]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 235:
Theorem (235) [serial 1330] used for:
    normalization of [serial 1324] 


Theorem (237)                               [serial 1321] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [33] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1318]
Solved by:  Guided Substitution of Equals
and theorem 236:
Theorem (236) [serial 1324] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1321] 


Theorem (238)                               [serial 1318] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [33] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) )
   or ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1303]
Solved by:  Substitution of Assertion Labels
and theorem 237:
Theorem (237) [serial 1321] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1318] 


Theorem (239)                               [serial 1303] 
P [106] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [115] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1294]
Solved by:  Substitution of Assertion Labels
and theorem 238:
Theorem (238) [serial 1318] used for:
  Substituted assertions' predicates for labels  [serial 1303] 


Theorem (240)                               [serial 1294] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [115] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1288]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 239:
Theorem (239) [serial 1303] used for:
    normalization of [serial 1294] 


Theorem (241)                               [serial 1288] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [115] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1282]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 240:
Theorem (240) [serial 1294] used for:
  Associativity: (b.c).a = a.b.c [serial 1288] 


Theorem (242)                               [serial 1282] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [115] ca!(0 mpss)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1162]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 231 241:
Theorem (231) [serial 1287] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1282] 
Theorem (241) [serial 1288] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1282] 


Theorem (243)                               [serial 1162] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [115]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 211 227 242:
Theorem (211) [serial 1280] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1162] 
Theorem (227) [serial 1281] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1162] 
Theorem (242) [serial 1282] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1162] 


Theorem (244)                               [serial 1157] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [115]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 243:
Theorem (243) [serial 1162] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1157] 


Theorem (245)                               [serial 1440] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1439]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (246)                               [serial 1441] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1439]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (247)                               [serial 1456] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1452]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (248)                               [serial 1452] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*b ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1448]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 247:
Theorem (247) [serial 1456] used for:
    normalization of [serial 1452] 


Theorem (249)                               [serial 1448] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:    normalization of [serial 1442]
Solved by:  Guided Substitution of Equals
and theorem 248:
Theorem (248) [serial 1452] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1448] 


Theorem (250)                               [serial 1442] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1439]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 249:
Theorem (249) [serial 1448] used for:
    normalization of [serial 1442] 


Theorem (251)                               [serial 1439] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1433]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 245 246 250:
Theorem (245) [serial 1440] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1439] 
Theorem (246) [serial 1441] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1439] 
Theorem (250) [serial 1442] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1439] 


Theorem (252)                               [serial 1433] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1429]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 251:
Theorem (251) [serial 1439] used for:
  Associativity: (b.c).a = a.b.c [serial 1433] 


Theorem (253)                               [serial 1429] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1421]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 252:
Theorem (252) [serial 1433] used for:
    normalization of [serial 1429] 


Theorem (254)                               [serial 1421] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1417]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 253:
Theorem (253) [serial 1429] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1421] 


Theorem (255)                               [serial 1417] 
P [106] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1409]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 254:
Theorem (254) [serial 1421] used for:
    normalization of [serial 1417] 


Theorem (256)                               [serial 1409] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1405]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 255:
Theorem (255) [serial 1417] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1409] 


Theorem (257)                               [serial 1405] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
  and not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1402]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 256:
Theorem (256) [serial 1409] used for:
    normalization of [serial 1405] 


Theorem (258)                               [serial 1402] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
  and not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1399]
Solved by:  Guided Substitution of Equals
and theorem 257:
Theorem (257) [serial 1405] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1402] 


Theorem (259)                               [serial 1399] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
  and not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1382]
Solved by:  Substitution of Assertion Labels
and theorem 258:
Theorem (258) [serial 1402] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1399] 


Theorem (260)                               [serial 1382] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [12] << SB()
  and not EB() >>
Why created:    normalization of [serial 1372]
Solved by:  Substitution of Assertion Labels
and theorem 259:
Theorem (259) [serial 1399] used for:
  Substituted assertions' predicates for labels  [serial 1382] 


Theorem (261)                               [serial 1372] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [120] ->
Q [12] << SB()
  and not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1366]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 260:
Theorem (260) [serial 1382] used for:
    normalization of [serial 1372] 


Theorem (262)                               [serial 1366] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [120] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1363]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 261:
Theorem (261) [serial 1372] used for:
  Associativity: (b.c).a = a.b.c [serial 1366] 


Theorem (263)                               [serial 1388] 
P [120] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1378]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (264)                               [serial 1378] 
P [120] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [120] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1373]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 263:
Theorem (263) [serial 1388] used for:
    normalization of [serial 1378] 


Theorem (265)                               [serial 1373] 
P [120] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [120] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1367]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 264:
Theorem (264) [serial 1378] used for:
  Associativity: (b.c).a = a.b.c [serial 1373] 


Theorem (266)                               [serial 1367] 
P [120] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [120] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1363]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 265:
Theorem (265) [serial 1373] used for:
  Associativity: (b.c).a = a.b.c [serial 1367] 


Theorem (267)                               [serial 1363] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [120] sb!(true)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1163]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 262 266:
Theorem (262) [serial 1366] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1363] 
Theorem (266) [serial 1367] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1363] 


Theorem (268)                               [serial 1435] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [120] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1430]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (269)                               [serial 1430] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [120] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1423]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 268:
Theorem (268) [serial 1435] used for:
    normalization of [serial 1430] 


Theorem (270)                               [serial 1423] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [120] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1418]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 269:
Theorem (269) [serial 1430] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1423] 


Theorem (271)                               [serial 1418] 
P [106] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [120] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1411]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 270:
Theorem (270) [serial 1423] used for:
    normalization of [serial 1418] 


Theorem (272)                               [serial 1411] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [120] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1406]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 271:
Theorem (271) [serial 1418] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1411] 


Theorem (273)                               [serial 1406] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [120] << not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1403]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 272:
Theorem (272) [serial 1411] used for:
    normalization of [serial 1406] 


Theorem (274)                               [serial 1403] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [120] << not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1400]
Solved by:  Guided Substitution of Equals
and theorem 273:
Theorem (273) [serial 1406] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1403] 


Theorem (275)                               [serial 1400] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [120] << not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1384]
Solved by:  Substitution of Assertion Labels
and theorem 274:
Theorem (274) [serial 1403] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1400] 


Theorem (276)                               [serial 1384] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [120] << not EB() >>
Why created:    normalization of [serial 1374]
Solved by:  Substitution of Assertion Labels
and theorem 275:
Theorem (275) [serial 1400] used for:
  Substituted assertions' predicates for labels  [serial 1384] 


Theorem (277)                               [serial 1374] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [120] ->
Q [120] << not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1368]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 276:
Theorem (276) [serial 1384] used for:
    normalization of [serial 1374] 


Theorem (278)                               [serial 1368] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [120] ->
Q [120] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1364]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 277:
Theorem (277) [serial 1374] used for:
  Associativity: (b.c).a = a.b.c [serial 1368] 


Theorem (279)                               [serial 1390] 
P [120] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1379]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (280)                               [serial 1379] 
P [120] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( not EB() )@now >>
S [120] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1375]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 279:
Theorem (279) [serial 1390] used for:
    normalization of [serial 1379] 


Theorem (281)                               [serial 1375] 
P [120] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [120] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1369]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 280:
Theorem (280) [serial 1379] used for:
  Associativity: (b.c).a = a.b.c [serial 1375] 


Theorem (282)                               [serial 1369] 
P [120] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [120] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1364]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 281:
Theorem (281) [serial 1375] used for:
  Associativity: (b.c).a = a.b.c [serial 1369] 


Theorem (283)                               [serial 1364] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [120] eb!(false)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1163]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 278 282:
Theorem (278) [serial 1368] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1364] 
Theorem (282) [serial 1369] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1364] 


Theorem (284)                               [serial 1392] 
P [120] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1380]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (285)                               [serial 1380] 
P [120] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [120] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1376]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 284:
Theorem (284) [serial 1392] used for:
    normalization of [serial 1380] 


Theorem (286)                               [serial 1376] 
P [120] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [120] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1370]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 285:
Theorem (285) [serial 1380] used for:
  Associativity: (b.c).a = a.b.c [serial 1376] 


Theorem (287)                               [serial 1370] 
P [120] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [120] ->
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1365]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 286:
Theorem (286) [serial 1376] used for:
  Associativity: (b.c).a = a.b.c [serial 1370] 


Theorem (288)                               [serial 1454] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1451]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (289)                               [serial 1451] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*b ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1444]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 288:
Theorem (288) [serial 1454] used for:
    normalization of [serial 1451] 


Theorem (290)                               [serial 1444] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:    normalization of [serial 1438]
Solved by:  Guided Substitution of Equals
and theorem 289:
Theorem (289) [serial 1451] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1444] 


Theorem (291)                               [serial 1438] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1425]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 290:
Theorem (290) [serial 1444] used for:
    normalization of [serial 1438] 


Theorem (292)                               [serial 1425] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1419]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 291:
Theorem (291) [serial 1438] used for:
  Associativity: (b.c).a = a.b.c [serial 1425] 


Theorem (293)                               [serial 1419] 
P [106] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1413]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 292:
Theorem (292) [serial 1425] used for:
    normalization of [serial 1419] 


Theorem (294)                               [serial 1413] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1407]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 293:
Theorem (293) [serial 1419] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1413] 


Theorem (295)                               [serial 1407] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1404]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 294:
Theorem (294) [serial 1413] used for:
    normalization of [serial 1407] 


Theorem (296)                               [serial 1404] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1401]
Solved by:  Guided Substitution of Equals
and theorem 295:
Theorem (295) [serial 1407] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1404] 


Theorem (297)                               [serial 1401] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) )
   or ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1386]
Solved by:  Substitution of Assertion Labels
and theorem 296:
Theorem (296) [serial 1404] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1401] 


Theorem (298)                               [serial 1386] 
P [106] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [120] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1377]
Solved by:  Substitution of Assertion Labels
and theorem 297:
Theorem (297) [serial 1401] used for:
  Substituted assertions' predicates for labels  [serial 1386] 


Theorem (299)                               [serial 1377] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [120] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1371]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 298:
Theorem (298) [serial 1386] used for:
    normalization of [serial 1377] 


Theorem (300)                               [serial 1371] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [120] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1365]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 299:
Theorem (299) [serial 1377] used for:
  Associativity: (b.c).a = a.b.c [serial 1371] 


Theorem (301)                               [serial 1365] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [120] ca!(0 mpss)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1163]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 287 300:
Theorem (287) [serial 1370] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1365] 
Theorem (300) [serial 1371] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1365] 


Theorem (302)                               [serial 1163] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [120]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 267 283 301:
Theorem (267) [serial 1363] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1163] 
Theorem (283) [serial 1364] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1163] 
Theorem (301) [serial 1365] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1163] 


Theorem (303)                               [serial 1158] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [120]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B3>> S3 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 302:
Theorem (302) [serial 1163] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1158] 


Theorem (304)                               [serial 1517] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1514]
Solved by:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (305)                               [serial 1514] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*b ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1511]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 304:
Theorem (304) [serial 1517] used for:
    normalization of [serial 1514] 


Theorem (306)                               [serial 1511] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:    normalization of [serial 1507]
Solved by:  Guided Substitution of Equals
and theorem 305:
Theorem (305) [serial 1514] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1511] 


Theorem (307)                               [serial 1507] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1503]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 306:
Theorem (306) [serial 1511] used for:
    normalization of [serial 1507] 


Theorem (308)                               [serial 1503] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) >>
Why created:    normalization of [serial 1499]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 307:
Theorem (307) [serial 1507] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1503] 


Theorem (309)                               [serial 1499] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) )
   or not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1497]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 308:
Theorem (308) [serial 1503] used for:
    normalization of [serial 1499] 


Theorem (310)                               [serial 1497] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v
   or not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1494]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 309:
Theorem (309) [serial 1499] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1497] 


Theorem (311)                               [serial 1494] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v )
   or ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1490]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 310:
Theorem (310) [serial 1497] used for:
  Associativity: (b.c).a = a.b.c [serial 1494] 


Theorem (312)                               [serial 1490] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) )
   or not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1488]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 311:
Theorem (311) [serial 1494] used for:
    normalization of [serial 1490] 


Theorem (313)                               [serial 1488] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) )
   or not ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1485]
Solved by:  Substitution of Assertion Labels
and theorem 312:
Theorem (312) [serial 1490] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1488] 


Theorem (314)                               [serial 1485] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << EB()
   or not SB() >>
Why created:    normalization of [serial 1482]
Solved by:  Substitution of Assertion Labels
and theorem 313:
Theorem (313) [serial 1488] used for:
  Substituted assertions' predicates for labels  [serial 1485] 


Theorem (315)                               [serial 1482] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1474]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 314:
Theorem (314) [serial 1485] used for:
    normalization of [serial 1482] 


Theorem (316)                               [serial 1474] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1466]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 315:
Theorem (315) [serial 1482] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1474] 


Theorem (317)                               [serial 1479] 
P [125] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [125] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1475]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (318)                               [serial 1475] 
P [125] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [125] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1466]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 317:
Theorem (317) [serial 1479] used for:
  Associativity: (b.c).a = a.b.c [serial 1475] 


Theorem (319)                               [serial 1466] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] sb!(false)
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1462]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 316 318:
Theorem (316) [serial 1474] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1466] 
Theorem (318) [serial 1475] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1466] 


Theorem (320)                               [serial 1462] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [125] sb!(false)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1459]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 319:
Theorem (319) [serial 1466] used for:
    normalization of [serial 1462] 


Theorem (321)                               [serial 1459] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [125] sb!(false)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1164]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 320:
Theorem (320) [serial 1462] used for:
  Associativity: (b.c).a = a.b.c [serial 1459] 


Theorem (322)                               [serial 1520] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [125] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1519]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (323)                               [serial 1524] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1522]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (324)                               [serial 1522] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [125] ->
Q [86] << v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1521]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 323:
Theorem (323) [serial 1524] used for:
    normalization of [serial 1522] 


Theorem (325)                               [serial 1521] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [125] ->
Q [86] << v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1519]
Solved by:  Guided Substitution of Equals
and theorem 324:
Theorem (324) [serial 1522] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1521] 


Theorem (326)                               [serial 1519] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [125] ->
Q [125] << v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss >>
Why created:  Guided Substitution of Equals Transitivity: x<y and y<z -> x<z  [serial 1509]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 322 325:
Theorem (322) [serial 1520] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1519] 
Theorem (325) [serial 1521] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1519] 


Theorem (327)                               [serial 1509] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss >>
Why created:    normalization of [serial 1506]
Solved by:  Guided Substitution of Equals
  Transitivity: x<y and y<z -> x<z
and theorem 326:
Theorem (326) [serial 1519] used for:
  Guided Substitution of Equals Transitivity: x<y and y<z -> x<z  [serial 1509] 


Theorem (328)                               [serial 1506] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1501]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 327:
Theorem (327) [serial 1509] used for:
    normalization of [serial 1506] 


Theorem (329)                               [serial 1501] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) >>
Why created:    normalization of [serial 1498]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 328:
Theorem (328) [serial 1506] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1501] 


Theorem (330)                               [serial 1498] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1492]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 329:
Theorem (329) [serial 1501] used for:
    normalization of [serial 1498] 


Theorem (331)                               [serial 1492] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1489]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 330:
Theorem (330) [serial 1498] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1492] 


Theorem (332)                               [serial 1489] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1487]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 331:
Theorem (331) [serial 1492] used for:
    normalization of [serial 1489] 


Theorem (333)                               [serial 1487] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1476]
Solved by:  Substitution of Assertion Labels
and theorem 332:
Theorem (332) [serial 1489] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1487] 


Theorem (334)                               [serial 1476] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ->
Q [125] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1468]
Solved by:  Substitution of Assertion Labels
and theorem 333:
Theorem (333) [serial 1487] used for:
  Substituted assertions' predicates for labels  [serial 1476] 


Theorem (335)                               [serial 1480] 
P [125] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [125] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1477]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (336)                               [serial 1477] 
P [125] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [125] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1468]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 335:
Theorem (335) [serial 1480] used for:
  Associativity: (b.c).a = a.b.c [serial 1477] 


Theorem (337)                               [serial 1468] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] eb!(false)
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1463]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 334 336:
Theorem (334) [serial 1476] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1468] 
Theorem (336) [serial 1477] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1468] 


Theorem (338)                               [serial 1463] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [125] eb!(false)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1460]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 337:
Theorem (337) [serial 1468] used for:
    normalization of [serial 1463] 


Theorem (339)                               [serial 1460] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [125] eb!(false)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1164]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 338:
Theorem (338) [serial 1463] used for:
  Associativity: (b.c).a = a.b.c [serial 1460] 


Theorem (340)                               [serial 1481] 
P [125] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [125] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1478]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (341)                               [serial 1478] 
P [125] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [125] ->
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1470]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 340:
Theorem (340) [serial 1481] used for:
  Associativity: (b.c).a = a.b.c [serial 1478] 


Theorem (342)                               [serial 1470] 
P [106] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [125] ca!(xl)
Q [62] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1464]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorem 341:
Theorem (341) [serial 1478] used for:
  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1470] 


Theorem (343)                               [serial 1464] 
P [106] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [125] ca!(xl)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1461]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 342:
Theorem (342) [serial 1470] used for:
    normalization of [serial 1464] 


Theorem (344)                               [serial 1461] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [125] ca!(xl)
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1164]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 343:
Theorem (343) [serial 1464] used for:
  Associativity: (b.c).a = a.b.c [serial 1461] 


Theorem (345)                               [serial 1164] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [125]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 321 339 344:
Theorem (321) [serial 1459] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1164] 
Theorem (339) [serial 1460] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1164] 
Theorem (344) [serial 1461] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1164] 


Theorem (346)                               [serial 1159] 
P [106] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [125]   {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B4>> S4 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 345:
Theorem (345) [serial 1164] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1159] 


Theorem (347)                               [serial 1153] 
P [102] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [106]   if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 123 153 190 244 303 346:
Theorem (123) [serial 1154] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153] 
Theorem (153) [serial 1155] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1153] 
Theorem (190) [serial 1156] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1153] 
Theorem (244) [serial 1157] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1153] 
Theorem (303) [serial 1158] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1153] 
Theorem (346) [serial 1159] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1153] 


Theorem (348)                               [serial 1151] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [102] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1017]
Solved by:  Introduction of Existential Quantification
and theorems 111 347:
Theorem (111) [serial 1152] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151] 
Theorem (347) [serial 1153] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151] 


Theorem (349)                               [serial 1017] 
P [101] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [102] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A};
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 348:
Theorem (348) [serial 1151] used for:
  Associativity: (b.c).a = a.b.c [serial 1017] 


Theorem (350)                               [serial 1018] 
P [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [129] ->
Q [60] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{};
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (351)                               [serial 1531] 
P [62] << iSeg.e <= p
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [135] ->
Q [136] << CMA = ma
  and CMA.seg[1 + i] = nSeg >>
Why created:    normalization of [serial 1528]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (352)                               [serial 1528] 
P [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [135] ->
Q [136] << nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1526]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 351:
Theorem (351) [serial 1531] used for:
    normalization of [serial 1528] 


Theorem (353)                               [serial 1526] 
P [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [135] iSeg := nSeg
Q [136] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 352:
Theorem (352) [serial 1528] used for:
  applied wp for assignment [serial 1526] 


Theorem (354)                               [serial 1533] 
P [136] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
S [137] ->
Q [64] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
Why created:    normalization of [serial 1529]
Solved by:  Identity (id):  P->P is tautology


Theorem (355)                               [serial 1529] 
P [136] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [137] ->
Q [64] << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1527]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 354:
Theorem (354) [serial 1533] used for:
    normalization of [serial 1529] 


Theorem (356)                               [serial 1527] 
P [136] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [137] i := i + 1
Q [64] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1019]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 355:
Theorem (355) [serial 1529] used for:
  applied wp for assignment [serial 1527] 


Theorem (357)                               [serial 1019] 
P [62] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [135]   iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1]
    and ma = CMA >>
  i := i + 1 
Q [64] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 353 356:
Theorem (353) [serial 1526] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019] 
Theorem (356) [serial 1527] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1019] 


Theorem (358)                               [serial 1540] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [142] ->
Q [60] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (359)                               [serial 1541] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [142] ->
Q [60] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (360)                               [serial 1546] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [142] ->
Q [60] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1544]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (361)                               [serial 1544] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [142] ->
Q [60] << ma.seg[1 + i] = ma.seg[1 + i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1542]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 360:
Theorem (360) [serial 1546] used for:
  Equality Law (idistr):  a=a <-> true [serial 1544] 


Theorem (362)                               [serial 1542] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [142] ->
Q [60] << CMA.seg[1 + i] = ma.seg[1 + i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538]
Solved by:  Guided Substitution of Equals
and theorem 361:
Theorem (361) [serial 1544] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1542] 


Theorem (363)                               [serial 1545] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [142] ->
Q [60] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1543]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (364)                               [serial 1543] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [142] ->
Q [60] << i < CMA.num_segments >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538]
Solved by:  Guided Substitution of Equals
and theorem 363:
Theorem (363) [serial 1545] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1543] 


Theorem (365)                               [serial 1538] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [142] ->
Q [60] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = ma.seg[1 + i]
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1536]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 358 359 362 364:
Theorem (358) [serial 1540] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538] 
Theorem (359) [serial 1541] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538] 
Theorem (362) [serial 1542] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538] 
Theorem (364) [serial 1543] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538] 


Theorem (366)                               [serial 1536] 
P [64] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [142] ->
Q [60] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1020]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 365:
Theorem (365) [serial 1538] used for:
    normalization of [serial 1536] 


Theorem (367)                               [serial 1020] 
P [64] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [142] nSeg := ma.seg[i + 1]
Q [60] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 366:
Theorem (366) [serial 1536] used for:
  applied wp for assignment [serial 1020] 


Theorem (368)                               [serial 1553] 
P [64] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [147] ->
Q [147] << true >>
Why created:    normalization of [serial 1549]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (369)                               [serial 1549] 
P [64] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [147] ->
Q [147] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1547]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 368:
Theorem (368) [serial 1553] used for:
    normalization of [serial 1549] 


Theorem (370)                               [serial 1571] 
P [147] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [147] ->
Q [148] << CMA = ma >>
Why created:    normalization of [serial 1566]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (371)                               [serial 1566] 
P [147] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [147] ->
Q [148] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 370:
Theorem (370) [serial 1571] used for:
    normalization of [serial 1566] 


Theorem (372)                               [serial 1582] 
P [147] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [147] ->
Q [148] << i = ma.num_segments >>
Why created:    normalization of [serial 1579]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (373)                               [serial 1579] 
P [147] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [147] ->
Q [148] << ma.num_segments = i >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1573]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 372:
Theorem (372) [serial 1582] used for:
    normalization of [serial 1579] 


Theorem (374)                               [serial 1573] 
P [147] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [147] ->
Q [148] << CMA.num_segments = i >>
Why created:    normalization of [serial 1567]
Solved by:  Guided Substitution of Equals
and theorem 373:
Theorem (373) [serial 1579] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1573] 


Theorem (375)                               [serial 1567] 
P [147] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [147] ->
Q [148] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 374:
Theorem (374) [serial 1573] used for:
    normalization of [serial 1567] 


Theorem (376)                               [serial 1575] 
P [147] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [147] ->
Q [148] << CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1568]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (377)                               [serial 1568] 
P [147] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [147] ->
Q [148] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 376:
Theorem (376) [serial 1575] used for:
    normalization of [serial 1568] 


Theorem (378)                               [serial 1561] 
P [147] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [147] ->
Q [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:  Law of And-Simplification:  P and true is P [serial 1555]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 371 375 377:
Theorem (371) [serial 1566] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561] 
Theorem (375) [serial 1567] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561] 
Theorem (377) [serial 1568] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561] 


Theorem (379)                               [serial 1555] 
P [147] << true
  and ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) >>
S [147] ->
Q [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1550]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 378:
Theorem (378) [serial 1561] used for:
  Law of And-Simplification:  P and true is P [serial 1555] 


Theorem (380)                               [serial 1550] 
P [147] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [147] ->
Q [148] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1547]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 379:
Theorem (379) [serial 1555] used for:
    normalization of [serial 1550] 


Theorem (381)                               [serial 1547] 
P [64] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [147] r!
Q [148] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1021]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 369 380:
Theorem (369) [serial 1549] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1547] 
Theorem (380) [serial 1550] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1547] 


Theorem (382)                               [serial 1562] 
P [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [150] ->
Q [66] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1557]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (383)                               [serial 1563] 
P [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [150] ->
Q [66] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1557]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (384)                               [serial 1564] 
P [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [150] ->
Q [66] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1557]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (385)                               [serial 1586] 
P [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [150] ->
Q [66] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1585]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (386)                               [serial 1585] 
P [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [150] ->
Q [66] << ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea; m->trainModes'FS;] ) = [segment: 
v_n->0 mps; v_e->0 mps; e->ma.ea; m->trainModes'FS;] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1584]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 385:
Theorem (385) [serial 1586] used for:
  Equality Law (idistr):  a=a <-> true [serial 1585] 


Theorem (387)                               [serial 1584] 
P [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [150] ->
Q [66] << ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] ) = [segment: 
v_n->0 mps; v_e->0 mps; e->ma.ea; m->trainModes'FS;] >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1565]
Solved by:  Guided Substitution of Equals
and theorem 386:
Theorem (386) [serial 1585] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1584] 


Theorem (388)                               [serial 1565] 
P [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [150] ->
Q [66] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea; m->trainModes'FS;] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1557]
Solved by:  Guided Substitution of Equals
  Substitution of Assertion Labels
and theorem 387:
Theorem (387) [serial 1584] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1565] 


Theorem (389)                               [serial 1557] 
P [148] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [150] ->
Q [66] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea; m->trainModes'FS;] >>
Why created:    normalization of [serial 1551]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 382 383 384 388:
Theorem (382) [serial 1562] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1557] 
Theorem (383) [serial 1563] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1557] 
Theorem (384) [serial 1564] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1557] 
Theorem (388) [serial 1565] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1557] 


Theorem (390)                               [serial 1551] 
P [148] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [150] ->
Q [66] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea; m->trainModes'FS;] ) = NULL_SEGMENT()
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1548]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 389:
Theorem (389) [serial 1557] used for:
    normalization of [serial 1551] 


Theorem (391)                               [serial 1548] 
P [148] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [150] nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea; m->trainModes'FS;]
Q [66] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1021]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 390:
Theorem (390) [serial 1551] used for:
  applied wp for assignment [serial 1548] 


Theorem (392)                               [serial 1021] 
P [64] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [147]   r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea; m->trainModes'FS;] 
Q [66] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 381 391:
Theorem (381) [serial 1547] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1021] 
Theorem (391) [serial 1548] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1021] 


Theorem (393)                               [serial 1022] 
P [64] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [157] ->
Q [73] << true >>
Why created:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (394)                               [serial 1628] 
P [161] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [161] ->
Q [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1627]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (395)                               [serial 1627] 
P [161] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [161] ->
Q [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 394:
Theorem (394) [serial 1628] used for:
  Law of And-Simplification:  P and true is P [serial 1627] 


Theorem (396)                               [serial 1628] 
P [161] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [161] ->
Q [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1627]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (397)                               [serial 1627] 
P [161] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [161] ->
Q [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 396:
Theorem (396) [serial 1628] used for:
  Law of And-Simplification:  P and true is P [serial 1627] 


Theorem (398)                               [serial 1621] 
P [161] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [161] ->
Q [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1601]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 397 397:
Theorem (397) [serial 1627] used for:
   add user-defined axioms to postcondition 
Theorem (397) [serial 1627] used for:
   add user-defined axioms to postcondition 


Theorem (399)                               [serial 1601] 
P [161] << p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() ) >>
S [161] ->
Q [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:    normalization of [serial 1587]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 398:
Theorem (398) [serial 1621] used for:
  Associativity: (b.c).a = a.b.c [serial 1601] 


Theorem (400)                               [serial 1587] 
P [161] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [161] ->
Q [162] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 399:
Theorem (399) [serial 1601] used for:
    normalization of [serial 1587] 


Theorem (401)                               [serial 1641] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << true >>
Why created:    normalization of [serial 1639]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (402)                               [serial 1639] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1638]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 401:
Theorem (401) [serial 1641] used for:
    normalization of [serial 1639] 


Theorem (403)                               [serial 1638] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1637]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 402:
Theorem (402) [serial 1639] used for:
  Law of And-Simplification:  P and P is P [serial 1638] 


Theorem (404)                               [serial 1637] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1636]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 403:
Theorem (403) [serial 1638] used for:
  Law of And-Simplification:  P and P is P [serial 1637] 


Theorem (405)                               [serial 1636] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1635]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 404:
Theorem (404) [serial 1637] used for:
  Law of And-Simplification:  P and P is P [serial 1636] 


Theorem (406)                               [serial 1635] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1634]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 405:
Theorem (405) [serial 1636] used for:
  Law of And-Simplification:  P and P is P [serial 1635] 


Theorem (407)                               [serial 1634] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1633]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 406:
Theorem (406) [serial 1635] used for:
  Law of And-Simplification:  P and P is P [serial 1634] 


Theorem (408)                               [serial 1633] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1631]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 407:
Theorem (407) [serial 1634] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1633] 


Theorem (409)                               [serial 1631] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1629]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 408:
Theorem (408) [serial 1633] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1631] 


Theorem (410)                               [serial 1629] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1603]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 409:
Theorem (409) [serial 1631] used for:
    normalization of [serial 1629] 


Theorem (411)                               [serial 1603] 
P [162] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1589]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 410:
Theorem (410) [serial 1629] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1603] 


Theorem (412)                               [serial 1589] 
P [162] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165] ->
Q [165] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1588]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 411:
Theorem (411) [serial 1603] used for:
    normalization of [serial 1589] 


Theorem (413)                               [serial 1662] 
P [165] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [167] ->
Q [14] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v >>
Why created:    normalization of [serial 1658]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (414)                               [serial 1658] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [167] ->
Q [14] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1655]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 413:
Theorem (413) [serial 1662] used for:
    normalization of [serial 1658] 


Theorem (415)                               [serial 1655] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [167] ->
Q [14] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1646]
Solved by:  Substitution of Assertion Labels
and theorem 414:
Theorem (414) [serial 1658] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1655] 


Theorem (416)                               [serial 1646] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [167] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1643]
Solved by:  Substitution of Assertion Labels
and theorem 415:
Theorem (415) [serial 1655] used for:
  Substituted assertions' predicates for labels  [serial 1646] 


Theorem (417)                               [serial 1652] 
P [167] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [167] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1647]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (418)                               [serial 1647] 
P [167] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [167] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1643]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 417:
Theorem (417) [serial 1652] used for:
  Associativity: (b.c).a = a.b.c [serial 1647] 


Theorem (419)                               [serial 1643] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [167] eb!(true)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1622]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 416 418:
Theorem (416) [serial 1646] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1643] 
Theorem (418) [serial 1647] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1643] 


Theorem (420)                               [serial 1681] 
P [165] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [167] ->
Q [167] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v
   or ( not ( iSeg.v_n <= v )
  and not ( nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1678]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (421)                               [serial 1678] 
P [165] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [167] ->
Q [167] << ( not ( iSeg.v_n <= v )
  and not ( nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) )
   or ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1675]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 420:
Theorem (420) [serial 1681] used for:
  Associativity: (b.c).a = a.b.c [serial 1678] 


Theorem (422)                               [serial 1675] 
P [165] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [167] ->
Q [167] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1673]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 421:
Theorem (421) [serial 1678] used for:
    normalization of [serial 1675] 


Theorem (423)                               [serial 1673] 
P [165] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [167] ->
Q [167] << not ( not ( iSeg.v_e <= v )
  and not ( nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) )
   or not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1670]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 422:
Theorem (422) [serial 1675] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1673] 


Theorem (424)                               [serial 1670] 
P [165] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [167] ->
Q [167] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1664]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 423:
Theorem (423) [serial 1673] used for:
    normalization of [serial 1670] 


Theorem (425)                               [serial 1664] 
P [165] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [167] ->
Q [167] << not ( not ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
  and ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) ) >>
Why created:    normalization of [serial 1659]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 424:
Theorem (424) [serial 1670] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1664] 


Theorem (426)                               [serial 1659] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [167] ->
Q [167] << not ( ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
  and not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1656]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 425:
Theorem (425) [serial 1664] used for:
    normalization of [serial 1659] 


Theorem (427)                               [serial 1656] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [167] ->
Q [167] << not ( ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
  and not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1648]
Solved by:  Substitution of Assertion Labels
and theorem 426:
Theorem (426) [serial 1659] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1656] 


Theorem (428)                               [serial 1648] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [167] ->
Q [167] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1644]
Solved by:  Substitution of Assertion Labels
and theorem 427:
Theorem (427) [serial 1656] used for:
  Substituted assertions' predicates for labels  [serial 1648] 


Theorem (429)                               [serial 1653] 
P [167] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [167] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1649]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (430)                               [serial 1649] 
P [167] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [167] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1644]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 429:
Theorem (429) [serial 1653] used for:
  Associativity: (b.c).a = a.b.c [serial 1649] 


Theorem (431)                               [serial 1644] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [167] sb!(false)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1622]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 428 430:
Theorem (428) [serial 1648] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1644] 
Theorem (430) [serial 1649] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1644] 


Theorem (432)                               [serial 1654] 
P [167] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = ( 0 mpss ) )@now >>
S [167] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1650]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (433)                               [serial 1650] 
P [167] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = ( 0 mpss ) )@now >>
S [167] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1645]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 432:
Theorem (432) [serial 1654] used for:
  Associativity: (b.c).a = a.b.c [serial 1650] 


Theorem (434)                               [serial 1680] 
P [165] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [167] ->
Q [33] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v
   or iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1666]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (435)                               [serial 1666] 
P [165] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [167] ->
Q [33] << ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1660]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 434:
Theorem (434) [serial 1680] used for:
  Associativity: (b.c).a = a.b.c [serial 1666] 


Theorem (436)                               [serial 1660] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [167] ->
Q [33] << ( ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1657]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 435:
Theorem (435) [serial 1666] used for:
    normalization of [serial 1660] 


Theorem (437)                               [serial 1657] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [167] ->
Q [33] << ( ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
   or ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1651]
Solved by:  Substitution of Assertion Labels
and theorem 436:
Theorem (436) [serial 1660] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1657] 


Theorem (438)                               [serial 1651] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [167] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1645]
Solved by:  Substitution of Assertion Labels
and theorem 437:
Theorem (437) [serial 1657] used for:
  Substituted assertions' predicates for labels  [serial 1651] 


Theorem (439)                               [serial 1645] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [167] ca!(0 mpss)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1622]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 433 438:
Theorem (433) [serial 1650] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1645] 
Theorem (438) [serial 1651] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1645] 


Theorem (440)                               [serial 1622] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [167]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1605]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 419 431 439:
Theorem (419) [serial 1643] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1622] 
Theorem (431) [serial 1644] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1622] 
Theorem (439) [serial 1645] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1622] 


Theorem (441)                               [serial 1605] 
P [165] << iSeg.v_e <= v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [167]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1595]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 440:
Theorem (440) [serial 1622] used for:
  Associativity: (b.c).a = a.b.c [serial 1605] 


Theorem (442)                               [serial 1595] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [167]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1590]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 441:
Theorem (441) [serial 1605] used for:
    normalization of [serial 1595] 


Theorem (443)                               [serial 1590] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [167]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1588]
Solved by:  Introduction of Existential Quantification
and theorem 442:
Theorem (442) [serial 1595] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1590] 


Theorem (444)                               [serial 1739] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1735]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (445)                               [serial 1735] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [14] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e <= v*v >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1725]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 444:
Theorem (444) [serial 1739] used for:
    normalization of [serial 1735] 


Theorem (446)                               [serial 1725] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [14] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v >>
Why created:    normalization of [serial 1721]
Solved by:  Guided Substitution of Equals
and theorem 445:
Theorem (445) [serial 1735] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1725] 


Theorem (447)                               [serial 1721] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [170] ->
Q [14] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1718]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 446:
Theorem (446) [serial 1725] used for:
    normalization of [serial 1721] 


Theorem (448)                               [serial 1718] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [170] ->
Q [14] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1692]
Solved by:  Substitution of Assertion Labels
and theorem 447:
Theorem (447) [serial 1721] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1718] 


Theorem (449)                               [serial 1692] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [170] ->
Q [14] << EB() >>
Why created:    normalization of [serial 1685]
Solved by:  Substitution of Assertion Labels
and theorem 448:
Theorem (448) [serial 1718] used for:
  Substituted assertions' predicates for labels  [serial 1692] 


Theorem (450)                               [serial 1685] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [170] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1682]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 449:
Theorem (449) [serial 1692] used for:
    normalization of [serial 1685] 


Theorem (451)                               [serial 1709] 
P [170] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and EB()@now >>
S [170] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1694]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (452)                               [serial 1694] 
P [170] << EB()@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [170] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1686]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 451:
Theorem (451) [serial 1709] used for:
  Associativity: (b.c).a = a.b.c [serial 1694] 


Theorem (453)                               [serial 1686] 
P [170] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [170] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1682]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 452:
Theorem (452) [serial 1694] used for:
    normalization of [serial 1686] 


Theorem (454)                               [serial 1682] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [170] eb!(true)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1623]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 450 453:
Theorem (450) [serial 1685] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1682] 
Theorem (453) [serial 1686] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1682] 


Theorem (455)                               [serial 1743] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [170] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1737]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (456)                               [serial 1737] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [170] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e <= v*v
   or not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1734]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 455:
Theorem (455) [serial 1743] used for:
    normalization of [serial 1737] 


Theorem (457)                               [serial 1734] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [170] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v
   or not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1729]
Solved by:  Guided Substitution of Equals
and theorem 456:
Theorem (456) [serial 1737] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1734] 


Theorem (458)                               [serial 1729] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [170] << not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v )
   or ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1723]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 457:
Theorem (457) [serial 1734] used for:
  Associativity: (b.c).a = a.b.c [serial 1729] 


Theorem (459)                               [serial 1723] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [170] ->
Q [170] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) )
   or not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1720]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 458:
Theorem (458) [serial 1729] used for:
    normalization of [serial 1723] 


Theorem (460)                               [serial 1720] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [170] ->
Q [170] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) )
   or not ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1716]
Solved by:  Substitution of Assertion Labels
and theorem 459:
Theorem (459) [serial 1723] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1720] 


Theorem (461)                               [serial 1716] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [170] ->
Q [170] << EB()
   or not SB() >>
Why created:    normalization of [serial 1712]
Solved by:  Substitution of Assertion Labels
and theorem 460:
Theorem (460) [serial 1720] used for:
  Substituted assertions' predicates for labels  [serial 1716] 


Theorem (462)                               [serial 1712] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [170] ->
Q [170] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1696]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 461:
Theorem (461) [serial 1716] used for:
    normalization of [serial 1712] 


Theorem (463)                               [serial 1696] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [170] ->
Q [170] << not ( SB()
  and not EB() ) >>
Why created:    normalization of [serial 1687]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 462:
Theorem (462) [serial 1712] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1696] 


Theorem (464)                               [serial 1687] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [170] ->
Q [170] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1683]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 463:
Theorem (463) [serial 1696] used for:
    normalization of [serial 1687] 


Theorem (465)                               [serial 1710] 
P [170] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [170] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1698]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (466)                               [serial 1698] 
P [170] << ( not ( SB()
  and not EB() ) )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [170] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1688]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 465:
Theorem (465) [serial 1710] used for:
  Associativity: (b.c).a = a.b.c [serial 1698] 


Theorem (467)                               [serial 1688] 
P [170] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [170] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1683]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 466:
Theorem (466) [serial 1698] used for:
    normalization of [serial 1688] 


Theorem (468)                               [serial 1683] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [170] sb!(false)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1623]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 464 467:
Theorem (464) [serial 1687] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1683] 
Theorem (467) [serial 1688] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1683] 


Theorem (469)                               [serial 1711] 
P [170] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = 0 mpss )@now >>
S [170] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1700]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (470)                               [serial 1700] 
P [170] << ( ca = 0 mpss )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [170] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1689]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 469:
Theorem (469) [serial 1711] used for:
  Associativity: (b.c).a = a.b.c [serial 1700] 


Theorem (471)                               [serial 1689] 
P [170] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = ( 0 mpss ) )@now >>
S [170] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1684]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 470:
Theorem (470) [serial 1700] used for:
    normalization of [serial 1689] 


Theorem (472)                               [serial 1741] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [33] << iSeg.v_e <= v
   or iSeg.v_n <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v >>
Why created:    normalization of [serial 1736]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (473)                               [serial 1736] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [33] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e <= v*v
   or iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1733]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 472:
Theorem (472) [serial 1741] used for:
    normalization of [serial 1736] 


Theorem (474)                               [serial 1733] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [33] << iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v
   or iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1727]
Solved by:  Guided Substitution of Equals
and theorem 473:
Theorem (473) [serial 1736] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1733] 


Theorem (475)                               [serial 1727] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [170] ->
Q [33] << ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1722]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 474:
Theorem (474) [serial 1733] used for:
  Associativity: (b.c).a = a.b.c [serial 1727] 


Theorem (476)                               [serial 1722] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [170] ->
Q [33] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1719]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 475:
Theorem (475) [serial 1727] used for:
    normalization of [serial 1722] 


Theorem (477)                               [serial 1719] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [170] ->
Q [33] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) )
   or ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1702]
Solved by:  Substitution of Assertion Labels
and theorem 476:
Theorem (476) [serial 1722] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1719] 


Theorem (478)                               [serial 1702] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [170] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1690]
Solved by:  Substitution of Assertion Labels
and theorem 477:
Theorem (477) [serial 1719] used for:
  Substituted assertions' predicates for labels  [serial 1702] 


Theorem (479)                               [serial 1690] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [170] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1684]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 478:
Theorem (478) [serial 1702] used for:
    normalization of [serial 1690] 


Theorem (480)                               [serial 1684] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [170] ca!(0 mpss)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1623]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 471 479:
Theorem (471) [serial 1689] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1684] 
Theorem (479) [serial 1690] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1684] 


Theorem (481)                               [serial 1623] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [170]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1607]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 454 468 480:
Theorem (454) [serial 1682] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1623] 
Theorem (468) [serial 1683] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1623] 
Theorem (480) [serial 1684] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1623] 


Theorem (482)                               [serial 1607] 
P [165] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [170]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1596]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 481:
Theorem (481) [serial 1623] used for:
  Associativity: (b.c).a = a.b.c [serial 1607] 


Theorem (483)                               [serial 1596] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [170]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1591]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 482:
Theorem (482) [serial 1607] used for:
    normalization of [serial 1596] 


Theorem (484)                               [serial 1591] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [170]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1588]
Solved by:  Introduction of Existential Quantification
and theorem 483:
Theorem (483) [serial 1596] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1591] 


Theorem (485)                               [serial 1809] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (486)                               [serial 1810] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (487)                               [serial 1813] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:    normalization of [serial 1811]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (488)                               [serial 1811] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 487:
Theorem (487) [serial 1813] used for:
    normalization of [serial 1811] 


Theorem (489)                               [serial 1808] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1801]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 485 486 488:
Theorem (485) [serial 1809] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808] 
Theorem (486) [serial 1810] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808] 
Theorem (488) [serial 1811] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808] 


Theorem (490)                               [serial 1801] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1796]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 489:
Theorem (489) [serial 1808] used for:
  Associativity: (b.c).a = a.b.c [serial 1801] 


Theorem (491)                               [serial 1796] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [12] << ( v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1790]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 490:
Theorem (490) [serial 1801] used for:
    normalization of [serial 1796] 


Theorem (492)                               [serial 1790] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [12] << ( v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1786]
Solved by:  Guided Substitution of Equals
and theorem 491:
Theorem (491) [serial 1796] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1790] 


Theorem (493)                               [serial 1786] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1778]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 492:
Theorem (492) [serial 1790] used for:
    normalization of [serial 1786] 


Theorem (494)                               [serial 1778] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1774]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 493:
Theorem (493) [serial 1786] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1778] 


Theorem (495)                               [serial 1774] 
P [165] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1766]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 494:
Theorem (494) [serial 1778] used for:
    normalization of [serial 1774] 


Theorem (496)                               [serial 1766] 
P [165] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [12] << not ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
  and ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1762]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 495:
Theorem (495) [serial 1774] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1766] 


Theorem (497)                               [serial 1762] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [174] ->
Q [12] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
  and not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1759]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 496:
Theorem (496) [serial 1766] used for:
    normalization of [serial 1762] 


Theorem (498)                               [serial 1759] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [174] ->
Q [12] << ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
  and not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1750]
Solved by:  Substitution of Assertion Labels
and theorem 497:
Theorem (497) [serial 1762] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1759] 


Theorem (499)                               [serial 1750] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [174] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1747]
Solved by:  Substitution of Assertion Labels
and theorem 498:
Theorem (498) [serial 1759] used for:
  Substituted assertions' predicates for labels  [serial 1750] 


Theorem (500)                               [serial 1756] 
P [174] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [174] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1751]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (501)                               [serial 1751] 
P [174] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [174] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1747]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 500:
Theorem (500) [serial 1756] used for:
  Associativity: (b.c).a = a.b.c [serial 1751] 


Theorem (502)                               [serial 1747] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [174] sb!(true)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1624]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 499 501:
Theorem (499) [serial 1750] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1747] 
Theorem (501) [serial 1751] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1747] 


Theorem (503)                               [serial 1803] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [174] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1797]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (504)                               [serial 1797] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [174] << v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1792]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 503:
Theorem (503) [serial 1803] used for:
    normalization of [serial 1797] 


Theorem (505)                               [serial 1792] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [174] << v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss >>
Why created:    normalization of [serial 1787]
Solved by:  Guided Substitution of Equals
and theorem 504:
Theorem (504) [serial 1797] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1792] 


Theorem (506)                               [serial 1787] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [174] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1780]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 505:
Theorem (505) [serial 1792] used for:
    normalization of [serial 1787] 


Theorem (507)                               [serial 1780] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [174] << not ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) >>
Why created:    normalization of [serial 1775]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 506:
Theorem (506) [serial 1787] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1780] 


Theorem (508)                               [serial 1775] 
P [165] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [174] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1768]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 507:
Theorem (507) [serial 1780] used for:
    normalization of [serial 1775] 


Theorem (509)                               [serial 1768] 
P [165] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [174] << not ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1763]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 508:
Theorem (508) [serial 1775] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1768] 


Theorem (510)                               [serial 1763] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [174] ->
Q [174] << not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1760]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 509:
Theorem (509) [serial 1768] used for:
    normalization of [serial 1763] 


Theorem (511)                               [serial 1760] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [174] ->
Q [174] << not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1752]
Solved by:  Substitution of Assertion Labels
and theorem 510:
Theorem (510) [serial 1763] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1760] 


Theorem (512)                               [serial 1752] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [174] ->
Q [174] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1748]
Solved by:  Substitution of Assertion Labels
and theorem 511:
Theorem (511) [serial 1760] used for:
  Substituted assertions' predicates for labels  [serial 1752] 


Theorem (513)                               [serial 1757] 
P [174] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [174] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1753]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (514)                               [serial 1753] 
P [174] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [174] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1748]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 513:
Theorem (513) [serial 1757] used for:
  Associativity: (b.c).a = a.b.c [serial 1753] 


Theorem (515)                               [serial 1748] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [174] eb!(false)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1624]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 512 514:
Theorem (512) [serial 1752] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1748] 
Theorem (514) [serial 1753] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1748] 


Theorem (516)                               [serial 1758] 
P [174] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [174] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1754]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (517)                               [serial 1754] 
P [174] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [174] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1749]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 516:
Theorem (516) [serial 1758] used for:
  Associativity: (b.c).a = a.b.c [serial 1754] 


Theorem (518)                               [serial 1807] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1799]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (519)                               [serial 1799] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1795]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 518:
Theorem (518) [serial 1807] used for:
  Associativity: (b.c).a = a.b.c [serial 1799] 


Theorem (520)                               [serial 1795] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1782]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 519:
Theorem (519) [serial 1799] used for:
    normalization of [serial 1795] 


Theorem (521)                               [serial 1782] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1776]
Solved by:  Guided Substitution of Equals
and theorem 520:
Theorem (520) [serial 1795] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1782] 


Theorem (522)                               [serial 1776] 
P [165] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1770]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 521:
Theorem (521) [serial 1782] used for:
    normalization of [serial 1776] 


Theorem (523)                               [serial 1770] 
P [165] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [174] ->
Q [33] << ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1764]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 522:
Theorem (522) [serial 1776] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1770] 


Theorem (524)                               [serial 1764] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [174] ->
Q [33] << ( ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1761]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 523:
Theorem (523) [serial 1770] used for:
    normalization of [serial 1764] 


Theorem (525)                               [serial 1761] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [174] ->
Q [33] << ( ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
   or ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1755]
Solved by:  Substitution of Assertion Labels
and theorem 524:
Theorem (524) [serial 1764] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1761] 


Theorem (526)                               [serial 1755] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [174] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1749]
Solved by:  Substitution of Assertion Labels
and theorem 525:
Theorem (525) [serial 1761] used for:
  Substituted assertions' predicates for labels  [serial 1755] 


Theorem (527)                               [serial 1749] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [174] ca!(0 mpss)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1624]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 517 526:
Theorem (517) [serial 1754] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1749] 
Theorem (526) [serial 1755] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1749] 


Theorem (528)                               [serial 1624] 
P [165] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [174]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1609]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 502 515 527:
Theorem (502) [serial 1747] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1624] 
Theorem (515) [serial 1748] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1624] 
Theorem (527) [serial 1749] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1624] 


Theorem (529)                               [serial 1609] 
P [165] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [174]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1597]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 528:
Theorem (528) [serial 1624] used for:
  Associativity: (b.c).a = a.b.c [serial 1609] 


Theorem (530)                               [serial 1597] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [174]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1592]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 529:
Theorem (529) [serial 1609] used for:
    normalization of [serial 1597] 


Theorem (531)                               [serial 1592] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [174]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1588]
Solved by:  Introduction of Existential Quantification
and theorem 530:
Theorem (530) [serial 1597] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1592] 


Theorem (532)                               [serial 1877] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (533)                               [serial 1878] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (534)                               [serial 1891] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1887]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (535)                               [serial 1887] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*b ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1883]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 534:
Theorem (534) [serial 1891] used for:
    normalization of [serial 1887] 


Theorem (536)                               [serial 1883] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:    normalization of [serial 1879]
Solved by:  Guided Substitution of Equals
and theorem 535:
Theorem (535) [serial 1887] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1883] 


Theorem (537)                               [serial 1879] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 536:
Theorem (536) [serial 1883] used for:
    normalization of [serial 1879] 


Theorem (538)                               [serial 1876] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1869]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 532 533 537:
Theorem (532) [serial 1877] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876] 
Theorem (533) [serial 1878] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876] 
Theorem (537) [serial 1879] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1876] 


Theorem (539)                               [serial 1869] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1864]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 538:
Theorem (538) [serial 1876] used for:
  Associativity: (b.c).a = a.b.c [serial 1869] 


Theorem (540)                               [serial 1864] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [12] << ( v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1858]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 539:
Theorem (539) [serial 1869] used for:
    normalization of [serial 1864] 


Theorem (541)                               [serial 1858] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [12] << ( v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1854]
Solved by:  Guided Substitution of Equals
and theorem 540:
Theorem (540) [serial 1864] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1858] 


Theorem (542)                               [serial 1854] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1846]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 541:
Theorem (541) [serial 1858] used for:
    normalization of [serial 1854] 


Theorem (543)                               [serial 1846] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1842]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 542:
Theorem (542) [serial 1854] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1846] 


Theorem (544)                               [serial 1842] 
P [165] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1834]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 543:
Theorem (543) [serial 1846] used for:
    normalization of [serial 1842] 


Theorem (545)                               [serial 1834] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [12] << not ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
  and ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1830]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 544:
Theorem (544) [serial 1842] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1834] 


Theorem (546)                               [serial 1830] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [179] ->
Q [12] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
  and not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1827]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 545:
Theorem (545) [serial 1834] used for:
    normalization of [serial 1830] 


Theorem (547)                               [serial 1827] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [179] ->
Q [12] << ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
  and not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1818]
Solved by:  Substitution of Assertion Labels
and theorem 546:
Theorem (546) [serial 1830] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1827] 


Theorem (548)                               [serial 1818] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [179] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1815]
Solved by:  Substitution of Assertion Labels
and theorem 547:
Theorem (547) [serial 1827] used for:
  Substituted assertions' predicates for labels  [serial 1818] 


Theorem (549)                               [serial 1824] 
P [179] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [179] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1819]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (550)                               [serial 1819] 
P [179] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [179] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1815]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 549:
Theorem (549) [serial 1824] used for:
  Associativity: (b.c).a = a.b.c [serial 1819] 


Theorem (551)                               [serial 1815] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [179] sb!(true)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1625]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 548 550:
Theorem (548) [serial 1818] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1815] 
Theorem (550) [serial 1819] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1815] 


Theorem (552)                               [serial 1871] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [179] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1865]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (553)                               [serial 1865] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [179] << v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1860]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 552:
Theorem (552) [serial 1871] used for:
    normalization of [serial 1865] 


Theorem (554)                               [serial 1860] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [179] << v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss >>
Why created:    normalization of [serial 1855]
Solved by:  Guided Substitution of Equals
and theorem 553:
Theorem (553) [serial 1865] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1860] 


Theorem (555)                               [serial 1855] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [179] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1848]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 554:
Theorem (554) [serial 1860] used for:
    normalization of [serial 1855] 


Theorem (556)                               [serial 1848] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [179] << not ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) >>
Why created:    normalization of [serial 1843]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 555:
Theorem (555) [serial 1855] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1848] 


Theorem (557)                               [serial 1843] 
P [165] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [179] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1836]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 556:
Theorem (556) [serial 1848] used for:
    normalization of [serial 1843] 


Theorem (558)                               [serial 1836] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [179] << not ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1831]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 557:
Theorem (557) [serial 1843] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1836] 


Theorem (559)                               [serial 1831] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [179] ->
Q [179] << not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1828]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 558:
Theorem (558) [serial 1836] used for:
    normalization of [serial 1831] 


Theorem (560)                               [serial 1828] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [179] ->
Q [179] << not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1820]
Solved by:  Substitution of Assertion Labels
and theorem 559:
Theorem (559) [serial 1831] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1828] 


Theorem (561)                               [serial 1820] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [179] ->
Q [179] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1816]
Solved by:  Substitution of Assertion Labels
and theorem 560:
Theorem (560) [serial 1828] used for:
  Substituted assertions' predicates for labels  [serial 1820] 


Theorem (562)                               [serial 1825] 
P [179] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [179] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1821]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (563)                               [serial 1821] 
P [179] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [179] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1816]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 562:
Theorem (562) [serial 1825] used for:
  Associativity: (b.c).a = a.b.c [serial 1821] 


Theorem (564)                               [serial 1816] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [179] eb!(false)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1625]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 561 563:
Theorem (561) [serial 1820] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1816] 
Theorem (563) [serial 1821] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1816] 


Theorem (565)                               [serial 1826] 
P [179] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [179] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1822]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (566)                               [serial 1822] 
P [179] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [179] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1817]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 565:
Theorem (565) [serial 1826] used for:
  Associativity: (b.c).a = a.b.c [serial 1822] 


Theorem (567)                               [serial 1889] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1886]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (568)                               [serial 1886] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*b ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1881]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 567:
Theorem (567) [serial 1889] used for:
    normalization of [serial 1886] 


Theorem (569)                               [serial 1881] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:    normalization of [serial 1875]
Solved by:  Guided Substitution of Equals
and theorem 568:
Theorem (568) [serial 1886] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1881] 


Theorem (570)                               [serial 1875] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1867]
Solved by:  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 569:
Theorem (569) [serial 1881] used for:
    normalization of [serial 1875] 


Theorem (571)                               [serial 1867] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1863]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 570:
Theorem (570) [serial 1875] used for:
  Associativity: (b.c).a = a.b.c [serial 1867] 


Theorem (572)                               [serial 1863] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1850]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 571:
Theorem (571) [serial 1867] used for:
    normalization of [serial 1863] 


Theorem (573)                               [serial 1850] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) >>
Why created:    normalization of [serial 1844]
Solved by:  Guided Substitution of Equals
and theorem 572:
Theorem (572) [serial 1863] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1850] 


Theorem (574)                               [serial 1844] 
P [165] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1838]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 573:
Theorem (573) [serial 1850] used for:
    normalization of [serial 1844] 


Theorem (575)                               [serial 1838] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [179] ->
Q [33] << ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v )
   or ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1832]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 574:
Theorem (574) [serial 1844] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1838] 


Theorem (576)                               [serial 1832] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [179] ->
Q [33] << ( ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) )
   or ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1829]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 575:
Theorem (575) [serial 1838] used for:
    normalization of [serial 1832] 


Theorem (577)                               [serial 1829] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [179] ->
Q [33] << ( ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) )
   or ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1823]
Solved by:  Substitution of Assertion Labels
and theorem 576:
Theorem (576) [serial 1832] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1829] 


Theorem (578)                               [serial 1823] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [179] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1817]
Solved by:  Substitution of Assertion Labels
and theorem 577:
Theorem (577) [serial 1829] used for:
  Substituted assertions' predicates for labels  [serial 1823] 


Theorem (579)                               [serial 1817] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [179] ca!(0 mpss)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1625]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 566 578:
Theorem (566) [serial 1822] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1817] 
Theorem (578) [serial 1823] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1817] 


Theorem (580)                               [serial 1625] 
P [165] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [179]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1611]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 551 564 579:
Theorem (551) [serial 1815] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1625] 
Theorem (564) [serial 1816] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1625] 
Theorem (579) [serial 1817] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1625] 


Theorem (581)                               [serial 1611] 
P [165] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [179]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1598]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 580:
Theorem (580) [serial 1625] used for:
  Associativity: (b.c).a = a.b.c [serial 1611] 


Theorem (582)                               [serial 1598] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [179]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1593]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 581:
Theorem (581) [serial 1611] used for:
    normalization of [serial 1598] 


Theorem (583)                               [serial 1593] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [179]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B3>> S3 <<Q>> in alternative for [serial 1588]
Solved by:  Introduction of Existential Quantification
and theorem 582:
Theorem (582) [serial 1598] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1593] 


Theorem (584)                               [serial 1940] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1937]
Solved by:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (585)                               [serial 1937] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*b ) >>
Why created:  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1934]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 584:
Theorem (584) [serial 1940] used for:
    normalization of [serial 1937] 


Theorem (586)                               [serial 1934] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) >>
Why created:    normalization of [serial 1930]
Solved by:  Guided Substitution of Equals
and theorem 585:
Theorem (585) [serial 1937] used for:
  Guided Substitution of Equals 
 replacing "CTCS_Property::SB_Rate mpss" with its = "b" in its postcondition [serial 1934] 


Theorem (587)                               [serial 1930] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss )
   or ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1929]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 586:
Theorem (586) [serial 1934] used for:
    normalization of [serial 1930] 


Theorem (588)                               [serial 1929] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1925]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 587:
Theorem (587) [serial 1930] used for:
  Associativity: (b.c).a = a.b.c [serial 1929] 


Theorem (589)                               [serial 1925] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( not ( v < iSeg.v_n )
   or not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) >>
Why created:    normalization of [serial 1921]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 588:
Theorem (588) [serial 1929] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1925] 


Theorem (590)                               [serial 1921] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss ) ) )
   or ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1917]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 589:
Theorem (589) [serial 1925] used for:
    normalization of [serial 1921] 


Theorem (591)                               [serial 1917] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( iSeg.v_n <= v
   or nSeg.v_n*nSeg.v_n + ( iSeg.e - p )*2*CTCS_Property::SB_Rate mpss <= 
v*v )
   or ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1913]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 590:
Theorem (590) [serial 1921] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1917] 


Theorem (592)                               [serial 1913] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) )
   or not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*CTCS_Property::SB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1911]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 591:
Theorem (591) [serial 1917] used for:
    normalization of [serial 1913] 


Theorem (593)                               [serial 1911] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) )
   or not ( BRAKE(pos : p, v_lim : iSeg.v_n, next_v_lim : nSeg.v_n, ba : CTCS_Property::SB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1908]
Solved by:  Substitution of Assertion Labels
and theorem 592:
Theorem (592) [serial 1913] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1911] 


Theorem (594)                               [serial 1908] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << EB()
   or not SB() >>
Why created:    normalization of [serial 1905]
Solved by:  Substitution of Assertion Labels
and theorem 593:
Theorem (593) [serial 1911] used for:
  Substituted assertions' predicates for labels  [serial 1908] 


Theorem (595)                               [serial 1905] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1897]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 594:
Theorem (594) [serial 1908] used for:
    normalization of [serial 1905] 


Theorem (596)                               [serial 1897] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1894]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 595:
Theorem (595) [serial 1905] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1897] 


Theorem (597)                               [serial 1902] 
P [184] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [184] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1898]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (598)                               [serial 1898] 
P [184] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [184] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1894]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 597:
Theorem (597) [serial 1902] used for:
  Associativity: (b.c).a = a.b.c [serial 1898] 


Theorem (599)                               [serial 1894] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] sb!(false)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1626]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 596 598:
Theorem (596) [serial 1897] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1894] 
Theorem (598) [serial 1898] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1894] 


Theorem (600)                               [serial 1948] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [184] ->
Q [86] << v < iSeg.v_e >>
Why created:  Transitivity: x<y and y<z -> x<z  [serial 1946]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (601)                               [serial 1946] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Solved by:  Transitivity: x<y and y<z -> x<z
and theorem 600:
Theorem (600) [serial 1948] used for:
  Transitivity: x<y and y<z -> x<z  [serial 1946] 


Theorem (602)                               [serial 1947] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (603)                               [serial 1944] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1942]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 601 602:
Theorem (601) [serial 1946] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944] 
Theorem (602) [serial 1947] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1944] 


Theorem (604)                               [serial 1942] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*e >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1932]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
and theorem 603:
Theorem (603) [serial 1944] used for:
    normalization of [serial 1942] 


Theorem (605)                               [serial 1932] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss >>
Why created:    normalization of [serial 1928]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
and theorem 604:
Theorem (604) [serial 1942] used for:
  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "CTCS_Property::EB_Rate mpss" with its = "e" in its postcondition [serial 1932] 


Theorem (606)                               [serial 1928] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1923]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 605:
Theorem (605) [serial 1932] used for:
    normalization of [serial 1928] 


Theorem (607)                               [serial 1923] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( not ( v < iSeg.v_e )
   or not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) >>
Why created:    normalization of [serial 1920]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 606:
Theorem (606) [serial 1928] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1923] 


Theorem (608)                               [serial 1920] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1915]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 607:
Theorem (607) [serial 1923] used for:
    normalization of [serial 1920] 


Theorem (609)                               [serial 1915] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( iSeg.v_e <= v
   or nSeg.v_e*nSeg.v_e + ( iSeg.e - p )*2*CTCS_Property::EB_Rate mpss <= 
v*v ) >>
Why created:    normalization of [serial 1912]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 608:
Theorem (608) [serial 1920] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1915] 


Theorem (610)                               [serial 1912] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*CTCS_Property::EB_Rate mpss*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1910]
Solved by:  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 609:
Theorem (609) [serial 1915] used for:
    normalization of [serial 1912] 


Theorem (611)                               [serial 1910] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea; m->trainModes'FS;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not ( BRAKE(pos : p, v_lim : iSeg.v_e, next_v_lim : nSeg.v_e, ba : CTCS_Property::EB_Rate mpss, vel : v, en : iSeg.e) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1899]
Solved by:  Substitution of Assertion Labels
and theorem 610:
Theorem (610) [serial 1912] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1910] 


Theorem (612)                               [serial 1899] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ->
Q [184] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1895]
Solved by:  Substitution of Assertion Labels
and theorem 611:
Theorem (611) [serial 1910] used for:
  Substituted assertions' predicates for labels  [serial 1899] 


Theorem (613)                               [serial 1903] 
P [184] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [184] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1900]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (614)                               [serial 1900] 
P [184] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [184] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1895]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 613:
Theorem (613) [serial 1903] used for:
  Associativity: (b.c).a = a.b.c [serial 1900] 


Theorem (615)                               [serial 1895] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] eb!(false)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1626]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 612 614:
Theorem (612) [serial 1899] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1895] 
Theorem (614) [serial 1900] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1895] 


Theorem (616)                               [serial 1904] 
P [184] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [184] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1901]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (617)                               [serial 1901] 
P [184] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [184] ->
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1896]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 616:
Theorem (616) [serial 1904] used for:
  Associativity: (b.c).a = a.b.c [serial 1901] 


Theorem (618)                               [serial 1896] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184] ca!(xl)
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1626]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorem 617:
Theorem (617) [serial 1901] used for:
  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1896] 


Theorem (619)                               [serial 1626] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [184]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1613]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 599 615 618:
Theorem (599) [serial 1894] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1626] 
Theorem (615) [serial 1895] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1626] 
Theorem (618) [serial 1896] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1626] 


Theorem (620)                               [serial 1613] 
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [184]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1599]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 619:
Theorem (619) [serial 1626] used for:
  Associativity: (b.c).a = a.b.c [serial 1613] 


Theorem (621)                               [serial 1599] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [184]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1594]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 620:
Theorem (620) [serial 1613] used for:
    normalization of [serial 1599] 


Theorem (622)                               [serial 1594] 
P [165] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [184]   {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B4>> S4 <<Q>> in alternative for [serial 1588]
Solved by:  Introduction of Existential Quantification
and theorem 621:
Theorem (621) [serial 1599] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1594] 


Theorem (623)                               [serial 1588] 
P [162] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [165]   if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 412 443 484 531 583 622:
Theorem (412) [serial 1589] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1588] 
Theorem (443) [serial 1590] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1588] 
Theorem (484) [serial 1591] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1588] 
Theorem (531) [serial 1592] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1588] 
Theorem (583) [serial 1593] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1588] 
Theorem (622) [serial 1594] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1588] 


Theorem (624)                               [serial 1023] 
P [161] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [162] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegmentMoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
Solved by:  Introduction of Existential Quantification
and theorems 400 623:
Theorem (400) [serial 1587] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023] 
Theorem (623) [serial 1588] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023] 


Theorem (625)                               [serial 1024] 
P [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [188] ->
Q [66] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (626)                               [serial 1966] 
P [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [68] ->
Q [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:  Law of And-Simplification:  P and true is P [serial 1965]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (627)                               [serial 1965] 
P [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [68] ->
Q [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 626:
Theorem (626) [serial 1966] used for:
  Law of And-Simplification:  P and true is P [serial 1965] 


Theorem (628)                               [serial 1966] 
P [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [68] ->
Q [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:  Law of And-Simplification:  P and true is P [serial 1965]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (629)                               [serial 1965] 
P [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [68] ->
Q [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 628:
Theorem (628) [serial 1966] used for:
  Law of And-Simplification:  P and true is P [serial 1965] 


Theorem (630)                               [serial 1954] 
P [68] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [68] ->
Q [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
Why created:    normalization of [serial 1949]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 629 629:
Theorem (629) [serial 1965] used for:
   add user-defined axioms to postcondition 
Theorem (629) [serial 1965] used for:
   add user-defined axioms to postcondition 


Theorem (631)                               [serial 1949] 
P [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [68] ->
Q [193] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 630:
Theorem (630) [serial 1954] used for:
    normalization of [serial 1949] 


Theorem (632)                               [serial 1967] 
P [199] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (633)                               [serial 1968] 
P [199] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (634)                               [serial 1972] 
P [199] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1969]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (635)                               [serial 1969] 
P [199] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  Guided Substitution of Equals
and theorem 634:
Theorem (634) [serial 1972] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1969] 


Theorem (636)                               [serial 1970] 
P [199] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << NEXT_MA = next_ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (637)                               [serial 1971] 
P [199] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << NEXT_MA.seg[1] = nSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (638)                               [serial 1956] 
P [199] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
Why created:    normalization of [serial 1950]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 632 633 635 636 637:
Theorem (632) [serial 1967] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (633) [serial 1968] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (635) [serial 1969] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (636) [serial 1970] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 
Theorem (637) [serial 1971] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1956] 


Theorem (639)                               [serial 1950] 
P [199] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
S [70] ->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:  <<Q1>> -> <<Q>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 638:
Theorem (638) [serial 1956] used for:
    normalization of [serial 1950] 


Theorem (640)                               [serial 1981] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [195] ->
Q [197] << CMA = ma >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1977]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (641)                               [serial 1977] 
P [195] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [195] ->
Q [197] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1975]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 640:
Theorem (640) [serial 1981] used for:
  Associativity: (b.c).a = a.b.c [serial 1977] 


Theorem (642)                               [serial 1982] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [195] ->
Q [196] << CMA.num_segments = i >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1978]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (643)                               [serial 1978] 
P [195] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [195] ->
Q [196] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1975]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 642:
Theorem (642) [serial 1982] used for:
  Associativity: (b.c).a = a.b.c [serial 1978] 


Theorem (644)                               [serial 1994] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [195] ->
Q [197] << CMA.seg[i] = iSeg >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1988]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (645)                               [serial 1988] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [195] ->
Q [197] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    normalization of [serial 1985]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
and theorem 644:
Theorem (644) [serial 1994] used for:
  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1988] 


Theorem (646)                               [serial 1985] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [195] ->
Q [197] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1983]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 645:
Theorem (645) [serial 1988] used for:
    normalization of [serial 1985] 


Theorem (647)                               [serial 1983] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [195] ->
Q [197] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1979]
Solved by:  Substitution of Assertion Labels
and theorem 646:
Theorem (646) [serial 1985] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1983] 


Theorem (648)                               [serial 1979] 
P [195] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [195] ->
Q [197] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1975]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 647:
Theorem (647) [serial 1983] used for:
  Associativity: (b.c).a = a.b.c [serial 1979] 


Theorem (649)                               [serial 1993] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [195] ->
Q [196] << RMA = next_ma >>
Why created:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1990]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (650)                               [serial 1990] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [195] ->
Q [196] << NEXT_MA = next_ma >>
Why created:    normalization of [serial 1986]
Solved by:  Guided Substitution of Equals
and theorem 649:
Theorem (649) [serial 1993] used for:
  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1990] 


Theorem (651)                               [serial 1986] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [195] ->
Q [196] << NEXT_MA = next_ma >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1984]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 650:
Theorem (650) [serial 1990] used for:
    normalization of [serial 1986] 


Theorem (652)                               [serial 1984] 
P [195] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [195] ->
Q [196] << NEXT_MA = next_ma >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1980]
Solved by:  Substitution of Assertion Labels
and theorem 651:
Theorem (651) [serial 1986] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1984] 


Theorem (653)                               [serial 1980] 
P [195] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [195] ->
Q [196] << NEXT_MA = next_ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1975]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 652:
Theorem (652) [serial 1984] used for:
  Associativity: (b.c).a = a.b.c [serial 1980] 


Theorem (654)                               [serial 1975] 
P [195] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [195] ->
Q [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1973]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 641 643 648 653:
Theorem (641) [serial 1977] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1975] 
Theorem (643) [serial 1978] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1975] 
Theorem (648) [serial 1979] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1975] 
Theorem (653) [serial 1980] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1975] 


Theorem (655)                               [serial 1973] 
P [195] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [195] ->
Q [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1958]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 654:
Theorem (654) [serial 1975] used for:
    normalization of [serial 1973] 


Theorem (656)                               [serial 1958] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [195] m_a?(next_ma)
Q [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1951]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 655:
Theorem (655) [serial 1973] used for:
  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1958] 


Theorem (657)                               [serial 1951] 
P [193] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
S [195] m_a?(next_ma)
Q [196] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 656:
Theorem (656) [serial 1958] used for:
    normalization of [serial 1951] 


Theorem (658)                               [serial 1996] 
P [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [198] ->
Q [200] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (659)                               [serial 1997] 
P [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [198] ->
Q [199] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (660)                               [serial 1998] 
P [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [198] ->
Q [200] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (661)                               [serial 1999] 
P [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [198] ->
Q [199] << NEXT_MA = next_ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (662)                               [serial 2002] 
P [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [198] ->
Q [201] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2001]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (663)                               [serial 2001] 
P [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [198] ->
Q [201] << next_ma.seg[1] = next_ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 2000]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 662:
Theorem (662) [serial 2002] used for:
  Equality Law (idistr):  a=a <-> true [serial 2001] 


Theorem (664)                               [serial 2000] 
P [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [198] ->
Q [201] << NEXT_MA.seg[1] = next_ma.seg[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995]
Solved by:  Guided Substitution of Equals
and theorem 663:
Theorem (663) [serial 2001] used for:
  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 2000] 


Theorem (665)                               [serial 1995] 
P [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [198] ->
Q [199] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>
Why created:  applied wp for assignment [serial 1960]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 658 659 660 661 664:
Theorem (658) [serial 1996] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995] 
Theorem (659) [serial 1997] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995] 
Theorem (660) [serial 1998] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995] 
Theorem (661) [serial 1999] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995] 
Theorem (664) [serial 2000] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1995] 


Theorem (666)                               [serial 1960] 
P [196] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [198] nSeg := next_ma.seg[1]
Q [199] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
Why created:    normalization of [serial 1952]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 665:
Theorem (665) [serial 1995] used for:
  applied wp for assignment [serial 1960] 


Theorem (667)                               [serial 1952] 
P [196] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [198] nSeg := next_ma.seg[1]
Q [199] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
Why created:  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 666:
Theorem (666) [serial 1960] used for:
    normalization of [serial 1952] 


Theorem (668)                               [serial 1025] 
P [68] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [193]   << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and AXIOM_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1] >> 
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 631 639 657 667:
Theorem (631) [serial 1949] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1025] 
Theorem (639) [serial 1950] used for:
  <<Q1>> -> <<Q>> in sequential composition for [serial 1025] 
Theorem (657) [serial 1951] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1025] 
Theorem (667) [serial 1952] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1025] 


Theorem (669)                               [serial 2003] 
P [205] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [204] ->
Q [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1026]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (670)                               [serial 1026] 
P [205] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [204] ->
Q [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{};
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 669:
Theorem (669) [serial 2003] used for:
  Associativity: (b.c).a = a.b.c [serial 1026] 


Theorem (671)                               [serial 1027] 
P [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [207] ->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{};
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (672)                               [serial 2013] 
P [72] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [72] ->
Q [212] << NEXT_MA = next_ma >>
Why created:    normalization of [serial 2011]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (673)                               [serial 2011] 
P [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [72] ->
Q [212] << ( next_ma = NEXT_MA ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2010]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 672:
Theorem (672) [serial 2013] used for:
    normalization of [serial 2011] 


Theorem (674)                               [serial 2010] 
P [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [72] ->
Q [212] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 673:
Theorem (673) [serial 2011] used for:
  Law of And-Simplification:  P and true is P [serial 2010] 


Theorem (675)                               [serial 2013] 
P [72] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [72] ->
Q [212] << NEXT_MA = next_ma >>
Why created:    normalization of [serial 2011]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (676)                               [serial 2011] 
P [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [72] ->
Q [212] << ( next_ma = NEXT_MA ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2010]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 675:
Theorem (675) [serial 2013] used for:
    normalization of [serial 2011] 


Theorem (677)                               [serial 2010] 
P [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [72] ->
Q [212] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 676:
Theorem (676) [serial 2011] used for:
  Law of And-Simplification:  P and true is P [serial 2010] 


Theorem (678)                               [serial 2004] 
P [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [72] ->
Q [212] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 677 677:
Theorem (677) [serial 2010] used for:
   add user-defined axioms to postcondition 
Theorem (677) [serial 2010] used for:
   add user-defined axioms to postcondition 


Theorem (679)                               [serial 2019] 
P [220] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [60] ->
Q [60] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2017]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (680)                               [serial 2020] 
P [220] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [60] ->
Q [60] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2017]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (681)                               [serial 2021] 
P [220] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [60] ->
Q [60] << CMA.seg[1 + i] = nSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2017]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (682)                               [serial 2026] 
P [220] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [60] ->
Q [60] << 1 < ma.num_segments >>
Why created:    normalization of [serial 2024]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (683)                               [serial 2024] 
P [220] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [60] ->
Q [60] << ( 1 ) < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 2023]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 682:
Theorem (682) [serial 2026] used for:
    normalization of [serial 2024] 


Theorem (684)                               [serial 2023] 
P [220] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [60] ->
Q [60] << ( 1 ) < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 2022]
Solved by:  Guided Substitution of Equals
and theorem 683:
Theorem (683) [serial 2024] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 2023] 


Theorem (685)                               [serial 2022] 
P [220] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [60] ->
Q [60] << i < CMA.num_segments >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2017]
Solved by:  Guided Substitution of Equals
and theorem 684:
Theorem (684) [serial 2023] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 2022] 


Theorem (686)                               [serial 2017] 
P [220] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [60] ->
Q [60] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 2015]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 679 680 681 685:
Theorem (679) [serial 2019] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2017] 
Theorem (680) [serial 2020] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2017] 
Theorem (681) [serial 2021] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2017] 
Theorem (685) [serial 2022] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2017] 


Theorem (687)                               [serial 2015] 
P [220] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ( 1 < ma.num_segments ) >>
S [60] ->
Q [60] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2005]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 686:
Theorem (686) [serial 2017] used for:
    normalization of [serial 2015] 


Theorem (688)                               [serial 2005] 
P [220] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [60] ->
Q [60] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<Q3>> -> <<Q>> in sequential composition for [serial 1028]
Solved by:  Substitution of Assertion Labels
and theorem 687:
Theorem (687) [serial 2015] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2005] 


Theorem (689)                               [serial 2033] 
P [212] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [213] ->
Q [214] << NEXT_MA = next_ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 2031]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (690)                               [serial 2031] 
P [212] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [213] ->
Q [214] << CMA = next_ma >>
Why created:    normalization of [serial 2029]
Solved by:  Guided Substitution of Equals
and theorem 689:
Theorem (689) [serial 2033] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 2031] 


Theorem (691)                               [serial 2029] 
P [212] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [213] ->
Q [214] << next_ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2028]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 690:
Theorem (690) [serial 2031] used for:
    normalization of [serial 2029] 


Theorem (692)                               [serial 2028] 
P [212] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [213] ->
Q [214] << next_ma = CMA >>
Why created:  applied wp for assignment [serial 2006]
Solved by:  Substitution of Assertion Labels
and theorem 691:
Theorem (691) [serial 2029] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2028] 


Theorem (693)                               [serial 2006] 
P [212] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [213] ma := next_ma
Q [214] << ma = CMA >>
Why created:  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 692:
Theorem (692) [serial 2028] used for:
  applied wp for assignment [serial 2006] 


Theorem (694)                               [serial 2041] 
P [214] << CMA = ma >>
S [215] ->
Q [216] << CMA = ma >>
Why created:    normalization of [serial 2039]
Solved by:  Identity (id):  P->P is tautology


Theorem (695)                               [serial 2039] 
P [214] << CMA = ma >>
S [215] ->
Q [216] << ( CMA = ma ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2038]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 694:
Theorem (694) [serial 2041] used for:
    normalization of [serial 2039] 


Theorem (696)                               [serial 2038] 
P [214] << CMA = ma >>
S [215] ->
Q [216] << CMA = ma
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2036]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 695:
Theorem (695) [serial 2039] used for:
  Law of And-Simplification:  P and true is P [serial 2038] 


Theorem (697)                               [serial 2036] 
P [214] << CMA = ma >>
S [215] ->
Q [216] << CMA = ma
  and 1 = 1 >>
Why created:    normalization of [serial 2034]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 696:
Theorem (696) [serial 2038] used for:
  Equality Law (idistr):  a=a <-> true [serial 2036] 


Theorem (698)                               [serial 2034] 
P [214] << ma = CMA >>
S [215] ->
Q [216] << ( 1 ) = 1
  and ma = CMA >>
Why created:  applied wp for assignment [serial 2007]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 697:
Theorem (697) [serial 2036] used for:
    normalization of [serial 2034] 


Theorem (699)                               [serial 2007] 
P [214] << ma = CMA >>
S [215] i := 1
Q [216] << i = 1
  and ma = CMA >>
Why created:  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 698:
Theorem (698) [serial 2034] used for:
  applied wp for assignment [serial 2007] 


Theorem (700)                               [serial 2044] 
P [216] << i = 1
  and ma = CMA >>
S [217] ->
Q [218] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2043]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (701)                               [serial 2045] 
P [216] << i = 1
  and ma = CMA >>
S [217] ->
Q [218] << ma = CMA >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2043]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (702)                               [serial 2052] 
P [216] << CMA = ma
  and i = 1 >>
S [217] ->
Q [218] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2050]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (703)                               [serial 2050] 
P [216] << CMA = ma
  and i = 1 >>
S [217] ->
Q [218] << ma.seg[1] = ma.seg[1] >>
Why created:    normalization of [serial 2048]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 702:
Theorem (702) [serial 2052] used for:
  Equality Law (idistr):  a=a <-> true [serial 2050] 


Theorem (704)                               [serial 2048] 
P [216] << i = 1
  and ma = CMA >>
S [217] ->
Q [218] << ma.seg[1] = ma.seg[( 1 )] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 2047]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 703:
Theorem (703) [serial 2050] used for:
    normalization of [serial 2048] 


Theorem (705)                               [serial 2047] 
P [216] << i = 1
  and ma = CMA >>
S [217] ->
Q [218] << ma.seg[1] = ma.seg[i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 2046]
Solved by:  Guided Substitution of Equals
and theorem 704:
Theorem (704) [serial 2048] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 2047] 


Theorem (706)                               [serial 2046] 
P [216] << i = 1
  and ma = CMA >>
S [217] ->
Q [218] << ma.seg[1] = CMA.seg[i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2043]
Solved by:  Guided Substitution of Equals
and theorem 705:
Theorem (705) [serial 2047] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 2046] 


Theorem (707)                               [serial 2043] 
P [216] << i = 1
  and ma = CMA >>
S [217] ->
Q [218] << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>
Why created:  applied wp for assignment [serial 2008]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 700 701 706:
Theorem (700) [serial 2044] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2043] 
Theorem (701) [serial 2045] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2043] 
Theorem (706) [serial 2046] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2043] 


Theorem (708)                               [serial 2008] 
P [216] << i = 1
  and ma = CMA >>
S [217] iSeg := ma.seg[1]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 707:
Theorem (707) [serial 2043] used for:
  applied wp for assignment [serial 2008] 


Theorem (709)                               [serial 2056] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (710)                               [serial 2057] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << ma = CMA >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (711)                               [serial 2058] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << iSeg = CMA.seg[i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (712)                               [serial 2065] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [219] ->
Q [220] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2064]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (713)                               [serial 2064] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [219] ->
Q [220] << ma.seg[2] = ma.seg[2] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 2062]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 712:
Theorem (712) [serial 2065] used for:
  Equality Law (idistr):  a=a <-> true [serial 2064] 


Theorem (714)                               [serial 2062] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [219] ->
Q [220] << CMA.seg[2] = ma.seg[2] >>
Why created:    normalization of [serial 2060]
Solved by:  Guided Substitution of Equals
and theorem 713:
Theorem (713) [serial 2064] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 2062] 


Theorem (715)                               [serial 2060] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 2059]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 714:
Theorem (714) [serial 2062] used for:
    normalization of [serial 2060] 


Theorem (716)                               [serial 2059] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << ma.seg[2] = CMA.seg[i + 1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055]
Solved by:  Guided Substitution of Equals
and theorem 715:
Theorem (715) [serial 2060] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 2059] 


Theorem (717)                               [serial 2055] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
Why created:  applied wp for assignment [serial 2054]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 709 710 711 716:
Theorem (709) [serial 2056] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055] 
Theorem (710) [serial 2057] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055] 
Theorem (711) [serial 2058] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055] 
Theorem (716) [serial 2059] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055] 


Theorem (718)                               [serial 2054] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] nSeg := ma.seg[2]
Q [220] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 2053]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 717:
Theorem (717) [serial 2055] used for:
  applied wp for assignment [serial 2054] 


Theorem (719)                               [serial 2053] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] nSeg := ma.seg[2]
Q [220] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 718:
Theorem (718) [serial 2054] used for:
  Law of And-Simplification:  P and true is P [serial 2053] 


Theorem (720)                               [serial 2056] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (721)                               [serial 2057] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << ma = CMA >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (722)                               [serial 2058] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << iSeg = CMA.seg[i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (723)                               [serial 2065] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [219] ->
Q [220] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2064]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (724)                               [serial 2064] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [219] ->
Q [220] << ma.seg[2] = ma.seg[2] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 2062]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 723:
Theorem (723) [serial 2065] used for:
  Equality Law (idistr):  a=a <-> true [serial 2064] 


Theorem (725)                               [serial 2062] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [219] ->
Q [220] << CMA.seg[2] = ma.seg[2] >>
Why created:    normalization of [serial 2060]
Solved by:  Guided Substitution of Equals
and theorem 724:
Theorem (724) [serial 2064] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 2062] 


Theorem (726)                               [serial 2060] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 2059]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 725:
Theorem (725) [serial 2062] used for:
    normalization of [serial 2060] 


Theorem (727)                               [serial 2059] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << ma.seg[2] = CMA.seg[i + 1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055]
Solved by:  Guided Substitution of Equals
and theorem 726:
Theorem (726) [serial 2060] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 2059] 


Theorem (728)                               [serial 2055] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] ->
Q [220] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
Why created:  applied wp for assignment [serial 2054]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 720 721 722 727:
Theorem (720) [serial 2056] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055] 
Theorem (721) [serial 2057] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055] 
Theorem (722) [serial 2058] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055] 
Theorem (727) [serial 2059] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2055] 


Theorem (729)                               [serial 2054] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] nSeg := ma.seg[2]
Q [220] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 2053]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 728:
Theorem (728) [serial 2055] used for:
  applied wp for assignment [serial 2054] 


Theorem (730)                               [serial 2053] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] nSeg := ma.seg[2]
Q [220] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 729:
Theorem (729) [serial 2054] used for:
  Law of And-Simplification:  P and true is P [serial 2053] 


Theorem (731)                               [serial 2009] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [219] nSeg := ma.seg[2]
Q [220] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
Why created:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 730 730:
Theorem (730) [serial 2053] used for:
   add user-defined axioms to postcondition 
Theorem (730) [serial 2053] used for:
   add user-defined axioms to postcondition 


Theorem (732)                               [serial 1028] 
P [72] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [212]   << AXIOM_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : ma) >> 
Q [60] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 678 688 693 699 708 731:
Theorem (678) [serial 2004] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1028] 
Theorem (688) [serial 2005] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1028] 
Theorem (693) [serial 2006] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028] 
Theorem (699) [serial 2007] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028] 
Theorem (708) [serial 2008] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028] 
Theorem (731) [serial 2009] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1028] 


Theorem (733)                               [serial 1002] 
P [33] <<   >>
S [41] ->
Q [33] << AutoBrake.i proof obligations >>
Why created:  Initial proof obligations for AutoBrake.i
Solved by:  Component verification conditions
and theorems 1 2 3 5 9 11 12 15 17 21 25 26 27 106 349 350 357 367 392 393 624 625 668 670 671 732:
Theorem (1) [serial 1003] used for:
  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition. 
Theorem (2) [serial 1004] used for:
  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition. 
Theorem (3) [serial 1005] used for:
  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition. 
Theorem (5) [serial 1006] used for:
  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition. 
Theorem (9) [serial 1007] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>> 
Theorem (11) [serial 1008] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (12) [serial 1009] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>> 
Theorem (15) [serial 1010] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (17) [serial 1011] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>> 
Theorem (21) [serial 1012] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>> 
Theorem (25) [serial 1013] used for:
   <<M(Start)>> A <<M(WaitFirstMA)>> for GoStart-[ ]->WaitFirstMA{A}; 
Theorem (26) [serial 1014] used for:
   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMAWaitFirstMA-[x]->CheckFirstMA{}; 
Theorem (27) [serial 1015] used for:
   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYetCheckFirstMA-[x]->WaitFirstMA{}; 
Theorem (106) [serial 1016] used for:
   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A}; 
Theorem (349) [serial 1017] used for:
   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A}; 
Theorem (350) [serial 1018] used for:
   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{}; 
Theorem (357) [serial 1019] used for:
   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A}; 
Theorem (367) [serial 1020] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A}; 
Theorem (392) [serial 1021] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A}; 
Theorem (393) [serial 1022] used for:
   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{}; 
Theorem (624) [serial 1023] used for:
   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegmentMoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A}; 
Theorem (625) [serial 1024] used for:
   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{}; 
Theorem (668) [serial 1025] used for:
   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A}; 
Theorem (670) [serial 1026] used for:
   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{}; 
Theorem (671) [serial 1027] used for:
   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{}; 
Theorem (732) [serial 1028] used for:
   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A}; 


Theorem (734)                               [serial 1029] 
P [1] << xl = OPERATOR_XL >>
S [2] ->
Q [1] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
Solved by:  Identity (id):  P->P is tautology


Theorem (735)                               [serial 1030] 
P [1] << p = POSITION >>
S [2] ->
Q [1] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
Solved by:  Identity (id):  P->P is tautology


Theorem (736)                               [serial 1031] 
P [1] << v = VELOCITY >>
S [2] ->
Q [1] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
Solved by:  Identity (id):  P->P is tautology


Theorem (737)                               [serial 1032] 
P [1] << SB()
  and not EB() >>
S [2] ->
Q [1] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (738)                               [serial 1033] 
P [1] << EB() >>
S [2] ->
Q [1] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (739)                               [serial 1034] 
P [1] << ma_m_a = RMA >>
S [2] ->
Q [1] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
Solved by:  Identity (id):  P->P is tautology


Theorem (740)                               [serial 1035] 
P [27] << ma = RMA >>
S [19] ->
Q [14] << ma = RMA >>
Why created:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
Solved by:  Identity (id):  P->P is tautology


Theorem (741)                               [serial 1036] 
P [14] << ma_m_a = RMA >>
S [73] ->
Q [94] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
Solved by:  Identity (id):  P->P is tautology


Theorem (742)                               [serial 1037] 
P [32] << p = POSITION >>
S [74] ->
Q [89] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
Solved by:  Identity (id):  P->P is tautology


Theorem (743)                               [serial 1038] 
P [34] << v = VELOCITY >>
S [75] ->
Q [91] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
Solved by:  Identity (id):  P->P is tautology


Theorem (744)                               [serial 1039] 
P [59] << xl = OPERATOR_XL >>
S [76] ->
Q [23] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
Solved by:  Identity (id):  P->P is tautology


Theorem (745)                               [serial 1040] 
P [85] << SB()
  and not EB() >>
S [77] ->
Q [44] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (746)                               [serial 1041] 
P [87] << EB() >>
S [78] ->
Q [51] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (747)                               [serial 1042] 
P [89] << p = POSITION >>
S [103] ->
Q [19] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
Solved by:  Identity (id):  P->P is tautology


Theorem (748)                               [serial 1043] 
P [91] << v = VELOCITY >>
S [104] ->
Q [21] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
Solved by:  Identity (id):  P->P is tautology


Theorem (749)                               [serial 1044] 
P [94] << m_a = RMA >>
S [106] ->
Q [17] << m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
Solved by:  Identity (id):  P->P is tautology


Theorem (750)                               [serial 1045] 
P [12] << SB()
  and not EB() >>
S [108] ->
Q [85] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
Solved by:  Identity (id):  P->P is tautology


Theorem (751)                               [serial 1046] 
P [14] << EB() >>
S [109] ->
Q [87] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
Solved by:  Identity (id):  P->P is tautology


Theorem (752)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
and theorems 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751:
Theorem (733) [serial 1002] used for:
  Initial proof obligations for AutoBrake.i 
Theorem (734) [serial 1029] used for:
  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl 
Theorem (735) [serial 1030] used for:
  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p 
Theorem (736) [serial 1031] used for:
  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v 
Theorem (737) [serial 1032] used for:
  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake 
Theorem (738) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake 
Theorem (739) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a 
Theorem (740) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma 
Theorem (741) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a 
Theorem (742) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p 
Theorem (743) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v 
Theorem (744) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl 
Theorem (745) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake 
Theorem (746) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake 
Theorem (747) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p 
Theorem (748) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v 
Theorem (749) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a 
Theorem (750) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb 
Theorem (751) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb 


closing proof.txt file 