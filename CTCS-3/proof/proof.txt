This file, proof.txt, was produced the BLESS Proof Assistant v3.2.2
  at Fri Jan 26 05:07:33 CST 2024 by brianlarson

Theorem (1)                               [serial 1003] 
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
Solved by: Anything Implies True (a1tru): P->true

Theorem (2)                               [serial 1004] 
P [54] << true >>
S [39] ->
Q [39] << true >>
Why created:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
Solved by: Anything Implies True (a1tru): P->true

Theorem (3)                               [serial 1005] 
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
Solved by: Anything Implies True (a1tru): P->true

Theorem (4)                               [serial 1048] 
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [39] ->
Q [39] << true >>
Why created:    normalization of [serial 1006]
  Using: (eqcom) (bl.ancom) 
Solved by: Anything Implies True (a1tru): P->true

Theorem (5)                               [serial 1006] 
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 4:
Theorem (4) [serial 1048] used for:
    normalization of [serial 1006] 


Theorem (6)                               [serial 1051] 
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59] ->
Q [59] << p < iSeg.e or ( not ( p < iSeg.e ) ) >>
Why created:  Replacing <= with not < of [serial 1050]
Solved by: Law of Excluded middle. (exmid)

Theorem (7)                               [serial 1050] 
P [59] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [59] ->
Q [59] << p < iSeg.e or iSeg.e <= p >>
Why created:    normalization of [serial 1007]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 6:
Theorem (6) [serial 1051] used for:
  Replacing <= with not < of [serial 1050] 


Theorem (8)                               [serial 1007] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [59] ->
Q [59] << ( p < iSeg.e ) or ( p >= iSeg.e ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 7:
Theorem (7) [serial 1050] used for:
    normalization of [serial 1007] 


Theorem (9)                               [serial 1008] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65] ->
Q [65] << ( not m_a'fresh ) or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by: Law of Excluded middle. (exmid)

Theorem (10)                               [serial 1009] 
P [53] << true >>
S [53] ->
Q [53] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (11)                               [serial 1055] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61] ->
Q [61] << i < ma.num_segments or ma.num_segments < i or i = ma.num_segments >>
Why created:    normalization of [serial 1010]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) changeGreaterThanToLessThan (bl.orcom) 
Solved by: Trichotomy law for 'less than'. (lttri4)

Theorem (12)                               [serial 1010] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61] ->
Q [61] << ( i < ma.num_segments ) or ( i = ma.num_segments ) or ( i > ma.num_segments ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) [change A>B to B<A] Disjunction Commutes. (bl.orcom) and theorem 11:
Theorem (11) [serial 1055] used for:
    normalization of [serial 1010] 


Theorem (13)                               [serial 1011] 
P [55] << true >>
S [55] ->
Q [55] << ( not m_a'fresh ) or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
Solved by: Law of Excluded middle. (exmid)

Theorem (14)                               [serial 1060] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70] ->
Q [70] << p < ma.ea or ( not ( p < ma.ea ) ) >>
Why created:  Replacing <= with not < of [serial 1059]
Solved by: Law of Excluded middle. (exmid)

Theorem (15)                               [serial 1059] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [70] ->
Q [70] << p < ma.ea or ma.ea <= p >>
Why created:    normalization of [serial 1012]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 14:
Theorem (14) [serial 1060] used for:
  Replacing <= with not < of [serial 1059] 


Theorem (16)                               [serial 1012] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70] ->
Q [70] << ( p < ma.ea ) or ( p >= ma.ea ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 15:
Theorem (15) [serial 1059] used for:
    normalization of [serial 1012] 


Theorem (17)                               [serial 1063] 
P [53] << true >>
S [76] ->
Q [76] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1062]
Solved by: Anything Implies True (a1tru): P->true

Theorem (18)                               [serial 1064] 
P [76] << ( true )
  and true@now >>
S [76] ->
Q [54] << true >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1062]
Solved by: Anything Implies True (a1tru): P->true

Theorem (19)                               [serial 1062] 
P [53] << true >>
S [76] r!
Q [54] << true >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 17 18:
Theorem (17) [serial 1063] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1062] 
Theorem (18) [serial 1064] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1062] 


Theorem (20)                               [serial 1013] 
P [53] << true >>
S [76] r!
Q [54] << true >>
Why created:   <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A};
Solved by: null and theorem 19:
Theorem (19) [serial 1062] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013] 


Theorem (21)                               [serial 1014] 
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [78] ->
Q [55] << true >>
Why created:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{};
Solved by: Anything Implies True (a1tru): P->true

Theorem (22)                               [serial 1015] 
P [82] << not m_a'fresh >>
S [81] ->
Q [54] << true >>
Why created:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{};
Solved by: Anything Implies True (a1tru): P->true

Theorem (23)                               [serial 1071] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Anything Implies True (a1tru): P->true

Theorem (24)                               [serial 1071] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Anything Implies True (a1tru): P->true

Theorem (25)                               [serial 1065] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << GIVEN_CMA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 24 24:
Theorem (24) [serial 1071] used for:
   add user-defined "givens" to postcondition 
Theorem (24) [serial 1071] used for:
   add user-defined "givens" to postcondition 


Theorem (26)                               [serial 1096] 
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << 1  < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1095]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (27)                               [serial 1095] 
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << 1  < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1094]
Solved by:  Guided Substitution of Equals
 and theorem 26:
Theorem (26) [serial 1096] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1095] 


Theorem (28)                               [serial 1094] 
P [95] << 1  < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << i < ma.num_segments >>
Why created:    normalization of [serial 1092]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Guided Substitution of Equals
 and theorem 27:
Theorem (27) [serial 1095] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1094] 


Theorem (29)                               [serial 1092] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57] ->
Q [57] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1091]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 28:
Theorem (28) [serial 1094] used for:
    normalization of [serial 1092] 


Theorem (30)                               [serial 1091] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and ( 1  < CMA.num_segments ) >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1087]
Solved by:  Guided Substitution of Equals
 and theorem 29:
Theorem (29) [serial 1092] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1091] 


Theorem (31)                               [serial 1087] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1077]
Solved by: Predicate Invocation. (PI) and theorem 30:
Theorem (30) [serial 1091] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1087] 


Theorem (32)                               [serial 1088] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1077]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (33)                               [serial 1089] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1077]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (34)                               [serial 1090] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1077]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (35)                               [serial 1077] 
P [95] << CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1066]
  Using: (bl.addcom) (eqcom) (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 31 32 33 34:
Theorem (31) [serial 1087] used for:
  Join consequents with conjunction. (3jca)
   [serial 1077] 
Theorem (32) [serial 1088] used for:
  Join consequents with conjunction. (3jca)
   [serial 1077] 
Theorem (33) [serial 1089] used for:
  Join consequents with conjunction. (3jca)
   [serial 1077] 
Theorem (34) [serial 1090] used for:
  Join consequents with conjunction. (3jca)
   [serial 1077] 


Theorem (36)                               [serial 1066] 
P [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  <<Q4>> -> <<Q>> in sequential composition for [serial 1016]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 35:
Theorem (35) [serial 1077] used for:
    normalization of [serial 1066] 


Theorem (37)                               [serial 1101] 
P [87] << CMA = RMA
  and RMA = ma >>
S [87] ->
Q [88] << RMA = ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1100]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (38)                               [serial 1100] 
P [87] << CMA = RMA
  and RMA = ma >>
S [87] ->
Q [88] << CMA = ma >>
Why created:    normalization of [serial 1098]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Guided Substitution of Equals
 and theorem 37:
Theorem (37) [serial 1101] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1100] 


Theorem (39)                               [serial 1098] 
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87] ->
Q [88] << CMA = ma >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1097]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 38:
Theorem (38) [serial 1100] used for:
    normalization of [serial 1098] 


Theorem (40)                               [serial 1097] 
P [87] << ( GIVEN_CMA_IS_RMA() )
  and ma = RMA >>
S [87] ->
Q [88] << CMA = ma >>
Why created:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1079]
Solved by: Predicate Invocation. (PI) and theorem 39:
Theorem (39) [serial 1098] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1097] 


Theorem (41)                               [serial 1079] 
P [86] << GIVEN_CMA_IS_RMA() >>
S [87] m_a?(ma)
Q [88] << CMA = ma >>
Why created:    normalization of [serial 1067]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 40:
Theorem (40) [serial 1097] used for:
  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1079] 


Theorem (42)                               [serial 1067] 
P [86] << GIVEN_CMA_IS_RMA() >>
S [87] m_a?(ma)
Q [88] << ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
Solved by: Equality Commutes. (eqcom) and theorem 41:
Theorem (41) [serial 1079] used for:
    normalization of [serial 1067] 


Theorem (43)                               [serial 1102] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma
  and 1  = 1  >>
Why created:  applied wp for assignment [serial 1081]
Solved by: Law of identity. (eqid)

Theorem (44)                               [serial 1081] 
P [88] << CMA = ma >>
S [89] i := 1 
Q [90] << CMA = ma
  and 1  = i >>
Why created:    normalization of [serial 1068]
  Using: (eqcom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 43:
Theorem (43) [serial 1102] used for:
  applied wp for assignment [serial 1081] 


Theorem (45)                               [serial 1068] 
P [88] << ma = CMA >>
S [89] i := 1 
Q [90] << i = 1 
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 44:
Theorem (44) [serial 1081] used for:
    normalization of [serial 1068] 


Theorem (46)                               [serial 1072] 
P [90] << i = 1 
  and ma = CMA >>
S [91] iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (47)                               [serial 1072] 
P [90] << i = 1 
  and ma = CMA >>
S [91] iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (48)                               [serial 1069] 
P [90] << i = 1 
  and ma = CMA >>
S [91] iSeg := ma.seg[1 ]
Q [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 47 47:
Theorem (47) [serial 1072] used for:
   add user-defined "givens" to postcondition 
Theorem (47) [serial 1072] used for:
   add user-defined "givens" to postcondition 


Theorem (49)                               [serial 1073] 
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (50)                               [serial 1073] 
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (51)                               [serial 1070] 
P [92] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and GIVEN_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2 ]
Q [95] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : CMA) >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 50 50:
Theorem (50) [serial 1073] used for:
   add user-defined "givens" to postcondition 
Theorem (50) [serial 1073] used for:
   add user-defined "givens" to postcondition 


Theorem (52)                               [serial 1016] 
P [85] << m_a'fresh >>
S [86]   << GIVEN_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1 
  ;
  << i = 1 
    and ma = CMA >>
  iSeg := ma.seg[1 ]
  ;
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and GIVEN_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2 ]
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1 ]
    and GIVEN_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 25 36 42 45 48 51:
Theorem (25) [serial 1065] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1016] 
Theorem (36) [serial 1066] used for:
  <<Q4>> -> <<Q>> in sequential composition for [serial 1016] 
Theorem (42) [serial 1067] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016] 
Theorem (45) [serial 1068] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016] 
Theorem (48) [serial 1069] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016] 
Theorem (51) [serial 1070] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016] 


Theorem (53)                               [serial 1017] 
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A};
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (54)                               [serial 1488] 
P [59] << i < CMA.num_segments
  and p < iSeg.e
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [128] ->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1018]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (55)                               [serial 1018] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{};
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 54:
Theorem (54) [serial 1488] used for:
    normalization of [serial 1018] 


Theorem (56)                               [serial 1494] 
P [59] << i < CMA.num_segments
  and iSeg.e <= p
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
S [134] ->
Q [135] << CMA = ma
  and CMA.seg[1  + i] = nSeg >>
Why created:    normalization of [serial 1491]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (57)                               [serial 1491] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134] ->
Q [135] << nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1489]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 56:
Theorem (56) [serial 1494] used for:
    normalization of [serial 1491] 


Theorem (58)                               [serial 1489] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134] iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 57:
Theorem (57) [serial 1491] used for:
  applied wp for assignment [serial 1489] 


Theorem (59)                               [serial 1496] 
P [135] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
S [136] ->
Q [61] << CMA = ma
  and CMA.seg[1  + i] = iSeg >>
Why created:    normalization of [serial 1492]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (60)                               [serial 1492] 
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136] ->
Q [61] << iSeg = CMA.seg[( i + 1  )]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1490]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 59:
Theorem (59) [serial 1496] used for:
    normalization of [serial 1492] 


Theorem (61)                               [serial 1490] 
P [135] << iSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
S [136] i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 60:
Theorem (60) [serial 1492] used for:
  applied wp for assignment [serial 1490] 


Theorem (62)                               [serial 1019] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]   iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1 ]
    and ma = CMA >>
  i := i + 1  
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 58 61:
Theorem (58) [serial 1489] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019] 
Theorem (61) [serial 1490] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019] 


Theorem (63)                               [serial 1504] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1500]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (64)                               [serial 1500] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << i < CMA.num_segments >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1499]
Solved by:  Guided Substitution of Equals
 and theorem 63:
Theorem (63) [serial 1504] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1500] 


Theorem (65)                               [serial 1501] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1499]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (66)                               [serial 1505] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << ma.seg[1  + i] = ma.seg[1  + i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1502]
Solved by: Law of identity. (eqid)

Theorem (67)                               [serial 1502] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << CMA.seg[1  + i] = ma.seg[1  + i] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1499]
Solved by:  Guided Substitution of Equals
 and theorem 66:
Theorem (66) [serial 1505] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1502] 


Theorem (68)                               [serial 1503] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1499]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (69)                               [serial 1499] 
P [61] << i < ma.num_segments
  and CMA = ma
  and CMA.seg[i] = iSeg >>
S [141] ->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = ma.seg[1  + i]
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1497]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 64 65 67 68:
Theorem (64) [serial 1500] used for:
  Join consequents with conjunction. (3jca)
   [serial 1499] 
Theorem (65) [serial 1501] used for:
  Join consequents with conjunction. (3jca)
   [serial 1499] 
Theorem (67) [serial 1502] used for:
  Join consequents with conjunction. (3jca)
   [serial 1499] 
Theorem (68) [serial 1503] used for:
  Join consequents with conjunction. (3jca)
   [serial 1499] 


Theorem (70)                               [serial 1497] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1 ] = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1020]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 69:
Theorem (69) [serial 1499] used for:
    normalization of [serial 1497] 


Theorem (71)                               [serial 1020] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141] nSeg := ma.seg[i + 1 ]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 70:
Theorem (70) [serial 1497] used for:
  applied wp for assignment [serial 1020] 


Theorem (72)                               [serial 1513] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [146] << true >>
Why created:    normalization of [serial 1509]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Anything Implies True (a1tru): P->true

Theorem (73)                               [serial 1509] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146] ->
Q [146] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1507]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 72:
Theorem (72) [serial 1513] used for:
    normalization of [serial 1509] 


Theorem (74)                               [serial 1515] 
P [146] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments )
  and true >>
S [146] ->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1510]
  Using: (bl.atintro) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (75)                               [serial 1510] 
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146] ->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1507]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 74:
Theorem (74) [serial 1515] used for:
    normalization of [serial 1510] 


Theorem (76)                               [serial 1507] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146] r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 73 75:
Theorem (73) [serial 1509] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1507] 
Theorem (75) [serial 1510] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1507] 


Theorem (77)                               [serial 1519] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1517]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (78)                               [serial 1520] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA.num_segments = i >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1517]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (79)                               [serial 1521] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1517]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (80)                               [serial 1538] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1537]
Solved by: Law of identity. (eqid)

Theorem (81)                               [serial 1537] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->CMA.ea;] ) = [segment: v_n->0.0 mps; 
v_e->0.0 mps; e->ma.ea;] >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1522]
Solved by:  Guided Substitution of Equals
 and theorem 80:
Theorem (80) [serial 1538] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1537] 


Theorem (82)                               [serial 1522] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1517]
Solved by:  Guided Substitution of Equals
 Predicate Invocation. (PI) and theorem 81:
Theorem (81) [serial 1537] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1522] 


Theorem (83)                               [serial 1517] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] >>
Why created:    normalization of [serial 1511]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 77 78 79 82:
Theorem (77) [serial 1519] used for:
  Join consequents with conjunction. (3jca)
   [serial 1517] 
Theorem (78) [serial 1520] used for:
  Join consequents with conjunction. (3jca)
   [serial 1517] 
Theorem (79) [serial 1521] used for:
  Join consequents with conjunction. (3jca)
   [serial 1517] 
Theorem (82) [serial 1522] used for:
  Join consequents with conjunction. (3jca)
   [serial 1517] 


Theorem (84)                               [serial 1511] 
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149] ->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1508]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 83:
Theorem (83) [serial 1517] used for:
    normalization of [serial 1511] 


Theorem (85)                               [serial 1508] 
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149] nSeg := [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 84:
Theorem (84) [serial 1511] used for:
  applied wp for assignment [serial 1508] 


Theorem (86)                               [serial 1021] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]   r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0.0 mps; v_e->0.0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 76 85:
Theorem (76) [serial 1507] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021] 
Theorem (85) [serial 1508] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021] 


Theorem (87)                               [serial 1022] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155] ->
Q [72] << true >>
Why created:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{};
Solved by: Anything Implies True (a1tru): P->true

Theorem (88)                               [serial 1554] 
P [159] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg )
  and p@now
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:    normalization of [serial 1540]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (89)                               [serial 1540] 
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [159] ->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 88:
Theorem (88) [serial 1554] used for:
    normalization of [serial 1540] 


Theorem (90)                               [serial 1578] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *
e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
v < iSeg.v_e or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or v < iSeg.v_e or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or v < iSeg.v_e or not ( v < iSeg.v_n ) or not ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e or not ( v*v < ( iSeg.e - p )*
2 *b + nSeg.v_n*nSeg.v_n ) or not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e ) or not ( v < iSeg.v_e ) )
  and ( v < iSeg.v_n or not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) or 
not ( v < iSeg.v_n ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e ) or 
not ( v < iSeg.v_e ) ) >>
Why created:  Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1577]
Solved by: Law of Excluded middle. (exmid)

Theorem (91)                               [serial 1577] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) or ( v*v < 
( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and not ( v < iSeg.v_n ) ) or not ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*
nSeg.v_e ) or not ( v < iSeg.v_e ) >>
Why created:    normalization of [serial 1575]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bl.orcom) 
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 90:
Theorem (90) [serial 1578] used for:
  Distribution and-over-or with wff lists. (bl.dba2owl)
   while transforming into
  conjunctive normal form [serial 1577] 


Theorem (92)                               [serial 1575] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n ) ) ) or ( v*
v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( not ( v < iSeg.v_n ) ) ) or ( not ( v*v < ( iSeg.e - p )*2 *e + 
nSeg.v_e*nSeg.v_e ) ) or ( not ( v < iSeg.v_e ) ) >>
Why created:  Replacing <= with not < of [serial 1556]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 91:
Theorem (91) [serial 1577] used for:
    normalization of [serial 1575] 


Theorem (93)                               [serial 1556] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n ) or ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v ) or ( v*v < ( iSeg.e - p )*
2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v ) or ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v or 
iSeg.v_e <= v >>
Why created:    normalization of [serial 1542]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.mulcom) (bl.ancom) (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 92:
Theorem (92) [serial 1575] used for:
  Replacing <= with not < of [serial 1556] 


Theorem (94)                               [serial 1542] 
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v >= iSeg.v_e ) or ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or 
( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) or ( v*v < nSeg.v_e*
nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1541]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Multiplication Commutes. (bl.mulcom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 93:
Theorem (93) [serial 1556] used for:
    normalization of [serial 1542] 


Theorem (95)                               [serial 1558] 
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and iSeg.v_e <= v >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1548]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (96)                               [serial 1548] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1543]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 95:
Theorem (95) [serial 1558] used for:
    normalization of [serial 1548] 


Theorem (97)                               [serial 1543] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 96:
Theorem (96) [serial 1548] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1543] 


Theorem (98)                               [serial 1560] 
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1549]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.mulcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (99)                               [serial 1549] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1544]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Multiplication Commutes. (bl.mulcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 98:
Theorem (98) [serial 1560] used for:
    normalization of [serial 1549] 


Theorem (100)                               [serial 1544] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [168]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 99:
Theorem (99) [serial 1549] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1544] 


Theorem (101)                               [serial 1562] 
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and iSeg.v_n <= v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1550]
  Using: (bl.addcom) (eqcom) changeAtLeastToAtMost (bl.mulcom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (102)                               [serial 1550] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1545]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [change A>=B to B<=A] Multiplication Commutes. (bl.mulcom) Conjunction Commutes. (bl.ancom) and theorem 101:
Theorem (101) [serial 1562] used for:
    normalization of [serial 1550] 


Theorem (103)                               [serial 1545] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [172]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 102:
Theorem (102) [serial 1550] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1545] 


Theorem (104)                               [serial 1564] 
P [163] << ( v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e
  and ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n <= v*v )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1551]
  Using: (bl.addcom) (eqcom) (bl.mulcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (105)                               [serial 1551] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0.0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1546]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) Multiplication Commutes. (bl.mulcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 104:
Theorem (104) [serial 1564] used for:
    normalization of [serial 1551] 


Theorem (106)                               [serial 1546] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ) ) >>
S [177]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0.0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B3>> S3 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 105:
Theorem (105) [serial 1551] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1546] 


Theorem (107)                               [serial 1566] 
P [163] << ( v*v < ( iSeg.e - p )*2 *b + nSeg.v_n*nSeg.v_n
  and v*v < ( iSeg.e - p )*2 *e + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_n )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) ) >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg >>
Why created:    normalization of [serial 1552]
  Using: (bl.addcom) (eqcom) (bl.mulcom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (108)                               [serial 1552] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1547]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) Multiplication Commutes. (bl.mulcom) Conjunction Commutes. (bl.ancom) and theorem 107:
Theorem (107) [serial 1566] used for:
    normalization of [serial 1552] 


Theorem (109)                               [serial 1547] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ) ) >>
S [182]   {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B4>> S4 <<Q>> in alternative for [serial 1541]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 108:
Theorem (108) [serial 1552] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1547] 


Theorem (110)                               [serial 1541] 
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
S [163]   if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
Solved by: and theorems 94 97 100 103 106 109:
Theorem (94) [serial 1542] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1541] 
Theorem (97) [serial 1543] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1541] 
Theorem (100) [serial 1544] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1541] 
Theorem (103) [serial 1545] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1541] 
Theorem (106) [serial 1546] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1541] 
Theorem (109) [serial 1547] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1541] 


Theorem (111)                               [serial 1023] 
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and GIVEN_B()
  and GIVEN_E()
  and GIVEN_V(seg : iSeg)
  and GIVEN_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0.0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2 *b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2 *e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
Solved by: null and theorems 89 110:
Theorem (89) [serial 1540] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023] 
Theorem (110) [serial 1541] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023] 


Theorem (112)                               [serial 1024] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186] ->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (113)                               [serial 1795] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (114)                               [serial 1795] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (115)                               [serial 1788] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = nSeg
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:    normalization of [serial 1783]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 114 114:
Theorem (114) [serial 1795] used for:
   add user-defined "givens" to postcondition 
Theorem (114) [serial 1795] used for:
   add user-defined "givens" to postcondition 


Theorem (116)                               [serial 1783] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65] ->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 115:
Theorem (115) [serial 1788] used for:
    normalization of [serial 1783] 


Theorem (117)                               [serial 1797] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (118)                               [serial 1798] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA.num_segments = i >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (119)                               [serial 1802] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "CMA.num_segments" in its postcondition [serial 1799]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (120)                               [serial 1799] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by:  Guided Substitution of Equals
 and theorem 119:
Theorem (119) [serial 1802] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "CMA.num_segments" in its postcondition [serial 1799] 


Theorem (121)                               [serial 1800] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [68] << NEXT_MA = next_ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (122)                               [serial 1801] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << NEXT_MA.seg[1 ] = nSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1790]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (123)                               [serial 1790] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
S [67] ->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:    normalization of [serial 1784]
  Using: (eqcom) (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 117 118 120 121 122:
Theorem (117) [serial 1797] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 
Theorem (118) [serial 1798] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 
Theorem (120) [serial 1799] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 
Theorem (121) [serial 1800] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 
Theorem (122) [serial 1801] used for:
  Join consequents with conjunction. (3jca)
   [serial 1790] 


Theorem (124)                               [serial 1784] 
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
S [67] ->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 123:
Theorem (123) [serial 1790] used for:
    normalization of [serial 1784] 


Theorem (125)                               [serial 1806] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1805]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (126)                               [serial 1807] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [194] << CMA.num_segments = i >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1805]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (127)                               [serial 1808] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1805]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (128)                               [serial 1809] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1805]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (129)                               [serial 1805] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and RMA = next_ma >>
S [193] ->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1803]
Solved by: Join consequents with conjunction. (3jca) and theorems 125 126 127 128:
Theorem (125) [serial 1806] used for:
  Join consequents with conjunction. (3jca)
   [serial 1805] 
Theorem (126) [serial 1807] used for:
  Join consequents with conjunction. (3jca)
   [serial 1805] 
Theorem (127) [serial 1808] used for:
  Join consequents with conjunction. (3jca)
   [serial 1805] 
Theorem (128) [serial 1809] used for:
  Join consequents with conjunction. (3jca)
   [serial 1805] 


Theorem (130)                               [serial 1803] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193] ->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1792]
Solved by: Equality Commutes. (eqcom) and theorem 129:
Theorem (129) [serial 1805] used for:
    normalization of [serial 1803] 


Theorem (131)                               [serial 1792] 
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193] m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1785]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 130:
Theorem (130) [serial 1803] used for:
  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1792] 


Theorem (132)                               [serial 1785] 
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and GIVEN_NEXT_MA_IS_RMA() >>
S [193] m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 131:
Theorem (131) [serial 1792] used for:
    normalization of [serial 1785] 


Theorem (133)                               [serial 1823] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [198] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (134)                               [serial 1824] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << CMA.num_segments = i >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (135)                               [serial 1825] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (136)                               [serial 1826] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << NEXT_MA = next_ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (137)                               [serial 1828] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << next_ma.seg[1 ] = next_ma.seg[1 ] >>
Why created:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1827]
Solved by: Law of identity. (eqid)

Theorem (138)                               [serial 1827] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1822]
Solved by:  Guided Substitution of Equals
 and theorem 137:
Theorem (137) [serial 1828] used for:
  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1827] 


Theorem (139)                               [serial 1822] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = next_ma.seg[1 ] >>
Why created:  applied wp for assignment [serial 1794]
Solved by: Join consequents with conjunction. (3jca) and theorems 133 134 135 136 138:
Theorem (133) [serial 1823] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 
Theorem (134) [serial 1824] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 
Theorem (135) [serial 1825] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 
Theorem (136) [serial 1826] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 
Theorem (138) [serial 1827] used for:
  Join consequents with conjunction. (3jca)
   [serial 1822] 


Theorem (140)                               [serial 1794] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] nSeg := next_ma.seg[1 ]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1 ] = nSeg >>
Why created:    normalization of [serial 1786]
  Using: (eqcom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 139:
Theorem (139) [serial 1822] used for:
  applied wp for assignment [serial 1794] 


Theorem (141)                               [serial 1786] 
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196] nSeg := next_ma.seg[1 ]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1 ] >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 140:
Theorem (140) [serial 1794] used for:
    normalization of [serial 1786] 


Theorem (142)                               [serial 1025] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]   << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and GIVEN_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1 ]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1 ] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 116 124 132 141:
Theorem (116) [serial 1783] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1025] 
Theorem (124) [serial 1784] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1025] 
Theorem (132) [serial 1785] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025] 
Theorem (141) [serial 1786] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025] 


Theorem (143)                               [serial 1026] 
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that p@u  ) >>
S [202] ->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{};
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (144)                               [serial 1027] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205] ->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{};
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (145)                               [serial 1837] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (146)                               [serial 1837] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (147)                               [serial 1831] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 146 146:
Theorem (146) [serial 1837] used for:
   add user-defined "givens" to postcondition 
Theorem (146) [serial 1837] used for:
   add user-defined "givens" to postcondition 


Theorem (148)                               [serial 1849] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << 1  < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1848]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (149)                               [serial 1848] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << 1  < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1844]
Solved by:  Guided Substitution of Equals
 and theorem 148:
Theorem (148) [serial 1849] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1848] 


Theorem (150)                               [serial 1844] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1843]
Solved by:  Guided Substitution of Equals
 and theorem 149:
Theorem (149) [serial 1848] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1844] 


Theorem (151)                               [serial 1845] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << CMA = ma >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1843]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (152)                               [serial 1846] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << CMA.seg[1  + i] = nSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1843]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (153)                               [serial 1847] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1843]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (154)                               [serial 1843] 
P [218] << 1  < ma.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg
  and 1  = i >>
S [57] ->
Q [57] << i < CMA.num_segments
  and CMA = ma
  and CMA.seg[1  + i] = nSeg
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1841]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 150 151 152 153:
Theorem (150) [serial 1844] used for:
  Join consequents with conjunction. (3jca)
   [serial 1843] 
Theorem (151) [serial 1845] used for:
  Join consequents with conjunction. (3jca)
   [serial 1843] 
Theorem (152) [serial 1846] used for:
  Join consequents with conjunction. (3jca)
   [serial 1843] 
Theorem (153) [serial 1847] used for:
  Join consequents with conjunction. (3jca)
   [serial 1843] 


Theorem (155)                               [serial 1841] 
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ( 1  < ma.num_segments ) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1832]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 154:
Theorem (154) [serial 1843] used for:
    normalization of [serial 1841] 


Theorem (156)                               [serial 1832] 
P [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:  <<Q4>> -> <<Q>> in sequential composition for [serial 1028]
Solved by: Predicate Invocation. (PI) and theorem 155:
Theorem (155) [serial 1841] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1832] 


Theorem (157)                               [serial 1854] 
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211] ->
Q [212] << NEXT_MA = next_ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1853]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (158)                               [serial 1853] 
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211] ->
Q [212] << CMA = next_ma >>
Why created:    normalization of [serial 1851]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Guided Substitution of Equals
 and theorem 157:
Theorem (157) [serial 1854] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1853] 


Theorem (159)                               [serial 1851] 
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211] ->
Q [212] << next_ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1850]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 158:
Theorem (158) [serial 1853] used for:
    normalization of [serial 1851] 


Theorem (160)                               [serial 1850] 
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211] ->
Q [212] << next_ma = CMA >>
Why created:  applied wp for assignment [serial 1833]
Solved by: Predicate Invocation. (PI) and theorem 159:
Theorem (159) [serial 1851] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1850] 


Theorem (161)                               [serial 1833] 
P [210] << GIVEN_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211] ma := next_ma
Q [212] << ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 160:
Theorem (160) [serial 1850] used for:
  applied wp for assignment [serial 1833] 


Theorem (162)                               [serial 1857] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << CMA = ma
  and 1  = 1  >>
Why created:    normalization of [serial 1855]
  Using: (eqcom) (bl.ancom) 
Solved by: Law of identity. (eqid)

Theorem (163)                               [serial 1855] 
P [212] << ma = CMA >>
S [213] ->
Q [214] << 1  = 1 
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1834]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 162:
Theorem (162) [serial 1857] used for:
    normalization of [serial 1855] 


Theorem (164)                               [serial 1834] 
P [212] << ma = CMA >>
S [213] i := 1 
Q [214] << i = 1 
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 163:
Theorem (163) [serial 1855] used for:
  applied wp for assignment [serial 1834] 


Theorem (165)                               [serial 1863] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << i = 1  >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1862]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (166)                               [serial 1864] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << ma = CMA >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1862]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (167)                               [serial 1869] 
P [214] << CMA = ma
  and 1  = i >>
S [215] ->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:    normalization of [serial 1867]
  Using: (eqcom) (bl.ancom) 
Solved by: Law of identity. (eqid)

Theorem (168)                               [serial 1867] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1 ] = ma.seg[1 ] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1866]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 167:
Theorem (167) [serial 1869] used for:
    normalization of [serial 1867] 


Theorem (169)                               [serial 1866] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1 ] = ma.seg[i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1865]
Solved by:  Guided Substitution of Equals
 and theorem 168:
Theorem (168) [serial 1867] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "1 " in its postcondition [serial 1866] 


Theorem (170)                               [serial 1865] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1 ] = CMA.seg[i] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1862]
Solved by:  Guided Substitution of Equals
 and theorem 169:
Theorem (169) [serial 1866] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1865] 


Theorem (171)                               [serial 1862] 
P [214] << i = 1 
  and ma = CMA >>
S [215] ->
Q [216] << i = 1 
  and ma = CMA
  and ma.seg[1 ] = CMA.seg[i] >>
Why created:  applied wp for assignment [serial 1835]
Solved by: Join consequents with conjunction. (3jca) and theorems 165 166 170:
Theorem (165) [serial 1863] used for:
  Join consequents with conjunction. (3jca)
   [serial 1862] 
Theorem (166) [serial 1864] used for:
  Join consequents with conjunction. (3jca)
   [serial 1862] 
Theorem (170) [serial 1865] used for:
  Join consequents with conjunction. (3jca)
   [serial 1862] 


Theorem (172)                               [serial 1835] 
P [214] << i = 1 
  and ma = CMA >>
S [215] iSeg := ma.seg[1 ]
Q [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 171:
Theorem (171) [serial 1862] used for:
  applied wp for assignment [serial 1835] 


Theorem (173)                               [serial 1871] 
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (174)                               [serial 1871] 
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (175)                               [serial 1836] 
P [216] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2 ]
Q [218] << i = 1 
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and GIVEN_NUM_SEG(ma : ma) >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 174 174:
Theorem (174) [serial 1871] used for:
   add user-defined "givens" to postcondition 
Theorem (174) [serial 1871] used for:
   add user-defined "givens" to postcondition 


Theorem (176)                               [serial 1028] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1 ]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]   << GIVEN_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1 
  ;
  << i = 1 
    and ma = CMA >>
  iSeg := ma.seg[1 ]
  ;
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2 ]
  << i = 1 
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1 ]
    and GIVEN_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1 ]
  and ma = CMA >>
Why created:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 147 156 161 164 172 175:
Theorem (147) [serial 1831] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1028] 
Theorem (156) [serial 1832] used for:
  <<Q4>> -> <<Q>> in sequential composition for [serial 1028] 
Theorem (161) [serial 1833] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028] 
Theorem (164) [serial 1834] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028] 
Theorem (172) [serial 1835] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028] 
Theorem (175) [serial 1836] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028] 


Theorem (177)                               [serial 1002] 
P [33] <<   >>
S [39] ->
Q [33] << AutoBrake.i proof obligations >>
Why created:  Initial proof obligations for AutoBrake.i
Solved by:  Component verification conditions
 and theorems 1 2 3 5 8 9 10 12 13 16 20 21 22 52 53 55 62 71 86 87 111 112 142 143 144 176:
Theorem (1) [serial 1003] used for:
  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition. 
Theorem (2) [serial 1004] used for:
  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition. 
Theorem (3) [serial 1005] used for:
  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition. 
Theorem (5) [serial 1006] used for:
  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition. 
Theorem (8) [serial 1007] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>> 
Theorem (9) [serial 1008] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (10) [serial 1009] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>> 
Theorem (12) [serial 1010] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (13) [serial 1011] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>> 
Theorem (16) [serial 1012] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>> 
Theorem (20) [serial 1013] used for:
   <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A}; 
Theorem (21) [serial 1014] used for:
   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{}; 
Theorem (22) [serial 1015] used for:
   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{}; 
Theorem (52) [serial 1016] used for:
   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A}; 
Theorem (53) [serial 1017] used for:
   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A}; 
Theorem (55) [serial 1018] used for:
   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{}; 
Theorem (62) [serial 1019] used for:
   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A}; 
Theorem (71) [serial 1020] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A}; 
Theorem (86) [serial 1021] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A}; 
Theorem (87) [serial 1022] used for:
   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{}; 
Theorem (111) [serial 1023] used for:
   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A}; 
Theorem (112) [serial 1024] used for:
   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{}; 
Theorem (142) [serial 1025] used for:
   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A}; 
Theorem (143) [serial 1026] used for:
   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{}; 
Theorem (144) [serial 1027] used for:
   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{}; 
Theorem (176) [serial 1028] used for:
   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A}; 


Theorem (178)                               [serial 1029] 
P [1] << ma_m_a = RMA >>
S [2] ->
Q [1] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection ma -> controller.control.m_a:
 ma -> m_a
Solved by: Identity (id):  P->P is tautology

Theorem (179)                               [serial 1030] 
P [1] << xl = OPERATOR_XL >>
S [2] ->
Q [1] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
Solved by: Identity (id):  P->P is tautology

Theorem (180)                               [serial 1031] 
P [1] << p = POSITION >>
S [2] ->
Q [1] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
Solved by: Identity (id):  P->P is tautology

Theorem (181)                               [serial 1032] 
P [1] << v = VELOCITY >>
S [2] ->
Q [1] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
Solved by: Identity (id):  P->P is tautology

Theorem (182)                               [serial 1033] 
P [1] << SB()
  and not EB() >>
S [2] ->
Q [1] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
Solved by: Identity (id):  P->P is tautology

Theorem (183)                               [serial 1034] 
P [1] << EB() >>
S [2] ->
Q [1] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
Solved by: Identity (id):  P->P is tautology

Theorem (184)                               [serial 1035] 
P [14] << ma_m_a = RMA >>
S [73] ->
Q [94] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
Solved by: Identity (id):  P->P is tautology

Theorem (185)                               [serial 1036] 
P [32] << p = POSITION >>
S [74] ->
Q [89] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
Solved by: Identity (id):  P->P is tautology

Theorem (186)                               [serial 1037] 
P [34] << v = VELOCITY >>
S [75] ->
Q [91] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
Solved by: Identity (id):  P->P is tautology

Theorem (187)                               [serial 1038] 
P [59] << xl = OPERATOR_XL >>
S [76] ->
Q [23] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
Solved by: Identity (id):  P->P is tautology

Theorem (188)                               [serial 1039] 
P [85] << SB()
  and not EB() >>
S [77] ->
Q [44] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
Solved by: Identity (id):  P->P is tautology

Theorem (189)                               [serial 1040] 
P [87] << EB() >>
S [78] ->
Q [51] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
Solved by: Identity (id):  P->P is tautology

Theorem (190)                               [serial 1041] 
P [89] << p = POSITION >>
S [103] ->
Q [19] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
Solved by: Identity (id):  P->P is tautology

Theorem (191)                               [serial 1042] 
P [91] << v = VELOCITY >>
S [104] ->
Q [21] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
Solved by: Identity (id):  P->P is tautology

Theorem (192)                               [serial 1043] 
P [94] << m_a = RMA >>
S [106] ->
Q [17] << m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
Solved by: Identity (id):  P->P is tautology

Theorem (193)                               [serial 1044] 
P [12] << SB()
  and not EB() >>
S [108] ->
Q [85] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
Solved by: Identity (id):  P->P is tautology

Theorem (194)                               [serial 1045] 
P [14] << EB() >>
S [109] ->
Q [87] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
Solved by: Identity (id):  P->P is tautology

Theorem (195)                               [serial 1046] 
P [27] << ma = RMA >>
S [19] ->
Q [14] << ma = RMA >>
Why created:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
Solved by: Identity (id):  P->P is tautology

Theorem (196)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
 and theorems 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195:
Theorem (177) [serial 1002] used for:
  Initial proof obligations for AutoBrake.i 
Theorem (178) [serial 1029] used for:
  Composition of Subcomponents via Directional Connection ma -> controller.control.m_a:
 ma -> m_a 
Theorem (179) [serial 1030] used for:
  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl 
Theorem (180) [serial 1031] used for:
  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p 
Theorem (181) [serial 1032] used for:
  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v 
Theorem (182) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake 
Theorem (183) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake 
Theorem (184) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a 
Theorem (185) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p 
Theorem (186) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v 
Theorem (187) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl 
Theorem (188) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake 
Theorem (189) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake 
Theorem (190) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p 
Theorem (191) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v 
Theorem (192) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a 
Theorem (193) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb 
Theorem (194) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb 
Theorem (195) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma 


closing proof file "/Applications/osate2_2023-03-master/Eclipse.app/Contents/MacOS/proof.txt" 