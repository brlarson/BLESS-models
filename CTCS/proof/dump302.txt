opening dump file "E:\AADL\BHA\osate2\dump.txt" Thu Nov 13 17:07:30 CST 2014
opening proof script file "E:\AADL\BHA\osate2\script.txt"
new script
You chose proof script: E:\AADL\BHA\osate2\workspace\CTCS\proofscripts/script.txt
Executing proof script . . .
****Load****

Starting to gather BLESS/subBLESS annex subclauses, Assertion annex libraries, and
 Assertion properties of features from packages open in the workspace.

The model is being loaded into BLESS.
Gathering property set "Memory_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@2e61681b (name: Memory_Properties)
What should be done with property associations?
Gathering property set "Communication_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@1dfb3634 (name: Communication_Properties)
What should be done with property associations?
Gathering property set "Modeling_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@35db6720 (name: Modeling_Properties)
What should be done with property associations?
Gathering property set "ARP4761".
psi:  org.osate.aadl2.impl.PropertySetImpl@24bee5a1 (name: ARP4761)
What should be done with property associations?
Gathering property set "AADL_Project".
psi:  org.osate.aadl2.impl.PropertySetImpl@6707d968 (name: AADL_Project)
What should be done with property associations?
Gathering property set "ARINC653".
psi:  org.osate.aadl2.impl.PropertySetImpl@1256e4a5 (name: ARINC653)
What should be done with property associations?
Gathering property set "Behavior_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@7eaa6522 (name: Behavior_Properties)
What should be done with property associations?
Gathering property set "Data_Model".
psi:  org.osate.aadl2.impl.PropertySetImpl@64d5dc25 (name: Data_Model)
What should be done with property associations?
Gathering property set "EMV2".
psi:  org.osate.aadl2.impl.PropertySetImpl@146834db (name: EMV2)
What should be done with property associations?
Gathering property set "Thread_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@68347da (name: Thread_Properties)
What should be done with property associations?
Gathering property set "BLESS".
psi:  org.osate.aadl2.impl.PropertySetImpl@af21326 (name: BLESS)
What should be done with property associations?
Gathering property set "CTCS_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@1ac72967 (name: CTCS_Properties)
What should be done with property associations?
Gathering property set "Deployment_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@96f36ed (name: Deployment_Properties)
What should be done with property associations?
Gathering property set "Programming_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@647f0671 (name: Programming_Properties)
What should be done with property associations?
Gathering property set "ARINC429".
psi:  org.osate.aadl2.impl.PropertySetImpl@169fd658 (name: ARINC429)
What should be done with property associations?
Gathering property set "SEI".
psi:  org.osate.aadl2.impl.PropertySetImpl@57b13702 (name: SEI)
What should be done with property associations?
Gathering property set "BLESS_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@3c7f4293 (name: BLESS_Properties)
What should be done with property associations?
Gathering property set "MILSTD882".
psi:  org.osate.aadl2.impl.PropertySetImpl@182bf9fb (name: MILSTD882)
What should be done with property associations?
Gathering property set "Timing_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@229835cf (name: Timing_Properties)
What should be done with property associations?
Gathering package "ErrorLibrary".
There are no component types in package "ErrorLibrary".
All component types in package "ErrorLibrary" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
ErrorLibrary has no component implementations.
Done with package ErrorLibrary.

Gathering package "Base_Types".
Creating a parse record for a "data" component type named "Boolean".
looking for features with BLESS::Assertion properties in Boolean
Boolean has no features.
Creating a parse record for a "data" component type named "Integer".
looking for features with BLESS::Assertion properties in Integer
Integer has no features.
Creating a parse record for a "data" component type named "Integer_8".
looking for features with BLESS::Assertion properties in Integer_8
Integer_8 has no features.
Creating a parse record for a "data" component type named "Integer_16".
looking for features with BLESS::Assertion properties in Integer_16
Integer_16 has no features.
Creating a parse record for a "data" component type named "Integer_32".
looking for features with BLESS::Assertion properties in Integer_32
Integer_32 has no features.
Creating a parse record for a "data" component type named "Integer_64".
looking for features with BLESS::Assertion properties in Integer_64
Integer_64 has no features.
Creating a parse record for a "data" component type named "Unsigned_8".
looking for features with BLESS::Assertion properties in Unsigned_8
Unsigned_8 has no features.
Creating a parse record for a "data" component type named "Unsigned_16".
looking for features with BLESS::Assertion properties in Unsigned_16
Unsigned_16 has no features.
Creating a parse record for a "data" component type named "Unsigned_32".
looking for features with BLESS::Assertion properties in Unsigned_32
Unsigned_32 has no features.
Creating a parse record for a "data" component type named "Unsigned_64".
looking for features with BLESS::Assertion properties in Unsigned_64
Unsigned_64 has no features.
Creating a parse record for a "data" component type named "Natural".
looking for features with BLESS::Assertion properties in Natural
Natural has no features.
Creating a parse record for a "data" component type named "Float".
looking for features with BLESS::Assertion properties in Float
Float has no features.
Creating a parse record for a "data" component type named "Float_32".
looking for features with BLESS::Assertion properties in Float_32
Float_32 has no features.
Creating a parse record for a "data" component type named "Float_64".
looking for features with BLESS::Assertion properties in Float_64
Float_64 has no features.
Creating a parse record for a "data" component type named "Character".
looking for features with BLESS::Assertion properties in Character
Character has no features.
Creating a parse record for a "data" component type named "String".
looking for features with BLESS::Assertion properties in String
String has no features.
All component types in package "Base_Types" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
Base_Types has no component implementations.
Done with package Base_Types.

Gathering package "CTCS_Types".
Creating a parse record for a "data" component type named "Position".
looking for features with BLESS::Assertion properties in Position
Position has no features.
Creating a parse record for a "data" component type named "DMI_Message".
looking for features with BLESS::Assertion properties in DMI_Message
DMI_Message has no features.
Creating a parse record for a "data" component type named "Velocity".
  data type "Velocity" has BLESS::Typed property "real".
Velocity BLESS::Typed property unparsed:  real
looking for features with BLESS::Assertion properties in Velocity
Velocity has no features.
Creating a parse record for a "data" component type named "Acceleration".
looking for features with BLESS::Assertion properties in Acceleration
Acceleration has no features.
Creating a parse record for a "data" component type named "Time".
looking for features with BLESS::Assertion properties in Time
Time has no features.
Creating a parse record for a "data" component type named "Deceleration".
looking for features with BLESS::Assertion properties in Deceleration
Deceleration has no features.
Creating a parse record for a "data" component type named "RBC_Permission".
looking for features with BLESS::Assertion properties in RBC_Permission
RBC_Permission has no features.
Creating a parse record for a "data" component type named "LUA".
looking for features with BLESS::Assertion properties in LUA
LUA has no features.
Creating a parse record for a "data" component type named "LU".
looking for features with BLESS::Assertion properties in LU
LU has no features.
Creating a parse record for a "data" component type named "MA_Size".
looking for features with BLESS::Assertion properties in MA_Size
MA_Size has no features.
Creating a parse record for a "data" component type named "DriverConfirmation".
looking for features with BLESS::Assertion properties in DriverConfirmation
DriverConfirmation has no features.
Creating a parse record for a "data" component type named "ModeTypes".
  data type "ModeTypes" has BLESS::Typed property "enumeration (FS,CO)".
ModeTypes BLESS::Typed property unparsed:  enumeration (FS, CO)
looking for features with BLESS::Assertion properties in ModeTypes
ModeTypes has no features.
Creating a parse record for a "data" component type named "MA_Request".
looking for features with BLESS::Assertion properties in MA_Request
MA_Request has no features.
Creating a parse record for a "data" component type named "EOA".
looking for features with BLESS::Assertion properties in EOA
EOA has no features.
Creating a parse record for a "data" component type named "Segment".
  data type "Segment" has BLESS::Typed property "record (
 	v1 :  CTCS_Types::Velocity;
 	v2 :  CTCS_Types::Velocity;
    e :   CTCS_Types::Position;
    m:    CTCS_Types::ModeTypes;
 )".
Segment BLESS::Typed property unparsed:  record 
  (v1:CTCS_Types::Velocity;
    v2:CTCS_Types::Velocity;
    e:CTCS_Types::Position;
    m:CTCS_Types::ModeTypes;)
looking for features with BLESS::Assertion properties in Segment
Segment has no features.
Creating a parse record for a "data" component type named "MovementAuthority".
  data type "MovementAuthority" has BLESS::Typed property "array [CTCS_Types::MA_Size] of CTCS_Types::Segment".
MovementAuthority BLESS::Typed property unparsed:  array[CTCS_Types::MA_Size] of CTCS_Types::Segment
looking for features with BLESS::Assertion properties in MovementAuthority
MovementAuthority has no features.
All component types in package "CTCS_Types" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
CTCS_Types has no component implementations.
Done with package CTCS_Types.

Gathering package "BLESS_Types".
Creating a parse record for a "data" component type named "Integer".
  data type "Integer" has BLESS::Typed property "integer".
Integer BLESS::Typed property unparsed:  integer
looking for features with BLESS::Assertion properties in Integer
Integer has no features.
Creating a parse record for a "data" component type named "Natural".
  data type "Natural" has BLESS::Typed property "natural".
Natural BLESS::Typed property unparsed:  natural
looking for features with BLESS::Assertion properties in Natural
Natural has no features.
Creating a parse record for a "data" component type named "Real".
  data type "Real" has BLESS::Typed property "real".
Real BLESS::Typed property unparsed:  real
looking for features with BLESS::Assertion properties in Real
Real has no features.
Creating a parse record for a "data" component type named "String".
  data type "String" has BLESS::Typed property "string".
String BLESS::Typed property unparsed:  string
looking for features with BLESS::Assertion properties in String
String has no features.
Creating a parse record for a "data" component type named "Fixed_Point".
  data type "Fixed_Point" has BLESS::Typed property "rational".
Fixed_Point BLESS::Typed property unparsed:  rational
looking for features with BLESS::Assertion properties in Fixed_Point
Fixed_Point has no features.
Creating a parse record for a "data" component type named "Time".
  data type "Time" has BLESS::Typed property "real".
Time BLESS::Typed property unparsed:  real
looking for features with BLESS::Assertion properties in Time
Time has no features.
Creating a parse record for a "data" component type named "flag".
  data type "flag" has BLESS::Typed property "boolean".
flag BLESS::Typed property unparsed:  boolean
looking for features with BLESS::Assertion properties in flag
flag has no features.
All component types in package "BLESS_Types" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
BLESS_Types has no component implementations.
Done with package BLESS_Types.

Gathering package "MA".
Creating a parse record for a "system" component type named "sysMA".
looking for features with BLESS::Assertion properties in sysMA
sysMA has no features.
Creating a parse record for a "abstract" component type named "Train".
Abstract component with name of "Train" had no BLESS to gather.
looking for features with BLESS::Assertion properties in Train
  feature ts org.osate.aadl2.impl.DataPortImpl@4e81fb24 (name: ts) (direction: out) on line 0
  feature tv org.osate.aadl2.impl.DataPortImpl@70dd4e58 (name: tv) (direction: out) on line 0
  feature "tv" has BLESS::Typed property "real".
tv as string tree:  real
tv as unparsed:  real
  feature ta org.osate.aadl2.impl.DataPortImpl@6580c77a (name: ta) (direction: in) on line 0
Creating a parse record for a "process" component type named "pController".
Process component with name of "pController" had no BLESS to gather.
looking for features with BLESS::Assertion properties in pController
  feature ps org.osate.aadl2.impl.DataPortImpl@28c368d4 (name: ps) (direction: in) on line 0
  feature pv org.osate.aadl2.impl.DataPortImpl@666b58be (name: pv) (direction: in) on line 0
  feature "pv" has BLESS::Typed property "real".
pv as string tree:  real
pv as unparsed:  real
  feature pa org.osate.aadl2.impl.DataPortImpl@59766c97 (name: pa) (direction: out) on line 0
  feature pea org.osate.aadl2.impl.DataPortImpl@4f14f8e9 (name: pea) (direction: in) on line 0
  feature pm org.osate.aadl2.impl.EventDataPortImpl@605017f0 (name: pm) (direction: in) on line 0
  feature "pm" has BLESS::Typed property "array [CTCS_Types::MA_Size] of CTCS_Types::Segment".
pm as string tree:  ^(array ^(:: CTCS_Types MA_Size ) of ^(:: CTCS_Types Segment ) )
pm as unparsed:  array[CTCS_Types::MA_Size] of CTCS_Types::Segment
  feature pr org.osate.aadl2.impl.EventPortImpl@783cd34c (name: pr) (direction: out) on line 0
Creating a parse record for a "thread" component type named "Controller".
looking for features with BLESS::Assertion properties in Controller
  feature ea org.osate.aadl2.impl.DataPortImpl@6154603f (name: ea) (direction: in) on line 0
  feature cs org.osate.aadl2.impl.DataPortImpl@4c635594 (name: cs) (direction: in) on line 0
  feature "cs" has BLESS::Assertion property "<<:=POSITION>>".
cs as string tree:  ^(ASSERTION_FUNCTION[1] POSITION )
cs as unparsed:  << := POSITION>> 
  feature cv org.osate.aadl2.impl.DataPortImpl@5cfc08c8 (name: cv) (direction: in) on line 0
  feature "cv" has BLESS::Assertion property "<<:=VELOCITY>>".
cv as string tree:  ^(ASSERTION_FUNCTION[1] VELOCITY )
cv as unparsed:  << := VELOCITY>> 
  feature "cv" has BLESS::Typed property "real".
cv as string tree:  real
cv as unparsed:  real
  feature ca org.osate.aadl2.impl.DataPortImpl@41d08a05 (name: ca) (direction: out) on line 0
  feature "ca" has BLESS::Assertion property "<<:=Acceleration()>>".
ca as string tree:  ^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
ca as unparsed:  << := Acceleration()>> 
  feature m org.osate.aadl2.impl.EventDataPortImpl@68677680 (name: m) (direction: in) on line 0
  feature "m" has BLESS::Assertion property "<<:=IMA>>".
m as string tree:  ^(ASSERTION_FUNCTION[1] IMA )
m as unparsed:  << := IMA>> 
  feature "m" has BLESS::Typed property "array [CTCS_Types::MA_Size] of CTCS_Types::Segment".
m as string tree:  ^(array ^(:: CTCS_Types MA_Size ) of ^(:: CTCS_Types Segment ) )
m as unparsed:  array[CTCS_Types::MA_Size] of CTCS_Types::Segment
  feature r org.osate.aadl2.impl.EventPortImpl@72e9feeb (name: r) (direction: out) on line 0
  feature "r" has BLESS::Assertion property "<<(s=CTCS_Properties::start) or (s>=(e-SR))>>".
r as string tree:  ^(ASSERTION[1] ^(or ^(( ^(= s ^(:: CTCS_Properties start ) ) ) ) ^(( ^(>= s ^(( ^(- e SR ) ) ) ) ) ) ) )
r as unparsed:  <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
Creating a parse record for a "device" component type named "RBC".
looking for features with BLESS::Assertion properties in RBC
  feature ea org.osate.aadl2.impl.DataPortImpl@50705e1b (name: ea) (direction: out) on line 0
  feature m org.osate.aadl2.impl.EventDataPortImpl@508e9cbd (name: m) (direction: out) on line 0
  feature "m" has BLESS::Typed property "array [CTCS_Types::MA_Size] of CTCS_Types::Segment".
m as string tree:  ^(array ^(:: CTCS_Types MA_Size ) of ^(:: CTCS_Types Segment ) )
m as unparsed:  array[CTCS_Types::MA_Size] of CTCS_Types::Segment
  feature r org.osate.aadl2.impl.EventPortImpl@65b070b (name: r) (direction: in) on line 0
All component types in package "MA" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
  gathering component implementation "sysMA.impl"
Looking for component type "sysMA", defining features this implementation uses.
no subprogram access map for component sysMA
  gathering component implementation "Train.impl"
  gathering component implementation "pController.impl"
  gathering component implementation "Controller.impl"
Found a BLESS annex subclause in component implementation "Controller.impl" in package "MA".
parsing Controller.impl
Controller.impl has loaded type maps
unparsed:
annex BLESS
{**  --Controller.impl
assert 
  <<SBL: :(s = CTCS_Properties::start) or ((v < iSeg.v2))>>
  <<EBL: :(v < iSeg.v1)>>
  <<DSPV1: :(((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))>>
  <<DSPV2: :(s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))>>
  <<Acceleration: := (NOCHANGE()) -> 0, (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate, 
                        (not EBL() or not DSPV1()) ->  -b, (SBL() and DSPV2()) -> xl>>  
invariant <<true>>
variables
  i: Base_Types::Integer:=0;
  b: CTCS_Types::Deceleration;
  v: CTCS_Types::Velocity:=0;
  s: CTCS_Types::Position;
  e: CTCS_Types::EOA;
  xl: CTCS_Types::Acceleration;
  iMA: CTCS_Types::MovementAuthority:=;
  iSeg,nSeg: CTCS_Types::Segment:=; 
states
  READY : initial state
    <<(i = 0) and (s = CTCS_Properties::start)>>;
  GMA : complete state
    <<(i = 0) and (s = CTCS_Properties::start)>>;
  CMA : state
    <<(i = 0) and (s = CTCS_Properties::start)>>;
  RETRY : state
    <<(i = 0) and (s = CTCS_Properties::start)>>;
  MFR : complete state
    <<SBL() and DSPV2()>>;
  CMF : state
    <<SBL() and DSPV2()>>;
  SBI : complete state
    <<not SBL() or not DSPV2()>>;
  CSB : state
    <<not SBL() or not DSPV2()>>;
  EBI : complete state
    <<not EBL() or not DSPV1()>>;
  STOP : final state
    <<(not EBL() or not DSPV1()) and v = 0>>;
transitions
  T0_go: READY-[]->GMA
    { <<(i = 0) and (s = CTCS_Properties::start)>>
       r!
       ;
       <<(i = 0) and (s = CTCS_Properties::start)>>
       ( --begining of simultaneous assignment
        i',
        s'
       :=
        i,
        s
       ) --end of simultaneous assignment

       <<(i' = 0) and (s' = CTCS_Properties::start)>> }
   ;  --end of T0_go

  T1_MA_Check: GMA-[on dispatch]->CMA
    { m?(iMA)
       ;
       <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
       ea?(e)
       <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>> }
   ;  --end of T1_MA_Check

  T2_MA_Ok: CMA-[not (iMA = )]->MFR
    { ( --begining of simultaneous assignment
        iSeg',
        nSeg',
        i',
        v',
        s',
        b',
        iMA'
       :=
        iSeg,
        nSeg,
        i,
        v,
        s,
        b,
        iMA
       ) --end of simultaneous assignment

       <<(SBL() and DSPV2())^1>> }
   ;  --end of T2_MA_Ok

  T3_Move_Check: MFR-[on dispatch]->CMF
    { {
        <<SBL() and DSPV2()>>
        cs?(s)
        <<s = POSITION>>
        &
        cv?(v)
        <<SBL() and DSPV2() and v = VELOCITY>>
       } 
       ;
       <<SBL() and DSPV2()>>
       if 
       (s >= (e-SR))~> 
         <<SBL() and DSPV2() and (s >= (e-SR))>>
         r!
         <<SBL() and DSPV2()>> 
       []
       (not (s >= (e-SR)))~> 
         <<SBL() and DSPV2()>>
         skip
         <<SBL() and DSPV2()>> 
       fi
       <<SBL() and DSPV2()>> }
   ;  --end of T3_Move_Check

  T4_SBI_Point: CMF-[not ((s = CTCS_Properties::start) or ((v < iSeg.v2))) or 
  not ((s = CTCS_Properties::start) or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+
  (2*b*iSeg.e)))))]->SBI
    { <<not SBL() or not DSPV2()>>
       ca!(CTCS_Properties::SB_Rate)
       ;
       <<not SBL() or not DSPV2()>>
       ( --begining of simultaneous assignment
        iSeg',
        nSeg',
        i',
        v',
        s',
        b',
        iMA'
       :=
        iSeg,
        nSeg,
        i,
        v,
        s,
        b,
        iMA
       ) --end of simultaneous assignment

       <<(not SBL() or not DSPV2())^1>> }
   ;  --end of T4_SBI_Point

  T5_Move_Ok: CMF-[((s = CTCS_Properties::start) or ((v < iSeg.v2))) or 
  (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))]->MFR
    { <<SBL() and DSPV2()>>
       ca!(xl)
       ;
       <<SBL() and DSPV2()>>
       ( --begining of simultaneous assignment
        i,
        iSeg,
        nSeg
       :=
        i+1,
        nSeg,
        iMA[i+2]
       ) --end of simultaneous assignment

       ;
       <<SBL() and DSPV2()>>
       ( --begining of simultaneous assignment
        iSeg',
        nSeg',
        i',
        v',
        s',
        b',
        iMA'
       :=
        iSeg,
        nSeg,
        i,
        v,
        s,
        b,
        iMA
       ) --end of simultaneous assignment

       <<(SBL() and DSPV2())^1>> }
   ;  --end of T5_Move_Ok

  T6_SBI_Check: SBI-[on dispatch]->CSB
    { {
        <<not SBL() or not DSPV2()>>
        cs?(s)
        <<s = POSITION>>
        &
        cv?(v)
        <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
       }  }
   ;  --end of T6_SBI_Check

  T7_SBI_Out: CSB-[((s = CTCS_Properties::start) or ((v < iSeg.v2))) and 
  ((s = CTCS_Properties::start) or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*
  b*iSeg.e)))))]->MFR
    { <<SBL() and DSPV2()>>
       ca!(xl)
       ;
       <<SBL() and DSPV2()>>
       ( --begining of simultaneous assignment
        iSeg',
        nSeg',
        i',
        v',
        s',
        b',
        iMA'
       :=
        iSeg,
        nSeg,
        i,
        v,
        s,
        b,
        iMA
       ) --end of simultaneous assignment

       <<(SBL() and DSPV2())^1>> }
   ;  --end of T7_SBI_Out

  T8_SBI_Ok: CSB-[not (((s = CTCS_Properties::start) or ((v < iSeg.v2))) and 
  ((s = CTCS_Properties::start) or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*
  b*iSeg.e))))))]->SBI
    { ( --begining of simultaneous assignment
        iSeg',
        nSeg',
        i',
        v',
        s',
        b',
        iMA'
       :=
        iSeg,
        nSeg,
        i,
        v,
        s,
        b,
        iMA
       ) --end of simultaneous assignment

       <<(not SBL() or not DSPV2())^1>> }
   ;  --end of T8_SBI_Ok

  T9_MA_NotOk: CMA-[iMA = ]->RETRY
    {} ;  --end of T9_MA_NotOk

  T10_MA_Retry: RETRY-[]->GMA
    { ( --begining of simultaneous assignment
        i',
        s'
       :=
        i,
        s
       ) --end of simultaneous assignment
   }
   ;  --end of T10_MA_Retry

  T11_EBI_Point: CMF-[not (v < iSeg.v1) or not ((((v**2)+(2*b*s)) < (
  iMA[nSeg.v1]+(2*b*iSeg.e))))]->EBI
    { <<not EBL() or not DSPV1()>>
       ca!(- b)
       ;
       <<not EBL() or not DSPV1()>>
       ( --begining of simultaneous assignment
        iSeg',
        nSeg',
        i',
        v',
        s',
        b',
        iMA'
       :=
        iSeg,
        nSeg,
        i,
        v,
        s,
        b,
        iMA
       ) --end of simultaneous assignment

       <<(not EBL() or not DSPV1())^1>> }
   ;  --end of T11_EBI_Point

  T12_Stop: EBI-[v = 0]->STOP
    {} ;  --end of T12_Stop

  T13_EBI_Point: SBI-[not (v < iSeg.v1) or not ((((v**2)+(2*b*s)) < (
  iMA[nSeg.v1]+(2*b*iSeg.e))))]->EBI
    { <<not EBL() or not DSPV1()>>
       ca!(- b)
       ;
       <<not EBL() or not DSPV1()>>
       ( --begining of simultaneous assignment
        iSeg',
        nSeg',
        i',
        v',
        s',
        b',
        iMA'
       :=
        iSeg,
        nSeg,
        i,
        v,
        s,
        b,
        iMA
       ) --end of simultaneous assignment

       <<(not EBL() or not DSPV1())^1>> }
   ;  --end of T13_EBI_Point
**}  --Controller.impl
Looking for component type "Controller", defining features this implementation uses.
no subprogram access map for component Controller
  gathering component implementation "RBC.impl"
Looking for component type "RBC", defining features this implementation uses.
no subprogram access map for component RBC
Done with package MA.

Data Component Name to Type map={CTCS_Types::MovementAuthority=array, BLESS_Types::Natural=natural, CTCS_Types::Segment=record, CTCS_Types::ModeTypes=enumeration, BLESS_Types::Integer=integer, CTCS_Types::Velocity=real, BLESS_Types::Fixed_Point=rational, BLESS_Types::flag=boolean, BLESS_Types::Time=real, BLESS_Types::Real=real, BLESS_Types::String=string}
Type Checking . . .
Creating proof obligations for components having BLESS or subBLESS annex subclauses.
 extracting initial proof obligation(s) for a package:  "ErrorLibrary"
 extracting initial proof obligation(s) for a package:  "Base_Types"
  no proof obligations created for "Float"
  no proof obligations created for "Integer_64"
  no proof obligations created for "Integer_16"
  no proof obligations created for "Unsigned_64"
  no proof obligations created for "Natural"
  no proof obligations created for "Unsigned_8"
  no proof obligations created for "Boolean"
  no proof obligations created for "Character"
  no proof obligations created for "Integer_8"
  no proof obligations created for "Unsigned_16"
  no proof obligations created for "String"
  no proof obligations created for "Float_64"
  no proof obligations created for "Unsigned_32"
  no proof obligations created for "Float_32"
  no proof obligations created for "Integer_32"
  no proof obligations created for "Integer"
 extracting initial proof obligation(s) for a package:  "CTCS_Types"
  no proof obligations created for "LU"
  no proof obligations created for "RBC_Permission"
  no proof obligations created for "Velocity"
  no proof obligations created for "DMI_Message"
  no proof obligations created for "Acceleration"
  no proof obligations created for "MA_Request"
  no proof obligations created for "EOA"
  no proof obligations created for "Time"
  no proof obligations created for "MA_Size"
  no proof obligations created for "ModeTypes"
  no proof obligations created for "Deceleration"
  no proof obligations created for "Segment"
  no proof obligations created for "Position"
  no proof obligations created for "LUA"
  no proof obligations created for "DriverConfirmation"
  no proof obligations created for "MovementAuthority"
 extracting initial proof obligation(s) for a package:  "BLESS_Types"
  no proof obligations created for "Real"
  no proof obligations created for "flag"
  no proof obligations created for "Time"
  no proof obligations created for "String"
  no proof obligations created for "Natural"
  no proof obligations created for "Fixed_Point"
  no proof obligations created for "Integer"
 extracting initial proof obligation(s) for a package:  "MA"
  no proof obligations created for "pController"
  creating proof obligations for "Controller"
extracting proof obligations for "Controller"
  no proof obligations created for "Train"
  creating proof obligations for "sysMA"
extracting proof obligations for "sysMA"
  creating proof obligations for "RBC"
extracting proof obligations for "RBC"
  creating proof obligations for "Controller.impl"
extracting proof obligations for "Controller.impl"
making initial obligations for complete states
making Serban's theorems
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
making initial proof obligations for transitions
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
  creating proof obligations for "RBC.impl"
extracting proof obligations for "RBC.impl"
  creating proof obligations for "sysMA.impl"
extracting proof obligations for "sysMA.impl"
Creating assume-guaranty proof obligations for port connections. (TBD)
connection proof obligations for package "ErrorLibrary"
connection proof obligations for package "Base_Types"
connection proof obligations for package "CTCS_Types"
connection proof obligations for package "BLESS_Types"
connection proof obligations for package "MA"
connection proof obligations for component implementation "sysMA.impl"
connection "MA::sysMA.impl.conn_position" has no source or destination Assertions.
connection "MA::sysMA.impl.conn_velocity" has no source or destination Assertions.
connection "MA::sysMA.impl.conn_acc" has no source or destination Assertions.
connection "MA::sysMA.impl.conn_req" has no source or destination Assertions.
connection "MA::sysMA.impl.conn_ma" has no source or destination Assertions.
connection "MA::sysMA.impl.conn_ea" has no source or destination Assertions.
connection proof obligations for component implementation "Train.impl"
connection proof obligations for component implementation "pController.impl"
connection "MA::pController.impl.conn_s" has no source Assertion.
connection "MA::pController.impl.conn_v" has no source Assertion.
connection "MA::pController.impl.conn_a" has no destination Assertion.
connection "MA::pController.impl.conn_req" has no destination Assertion.
connection "MA::pController.impl.conn_ma" has no source Assertion.
connection "MA::pController.impl.conn_ea" has no source or destination Assertions.
connection proof obligations for component implementation "Controller.impl"
connection proof obligations for component implementation "RBC.impl"
composition proof obligations for package "ErrorLibrary"
composition proof obligations for package "Base_Types"
composition proof obligations for package "CTCS_Types"
composition proof obligations for package "BLESS_Types"
composition proof obligations for package "MA"
Global.compilationUnits.size()=5
Global.compilationUnitStartingProductions.size()=0
Proof.label_assertion_map={DSPV1=ASSERTION[188], DSPV2=ASSERTION[189], EBL=ASSERTION[187], Acceleration=ASSERTION_FUNCTION[192], SBL=ASSERTION[186]}
Declarative Model is Loaded into BLESS.
No errors found.
****make-an****
Making obligation 0
Obligations:

[serial 1003]: MA::Controller.impl
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [107]->
Q [107] <<true>>
  What for: <<M(GMA)>> -> <<I>> from invariant I when complete state GMA has Assertion <<M(GMA)>> in its definition.


Done making obligation 0
#MA::Controller.impl
#[serial 1003] <<M(GMA)>> -> <<I>> from invariant I when complete state GMA has Assertion <<M(GMA)>> in its definition.
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1003]: MA::Controller.impl
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [107]->
Q [107] <<true>>
Reason:  True Conclusion Schema (tc): P->true
  What for: <<M(GMA)>> -> <<I>> from invariant I when complete state GMA has Assertion <<M(GMA)>> in its definition.

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1004]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [107]->
Q [107] <<true>>
  What for: <<M(MFR)>> -> <<I>> from invariant I when complete state MFR has Assertion <<M(MFR)>> in its definition.


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1004] <<M(MFR)>> -> <<I>> from invariant I when complete state MFR has Assertion <<M(MFR)>> in its definition.
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1004]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [107]->
Q [107] <<true>>
Reason:  True Conclusion Schema (tc): P->true
  What for: <<M(MFR)>> -> <<I>> from invariant I when complete state MFR has Assertion <<M(MFR)>> in its definition.

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1005]: MA::Controller.impl
P [126] <<not SBL() or not DSPV2()>>
S [107]->
Q [107] <<true>>
  What for: <<M(SBI)>> -> <<I>> from invariant I when complete state SBI has Assertion <<M(SBI)>> in its definition.


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1005] <<M(SBI)>> -> <<I>> from invariant I when complete state SBI has Assertion <<M(SBI)>> in its definition.
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1005]: MA::Controller.impl
P [126] <<not SBL() or not DSPV2()>>
S [107]->
Q [107] <<true>>
Reason:  True Conclusion Schema (tc): P->true
  What for: <<M(SBI)>> -> <<I>> from invariant I when complete state SBI has Assertion <<M(SBI)>> in its definition.

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1006]: MA::Controller.impl
P [128] <<not EBL() or not DSPV1()>>
S [107]->
Q [107] <<true>>
  What for: <<M(EBI)>> -> <<I>> from invariant I when complete state EBI has Assertion <<M(EBI)>> in its definition.


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1006] <<M(EBI)>> -> <<I>> from invariant I when complete state EBI has Assertion <<M(EBI)>> in its definition.
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1006]: MA::Controller.impl
P [128] <<not EBL() or not DSPV1()>>
S [107]->
Q [107] <<true>>
Reason:  True Conclusion Schema (tc): P->true
  What for: <<M(EBI)>> -> <<I>> from invariant I when complete state EBI has Assertion <<M(EBI)>> in its definition.

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1007]: MA::Controller.impl
P [127] <<not SBL() or not DSPV2()>>
S [127]->
Q [127] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))
or (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CSB, <<M(CSB)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1007] Serban's Theorem:  disjunction of execute conditions leaving execution state CSB, <<M(CSB)>> -> <<e1 or e2 or . . . en>>
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1007]: MA::Controller.impl
P [127] <<not SBL() or not DSPV2()>>
S [127]->
Q [127] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))
or (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
Reason:  Law of Excluded Middle: P or not P is tautology
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CSB, <<M(CSB)>> -> <<e1 or e2 or . . . en>>

Has applied law "Law of Excluded Middle: P or not P is tautology" to get:

[serial 1025]: MA::Controller.impl
P [127] <<not SBL() or not DSPV2()>>
S [127]->
Q [127] <<true>>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1007]

. . . done Applying Laws [12.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1025]: MA::Controller.impl
P [127] <<not SBL() or not DSPV2()>>
S [127]->
Q [127] <<true>>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1007]


Done applying laws
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1025]: MA::Controller.impl
P [127] <<not SBL() or not DSPV2()>>
S [127]->
Q [127] <<true>>
Reason:  True Conclusion Schema (tc): P->true
  What for: Law of Excluded Middle: P or not P is tautology [serial 1007]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1008]: MA::Controller.impl
P [125] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))
or (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))
or (not (v < iSeg.v1)
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CMF, <<M(CMF)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1008] Serban's Theorem:  disjunction of execute conditions leaving execution state CMF, <<M(CMF)>> -> <<e1 or e2 or . . . en>>
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1008]: MA::Controller.impl
P [125] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))
or (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))
or (not (v < iSeg.v1)
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CMF, <<M(CMF)>> -> <<e1 or e2 or . . . en>>

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1026]: MA::Controller.impl
P [125] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))
or ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))
or not (v < iSeg.v1)
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1008]


This Proof Obligation:

[serial 1026]: MA::Controller.impl
P [125] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))
or ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))
or not (v < iSeg.v1)
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
Reason:  Law of Excluded Middle: P or not P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 1008]

Has applied law "Law of Excluded Middle: P or not P is tautology" to get:

[serial 1027]: MA::Controller.impl
P [125] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<true>>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1026]

. . . done Applying Laws [13.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1027]: MA::Controller.impl
P [125] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<true>>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1026]


Done applying laws
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1027]: MA::Controller.impl
P [125] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<true>>
Reason:  True Conclusion Schema (tc): P->true
  What for: Law of Excluded Middle: P or not P is tautology [serial 1026]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [13.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1009]: MA::Controller.impl
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [123]->
Q [123] <<true>>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state RETRY, <<M(RETRY)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1009] Serban's Theorem:  disjunction of execute conditions leaving execution state RETRY, <<M(RETRY)>> -> <<e1 or e2 or . . . en>>
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1009]: MA::Controller.impl
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [123]->
Q [123] <<true>>
Reason:  True Conclusion Schema (tc): P->true
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state RETRY, <<M(RETRY)>> -> <<e1 or e2 or . . . en>>

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [13.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1010]: MA::Controller.impl
P [122] <<(i = 0) and (s = CTCS_Properties::start)>>
S [122]->
Q [122] <<(not (iMA = )) or (iMA = )>>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CMA, <<M(CMA)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1010] Serban's Theorem:  disjunction of execute conditions leaving execution state CMA, <<M(CMA)>> -> <<e1 or e2 or . . . en>>
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1010]: MA::Controller.impl
P [122] <<(i = 0) and (s = CTCS_Properties::start)>>
S [122]->
Q [122] <<(not (iMA = )) or (iMA = )>>
Reason:  Law of Excluded Middle: P or not P is tautology
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CMA, <<M(CMA)>> -> <<e1 or e2 or . . . en>>

Has applied law "Law of Excluded Middle: P or not P is tautology" to get:

[serial 1028]: MA::Controller.impl
P [122] <<(i = 0) and (s = CTCS_Properties::start)>>
S [122]->
Q [122] <<true>>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1010]

. . . done Applying Laws [13.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1028]: MA::Controller.impl
P [122] <<(i = 0) and (s = CTCS_Properties::start)>>
S [122]->
Q [122] <<true>>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1010]


Done applying laws
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1028]: MA::Controller.impl
P [122] <<(i = 0) and (s = CTCS_Properties::start)>>
S [122]->
Q [122] <<true>>
Reason:  True Conclusion Schema (tc): P->true
  What for: Law of Excluded Middle: P or not P is tautology [serial 1010]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [13.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1011]: MA::Controller.impl
P [120] <<(i = 0) and (s = CTCS_Properties::start)>>
S [134]<<(i = 0) and (s = CTCS_Properties::start)>>
r!
;
<<(i = 0) and (s = CTCS_Properties::start)>>
( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

<<(i' = 0) and (s' = CTCS_Properties::start)>>
Q [121] <<((i = 0) and (s = CTCS_Properties::start))^1>>
  What for:  <<M(READY)>> A <<M(GMA)>> for T0_go:READY-[ ]->GMA{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1011]  <<M(READY)>> A <<M(GMA)>> for T0_go:READY-[ ]->GMA{A};
****reduce****
This proof obligation:

[serial 1011]: MA::Controller.impl
P [120] <<(i = 0) and (s = CTCS_Properties::start)>>
S [134]<<(i = 0) and (s = CTCS_Properties::start)>>
r!
;
<<(i = 0) and (s = CTCS_Properties::start)>>
( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

<<(i' = 0) and (s' = CTCS_Properties::start)>>
Q [121] <<((i = 0) and (s = CTCS_Properties::start))^1>>
  What for:  <<M(READY)>> A <<M(GMA)>> for T0_go:READY-[ ]->GMA{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1029]: MA::Controller.impl
P [120] <<(i = 0) and (s = CTCS_Properties::start)>>
S [120]->
Q [133] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for: P -> P1 in sequential composition for [serial 1011]


[serial 1030]: MA::Controller.impl
P [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
S [121]->
Q [91] <<((i = 0) and (s = CTCS_Properties::start))^1>>
  What for: Q1 -> Q in sequential composition for [serial 1011]


[serial 1031]: MA::Controller.impl
P [133] <<(i = 0) and (s = CTCS_Properties::start)>>
S [134]r!
Q [135] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1011]


[serial 1032]: MA::Controller.impl
P [135] <<(i = 0) and (s = CTCS_Properties::start)>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1011]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1029]: MA::Controller.impl
P [120] <<(i = 0) and (s = CTCS_Properties::start)>>
S [120]->
Q [133] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for: P -> P1 in sequential composition for [serial 1011]



[serial 1030]: MA::Controller.impl
P [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
S [121]->
Q [91] <<((i = 0) and (s = CTCS_Properties::start))^1>>
  What for: Q1 -> Q in sequential composition for [serial 1011]



[serial 1031]: MA::Controller.impl
P [133] <<(i = 0) and (s = CTCS_Properties::start)>>
S [134]r!
Q [135] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1011]



[serial 1032]: MA::Controller.impl
P [135] <<(i = 0) and (s = CTCS_Properties::start)>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1011]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1029]: MA::Controller.impl
P [120] <<(i = 0) and (s = CTCS_Properties::start)>>
S [120]->
Q [133] <<(i = 0) and (s = CTCS_Properties::start)>>
Reason:  Identity (id):  P->P is tautology
  What for: P -> P1 in sequential composition for [serial 1011]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [13.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1030]: MA::Controller.impl
P [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
S [121]->
Q [91] <<((i = 0) and (s = CTCS_Properties::start))^1>>
  What for: Q1 -> Q in sequential composition for [serial 1011]



[serial 1031]: MA::Controller.impl
P [133] <<(i = 0) and (s = CTCS_Properties::start)>>
S [134]r!
Q [135] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1011]



[serial 1032]: MA::Controller.impl
P [135] <<(i = 0) and (s = CTCS_Properties::start)>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1011]


Done trying to apply axioms
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1030]: MA::Controller.impl
P [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
S [121]->
Q [91] <<((i = 0) and (s = CTCS_Properties::start))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Q1 -> Q in sequential composition for [serial 1011]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1033]: MA::Controller.impl
P [137] <<((i)^1 = 0)
  and
  ((s)^1 = CTCS_Properties::start)>>
S [121]->
Q [91] <<((i = 0)^1 and (s = CTCS_Properties::start)^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1030]


This Proof Obligation:

[serial 1032]: MA::Controller.impl
P [135] <<(i = 0) and (s = CTCS_Properties::start)>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1011]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1034]: MA::Controller.impl
P [135] <<(i = 0) and (s = CTCS_Properties::start)>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<((i)^1 = 0)
  and
  ((s)^1 = CTCS_Properties::start)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1032]

. . . done spltting timed atoms  [14.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [14.3 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1031]: MA::Controller.impl
P [133] <<(i = 0) and (s = CTCS_Properties::start)>>
S [134]r!
Q [135] <<(i = 0) and (s = CTCS_Properties::start)>>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1011]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1036]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]r!
Q [135] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1031]


This Proof Obligation:

[serial 1033]: MA::Controller.impl
P [137] <<((i)^1 = 0)
  and
  ((s)^1 = CTCS_Properties::start)>>
S [121]->
Q [91] <<((i = 0)^1 and (s = CTCS_Properties::start)^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1030]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1038]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<(CTCS_Properties::start = s)^1 and (i = 0)^1>>
  What for:   normalization of [serial 1033]


This Proof Obligation:

[serial 1034]: MA::Controller.impl
P [135] <<(i = 0) and (s = CTCS_Properties::start)>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<((i)^1 = 0)
  and
  ((s)^1 = CTCS_Properties::start)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1032]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1040]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
  What for:   normalization of [serial 1034]

. . . done Normalizing Unsolved Proof Obligations [15.0 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1036]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]r!
Q [135] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1031]



[serial 1038]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<(CTCS_Properties::start = s)^1 and (i = 0)^1>>
  What for:   normalization of [serial 1033]



[serial 1040]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
  What for:   normalization of [serial 1034]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1038]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<(CTCS_Properties::start = s)^1 and (i = 0)^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1033]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1044]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<((CTCS_Properties::start)^1 = (s)^1)
  and
  ((i)^1 = (0)^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1038]

. . . done spltting timed atoms  [15.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [15.2 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1044]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<((CTCS_Properties::start)^1 = (s)^1)
  and
  ((i)^1 = (0)^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1038]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Constants are always the same

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1048]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
  What for:   normalization of [serial 1044]

. . . done Normalizing Unsolved Proof Obligations [15.3 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1036]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]r!
Q [135] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1031]



[serial 1040]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
  What for:   normalization of [serial 1034]



[serial 1048]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
  What for:   normalization of [serial 1044]


Done completely distributing ^ and @, round 1.
Distributing carets . .
. . . done spltting timed atoms  [15.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [15.4 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [15.4 seconds ]
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1036]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]r!
Q [135] <<CTCS_Properties::start = s and i = 0>>
Reason:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
  What for:   normalization of [serial 1031]

Has applied <<pre>> -> <<M(r)>> for <<pre>> r! <<post>> to get:

[serial 1053]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]->
Q [1] <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
  What for: applied port output <<pre>> -> <<M(r)>> [serial 1036]

Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic

This Proof Obligation:

[serial 1036]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]r!
Q [135] <<CTCS_Properties::start = s and i = 0>>
Reason:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
  What for:   normalization of [serial 1031]

Thread "Controller.impl" has Dispatch_Protocol property Periodic
Has applied <<pre and r^0>> -> <<post>> for <<pre>> r! <<post>> to get:

[serial 1054]: MA::Controller.impl
P [134] <<(CTCS_Properties::start = s and i = 0) and r^0>>
S [134]->
Q [135] <<CTCS_Properties::start = s and i = 0>>
  What for: applied port output <<pre and r^0>> -> <<post>> [serial 1036]

solving assignment on line 136
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "i^1" with "i"
makes:  <<i = 0 and s^1 = CTCS_Properties::start>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "s^1" with "s"
makes:  <<i = 0 and s = CTCS_Properties::start>>

This Proof Obligation:

[serial 1040]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1034]

Has applied simultaneous assignmnet to get:

[serial 1055]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<i = 0 and s = CTCS_Properties::start>>
  What for: applied wp for simultaneous assignment [serial 1040]

. . . done applying atomic actions [15.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1053]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]->
Q [1] <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
  What for: applied port output <<pre>> -> <<M(r)>> [serial 1036]



[serial 1054]: MA::Controller.impl
P [134] <<(CTCS_Properties::start = s and i = 0) and r^0>>
S [134]->
Q [135] <<CTCS_Properties::start = s and i = 0>>
  What for: applied port output <<pre and r^0>> -> <<post>> [serial 1036]



[serial 1055]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<i = 0 and s = CTCS_Properties::start>>
  What for: applied wp for simultaneous assignment [serial 1040]



[serial 1055]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<i = 0 and s = CTCS_Properties::start>>
  What for: applied wp for simultaneous assignment [serial 1040]



[serial 1048]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
  What for:   normalization of [serial 1044]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1053]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]->
Q [1] <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
Reason:  Normalization
  What for: applied port output <<pre>> -> <<M(r)>> [serial 1036]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Zero is unique element: x+0 = x      x-0 = x

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1057]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]->
Q [1] <<(e-SR) <= s or CTCS_Properties::start = s>>
  What for:   normalization of [serial 1053]


This Proof Obligation:

[serial 1054]: MA::Controller.impl
P [134] <<(CTCS_Properties::start = s and i = 0) and r^0>>
S [134]->
Q [135] <<CTCS_Properties::start = s and i = 0>>
Reason:  Normalization
  What for: applied port output <<pre and r^0>> -> <<post>> [serial 1036]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1059]: MA::Controller.impl
P [134] <<r^0 and (CTCS_Properties::start = s and i = 0)>>
S [134]->
Q [135] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1054]


This Proof Obligation:

[serial 1055]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<i = 0 and s = CTCS_Properties::start>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1040]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1061]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1055]


This Proof Obligation:

[serial 1055]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<i = 0 and s = CTCS_Properties::start>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1040]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1063]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1055]

. . . done Normalizing Unsolved Proof Obligations [15.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1048]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
  What for:   normalization of [serial 1044]



[serial 1057]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]->
Q [1] <<(e-SR) <= s or CTCS_Properties::start = s>>
  What for:   normalization of [serial 1053]



[serial 1059]: MA::Controller.impl
P [134] <<r^0 and (CTCS_Properties::start = s and i = 0)>>
S [134]->
Q [135] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1054]



[serial 1061]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1055]



[serial 1063]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1055]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1048]: MA::Controller.impl
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121]->
Q [91] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1044]

Has been solved by Identity (id):  P->P is tautology
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 CTCS_Properties::start = s


This Proof Obligation:

[serial 1057]: MA::Controller.impl
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134]->
Q [1] <<(e-SR) <= s or CTCS_Properties::start = s>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for:   normalization of [serial 1053]

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1059]: MA::Controller.impl
P [134] <<r^0 and (CTCS_Properties::start = s and i = 0)>>
S [134]->
Q [135] <<CTCS_Properties::start = s and i = 0>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1054]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1061]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<CTCS_Properties::start = s and i = 0>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1055]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1063]: MA::Controller.impl
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136]->
Q [137] <<CTCS_Properties::start = s and i = 0>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1055]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [16.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1012]: MA::Controller.impl
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [141]m?(iMA)
;
<<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
ea?(e)
<<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
Q [122] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for:  <<M(GMA) and x>> A <<M(CMA)>> for T1_MA_Check:GMA-[x]->CMA{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1012]  <<M(GMA) and x>> A <<M(CMA)>> for T1_MA_Check:GMA-[x]->CMA{A};
****reduce****
This proof obligation:

[serial 1012]: MA::Controller.impl
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [141]m?(iMA)
;
<<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
ea?(e)
<<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
Q [122] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for:  <<M(GMA) and x>> A <<M(CMA)>> for T1_MA_Check:GMA-[x]->CMA{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1069]: MA::Controller.impl
P [142] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
S [122]->
Q [122] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for: Q1 -> Q in sequential composition for [serial 1012]


[serial 1070]: MA::Controller.impl
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [141]m?(iMA)
Q [141] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1012]


[serial 1071]: MA::Controller.impl
P [141] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
S [142]ea?(e)
Q [142] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1012]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1069]: MA::Controller.impl
P [142] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
S [122]->
Q [122] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for: Q1 -> Q in sequential composition for [serial 1012]



[serial 1070]: MA::Controller.impl
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [141]m?(iMA)
Q [141] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1012]



[serial 1071]: MA::Controller.impl
P [141] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
S [142]ea?(e)
Q [142] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1012]


done reducing composite actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1069]: MA::Controller.impl
P [142] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
S [122]->
Q [122] <<(i = 0) and (s = CTCS_Properties::start)>>
Reason:  Normalization
  What for: Q1 -> Q in sequential composition for [serial 1012]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1073]: MA::Controller.impl
P [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
S [122]->
Q [122] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1069]


This Proof Obligation:

[serial 1070]: MA::Controller.impl
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [141]m?(iMA)
Q [141] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1012]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1075]: MA::Controller.impl
P [121] <<CTCS_Properties::start = s and i = 0>>
S [141]m?(iMA)
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1070]


This Proof Obligation:

[serial 1071]: MA::Controller.impl
P [141] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
S [142]ea?(e)
Q [142] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1012]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1077]: MA::Controller.impl
P [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
S [142]ea?(e)
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1071]

. . . done Normalizing Unsolved Proof Obligations [16.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1073]: MA::Controller.impl
P [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
S [122]->
Q [122] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1069]



[serial 1075]: MA::Controller.impl
P [121] <<CTCS_Properties::start = s and i = 0>>
S [141]m?(iMA)
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1070]



[serial 1077]: MA::Controller.impl
P [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
S [142]ea?(e)
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1071]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1073]: MA::Controller.impl
P [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
S [122]->
Q [122] <<CTCS_Properties::start = s and i = 0>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for:   normalization of [serial 1069]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [16.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1075]: MA::Controller.impl
P [121] <<CTCS_Properties::start = s and i = 0>>
S [141]m?(iMA)
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1070]



[serial 1077]: MA::Controller.impl
P [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
S [142]ea?(e)
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1071]


Done trying to apply axioms
****atomic****
applying atomic actions . . .
portInAnd=^(and ^(( ^(and ^(= ^(:: CTCS_Properties start ) s ) ^(= i 0 ) ) ) ) ^(= iMA IMA ) )

This Proof Obligation:

[serial 1075]: MA::Controller.impl
P [121] <<CTCS_Properties::start = s and i = 0>>
S [141]m?(iMA)
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
Reason:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
  What for:   normalization of [serial 1070]

Has applied when <<pre and v=M(m)>> -> <<post>> for <<pre>> m?(iMA) <<post>> to get:

[serial 1081]: MA::Controller.impl
P [141] <<(CTCS_Properties::start = s and i = 0) and iMA = IMA>>
S [141]->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for: applied port input of value <<pre and iMA=M(m)>> -> <<post>> [serial 1075]

portInAnd=^(and ^(( ^(and ^(= ^(:: CTCS_Properties start ) s ) ^(= IMA iMA ) ^(= i 0 ) ) ) ) ^(= e ea ) )

This Proof Obligation:

[serial 1077]: MA::Controller.impl
P [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
S [142]ea?(e)
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
Reason:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
  What for:   normalization of [serial 1071]

Has applied when <<pre and v=M(ea)>> -> <<post>> for <<pre>> ea?(e) <<post>> to get:

[serial 1082]: MA::Controller.impl
P [142] <<(CTCS_Properties::start = s and IMA = iMA and i = 0) and e = ea>>
S [142]->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for: applied port input of value <<pre and e=M(ea)>> -> <<post>> [serial 1077]

. . . done applying atomic actions [16.6 seconds ]
After "atomic" remaining 
Obligations:

[serial 1081]: MA::Controller.impl
P [141] <<(CTCS_Properties::start = s and i = 0) and iMA = IMA>>
S [141]->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for: applied port input of value <<pre and iMA=M(m)>> -> <<post>> [serial 1075]



[serial 1082]: MA::Controller.impl
P [142] <<(CTCS_Properties::start = s and IMA = iMA and i = 0) and e = ea>>
S [142]->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for: applied port input of value <<pre and e=M(ea)>> -> <<post>> [serial 1077]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1081]: MA::Controller.impl
P [141] <<(CTCS_Properties::start = s and i = 0) and iMA = IMA>>
S [141]->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
Reason:  Normalization
  What for: applied port input of value <<pre and iMA=M(m)>> -> <<post>> [serial 1075]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1084]: MA::Controller.impl
P [141] <<IMA = iMA and (CTCS_Properties::start = s and i = 0)>>
S [141]->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1081]


This Proof Obligation:

[serial 1082]: MA::Controller.impl
P [142] <<(CTCS_Properties::start = s and IMA = iMA and i = 0) and e = ea>>
S [142]->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
Reason:  Normalization
  What for: applied port input of value <<pre and e=M(ea)>> -> <<post>> [serial 1077]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1086]: MA::Controller.impl
P [142] <<e = ea and (CTCS_Properties::start = s and IMA = iMA and i = 0)>>
S [142]->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1082]

. . . done Normalizing Unsolved Proof Obligations [16.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1084]: MA::Controller.impl
P [141] <<IMA = iMA and (CTCS_Properties::start = s and i = 0)>>
S [141]->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1081]



[serial 1086]: MA::Controller.impl
P [142] <<e = ea and (CTCS_Properties::start = s and IMA = iMA and i = 0)>>
S [142]->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for:   normalization of [serial 1082]


Done Normalizing
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1084]: MA::Controller.impl
P [141] <<IMA = iMA and (CTCS_Properties::start = s and i = 0)>>
S [141]->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1081]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1089]: MA::Controller.impl
P [141] <<CTCS_Properties::start = s and i = 0 and IMA = iMA>>
S [141]->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for: Associativity: (b.c).a = a.b.c [serial 1084]


This Proof Obligation:

[serial 1086]: MA::Controller.impl
P [142] <<e = ea and (CTCS_Properties::start = s and IMA = iMA and i = 0)>>
S [142]->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1082]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1090]: MA::Controller.impl
P [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0 and e = ea>>
S [142]->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for: Associativity: (b.c).a = a.b.c [serial 1086]

. . . done Applying Laws [16.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1089]: MA::Controller.impl
P [141] <<CTCS_Properties::start = s and i = 0 and IMA = iMA>>
S [141]->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for: Associativity: (b.c).a = a.b.c [serial 1084]



[serial 1090]: MA::Controller.impl
P [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0 and e = ea>>
S [142]->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
  What for: Associativity: (b.c).a = a.b.c [serial 1086]


Done applying laws
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1089]: MA::Controller.impl
P [141] <<CTCS_Properties::start = s and i = 0 and IMA = iMA>>
S [141]->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Associativity: (b.c).a = a.b.c [serial 1084]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1090]: MA::Controller.impl
P [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0 and e = ea>>
S [142]->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Associativity: (b.c).a = a.b.c [serial 1086]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [17.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1013]: MA::Controller.impl
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(SBL() and DSPV2())^1>>
Q [124] <<(SBL() and DSPV2())^1>>
  What for:  <<M(CMA) and x>> A <<M(MFR)>> for T2_MA_Ok:CMA-[x]->MFR{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1013]  <<M(CMA) and x>> A <<M(MFR)>> for T2_MA_Ok:CMA-[x]->MFR{A};
****reduce****

[serial 1091]: MA::Controller.impl
P [148] <<(SBL() and DSPV2())^1>>
S [124]->
Q [124] <<(SBL() and DSPV2())^1>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1013]


[serial 1092]: MA::Controller.impl
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(SBL() and DSPV2())^1>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1013]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1091]: MA::Controller.impl
P [148] <<(SBL() and DSPV2())^1>>
S [124]->
Q [124] <<(SBL() and DSPV2())^1>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1013]



[serial 1092]: MA::Controller.impl
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(SBL() and DSPV2())^1>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1013]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1091]: MA::Controller.impl
P [148] <<(SBL() and DSPV2())^1>>
S [124]->
Q [124] <<(SBL() and DSPV2())^1>>
Reason:  Identity (id):  P->P is tautology
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1013]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [17.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1092]: MA::Controller.impl
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(SBL() and DSPV2())^1>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1013]


Done trying to apply axioms
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1092]: MA::Controller.impl
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(SBL() and DSPV2())^1>>
Reason:  Substitution of Assertion Labels
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1013]

Has substituted Assertions' predicates for labels to get:

[serial 1093]: MA::Controller.impl
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
  What for: substituted Assertions' predicates for  labels  [serial 1092]

. . . done Substituting Assertions for Labels [17.2 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1093]: MA::Controller.impl
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1092]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1095]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1093]

. . . done Normalizing Unsolved Proof Obligations [17.4 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1095]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1093]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [17.5 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [17.5 seconds ]
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1095]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1093]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1098]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1095]

. . . done spltting timed atoms  [17.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [17.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1098]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1095]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1100]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1098]

. . . done Normalizing Unsolved Proof Obligations [17.8 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1100]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1098]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1100]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1098]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1102]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1100]

. . . done spltting timed atoms  [18.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [18.0 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [18.0 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1102]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1100]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 1102]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1100]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1104]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(((CTCS_Properties::start)^1 = (s)^1)
  or ((v)^1 < (iSeg.v2)^1))
  and
  (((CTCS_Properties::start)^1 = (s)^1)
  or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1102]

. . . done spltting timed atoms  [18.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [18.2 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1104]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(((CTCS_Properties::start)^1 = (s)^1)
  or ((v)^1 < (iSeg.v2)^1))
  and
  (((CTCS_Properties::start)^1 = (s)^1)
  or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1102]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1106]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1104]

. . . done Normalizing Unsolved Proof Obligations [18.5 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 1106]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1104]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 1106]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1104]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1108]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1106]

. . . done spltting timed atoms  [18.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [18.7 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1108]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1106]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1110]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1108]

. . . done Normalizing Unsolved Proof Obligations [18.8 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 1110]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1108]


Done completely distributing ^ and @, round 3.
Distributing carets . .

This Proof Obligation:

[serial 1110]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1108]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1112]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
  (iSeg.e)^1)))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1110]

. . . done spltting timed atoms  [19.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [19.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1112]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
  (iSeg.e)^1)))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1110]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1114]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1112]

. . . done Normalizing Unsolved Proof Obligations [19.2 seconds ]
After "completely distribute ^ and @" round 4 remaining 
Obligations:

[serial 1114]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1112]


Done completely distributing ^ and @, round 4.
Distributing carets . .
. . . done spltting timed atoms  [19.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [19.3 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [19.3 seconds ]
****atomic****
applying atomic actions . . .
solving assignment on line 147
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iSeg'" with "iSeg"
makes:  <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "v^1" with "v"
makes:  <<(s^1 = CTCS_Properties::start or v < iSeg.v2)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "s^1" with "s"
makes:  <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b^1*s*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "b^1" with "b"
makes:  <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]^1+(b*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iMA'" with "iMA"
makes:  <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>

This Proof Obligation:

[serial 1114]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1112]

Has applied simultaneous assignmnet to get:

[serial 1117]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1114]

. . . done applying atomic actions [19.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1117]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1114]



[serial 1117]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1114]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1117]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1114]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1119]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1117]


This Proof Obligation:

[serial 1117]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1114]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1121]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1117]

. . . done Normalizing Unsolved Proof Obligations [19.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1119]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1117]



[serial 1121]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1117]


Done Normalizing
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1119]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1117]

Has split postcondition to get:

[serial 1124]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<(CTCS_Properties::start = s or v < iSeg.v2)>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1119]


[serial 1125]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<(CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1119]


This Proof Obligation:

[serial 1121]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1117]

Has split postcondition to get:

[serial 1126]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<(CTCS_Properties::start = s or v < iSeg.v2)>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1121]


[serial 1127]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<(CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1121]

. . . done splitting postcondition  [19.7 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1124]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<(CTCS_Properties::start = s or v < iSeg.v2)>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1119]



[serial 1125]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<(CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1119]



[serial 1126]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<(CTCS_Properties::start = s or v < iSeg.v2)>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1121]



[serial 1127]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<(CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1121]


Done splitting postcondition
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1124]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<(CTCS_Properties::start = s or v < iSeg.v2)>>
Reason:  Normalization
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1119]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1129]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
  What for:   normalization of [serial 1124]


This Proof Obligation:

[serial 1125]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<(CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Normalization
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1119]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1131]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1125]


This Proof Obligation:

[serial 1126]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<(CTCS_Properties::start = s or v < iSeg.v2)>>
Reason:  Normalization
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1121]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1133]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
  What for:   normalization of [serial 1126]


This Proof Obligation:

[serial 1127]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<(CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Normalization
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1121]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1135]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1127]

. . . done Normalizing Unsolved Proof Obligations [19.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1129]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
  What for:   normalization of [serial 1124]



[serial 1131]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1125]



[serial 1133]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
  What for:   normalization of [serial 1126]



[serial 1135]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1127]


Done Normalizing
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 CTCS_Properties::start = s


This Proof Obligation:

[serial 1129]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for:   normalization of [serial 1124]

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 CTCS_Properties::start = s


This Proof Obligation:

[serial 1131]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for:   normalization of [serial 1125]

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 CTCS_Properties::start = s


This Proof Obligation:

[serial 1133]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for:   normalization of [serial 1126]

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 CTCS_Properties::start = s


This Proof Obligation:

[serial 1135]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for:   normalization of [serial 1127]

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [19.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1014]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [154]{
 <<SBL() and DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<SBL() and DSPV2() and v = VELOCITY>>
} 
;
<<SBL() and DSPV2()>>
if 
(s >= (e-SR))~> 
  <<SBL() and DSPV2() and (s >= (e-SR))>>
  r!
  <<SBL() and DSPV2()>> 
[]
(not (s >= (e-SR)))~> 
  <<SBL() and DSPV2()>>
  skip
  <<SBL() and DSPV2()>> 
fi
<<SBL() and DSPV2()>>
Q [125] <<SBL() and DSPV2()>>
  What for:  <<M(MFR) and x>> A <<M(CMF)>> for T3_Move_Check:MFR-[x]->CMF{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1014]  <<M(MFR) and x>> A <<M(CMF)>> for T3_Move_Check:MFR-[x]->CMF{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [20.0 seconds ]
After applying axioms, no change 
****reduce****
This proof obligation:

[serial 1014]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [154]{
 <<SBL() and DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<SBL() and DSPV2() and v = VELOCITY>>
} 
;
<<SBL() and DSPV2()>>
if 
(s >= (e-SR))~> 
  <<SBL() and DSPV2() and (s >= (e-SR))>>
  r!
  <<SBL() and DSPV2()>> 
[]
(not (s >= (e-SR)))~> 
  <<SBL() and DSPV2()>>
  skip
  <<SBL() and DSPV2()>> 
fi
<<SBL() and DSPV2()>>
Q [125] <<SBL() and DSPV2()>>
  What for:  <<M(MFR) and x>> A <<M(CMF)>> for T3_Move_Check:MFR-[x]->CMF{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1140]: MA::Controller.impl
P [167] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<SBL() and DSPV2()>>
  What for: Q1 -> Q in sequential composition for [serial 1014]


[serial 1141]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [153]{
 <<SBL() and DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<SBL() and DSPV2() and v = VELOCITY>>
} 
Q [156] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1014]


[serial 1142]: MA::Controller.impl
P [156] <<SBL() and DSPV2()>>
S [157]if 
(s >= (e-SR))~> 
  <<SBL() and DSPV2() and (s >= (e-SR))>>
  r!
  <<SBL() and DSPV2()>> 
[]
(not (s >= (e-SR)))~> 
  <<SBL() and DSPV2()>>
  skip
  <<SBL() and DSPV2()>> 
fi
Q [167] <<SBL() and DSPV2()>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1014]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1140]: MA::Controller.impl
P [167] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<SBL() and DSPV2()>>
  What for: Q1 -> Q in sequential composition for [serial 1014]



[serial 1141]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [153]{
 <<SBL() and DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<SBL() and DSPV2() and v = VELOCITY>>
} 
Q [156] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1014]



[serial 1142]: MA::Controller.impl
P [156] <<SBL() and DSPV2()>>
S [157]if 
(s >= (e-SR))~> 
  <<SBL() and DSPV2() and (s >= (e-SR))>>
  r!
  <<SBL() and DSPV2()>> 
[]
(not (s >= (e-SR)))~> 
  <<SBL() and DSPV2()>>
  skip
  <<SBL() and DSPV2()>> 
fi
Q [167] <<SBL() and DSPV2()>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1014]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1140]: MA::Controller.impl
P [167] <<SBL() and DSPV2()>>
S [125]->
Q [125] <<SBL() and DSPV2()>>
Reason:  Identity (id):  P->P is tautology
  What for: Q1 -> Q in sequential composition for [serial 1014]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [20.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1141]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [153]{
 <<SBL() and DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<SBL() and DSPV2() and v = VELOCITY>>
} 
Q [156] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1014]



[serial 1142]: MA::Controller.impl
P [156] <<SBL() and DSPV2()>>
S [157]if 
(s >= (e-SR))~> 
  <<SBL() and DSPV2() and (s >= (e-SR))>>
  r!
  <<SBL() and DSPV2()>> 
[]
(not (s >= (e-SR)))~> 
  <<SBL() and DSPV2()>>
  skip
  <<SBL() and DSPV2()>> 
fi
Q [167] <<SBL() and DSPV2()>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1014]


Done trying to apply axioms
****reduce****
Reducing Existential Quantification of:

[serial 1141]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [153]{
 <<SBL() and DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<SBL() and DSPV2() and v = VELOCITY>>
} 
Q [156] <<SBL() and DSPV2()>>
Reason:  Introduction of Existential Quantification (bl.elq)
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1014]

as this
			<<P and x=e>> -> <<A>>
			<<A>> T <<B>> 
 		<<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable x:t:=e; { <<A>> T <<B>> } <<Q>>
begat these:

[serial 1143]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [153]->
Q [153] <<SBL() and DSPV2()>>
  What for: <<P and x=e>> -> <<A>> in existential lattice quantification for [serial 1141]


[serial 1144]: MA::Controller.impl
P [153] <<SBL() and DSPV2()>>
S [154]<<SBL() and DSPV2()>>
cs?(s)
<<s = POSITION>>
&
cv?(v)
<<SBL() and DSPV2() and v = VELOCITY>>
Q [154] <<(s = POSITION) and (SBL() and DSPV2() and v = VELOCITY)>>
  What for: {A} T {B} in existential lattice quantification for [serial 1141]


[serial 1145]: MA::Controller.impl
P [154] <<(s = POSITION) and (SBL() and DSPV2() and v = VELOCITY)>>
S [153]->
Q [156] <<SBL() and DSPV2()>>
  What for: <<B>> -> <<Q>> in existential lattice quantification for [serial 1141]

This proof obligation:

[serial 1142]: MA::Controller.impl
P [156] <<SBL() and DSPV2()>>
S [157]if 
(s >= (e-SR))~> 
  <<SBL() and DSPV2() and (s >= (e-SR))>>
  r!
  <<SBL() and DSPV2()>> 
[]
(not (s >= (e-SR)))~> 
  <<SBL() and DSPV2()>>
  skip
  <<SBL() and DSPV2()>> 
fi
Q [167] <<SBL() and DSPV2()>>
Reason:  Alternative Rule:
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<B1 and P1>> S1 <<Q1>>, <<B2 and P2>> S2 <<Q2>>, . . . , <<Bn and Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1014]

as <<P>> if (B1)-><<P1>>S1<<Q1>> [] (B2)-><<P2>>S2<<Q2>> [] . . . [] (Bn)-><<Pn>>Sn<<Qn>> fi <<Q>> 

was reduced to:
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic

[serial 1146]: MA::Controller.impl
P [156] <<SBL() and DSPV2()>>
S [157]->
Q [157] <<(s >= (e-SR))
or (not (s >= (e-SR)))>>
  What for:   <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 1142]

Thread "Controller.impl" has Dispatch_Protocol property Periodic

[serial 1147]: MA::Controller.impl
P [157] <<(SBL() and DSPV2()) and (s >= (e-SR))>>
S [157]->
Q [158] <<SBL() and DSPV2() and (s >= (e-SR))>>
  What for:   <<P and B0>> -> <<P0>>  for [serial 1142]


[serial 1148]: MA::Controller.impl
P [158] <<SBL() and DSPV2() and (s >= (e-SR))>>
S [159]r!
Q [160] <<SBL() and DSPV2()>>
  What for:   <<P0>> S0 <<Q0>>  for [serial 1142]


[serial 1149]: MA::Controller.impl
P [160] <<SBL() and DSPV2()>>
S [157]->
Q [167] <<SBL() and DSPV2()>>
  What for:   <<Q0>> -> <<Q>>  for [serial 1142]

Thread "Controller.impl" has Dispatch_Protocol property Periodic

[serial 1150]: MA::Controller.impl
P [157] <<(SBL() and DSPV2())
  and
  (not (s >= (e-SR)))>>
S [157]->
Q [163] <<SBL() and DSPV2()>>
  What for:   <<P and B1>> -> <<P1>>  for [serial 1142]


[serial 1151]: MA::Controller.impl
P [163] <<SBL() and DSPV2()>>
S [164]skip
Q [165] <<SBL() and DSPV2()>>
  What for:   <<P1>> S1 <<Q1>>  for [serial 1142]


[serial 1152]: MA::Controller.impl
P [165] <<SBL() and DSPV2()>>
S [157]->
Q [167] <<SBL() and DSPV2()>>
  What for:   <<Q1>> -> <<Q>>  for [serial 1142]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1143]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [153]->
Q [153] <<SBL() and DSPV2()>>
  What for: <<P and x=e>> -> <<A>> in existential lattice quantification for [serial 1141]



[serial 1144]: MA::Controller.impl
P [153] <<SBL() and DSPV2()>>
S [154]<<SBL() and DSPV2()>>
cs?(s)
<<s = POSITION>>
&
cv?(v)
<<SBL() and DSPV2() and v = VELOCITY>>
Q [154] <<(s = POSITION) and (SBL() and DSPV2() and v = VELOCITY)>>
  What for: {A} T {B} in existential lattice quantification for [serial 1141]



[serial 1145]: MA::Controller.impl
P [154] <<(s = POSITION) and (SBL() and DSPV2() and v = VELOCITY)>>
S [153]->
Q [156] <<SBL() and DSPV2()>>
  What for: <<B>> -> <<Q>> in existential lattice quantification for [serial 1141]



[serial 1146]: MA::Controller.impl
P [156] <<SBL() and DSPV2()>>
S [157]->
Q [157] <<(s >= (e-SR))
or (not (s >= (e-SR)))>>
  What for:   <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 1142]



[serial 1147]: MA::Controller.impl
P [157] <<(SBL() and DSPV2()) and (s >= (e-SR))>>
S [157]->
Q [158] <<SBL() and DSPV2() and (s >= (e-SR))>>
  What for:   <<P and B0>> -> <<P0>>  for [serial 1142]



[serial 1148]: MA::Controller.impl
P [158] <<SBL() and DSPV2() and (s >= (e-SR))>>
S [159]r!
Q [160] <<SBL() and DSPV2()>>
  What for:   <<P0>> S0 <<Q0>>  for [serial 1142]



[serial 1149]: MA::Controller.impl
P [160] <<SBL() and DSPV2()>>
S [157]->
Q [167] <<SBL() and DSPV2()>>
  What for:   <<Q0>> -> <<Q>>  for [serial 1142]



[serial 1150]: MA::Controller.impl
P [157] <<(SBL() and DSPV2())
  and
  (not (s >= (e-SR)))>>
S [157]->
Q [163] <<SBL() and DSPV2()>>
  What for:   <<P and B1>> -> <<P1>>  for [serial 1142]



[serial 1151]: MA::Controller.impl
P [163] <<SBL() and DSPV2()>>
S [164]skip
Q [165] <<SBL() and DSPV2()>>
  What for:   <<P1>> S1 <<Q1>>  for [serial 1142]



[serial 1152]: MA::Controller.impl
P [165] <<SBL() and DSPV2()>>
S [157]->
Q [167] <<SBL() and DSPV2()>>
  What for:   <<Q1>> -> <<Q>>  for [serial 1142]


done reducing composite actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1143]: MA::Controller.impl
P [124] <<SBL() and DSPV2()>>
S [153]->
Q [153] <<SBL() and DSPV2()>>
Reason:  Normalization
  What for: <<P and x=e>> -> <<A>> in existential lattice quantification for [serial 1141]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1154]: MA::Controller.impl
P [124] <<DSPV2() and SBL()>>
S [153]->
Q [153] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1143]


This Proof Obligation:

[serial 1144]: MA::Controller.impl
P [153] <<SBL() and DSPV2()>>
S [154]<<SBL() and DSPV2()>>
cs?(s)
<<s = POSITION>>
&
cv?(v)
<<SBL() and DSPV2() and v = VELOCITY>>
Q [154] <<(s = POSITION) and (SBL() and DSPV2() and v = VELOCITY)>>
Reason:  Normalization
  What for: {A} T {B} in existential lattice quantification for [serial 1141]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1156]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]<<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
  What for:   normalization of [serial 1144]


This Proof Obligation:

[serial 1145]: MA::Controller.impl
P [154] <<(s = POSITION) and (SBL() and DSPV2() and v = VELOCITY)>>
S [153]->
Q [156] <<SBL() and DSPV2()>>
Reason:  Normalization
  What for: <<B>> -> <<Q>> in existential lattice quantification for [serial 1141]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1158]: MA::Controller.impl
P [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
S [153]->
Q [156] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1145]


This Proof Obligation:

[serial 1146]: MA::Controller.impl
P [156] <<SBL() and DSPV2()>>
S [157]->
Q [157] <<(s >= (e-SR))
or (not (s >= (e-SR)))>>
Reason:  Normalization
  What for:   <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 1142]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1160]: MA::Controller.impl
P [156] <<DSPV2() and SBL()>>
S [157]->
Q [157] <<(e-SR) <= s or not (e-SR) <= s>>
  What for:   normalization of [serial 1146]


This Proof Obligation:

[serial 1147]: MA::Controller.impl
P [157] <<(SBL() and DSPV2()) and (s >= (e-SR))>>
S [157]->
Q [158] <<SBL() and DSPV2() and (s >= (e-SR))>>
Reason:  Normalization
  What for:   <<P and B0>> -> <<P0>>  for [serial 1142]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1162]: MA::Controller.impl
P [157] <<(e-SR) <= s and (DSPV2() and SBL())>>
S [157]->
Q [158] <<(e-SR) <= s and DSPV2() and SBL()>>
  What for:   normalization of [serial 1147]


This Proof Obligation:

[serial 1148]: MA::Controller.impl
P [158] <<SBL() and DSPV2() and (s >= (e-SR))>>
S [159]r!
Q [160] <<SBL() and DSPV2()>>
Reason:  Normalization
  What for:   <<P0>> S0 <<Q0>>  for [serial 1142]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1164]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]r!
Q [160] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1148]


This Proof Obligation:

[serial 1149]: MA::Controller.impl
P [160] <<SBL() and DSPV2()>>
S [157]->
Q [167] <<SBL() and DSPV2()>>
Reason:  Normalization
  What for:   <<Q0>> -> <<Q>>  for [serial 1142]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1166]: MA::Controller.impl
P [160] <<DSPV2() and SBL()>>
S [157]->
Q [167] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1149]


This Proof Obligation:

[serial 1150]: MA::Controller.impl
P [157] <<(SBL() and DSPV2())
  and
  (not (s >= (e-SR)))>>
S [157]->
Q [163] <<SBL() and DSPV2()>>
Reason:  Normalization
  What for:   <<P and B1>> -> <<P1>>  for [serial 1142]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1168]: MA::Controller.impl
P [157] <<not (e-SR) <= s and (DSPV2() and SBL())>>
S [157]->
Q [163] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1150]


This Proof Obligation:

[serial 1151]: MA::Controller.impl
P [163] <<SBL() and DSPV2()>>
S [164]skip
Q [165] <<SBL() and DSPV2()>>
Reason:  Normalization
  What for:   <<P1>> S1 <<Q1>>  for [serial 1142]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1170]: MA::Controller.impl
P [163] <<DSPV2() and SBL()>>
S [164]skip
Q [165] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1151]


This Proof Obligation:

[serial 1152]: MA::Controller.impl
P [165] <<SBL() and DSPV2()>>
S [157]->
Q [167] <<SBL() and DSPV2()>>
Reason:  Normalization
  What for:   <<Q1>> -> <<Q>>  for [serial 1142]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1172]: MA::Controller.impl
P [165] <<DSPV2() and SBL()>>
S [157]->
Q [167] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1152]

. . . done Normalizing Unsolved Proof Obligations [20.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1154]: MA::Controller.impl
P [124] <<DSPV2() and SBL()>>
S [153]->
Q [153] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1143]



[serial 1156]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]<<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
  What for:   normalization of [serial 1144]



[serial 1158]: MA::Controller.impl
P [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
S [153]->
Q [156] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1145]



[serial 1160]: MA::Controller.impl
P [156] <<DSPV2() and SBL()>>
S [157]->
Q [157] <<(e-SR) <= s or not (e-SR) <= s>>
  What for:   normalization of [serial 1146]



[serial 1162]: MA::Controller.impl
P [157] <<(e-SR) <= s and (DSPV2() and SBL())>>
S [157]->
Q [158] <<(e-SR) <= s and DSPV2() and SBL()>>
  What for:   normalization of [serial 1147]



[serial 1164]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]r!
Q [160] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1148]



[serial 1166]: MA::Controller.impl
P [160] <<DSPV2() and SBL()>>
S [157]->
Q [167] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1149]



[serial 1168]: MA::Controller.impl
P [157] <<not (e-SR) <= s and (DSPV2() and SBL())>>
S [157]->
Q [163] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1150]



[serial 1170]: MA::Controller.impl
P [163] <<DSPV2() and SBL()>>
S [164]skip
Q [165] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1151]



[serial 1172]: MA::Controller.impl
P [165] <<DSPV2() and SBL()>>
S [157]->
Q [167] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1152]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1154]: MA::Controller.impl
P [124] <<DSPV2() and SBL()>>
S [153]->
Q [153] <<DSPV2() and SBL()>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1143]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1166]: MA::Controller.impl
P [160] <<DSPV2() and SBL()>>
S [157]->
Q [167] <<DSPV2() and SBL()>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1149]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1168]: MA::Controller.impl
P [157] <<not (e-SR) <= s and (DSPV2() and SBL())>>
S [157]->
Q [163] <<DSPV2() and SBL()>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1150]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1172]: MA::Controller.impl
P [165] <<DSPV2() and SBL()>>
S [157]->
Q [167] <<DSPV2() and SBL()>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1152]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [20.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1156]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]<<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
  What for:   normalization of [serial 1144]



[serial 1158]: MA::Controller.impl
P [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
S [153]->
Q [156] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1145]



[serial 1160]: MA::Controller.impl
P [156] <<DSPV2() and SBL()>>
S [157]->
Q [157] <<(e-SR) <= s or not (e-SR) <= s>>
  What for:   normalization of [serial 1146]



[serial 1162]: MA::Controller.impl
P [157] <<(e-SR) <= s and (DSPV2() and SBL())>>
S [157]->
Q [158] <<(e-SR) <= s and DSPV2() and SBL()>>
  What for:   normalization of [serial 1147]



[serial 1164]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]r!
Q [160] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1148]



[serial 1170]: MA::Controller.impl
P [163] <<DSPV2() and SBL()>>
S [164]skip
Q [165] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1151]


Done trying to apply axioms
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1156]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]<<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1144]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1183]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]<<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
  What for: Associativity: (b.c).a = a.b.c [serial 1156]


This Proof Obligation:

[serial 1158]: MA::Controller.impl
P [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
S [153]->
Q [156] <<DSPV2() and SBL()>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1145]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1184]: MA::Controller.impl
P [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
S [153]->
Q [156] <<DSPV2() and SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1158]


This Proof Obligation:

[serial 1160]: MA::Controller.impl
P [156] <<DSPV2() and SBL()>>
S [157]->
Q [157] <<(e-SR) <= s or not (e-SR) <= s>>
Reason:  Law of Excluded Middle: P or not P is tautology
  What for:   normalization of [serial 1146]

Has applied law "Law of Excluded Middle: P or not P is tautology" to get:

[serial 1185]: MA::Controller.impl
P [156] <<DSPV2() and SBL()>>
S [157]->
Q [157] <<true>>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1160]


This Proof Obligation:

[serial 1162]: MA::Controller.impl
P [157] <<(e-SR) <= s and (DSPV2() and SBL())>>
S [157]->
Q [158] <<(e-SR) <= s and DSPV2() and SBL()>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1147]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1186]: MA::Controller.impl
P [157] <<DSPV2() and SBL() and (e-SR) <= s>>
S [157]->
Q [158] <<(e-SR) <= s and DSPV2() and SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1162]

. . . done Applying Laws [20.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1164]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]r!
Q [160] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1148]



[serial 1170]: MA::Controller.impl
P [163] <<DSPV2() and SBL()>>
S [164]skip
Q [165] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1151]



[serial 1183]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]<<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
  What for: Associativity: (b.c).a = a.b.c [serial 1156]



[serial 1184]: MA::Controller.impl
P [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
S [153]->
Q [156] <<DSPV2() and SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1158]



[serial 1185]: MA::Controller.impl
P [156] <<DSPV2() and SBL()>>
S [157]->
Q [157] <<true>>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1160]



[serial 1186]: MA::Controller.impl
P [157] <<DSPV2() and SBL() and (e-SR) <= s>>
S [157]->
Q [158] <<(e-SR) <= s and DSPV2() and SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1162]


Done applying laws
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1184]: MA::Controller.impl
P [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
S [153]->
Q [156] <<DSPV2() and SBL()>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Associativity: (b.c).a = a.b.c [serial 1158]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1185]: MA::Controller.impl
P [156] <<DSPV2() and SBL()>>
S [157]->
Q [157] <<true>>
Reason:  True Conclusion Schema (tc): P->true
  What for: Law of Excluded Middle: P or not P is tautology [serial 1160]

Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1186]: MA::Controller.impl
P [157] <<DSPV2() and SBL() and (e-SR) <= s>>
S [157]->
Q [158] <<(e-SR) <= s and DSPV2() and SBL()>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Associativity: (b.c).a = a.b.c [serial 1162]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [20.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 1164]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]r!
Q [160] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1148]



[serial 1170]: MA::Controller.impl
P [163] <<DSPV2() and SBL()>>
S [164]skip
Q [165] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1151]



[serial 1183]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]<<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
  What for: Associativity: (b.c).a = a.b.c [serial 1156]


Done trying to apply axioms
****reduce****

Reducing Concurrent Computation of:

[serial 1183]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]<<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
Reason:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>> (bl.cck)
  What for: Associativity: (b.c).a = a.b.c [serial 1156]

To:

[serial 1187]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [153]->
Q [153] <<DSPV2() and SBL()>>
  What for: P -> P1 in concurrent composition for [serial 1183]


[serial 1188]: MA::Controller.impl
P [154] <<(POSITION = s) and (VELOCITY = v) and (DSPV2()) and (SBL())>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
  What for: Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1183]


[serial 1189]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]cs?(s)
Q [154] <<POSITION = s>>
  What for: <<P1>> S1 <<Q1>> in concurrent composition for [serial 1183]


[serial 1190]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]cv?(v)
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
  What for: <<P>> S2 <<Q2>> in concurrent composition for [serial 1183]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1164]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]r!
Q [160] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1148]



[serial 1170]: MA::Controller.impl
P [163] <<DSPV2() and SBL()>>
S [164]skip
Q [165] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1151]



[serial 1187]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [153]->
Q [153] <<DSPV2() and SBL()>>
  What for: P -> P1 in concurrent composition for [serial 1183]



[serial 1188]: MA::Controller.impl
P [154] <<(POSITION = s) and (VELOCITY = v) and (DSPV2()) and (SBL())>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
  What for: Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1183]



[serial 1189]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]cs?(s)
Q [154] <<POSITION = s>>
  What for: <<P1>> S1 <<Q1>> in concurrent composition for [serial 1183]



[serial 1190]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]cv?(v)
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
  What for: <<P>> S2 <<Q2>> in concurrent composition for [serial 1183]


done reducing composite actions
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1164]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]r!
Q [160] <<DSPV2() and SBL()>>
Reason:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
  What for:   normalization of [serial 1148]

Has applied <<pre>> -> <<M(r)>> for <<pre>> r! <<post>> to get:

[serial 1191]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]->
Q [1] <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
  What for: applied port output <<pre>> -> <<M(r)>> [serial 1164]

Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic

This Proof Obligation:

[serial 1164]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]r!
Q [160] <<DSPV2() and SBL()>>
Reason:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
  What for:   normalization of [serial 1148]

Thread "Controller.impl" has Dispatch_Protocol property Periodic
Has applied <<pre and r^0>> -> <<post>> for <<pre>> r! <<post>> to get:

[serial 1192]: MA::Controller.impl
P [159] <<((e-SR) <= s and DSPV2() and SBL()) and r^0>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
  What for: applied port output <<pre and r^0>> -> <<post>> [serial 1164]

change skip to ->

[serial 1193]: MA::Controller.impl
P [163] <<DSPV2() and SBL()>>
S [164]->
Q [165] <<DSPV2() and SBL()>>
  What for:   <<P>> -> <<Q>>
  for [serial 1170]

portInAnd=^(and ^(( ^(and ^(INVOKE[153] DSPV2 ) ^(INVOKE[153] SBL ) ) ) ) ^(= s POSITION ) )

This Proof Obligation:

[serial 1189]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]cs?(s)
Q [154] <<POSITION = s>>
Reason:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
  What for: <<P1>> S1 <<Q1>> in concurrent composition for [serial 1183]

Has applied when <<pre and v=M(cs)>> -> <<post>> for <<pre>> cs?(s) <<post>> to get:

[serial 1194]: MA::Controller.impl
P [154] <<(DSPV2() and SBL()) and s = POSITION>>
S [154]->
Q [154] <<POSITION = s>>
  What for: applied port input of value <<pre and s=M(cs)>> -> <<post>> [serial 1189]

portInAnd=^(and ^(( ^(and ^(INVOKE[153] DSPV2 ) ^(INVOKE[153] SBL ) ) ) ) ^(= v VELOCITY ) )

This Proof Obligation:

[serial 1190]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [154]cv?(v)
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
Reason:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
  What for: <<P>> S2 <<Q2>> in concurrent composition for [serial 1183]

Has applied when <<pre and v=M(cv)>> -> <<post>> for <<pre>> cv?(v) <<post>> to get:

[serial 1195]: MA::Controller.impl
P [154] <<(DSPV2() and SBL()) and v = VELOCITY>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
  What for: applied port input of value <<pre and v=M(cv)>> -> <<post>> [serial 1190]

. . . done applying atomic actions [20.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1191]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]->
Q [1] <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
  What for: applied port output <<pre>> -> <<M(r)>> [serial 1164]



[serial 1192]: MA::Controller.impl
P [159] <<((e-SR) <= s and DSPV2() and SBL()) and r^0>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
  What for: applied port output <<pre and r^0>> -> <<post>> [serial 1164]



[serial 1193]: MA::Controller.impl
P [163] <<DSPV2() and SBL()>>
S [164]->
Q [165] <<DSPV2() and SBL()>>
  What for:   <<P>> -> <<Q>>
  for [serial 1170]



[serial 1187]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [153]->
Q [153] <<DSPV2() and SBL()>>
  What for: P -> P1 in concurrent composition for [serial 1183]



[serial 1188]: MA::Controller.impl
P [154] <<(POSITION = s) and (VELOCITY = v) and (DSPV2()) and (SBL())>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
  What for: Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1183]



[serial 1194]: MA::Controller.impl
P [154] <<(DSPV2() and SBL()) and s = POSITION>>
S [154]->
Q [154] <<POSITION = s>>
  What for: applied port input of value <<pre and s=M(cs)>> -> <<post>> [serial 1189]



[serial 1195]: MA::Controller.impl
P [154] <<(DSPV2() and SBL()) and v = VELOCITY>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
  What for: applied port input of value <<pre and v=M(cv)>> -> <<post>> [serial 1190]


Done reducing atomic actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1193]: MA::Controller.impl
P [163] <<DSPV2() and SBL()>>
S [164]->
Q [165] <<DSPV2() and SBL()>>
Reason:  Identity (id):  P->P is tautology
  What for:   <<P>> -> <<Q>>
  for [serial 1170]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1187]: MA::Controller.impl
P [153] <<DSPV2() and SBL()>>
S [153]->
Q [153] <<DSPV2() and SBL()>>
Reason:  Identity (id):  P->P is tautology
  What for: P -> P1 in concurrent composition for [serial 1183]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [20.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1191]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]->
Q [1] <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
  What for: applied port output <<pre>> -> <<M(r)>> [serial 1164]



[serial 1192]: MA::Controller.impl
P [159] <<((e-SR) <= s and DSPV2() and SBL()) and r^0>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
  What for: applied port output <<pre and r^0>> -> <<post>> [serial 1164]



[serial 1188]: MA::Controller.impl
P [154] <<(POSITION = s) and (VELOCITY = v) and (DSPV2()) and (SBL())>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
  What for: Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1183]



[serial 1194]: MA::Controller.impl
P [154] <<(DSPV2() and SBL()) and s = POSITION>>
S [154]->
Q [154] <<POSITION = s>>
  What for: applied port input of value <<pre and s=M(cs)>> -> <<post>> [serial 1189]



[serial 1195]: MA::Controller.impl
P [154] <<(DSPV2() and SBL()) and v = VELOCITY>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
  What for: applied port input of value <<pre and v=M(cv)>> -> <<post>> [serial 1190]


Done trying to apply axioms
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1191]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]->
Q [1] <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
Reason:  Normalization
  What for: applied port output <<pre>> -> <<M(r)>> [serial 1164]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Zero is unique element: x+0 = x      x-0 = x

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1197]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]->
Q [1] <<(e-SR) <= s or CTCS_Properties::start = s>>
  What for:   normalization of [serial 1191]


This Proof Obligation:

[serial 1192]: MA::Controller.impl
P [159] <<((e-SR) <= s and DSPV2() and SBL()) and r^0>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
Reason:  Normalization
  What for: applied port output <<pre and r^0>> -> <<post>> [serial 1164]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1199]: MA::Controller.impl
P [159] <<r^0 and ((e-SR) <= s and DSPV2() and SBL())>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1192]


This Proof Obligation:

[serial 1188]: MA::Controller.impl
P [154] <<(POSITION = s) and (VELOCITY = v) and (DSPV2()) and (SBL())>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
Reason:  Normalization
  What for: Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1183]

  Normalization Axioms:

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1201]: MA::Controller.impl
P [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
S [154]->
Q [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
  What for:   normalization of [serial 1188]


This Proof Obligation:

[serial 1194]: MA::Controller.impl
P [154] <<(DSPV2() and SBL()) and s = POSITION>>
S [154]->
Q [154] <<POSITION = s>>
Reason:  Normalization
  What for: applied port input of value <<pre and s=M(cs)>> -> <<post>> [serial 1189]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1203]: MA::Controller.impl
P [154] <<POSITION = s and (DSPV2() and SBL())>>
S [154]->
Q [154] <<POSITION = s>>
  What for:   normalization of [serial 1194]


This Proof Obligation:

[serial 1195]: MA::Controller.impl
P [154] <<(DSPV2() and SBL()) and v = VELOCITY>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
Reason:  Normalization
  What for: applied port input of value <<pre and v=M(cv)>> -> <<post>> [serial 1190]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1205]: MA::Controller.impl
P [154] <<VELOCITY = v and (DSPV2() and SBL())>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
  What for:   normalization of [serial 1195]

. . . done Normalizing Unsolved Proof Obligations [20.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1197]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]->
Q [1] <<(e-SR) <= s or CTCS_Properties::start = s>>
  What for:   normalization of [serial 1191]



[serial 1199]: MA::Controller.impl
P [159] <<r^0 and ((e-SR) <= s and DSPV2() and SBL())>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1192]



[serial 1201]: MA::Controller.impl
P [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
S [154]->
Q [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
  What for:   normalization of [serial 1188]



[serial 1203]: MA::Controller.impl
P [154] <<POSITION = s and (DSPV2() and SBL())>>
S [154]->
Q [154] <<POSITION = s>>
  What for:   normalization of [serial 1194]



[serial 1205]: MA::Controller.impl
P [154] <<VELOCITY = v and (DSPV2() and SBL())>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
  What for:   normalization of [serial 1195]


Done Normalizing
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1199]: MA::Controller.impl
P [159] <<r^0 and ((e-SR) <= s and DSPV2() and SBL())>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1192]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1211]: MA::Controller.impl
P [159] <<(e-SR) <= s and DSPV2() and SBL() and r^0>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1199]


This Proof Obligation:

[serial 1203]: MA::Controller.impl
P [154] <<POSITION = s and (DSPV2() and SBL())>>
S [154]->
Q [154] <<POSITION = s>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1194]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1212]: MA::Controller.impl
P [154] <<DSPV2() and SBL() and POSITION = s>>
S [154]->
Q [154] <<POSITION = s>>
  What for: Associativity: (b.c).a = a.b.c [serial 1203]


This Proof Obligation:

[serial 1205]: MA::Controller.impl
P [154] <<VELOCITY = v and (DSPV2() and SBL())>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1195]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1213]: MA::Controller.impl
P [154] <<DSPV2() and SBL() and VELOCITY = v>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1205]

. . . done Applying Laws [20.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1197]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]->
Q [1] <<(e-SR) <= s or CTCS_Properties::start = s>>
  What for:   normalization of [serial 1191]



[serial 1201]: MA::Controller.impl
P [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
S [154]->
Q [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
  What for:   normalization of [serial 1188]



[serial 1211]: MA::Controller.impl
P [159] <<(e-SR) <= s and DSPV2() and SBL() and r^0>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1199]



[serial 1212]: MA::Controller.impl
P [154] <<DSPV2() and SBL() and POSITION = s>>
S [154]->
Q [154] <<POSITION = s>>
  What for: Associativity: (b.c).a = a.b.c [serial 1203]



[serial 1213]: MA::Controller.impl
P [154] <<DSPV2() and SBL() and VELOCITY = v>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1205]


Done applying laws
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 (e-SR) <= s


This Proof Obligation:

[serial 1197]: MA::Controller.impl
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159]->
Q [1] <<(e-SR) <= s or CTCS_Properties::start = s>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for:   normalization of [serial 1191]

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1201]: MA::Controller.impl
P [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
S [154]->
Q [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1188]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1211]: MA::Controller.impl
P [159] <<(e-SR) <= s and DSPV2() and SBL() and r^0>>
S [159]->
Q [160] <<DSPV2() and SBL()>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Associativity: (b.c).a = a.b.c [serial 1199]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1212]: MA::Controller.impl
P [154] <<DSPV2() and SBL() and POSITION = s>>
S [154]->
Q [154] <<POSITION = s>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 1203]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1213]: MA::Controller.impl
P [154] <<DSPV2() and SBL() and VELOCITY = v>>
S [154]->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Associativity: (b.c).a = a.b.c [serial 1205]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [20.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1015]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [174]<<not SBL() or not DSPV2()>>
ca!(CTCS_Properties::SB_Rate)
;
<<not SBL() or not DSPV2()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not SBL() or not DSPV2())^1>>
Q [126] <<(not SBL() or not DSPV2())^1>>
  What for:  <<M(CMF) and x>> A <<M(SBI)>> for T4_SBI_Point:CMF-[x]->SBI{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1015]  <<M(CMF) and x>> A <<M(SBI)>> for T4_SBI_Point:CMF-[x]->SBI{A};
****reduce****
This proof obligation:

[serial 1015]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [174]<<not SBL() or not DSPV2()>>
ca!(CTCS_Properties::SB_Rate)
;
<<not SBL() or not DSPV2()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not SBL() or not DSPV2())^1>>
Q [126] <<(not SBL() or not DSPV2())^1>>
  What for:  <<M(CMF) and x>> A <<M(SBI)>> for T4_SBI_Point:CMF-[x]->SBI{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1214]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [125]->
Q [174] <<not SBL() or not DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1015]


[serial 1215]: MA::Controller.impl
P [176] <<(not SBL() or not DSPV2())^1>>
S [126]->
Q [91] <<(not SBL() or not DSPV2())^1>>
  What for: Q1 -> Q in sequential composition for [serial 1015]


[serial 1216]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [174]ca!(CTCS_Properties::SB_Rate)
Q [174] <<not SBL() or not DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]


[serial 1217]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not SBL() or not DSPV2())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1214]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [125]->
Q [174] <<not SBL() or not DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1015]



[serial 1215]: MA::Controller.impl
P [176] <<(not SBL() or not DSPV2())^1>>
S [126]->
Q [91] <<(not SBL() or not DSPV2())^1>>
  What for: Q1 -> Q in sequential composition for [serial 1015]



[serial 1216]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [174]ca!(CTCS_Properties::SB_Rate)
Q [174] <<not SBL() or not DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]



[serial 1217]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not SBL() or not DSPV2())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1215]: MA::Controller.impl
P [176] <<(not SBL() or not DSPV2())^1>>
S [126]->
Q [91] <<(not SBL() or not DSPV2())^1>>
Reason:  Identity (id):  P->P is tautology
  What for: Q1 -> Q in sequential composition for [serial 1015]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [21.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1214]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [125]->
Q [174] <<not SBL() or not DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1015]



[serial 1216]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [174]ca!(CTCS_Properties::SB_Rate)
Q [174] <<not SBL() or not DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]



[serial 1217]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not SBL() or not DSPV2())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]


Done trying to apply axioms
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
****make-an****
Making obligation 13
Obligations:

[serial 1214]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [125]->
Q [174] <<not SBL() or not DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1015]


Done making obligation 13
#MA::Controller.impl
#[serial 1182] P -> P1 in sequential composition for [serial 1015]
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1214]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [125]->
Q [174] <<not SBL() or not DSPV2()>>
Reason:  Substitution of Assertion Labels
  What for: P -> P1 in sequential composition for [serial 1015]

Has substituted Assertions' predicates for labels to get:

[serial 1218]: MA::Controller.impl
P [125] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [125]->
Q [174] <<not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
  What for: substituted Assertions' predicates for  labels  [serial 1214]

. . . done Substituting Assertions for Labels [21.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1218]: MA::Controller.impl
P [125] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [125]->
Q [174] <<not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1214]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1220]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [125]->
Q [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1218]

. . . done Normalizing Unsolved Proof Obligations [21.2 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1220]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [125]->
Q [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1218]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [21.2 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [21.2 seconds ]
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1220]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [125]->
Q [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1218]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1216]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [174]ca!(CTCS_Properties::SB_Rate)
Q [174] <<not SBL() or not DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1184] <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[192] ^(LABEL Acceleration ) ^(CONDITIONAL_FUNCTION[101] ^(-> ^(( ^(INVOKE[101] NOCHANGE ) ) ) 0 ) ^(-> ^(( ^(or ^(not ^(INVOKE[102] SBL ) ) ^(not ^(INVOKE[102] DSPV2 ) ) ) ) ) ^(:: CTCS_Properties SB_Rate ) ) ^(-> ^(( ^(or ^(not ^(INVOKE[103] EBL ) ) ^(not ^(INVOKE[103] DSPV1 ) ) ) ) ) ^(- b ) ) ^(-> ^(( ^(and ^(INVOKE[104] SBL ) ^(INVOKE[104] DSPV2 ) ) ) ) xl ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  (NOCHANGE()) -> 0, (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate, 
  (not EBL() or not DSPV1()) ->  -b, (SBL() and DSPV2()) -> xl
Thread "Controller.impl" has Dispatch_Protocol property Periodic

This Proof Obligation:

[serial 1216]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [174]ca!(CTCS_Properties::SB_Rate)
Q [174] <<not SBL() or not DSPV2()>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]

Has applied <<pre and (ca=CTCS_Properties::SB_Rate)^0>> -> <<post>> for  <<pre>> ca!(::) <<post>> to get:

[serial 1223]: MA::Controller.impl
P [174] <<(not SBL() or not DSPV2())
  and
  (ca = (CTCS_Properties::SB_Rate))^0>>
S [174]->
Q [174] <<not SBL() or not DSPV2()>>
  What for: applied port output <<pre and (ca=CTCS_Properties::SB_Rate)^0>> -> <<post>> [serial 1216]

Has applied port output of conditional expression <<pre>> -> <<(not SBL() or not DSPV2())>>where (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate for ca!(CTCS_Properties::SB_Rate) to get:

[serial 1224]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [174]->
Q [102] <<(not SBL() or not DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(not SBL() or not DSPV2())>> where (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate for ca!(CTCS_Properties::SB_Rate) 
[serial 1216]

. . . done applying atomic actions [21.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1223]: MA::Controller.impl
P [174] <<(not SBL() or not DSPV2())
  and
  (ca = (CTCS_Properties::SB_Rate))^0>>
S [174]->
Q [174] <<not SBL() or not DSPV2()>>
  What for: applied port output <<pre and (ca=CTCS_Properties::SB_Rate)^0>> -> <<post>> [serial 1216]



[serial 1224]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [174]->
Q [102] <<(not SBL() or not DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(not SBL() or not DSPV2())>> where (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate for ca!(CTCS_Properties::SB_Rate) 
[serial 1216]


Done reducing atomic actions
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1223]: MA::Controller.impl
P [174] <<(not SBL() or not DSPV2())
  and
  (ca = (CTCS_Properties::SB_Rate))^0>>
S [174]->
Q [174] <<not SBL() or not DSPV2()>>
Reason:  Assume Present:  P = P@now = P^0 
  What for: applied port output <<pre and (ca=CTCS_Properties::SB_Rate)^0>> -> <<post>> [serial 1216]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1225]: MA::Controller.impl
P [174] <<CTCS_Properties::SB_Rate = ca and (not DSPV2() or not SBL())>>
S [174]->
Q [174] <<not DSPV2() or not SBL()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1223]

. . . done replacing P@now and P^0 with P  [21.3 seconds ]
After assuming present remaining 
Obligations:

[serial 1224]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [174]->
Q [102] <<(not SBL() or not DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(not SBL() or not DSPV2())>> where (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate for ca!(CTCS_Properties::SB_Rate) 
[serial 1216]



[serial 1225]: MA::Controller.impl
P [174] <<CTCS_Properties::SB_Rate = ca and (not DSPV2() or not SBL())>>
S [174]->
Q [174] <<not DSPV2() or not SBL()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1223]


Done assuming present.
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1224]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [174]->
Q [102] <<(not SBL() or not DSPV2())>>
Reason:  Normalization
  What for: applied port output of conditional expression <<pre>> -> <<(not SBL() or not DSPV2())>> where (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate for ca!(CTCS_Properties::SB_Rate) 
[serial 1216]

  Normalization Axioms:

    Reflexivity of Disjunction: (m or k) = (k or m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1227]: MA::Controller.impl
P [174] <<not DSPV2() or not SBL()>>
S [174]->
Q [102] <<not DSPV2() or not SBL()>>
  What for:   normalization of [serial 1224]

. . . done Normalizing Unsolved Proof Obligations [21.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1225]: MA::Controller.impl
P [174] <<CTCS_Properties::SB_Rate = ca and (not DSPV2() or not SBL())>>
S [174]->
Q [174] <<not DSPV2() or not SBL()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1223]



[serial 1227]: MA::Controller.impl
P [174] <<not DSPV2() or not SBL()>>
S [174]->
Q [102] <<not DSPV2() or not SBL()>>
  What for:   normalization of [serial 1224]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1225]: MA::Controller.impl
P [174] <<CTCS_Properties::SB_Rate = ca and (not DSPV2() or not SBL())>>
S [174]->
Q [174] <<not DSPV2() or not SBL()>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Assume Present:  P = P@now = P^0  [serial 1223]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1227]: MA::Controller.impl
P [174] <<not DSPV2() or not SBL()>>
S [174]->
Q [102] <<not DSPV2() or not SBL()>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1224]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1217]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not SBL() or not DSPV2())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1185] <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1217]: MA::Controller.impl
P [174] <<not SBL() or not DSPV2()>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not SBL() or not DSPV2())^1>>
Reason:  Substitution of Assertion Labels
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]

Has substituted Assertions' predicates for labels to get:

[serial 1230]: MA::Controller.impl
P [174] <<not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
  What for: substituted Assertions' predicates for  labels  [serial 1217]

. . . done Substituting Assertions for Labels [21.3 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1230]: MA::Controller.impl
P [174] <<not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1217]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1232]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1230]

. . . done Normalizing Unsolved Proof Obligations [21.3 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1232]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1230]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [21.4 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [21.4 seconds ]
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1232]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1230]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1235]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<((not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1232]

. . . done spltting timed atoms  [21.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.4 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1235]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<((not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1232]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1237]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1235]

. . . done Normalizing Unsolved Proof Obligations [21.5 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1237]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1235]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1237]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1235]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1239]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not ((CTCS_Properties::start = s or v < iSeg.v2))^1
or not ((CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1237]

. . . done spltting timed atoms  [21.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1239]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not ((CTCS_Properties::start = s or v < iSeg.v2))^1
or not ((CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1237]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1241]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)^1
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1239]

. . . done Normalizing Unsolved Proof Obligations [21.6 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1241]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)^1
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1239]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 1241]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)^1
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1239]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1243]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not ((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
or not ((CTCS_Properties::start = s)^1
or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1241]

. . . done spltting timed atoms  [21.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.6 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [21.6 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 1243]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not ((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
or not ((CTCS_Properties::start = s)^1
or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1241]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 1243]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not ((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
or not ((CTCS_Properties::start = s)^1
or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1241]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1245]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (((CTCS_Properties::start)^1 = (s)^1)
or ((v)^1 < (iSeg.v2)^1))
or not (((CTCS_Properties::start)^1 = (s)^1)
or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1243]

. . . done spltting timed atoms  [21.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.7 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1245]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (((CTCS_Properties::start)^1 = (s)^1)
or ((v)^1 < (iSeg.v2)^1))
or not (((CTCS_Properties::start)^1 = (s)^1)
or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1243]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1247]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1245]

. . . done Normalizing Unsolved Proof Obligations [21.7 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 1247]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1245]


Done completely distributing ^ and @, round 3.
Distributing carets . .

This Proof Obligation:

[serial 1247]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1245]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1249]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1247]

. . . done spltting timed atoms  [21.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.8 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1249]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1247]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1251]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1249]

. . . done Normalizing Unsolved Proof Obligations [21.8 seconds ]
After "completely distribute ^ and @" round 4 remaining 
Obligations:

[serial 1251]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1249]


Done completely distributing ^ and @, round 4.
Distributing carets . .

This Proof Obligation:

[serial 1251]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1249]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1253]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
(iSeg.e)^1)))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1251]

. . . done spltting timed atoms  [21.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1253]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
(iSeg.e)^1)))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1251]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1255]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1253]

. . . done Normalizing Unsolved Proof Obligations [21.9 seconds ]
After "completely distribute ^ and @" round 5 remaining 
Obligations:

[serial 1255]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1253]


Done completely distributing ^ and @, round 5.
Distributing carets . .
. . . done spltting timed atoms  [21.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.9 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [21.9 seconds ]
****atomic****
applying atomic actions . . .
solving assignment on line 175
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iSeg'" with "iSeg"
makes:  <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "v^1" with "v"
makes:  <<not (s^1 = CTCS_Properties::start or v < iSeg.v2)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "s^1" with "s"
makes:  <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b^1*s*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "b^1" with "b"
makes:  <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]^1+(b*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iMA'" with "iMA"
makes:  <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>

This Proof Obligation:

[serial 1255]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1253]

Has applied simultaneous assignmnet to get:

[serial 1258]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1255]

. . . done applying atomic actions [22.0 seconds ]
After "atomic" remaining 
Obligations:

[serial 1258]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1255]



[serial 1258]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1255]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1258]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1255]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1260]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1258]


This Proof Obligation:

[serial 1258]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1255]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1262]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1258]

. . . done Normalizing Unsolved Proof Obligations [22.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1260]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1258]



[serial 1262]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1258]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1260]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1258]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1262]: MA::Controller.impl
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175]->
Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1258]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [22.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1016]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [181]<<SBL() and DSPV2()>>
ca!(xl)
;
<<SBL() and DSPV2()>>
( --begining of simultaneous assignment
 i,
 iSeg,
 nSeg
:=
 i+1,
 nSeg,
 iMA[i+2]
) --end of simultaneous assignment

;
<<SBL() and DSPV2()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(SBL() and DSPV2())^1>>
Q [124] <<(SBL() and DSPV2())^1>>
  What for:  <<M(CMF) and x>> A <<M(MFR)>> for T5_Move_Ok:CMF-[x]->MFR{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1016]  <<M(CMF) and x>> A <<M(MFR)>> for T5_Move_Ok:CMF-[x]->MFR{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [22.1 seconds ]
After applying axioms, no change 
****reduce****
This proof obligation:

[serial 1016]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [181]<<SBL() and DSPV2()>>
ca!(xl)
;
<<SBL() and DSPV2()>>
( --begining of simultaneous assignment
 i,
 iSeg,
 nSeg
:=
 i+1,
 nSeg,
 iMA[i+2]
) --end of simultaneous assignment

;
<<SBL() and DSPV2()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(SBL() and DSPV2())^1>>
Q [124] <<(SBL() and DSPV2())^1>>
  What for:  <<M(CMF) and x>> A <<M(MFR)>> for T5_Move_Ok:CMF-[x]->MFR{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 1265]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [125]->
Q [181] <<SBL() and DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1016]


[serial 1266]: MA::Controller.impl
P [183] <<(SBL() and DSPV2())^1>>
S [124]->
Q [91] <<(SBL() and DSPV2())^1>>
  What for: Q2 -> Q in sequential composition for [serial 1016]


[serial 1267]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]ca!(xl)
Q [181] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]


[serial 1268]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]( --begining of simultaneous assignment
 i,
 iSeg,
 nSeg
:=
 i+1,
 nSeg,
 iMA[i+2]
) --end of simultaneous assignment

Q [182] <<SBL() and DSPV2()>>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]


[serial 1269]: MA::Controller.impl
P [182] <<SBL() and DSPV2()>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(SBL() and DSPV2())^1>>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1016]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1265]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [125]->
Q [181] <<SBL() and DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1016]



[serial 1266]: MA::Controller.impl
P [183] <<(SBL() and DSPV2())^1>>
S [124]->
Q [91] <<(SBL() and DSPV2())^1>>
  What for: Q2 -> Q in sequential composition for [serial 1016]



[serial 1267]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]ca!(xl)
Q [181] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]



[serial 1268]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]( --begining of simultaneous assignment
 i,
 iSeg,
 nSeg
:=
 i+1,
 nSeg,
 iMA[i+2]
) --end of simultaneous assignment

Q [182] <<SBL() and DSPV2()>>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]



[serial 1269]: MA::Controller.impl
P [182] <<SBL() and DSPV2()>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(SBL() and DSPV2())^1>>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1016]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1265]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [125]->
Q [181] <<SBL() and DSPV2()>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: P -> P1 in sequential composition for [serial 1016]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1266]: MA::Controller.impl
P [183] <<(SBL() and DSPV2())^1>>
S [124]->
Q [91] <<(SBL() and DSPV2())^1>>
Reason:  Identity (id):  P->P is tautology
  What for: Q2 -> Q in sequential composition for [serial 1016]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [22.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1267]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]ca!(xl)
Q [181] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]



[serial 1268]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]( --begining of simultaneous assignment
 i,
 iSeg,
 nSeg
:=
 i+1,
 nSeg,
 iMA[i+2]
) --end of simultaneous assignment

Q [182] <<SBL() and DSPV2()>>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]



[serial 1269]: MA::Controller.impl
P [182] <<SBL() and DSPV2()>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(SBL() and DSPV2())^1>>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1016]


Done trying to apply axioms
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
****make-an****
Making obligation 17
Obligations:

[serial 1267]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]ca!(xl)
Q [181] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]


Done making obligation 17
#MA::Controller.impl
#[serial 1239] <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[192] ^(LABEL Acceleration ) ^(CONDITIONAL_FUNCTION[101] ^(-> ^(( ^(INVOKE[101] NOCHANGE ) ) ) 0 ) ^(-> ^(( ^(or ^(not ^(INVOKE[102] SBL ) ) ^(not ^(INVOKE[102] DSPV2 ) ) ) ) ) ^(:: CTCS_Properties SB_Rate ) ) ^(-> ^(( ^(or ^(not ^(INVOKE[103] EBL ) ) ^(not ^(INVOKE[103] DSPV1 ) ) ) ) ) ^(- b ) ) ^(-> ^(( ^(and ^(INVOKE[104] SBL ) ^(INVOKE[104] DSPV2 ) ) ) ) xl ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  (NOCHANGE()) -> 0, (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate, 
  (not EBL() or not DSPV1()) ->  -b, (SBL() and DSPV2()) -> xl
Thread "Controller.impl" has Dispatch_Protocol property Periodic

This Proof Obligation:

[serial 1267]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]ca!(xl)
Q [181] <<SBL() and DSPV2()>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]

Has applied <<pre and (ca=xl)^0>> -> <<post>> for  <<pre>> ca!(xl) <<post>> to get:

[serial 1270]: MA::Controller.impl
P [181] <<(SBL() and DSPV2()) and (ca = xl)^0>>
S [181]->
Q [181] <<SBL() and DSPV2()>>
  What for: applied port output <<pre and (ca=xl)^0>> -> <<post>> [serial 1267]

Has applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>>where (SBL() and DSPV2()) -> xl for ca!(xl) to get:

[serial 1271]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]->
Q [104] <<(SBL() and DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1267]

. . . done applying atomic actions [22.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1270]: MA::Controller.impl
P [181] <<(SBL() and DSPV2()) and (ca = xl)^0>>
S [181]->
Q [181] <<SBL() and DSPV2()>>
  What for: applied port output <<pre and (ca=xl)^0>> -> <<post>> [serial 1267]



[serial 1271]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]->
Q [104] <<(SBL() and DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1267]


Done reducing atomic actions
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1270]: MA::Controller.impl
P [181] <<(SBL() and DSPV2()) and (ca = xl)^0>>
S [181]->
Q [181] <<SBL() and DSPV2()>>
Reason:  Assume Present:  P = P@now = P^0 
  What for: applied port output <<pre and (ca=xl)^0>> -> <<post>> [serial 1267]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1272]: MA::Controller.impl
P [181] <<ca = xl and (DSPV2() and SBL())>>
S [181]->
Q [181] <<DSPV2() and SBL()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1270]

. . . done replacing P@now and P^0 with P  [22.2 seconds ]
After assuming present remaining 
Obligations:

[serial 1271]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]->
Q [104] <<(SBL() and DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1267]



[serial 1272]: MA::Controller.impl
P [181] <<ca = xl and (DSPV2() and SBL())>>
S [181]->
Q [181] <<DSPV2() and SBL()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1270]


Done assuming present.
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1272]: MA::Controller.impl
P [181] <<ca = xl and (DSPV2() and SBL())>>
S [181]->
Q [181] <<DSPV2() and SBL()>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Assume Present:  P = P@now = P^0  [serial 1270]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [22.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1271]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]->
Q [104] <<(SBL() and DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1267]


Done trying to apply axioms
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1271]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [181]->
Q [104] <<(SBL() and DSPV2())>>
Reason:  Normalization
  What for: applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1267]

  Normalization Axioms:

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1274]: MA::Controller.impl
P [181] <<DSPV2() and SBL()>>
S [181]->
Q [104] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1271]

. . . done Normalizing Unsolved Proof Obligations [22.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1274]: MA::Controller.impl
P [181] <<DSPV2() and SBL()>>
S [181]->
Q [104] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1271]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1274]: MA::Controller.impl
P [181] <<DSPV2() and SBL()>>
S [181]->
Q [104] <<DSPV2() and SBL()>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1271]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [22.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1268]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]( --begining of simultaneous assignment
 i,
 iSeg,
 nSeg
:=
 i+1,
 nSeg,
 iMA[i+2]
) --end of simultaneous assignment

Q [182] <<SBL() and DSPV2()>>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1240] <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
****atomic****
applying atomic actions . . .
solving assignment on line 182
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic

This Proof Obligation:

[serial 1268]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]( --begining of simultaneous assignment
 i,
 iSeg,
 nSeg
:=
 i+1,
 nSeg,
 iMA[i+2]
) --end of simultaneous assignment

Q [182] <<SBL() and DSPV2()>>
Reason:  Simultaneous Assignment
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

Has applied simultaneous assignmnet to get:

[serial 1276]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]->
Q [182] <<SBL() and DSPV2()>>
  What for: applied wp for simultaneous assignment [serial 1268]

. . . done applying atomic actions [22.3 seconds ]
After "atomic" remaining 
Obligations:

[serial 1276]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]->
Q [182] <<SBL() and DSPV2()>>
  What for: applied wp for simultaneous assignment [serial 1268]



[serial 1276]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]->
Q [182] <<SBL() and DSPV2()>>
  What for: applied wp for simultaneous assignment [serial 1268]


Done reducing atomic actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1276]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]->
Q [182] <<SBL() and DSPV2()>>
Reason:  Identity (id):  P->P is tautology
  What for: applied wp for simultaneous assignment [serial 1268]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1276]: MA::Controller.impl
P [181] <<SBL() and DSPV2()>>
S [182]->
Q [182] <<SBL() and DSPV2()>>
Reason:  Identity (id):  P->P is tautology
  What for: applied wp for simultaneous assignment [serial 1268]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [22.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1269]: MA::Controller.impl
P [182] <<SBL() and DSPV2()>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(SBL() and DSPV2())^1>>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1016]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1241] <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1016]
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1269]: MA::Controller.impl
P [182] <<SBL() and DSPV2()>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(SBL() and DSPV2())^1>>
Reason:  Substitution of Assertion Labels
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1016]

Has substituted Assertions' predicates for labels to get:

[serial 1277]: MA::Controller.impl
P [182] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
  What for: substituted Assertions' predicates for  labels  [serial 1269]

. . . done Substituting Assertions for Labels [22.3 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1277]: MA::Controller.impl
P [182] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1269]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1279]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1277]

. . . done Normalizing Unsolved Proof Obligations [22.3 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1279]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1277]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [22.3 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [22.3 seconds ]
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1279]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1277]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1282]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1279]

. . . done spltting timed atoms  [22.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.4 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1282]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1279]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1284]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1282]

. . . done Normalizing Unsolved Proof Obligations [22.4 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1284]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1282]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1284]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1282]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1286]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1284]

. . . done spltting timed atoms  [22.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.5 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [22.5 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1286]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1284]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 1286]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1284]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1288]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(((CTCS_Properties::start)^1 = (s)^1)
  or ((v)^1 < (iSeg.v2)^1))
  and
  (((CTCS_Properties::start)^1 = (s)^1)
  or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1286]

. . . done spltting timed atoms  [22.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.5 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1288]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(((CTCS_Properties::start)^1 = (s)^1)
  or ((v)^1 < (iSeg.v2)^1))
  and
  (((CTCS_Properties::start)^1 = (s)^1)
  or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1286]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1290]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1288]

. . . done Normalizing Unsolved Proof Obligations [22.6 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 1290]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1288]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 1290]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1288]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1292]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1290]

. . . done spltting timed atoms  [22.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.7 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1292]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1290]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1294]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1292]

. . . done Normalizing Unsolved Proof Obligations [22.7 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 1294]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1292]


Done completely distributing ^ and @, round 3.
Distributing carets . .

This Proof Obligation:

[serial 1294]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1292]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1296]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
  (iSeg.e)^1)))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1294]

. . . done spltting timed atoms  [22.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.8 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1296]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
  (iSeg.e)^1)))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1294]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1298]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1296]

. . . done Normalizing Unsolved Proof Obligations [22.8 seconds ]
After "completely distribute ^ and @" round 4 remaining 
Obligations:

[serial 1298]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1296]


Done completely distributing ^ and @, round 4.
Distributing carets . .
. . . done spltting timed atoms  [22.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.8 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [22.8 seconds ]
****atomic****
applying atomic actions . . .
solving assignment on line 183
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iSeg'" with "iSeg"
makes:  <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "v^1" with "v"
makes:  <<(s^1 = CTCS_Properties::start or v < iSeg.v2)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "s^1" with "s"
makes:  <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b^1*s*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "b^1" with "b"
makes:  <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]^1+(b*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iMA'" with "iMA"
makes:  <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>

This Proof Obligation:

[serial 1298]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1296]

Has applied simultaneous assignmnet to get:

[serial 1301]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1298]

. . . done applying atomic actions [22.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 1301]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1298]



[serial 1301]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1298]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1301]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1298]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1303]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1301]


This Proof Obligation:

[serial 1301]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1298]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1305]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1301]

. . . done Normalizing Unsolved Proof Obligations [23.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1303]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1301]



[serial 1305]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1301]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1303]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1301]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1305]: MA::Controller.impl
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183]->
Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1301]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [23.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1017]: MA::Controller.impl
P [126] <<not SBL() or not DSPV2()>>
S [188]{
 <<not SBL() or not DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
} 
Q [127] <<not SBL() or not DSPV2()>>
  What for:  <<M(SBI) and x>> A <<M(CSB)>> for T6_SBI_Check:SBI-[x]->CSB{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1017]  <<M(SBI) and x>> A <<M(CSB)>> for T6_SBI_Check:SBI-[x]->CSB{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [23.1 seconds ]
After applying axioms, no change 
****reduce****

[serial 1308]: MA::Controller.impl
P [126] <<not SBL() or not DSPV2()>>
S [188]{
 <<not SBL() or not DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
} 
Q [127] <<not SBL() or not DSPV2()>>
  What for: as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1017]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1308]: MA::Controller.impl
P [126] <<not SBL() or not DSPV2()>>
S [188]{
 <<not SBL() or not DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
} 
Q [127] <<not SBL() or not DSPV2()>>
  What for: as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1017]


done reducing composite actions
****reduce****
Reducing Existential Quantification of:

[serial 1308]: MA::Controller.impl
P [126] <<not SBL() or not DSPV2()>>
S [188]{
 <<not SBL() or not DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
} 
Q [127] <<not SBL() or not DSPV2()>>
Reason:  Introduction of Existential Quantification (bl.elq)
  What for: as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1017]

as this
			<<P and x=e>> -> <<A>>
			<<A>> T <<B>> 
 		<<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable x:t:=e; { <<A>> T <<B>> } <<Q>>
begat these:

[serial 1309]: MA::Controller.impl
P [126] <<not SBL() or not DSPV2()>>
S [188]->
Q [188] <<not SBL() or not DSPV2()>>
  What for: <<P and x=e>> -> <<A>> in existential lattice quantification for [serial 1308]


[serial 1310]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]<<not SBL() or not DSPV2()>>
cs?(s)
<<s = POSITION>>
&
cv?(v)
<<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
  What for: {A} T {B} in existential lattice quantification for [serial 1308]


[serial 1311]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
S [188]->
Q [127] <<not SBL() or not DSPV2()>>
  What for: <<B>> -> <<Q>> in existential lattice quantification for [serial 1308]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1309]: MA::Controller.impl
P [126] <<not SBL() or not DSPV2()>>
S [188]->
Q [188] <<not SBL() or not DSPV2()>>
  What for: <<P and x=e>> -> <<A>> in existential lattice quantification for [serial 1308]



[serial 1310]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]<<not SBL() or not DSPV2()>>
cs?(s)
<<s = POSITION>>
&
cv?(v)
<<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
  What for: {A} T {B} in existential lattice quantification for [serial 1308]



[serial 1311]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
S [188]->
Q [127] <<not SBL() or not DSPV2()>>
  What for: <<B>> -> <<Q>> in existential lattice quantification for [serial 1308]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1309]: MA::Controller.impl
P [126] <<not SBL() or not DSPV2()>>
S [188]->
Q [188] <<not SBL() or not DSPV2()>>
Reason:  Identity (id):  P->P is tautology
  What for: <<P and x=e>> -> <<A>> in existential lattice quantification for [serial 1308]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [23.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1310]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]<<not SBL() or not DSPV2()>>
cs?(s)
<<s = POSITION>>
&
cv?(v)
<<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
  What for: {A} T {B} in existential lattice quantification for [serial 1308]



[serial 1311]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
S [188]->
Q [127] <<not SBL() or not DSPV2()>>
  What for: <<B>> -> <<Q>> in existential lattice quantification for [serial 1308]


Done trying to apply axioms
****reduce****

Reducing Concurrent Computation of:

[serial 1310]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]<<not SBL() or not DSPV2()>>
cs?(s)
<<s = POSITION>>
&
cv?(v)
<<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
Reason:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>> (bl.cck)
  What for: {A} T {B} in existential lattice quantification for [serial 1308]

To:

[serial 1312]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [188]->
Q [188] <<not SBL() or not DSPV2()>>
  What for: P -> P1 in concurrent composition for [serial 1310]


[serial 1313]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()))
  and
  ((v = VELOCITY))>>
S [189]->
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
  What for: Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1310]


[serial 1314]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]cs?(s)
Q [189] <<s = POSITION>>
  What for: <<P1>> S1 <<Q1>> in concurrent composition for [serial 1310]


[serial 1315]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]cv?(v)
Q [190] <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
  What for: <<P>> S2 <<Q2>> in concurrent composition for [serial 1310]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1312]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [188]->
Q [188] <<not SBL() or not DSPV2()>>
  What for: P -> P1 in concurrent composition for [serial 1310]



[serial 1313]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()))
  and
  ((v = VELOCITY))>>
S [189]->
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
  What for: Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1310]



[serial 1314]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]cs?(s)
Q [189] <<s = POSITION>>
  What for: <<P1>> S1 <<Q1>> in concurrent composition for [serial 1310]



[serial 1315]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]cv?(v)
Q [190] <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
  What for: <<P>> S2 <<Q2>> in concurrent composition for [serial 1310]



[serial 1311]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
S [188]->
Q [127] <<not SBL() or not DSPV2()>>
  What for: <<B>> -> <<Q>> in existential lattice quantification for [serial 1308]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1312]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [188]->
Q [188] <<not SBL() or not DSPV2()>>
Reason:  Identity (id):  P->P is tautology
  What for: P -> P1 in concurrent composition for [serial 1310]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [23.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1313]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()))
  and
  ((v = VELOCITY))>>
S [189]->
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
  What for: Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1310]



[serial 1314]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]cs?(s)
Q [189] <<s = POSITION>>
  What for: <<P1>> S1 <<Q1>> in concurrent composition for [serial 1310]



[serial 1315]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]cv?(v)
Q [190] <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
  What for: <<P>> S2 <<Q2>> in concurrent composition for [serial 1310]



[serial 1311]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
S [188]->
Q [127] <<not SBL() or not DSPV2()>>
  What for: <<B>> -> <<Q>> in existential lattice quantification for [serial 1308]


Done trying to apply axioms
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1313]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()))
  and
  ((v = VELOCITY))>>
S [189]->
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
Reason:  Normalization
  What for: Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1310]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1317]: MA::Controller.impl
P [189] <<POSITION = s and VELOCITY = v and (not DSPV2() or not SBL())>>
S [189]->
Q [189] <<POSITION = s and (VELOCITY = v and (not DSPV2() or not SBL()))>>
  What for:   normalization of [serial 1313]


This Proof Obligation:

[serial 1314]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]cs?(s)
Q [189] <<s = POSITION>>
Reason:  Normalization
  What for: <<P1>> S1 <<Q1>> in concurrent composition for [serial 1310]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1319]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cs?(s)
Q [189] <<POSITION = s>>
  What for:   normalization of [serial 1314]


This Proof Obligation:

[serial 1315]: MA::Controller.impl
P [188] <<not SBL() or not DSPV2()>>
S [189]cv?(v)
Q [190] <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
Reason:  Normalization
  What for: <<P>> S2 <<Q2>> in concurrent composition for [serial 1310]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1321]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cv?(v)
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
  What for:   normalization of [serial 1315]


This Proof Obligation:

[serial 1311]: MA::Controller.impl
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
S [188]->
Q [127] <<not SBL() or not DSPV2()>>
Reason:  Normalization
  What for: <<B>> -> <<Q>> in existential lattice quantification for [serial 1308]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1323]: MA::Controller.impl
P [189] <<POSITION = s and (VELOCITY = v and (not DSPV2() or not SBL()))>>
S [188]->
Q [127] <<not DSPV2() or not SBL()>>
  What for:   normalization of [serial 1311]

. . . done Normalizing Unsolved Proof Obligations [23.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1317]: MA::Controller.impl
P [189] <<POSITION = s and VELOCITY = v and (not DSPV2() or not SBL())>>
S [189]->
Q [189] <<POSITION = s and (VELOCITY = v and (not DSPV2() or not SBL()))>>
  What for:   normalization of [serial 1313]



[serial 1319]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cs?(s)
Q [189] <<POSITION = s>>
  What for:   normalization of [serial 1314]



[serial 1321]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cv?(v)
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
  What for:   normalization of [serial 1315]



[serial 1323]: MA::Controller.impl
P [189] <<POSITION = s and (VELOCITY = v and (not DSPV2() or not SBL()))>>
S [188]->
Q [127] <<not DSPV2() or not SBL()>>
  What for:   normalization of [serial 1311]


Done Normalizing
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1317]: MA::Controller.impl
P [189] <<POSITION = s and VELOCITY = v and (not DSPV2() or not SBL())>>
S [189]->
Q [189] <<POSITION = s and (VELOCITY = v and (not DSPV2() or not SBL()))>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1313]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1328]: MA::Controller.impl
P [189] <<POSITION = s and VELOCITY = v and (not DSPV2() or not SBL())>>
S [189]->
Q [189] <<VELOCITY = v and (not DSPV2() or not SBL()) and POSITION = s>>
  What for: Associativity: (b.c).a = a.b.c [serial 1317]


This Proof Obligation:

[serial 1323]: MA::Controller.impl
P [189] <<POSITION = s and (VELOCITY = v and (not DSPV2() or not SBL()))>>
S [188]->
Q [127] <<not DSPV2() or not SBL()>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1311]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1329]: MA::Controller.impl
P [189] <<VELOCITY = v and (not DSPV2() or not SBL()) and POSITION = s>>
S [188]->
Q [127] <<not DSPV2() or not SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1323]

. . . done Applying Laws [23.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1319]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cs?(s)
Q [189] <<POSITION = s>>
  What for:   normalization of [serial 1314]



[serial 1321]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cv?(v)
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
  What for:   normalization of [serial 1315]



[serial 1328]: MA::Controller.impl
P [189] <<POSITION = s and VELOCITY = v and (not DSPV2() or not SBL())>>
S [189]->
Q [189] <<VELOCITY = v and (not DSPV2() or not SBL()) and POSITION = s>>
  What for: Associativity: (b.c).a = a.b.c [serial 1317]



[serial 1329]: MA::Controller.impl
P [189] <<VELOCITY = v and (not DSPV2() or not SBL()) and POSITION = s>>
S [188]->
Q [127] <<not DSPV2() or not SBL()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1323]


Done applying laws
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1328]: MA::Controller.impl
P [189] <<POSITION = s and VELOCITY = v and (not DSPV2() or not SBL())>>
S [189]->
Q [189] <<VELOCITY = v and (not DSPV2() or not SBL()) and POSITION = s>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Associativity: (b.c).a = a.b.c [serial 1317]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1329]: MA::Controller.impl
P [189] <<VELOCITY = v and (not DSPV2() or not SBL()) and POSITION = s>>
S [188]->
Q [127] <<not DSPV2() or not SBL()>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 1323]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1319]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cs?(s)
Q [189] <<POSITION = s>>
  What for:   normalization of [serial 1314]



[serial 1321]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cv?(v)
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
  What for:   normalization of [serial 1315]


Done trying to apply axioms
****atomic****
applying atomic actions . . .
portInAnd=^(and ^(( ^(or ^(not ^(INVOKE[188] DSPV2 ) ) ^(not ^(INVOKE[188] SBL ) ) ) ) ) ^(= s POSITION ) )

This Proof Obligation:

[serial 1319]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cs?(s)
Q [189] <<POSITION = s>>
Reason:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
  What for:   normalization of [serial 1314]

Has applied when <<pre and v=M(cs)>> -> <<post>> for <<pre>> cs?(s) <<post>> to get:

[serial 1330]: MA::Controller.impl
P [189] <<(not DSPV2() or not SBL()) and s = POSITION>>
S [189]->
Q [189] <<POSITION = s>>
  What for: applied port input of value <<pre and s=M(cs)>> -> <<post>> [serial 1319]

portInAnd=^(and ^(( ^(or ^(not ^(INVOKE[188] DSPV2 ) ) ^(not ^(INVOKE[188] SBL ) ) ) ) ) ^(= v VELOCITY ) )

This Proof Obligation:

[serial 1321]: MA::Controller.impl
P [188] <<not DSPV2() or not SBL()>>
S [189]cv?(v)
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
Reason:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
  What for:   normalization of [serial 1315]

Has applied when <<pre and v=M(cv)>> -> <<post>> for <<pre>> cv?(v) <<post>> to get:

[serial 1331]: MA::Controller.impl
P [189] <<(not DSPV2() or not SBL()) and v = VELOCITY>>
S [189]->
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
  What for: applied port input of value <<pre and v=M(cv)>> -> <<post>> [serial 1321]

. . . done applying atomic actions [23.3 seconds ]
After "atomic" remaining 
Obligations:

[serial 1330]: MA::Controller.impl
P [189] <<(not DSPV2() or not SBL()) and s = POSITION>>
S [189]->
Q [189] <<POSITION = s>>
  What for: applied port input of value <<pre and s=M(cs)>> -> <<post>> [serial 1319]



[serial 1331]: MA::Controller.impl
P [189] <<(not DSPV2() or not SBL()) and v = VELOCITY>>
S [189]->
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
  What for: applied port input of value <<pre and v=M(cv)>> -> <<post>> [serial 1321]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1330]: MA::Controller.impl
P [189] <<(not DSPV2() or not SBL()) and s = POSITION>>
S [189]->
Q [189] <<POSITION = s>>
Reason:  Normalization
  What for: applied port input of value <<pre and s=M(cs)>> -> <<post>> [serial 1319]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1333]: MA::Controller.impl
P [189] <<POSITION = s and (not DSPV2() or not SBL())>>
S [189]->
Q [189] <<POSITION = s>>
  What for:   normalization of [serial 1330]


This Proof Obligation:

[serial 1331]: MA::Controller.impl
P [189] <<(not DSPV2() or not SBL()) and v = VELOCITY>>
S [189]->
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
Reason:  Normalization
  What for: applied port input of value <<pre and v=M(cv)>> -> <<post>> [serial 1321]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1335]: MA::Controller.impl
P [189] <<VELOCITY = v and (not DSPV2() or not SBL())>>
S [189]->
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
  What for:   normalization of [serial 1331]

. . . done Normalizing Unsolved Proof Obligations [23.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1333]: MA::Controller.impl
P [189] <<POSITION = s and (not DSPV2() or not SBL())>>
S [189]->
Q [189] <<POSITION = s>>
  What for:   normalization of [serial 1330]



[serial 1335]: MA::Controller.impl
P [189] <<VELOCITY = v and (not DSPV2() or not SBL())>>
S [189]->
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
  What for:   normalization of [serial 1331]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1333]: MA::Controller.impl
P [189] <<POSITION = s and (not DSPV2() or not SBL())>>
S [189]->
Q [189] <<POSITION = s>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1330]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1335]: MA::Controller.impl
P [189] <<VELOCITY = v and (not DSPV2() or not SBL())>>
S [189]->
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1331]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [23.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1018]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [198]<<SBL() and DSPV2()>>
ca!(xl)
;
<<SBL() and DSPV2()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(SBL() and DSPV2())^1>>
Q [124] <<(SBL() and DSPV2())^1>>
  What for:  <<M(CSB) and x>> A <<M(MFR)>> for T7_SBI_Out:CSB-[x]->MFR{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1018]  <<M(CSB) and x>> A <<M(MFR)>> for T7_SBI_Out:CSB-[x]->MFR{A};
****reduce****
This proof obligation:

[serial 1018]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [198]<<SBL() and DSPV2()>>
ca!(xl)
;
<<SBL() and DSPV2()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(SBL() and DSPV2())^1>>
Q [124] <<(SBL() and DSPV2())^1>>
  What for:  <<M(CSB) and x>> A <<M(MFR)>> for T7_SBI_Out:CSB-[x]->MFR{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1338]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [197] <<SBL() and DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1018]


[serial 1339]: MA::Controller.impl
P [201] <<(SBL() and DSPV2())^1>>
S [124]->
Q [91] <<(SBL() and DSPV2())^1>>
  What for: Q1 -> Q in sequential composition for [serial 1018]


[serial 1340]: MA::Controller.impl
P [197] <<SBL() and DSPV2()>>
S [198]ca!(xl)
Q [199] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1018]


[serial 1341]: MA::Controller.impl
P [199] <<SBL() and DSPV2()>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(SBL() and DSPV2())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1018]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1338]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [197] <<SBL() and DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1018]



[serial 1339]: MA::Controller.impl
P [201] <<(SBL() and DSPV2())^1>>
S [124]->
Q [91] <<(SBL() and DSPV2())^1>>
  What for: Q1 -> Q in sequential composition for [serial 1018]



[serial 1340]: MA::Controller.impl
P [197] <<SBL() and DSPV2()>>
S [198]ca!(xl)
Q [199] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1018]



[serial 1341]: MA::Controller.impl
P [199] <<SBL() and DSPV2()>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(SBL() and DSPV2())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1018]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1339]: MA::Controller.impl
P [201] <<(SBL() and DSPV2())^1>>
S [124]->
Q [91] <<(SBL() and DSPV2())^1>>
Reason:  Identity (id):  P->P is tautology
  What for: Q1 -> Q in sequential composition for [serial 1018]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [23.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 1338]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [197] <<SBL() and DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1018]



[serial 1340]: MA::Controller.impl
P [197] <<SBL() and DSPV2()>>
S [198]ca!(xl)
Q [199] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1018]



[serial 1341]: MA::Controller.impl
P [199] <<SBL() and DSPV2()>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(SBL() and DSPV2())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1018]


Done trying to apply axioms
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
****make-an****
Making obligation 22
Obligations:

[serial 1338]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [197] <<SBL() and DSPV2()>>
  What for: P -> P1 in sequential composition for [serial 1018]


Done making obligation 22
#MA::Controller.impl
#[serial 1314] P -> P1 in sequential composition for [serial 1018]
" "   (does nothing)
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1338]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [197] <<SBL() and DSPV2()>>
Reason:  Substitution of Assertion Labels
  What for: P -> P1 in sequential composition for [serial 1018]

Has substituted Assertions' predicates for labels to get:

[serial 1342]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [197] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1338]

. . . done Substituting Assertions for Labels [23.5 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1342]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [197] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1338]


Done substituting Assertion labels in postconditions.
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1342]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [197] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1338]

Has split postcondition to get:

[serial 1343]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [95] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1342]


[serial 1344]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [98] <<((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1342]

. . . done splitting postcondition  [23.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1343]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [95] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1342]



[serial 1344]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [98] <<((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1342]


Done splitting postcondition
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1343]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [95] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))>>
Reason:  Normalization
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1342]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Reflexivity of Disjunction: (m or k) = (k or m)

    Zero is unique element: x+0 = x      x-0 = x

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1346]: MA::Controller.impl
P [127] <<((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
  What for:   normalization of [serial 1343]


This Proof Obligation:

[serial 1344]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127]->
Q [98] <<((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
Reason:  Normalization
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1342]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Reflexivity of Disjunction: (m or k) = (k or m)

    Zero is unique element: x+0 = x      x-0 = x

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1348]: MA::Controller.impl
P [127] <<((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1344]

. . . done Normalizing Unsolved Proof Obligations [23.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1346]: MA::Controller.impl
P [127] <<((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
  What for:   normalization of [serial 1343]



[serial 1348]: MA::Controller.impl
P [127] <<((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1344]


Done Normalizing
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1346]: MA::Controller.impl
P [127] <<((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1343]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1351]: MA::Controller.impl
P [127] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
  What for: Associativity: (b.c).a = a.b.c [serial 1346]


This Proof Obligation:

[serial 1348]: MA::Controller.impl
P [127] <<((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1344]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1352]: MA::Controller.impl
P [127] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1348]

. . . done Applying Laws [23.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1351]: MA::Controller.impl
P [127] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
  What for: Associativity: (b.c).a = a.b.c [serial 1346]



[serial 1352]: MA::Controller.impl
P [127] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1348]


Done applying laws
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1351]: MA::Controller.impl
P [127] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 1346]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1352]: MA::Controller.impl
P [127] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not DSPV2() or not SBL())>>
S [127]->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 1348]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1340]: MA::Controller.impl
P [197] <<SBL() and DSPV2()>>
S [198]ca!(xl)
Q [199] <<SBL() and DSPV2()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1018]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1316] <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1018]
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[192] ^(LABEL Acceleration ) ^(CONDITIONAL_FUNCTION[101] ^(-> ^(( ^(INVOKE[101] NOCHANGE ) ) ) 0 ) ^(-> ^(( ^(or ^(not ^(INVOKE[102] SBL ) ) ^(not ^(INVOKE[102] DSPV2 ) ) ) ) ) ^(:: CTCS_Properties SB_Rate ) ) ^(-> ^(( ^(or ^(not ^(INVOKE[103] EBL ) ) ^(not ^(INVOKE[103] DSPV1 ) ) ) ) ) ^(- b ) ) ^(-> ^(( ^(and ^(INVOKE[104] SBL ) ^(INVOKE[104] DSPV2 ) ) ) ) xl ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  (NOCHANGE()) -> 0, (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate, 
  (not EBL() or not DSPV1()) ->  -b, (SBL() and DSPV2()) -> xl
Thread "Controller.impl" has Dispatch_Protocol property Periodic

This Proof Obligation:

[serial 1340]: MA::Controller.impl
P [197] <<SBL() and DSPV2()>>
S [198]ca!(xl)
Q [199] <<SBL() and DSPV2()>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1018]

Has applied <<pre and (ca=xl)^0>> -> <<post>> for  <<pre>> ca!(xl) <<post>> to get:

[serial 1353]: MA::Controller.impl
P [198] <<(SBL() and DSPV2()) and (ca = xl)^0>>
S [198]->
Q [199] <<SBL() and DSPV2()>>
  What for: applied port output <<pre and (ca=xl)^0>> -> <<post>> [serial 1340]

Has applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>>where (SBL() and DSPV2()) -> xl for ca!(xl) to get:

[serial 1354]: MA::Controller.impl
P [197] <<SBL() and DSPV2()>>
S [198]->
Q [104] <<(SBL() and DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1340]

. . . done applying atomic actions [23.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 1353]: MA::Controller.impl
P [198] <<(SBL() and DSPV2()) and (ca = xl)^0>>
S [198]->
Q [199] <<SBL() and DSPV2()>>
  What for: applied port output <<pre and (ca=xl)^0>> -> <<post>> [serial 1340]



[serial 1354]: MA::Controller.impl
P [197] <<SBL() and DSPV2()>>
S [198]->
Q [104] <<(SBL() and DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1340]


Done reducing atomic actions
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1353]: MA::Controller.impl
P [198] <<(SBL() and DSPV2()) and (ca = xl)^0>>
S [198]->
Q [199] <<SBL() and DSPV2()>>
Reason:  Assume Present:  P = P@now = P^0 
  What for: applied port output <<pre and (ca=xl)^0>> -> <<post>> [serial 1340]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1355]: MA::Controller.impl
P [198] <<ca = xl and (DSPV2() and SBL())>>
S [198]->
Q [199] <<DSPV2() and SBL()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1353]

. . . done replacing P@now and P^0 with P  [23.7 seconds ]
After assuming present remaining 
Obligations:

[serial 1354]: MA::Controller.impl
P [197] <<SBL() and DSPV2()>>
S [198]->
Q [104] <<(SBL() and DSPV2())>>
  What for: applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1340]



[serial 1355]: MA::Controller.impl
P [198] <<ca = xl and (DSPV2() and SBL())>>
S [198]->
Q [199] <<DSPV2() and SBL()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1353]


Done assuming present.
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1354]: MA::Controller.impl
P [197] <<SBL() and DSPV2()>>
S [198]->
Q [104] <<(SBL() and DSPV2())>>
Reason:  Normalization
  What for: applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1340]

  Normalization Axioms:

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1357]: MA::Controller.impl
P [197] <<DSPV2() and SBL()>>
S [198]->
Q [104] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1354]

. . . done Normalizing Unsolved Proof Obligations [23.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1355]: MA::Controller.impl
P [198] <<ca = xl and (DSPV2() and SBL())>>
S [198]->
Q [199] <<DSPV2() and SBL()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1353]



[serial 1357]: MA::Controller.impl
P [197] <<DSPV2() and SBL()>>
S [198]->
Q [104] <<DSPV2() and SBL()>>
  What for:   normalization of [serial 1354]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1355]: MA::Controller.impl
P [198] <<ca = xl and (DSPV2() and SBL())>>
S [198]->
Q [199] <<DSPV2() and SBL()>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Assume Present:  P = P@now = P^0  [serial 1353]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1357]: MA::Controller.impl
P [197] <<DSPV2() and SBL()>>
S [198]->
Q [104] <<DSPV2() and SBL()>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1354]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [23.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1341]: MA::Controller.impl
P [199] <<SBL() and DSPV2()>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(SBL() and DSPV2())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1018]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1317] <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1018]
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1341]: MA::Controller.impl
P [199] <<SBL() and DSPV2()>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(SBL() and DSPV2())^1>>
Reason:  Substitution of Assertion Labels
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1018]

Has substituted Assertions' predicates for labels to get:

[serial 1360]: MA::Controller.impl
P [199] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
  What for: substituted Assertions' predicates for  labels  [serial 1341]

. . . done Substituting Assertions for Labels [23.8 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1360]: MA::Controller.impl
P [199] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1341]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1362]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1360]

. . . done Normalizing Unsolved Proof Obligations [23.8 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1362]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1360]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [23.8 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [23.8 seconds ]
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1362]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1360]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1365]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1362]

. . . done spltting timed atoms  [23.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [23.8 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1365]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1362]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1367]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1365]

. . . done Normalizing Unsolved Proof Obligations [23.9 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1367]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1365]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1367]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1365]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1369]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1367]

. . . done spltting timed atoms  [23.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [23.9 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [23.9 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1369]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1367]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 1369]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1367]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1371]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(((CTCS_Properties::start)^1 = (s)^1)
  or ((v)^1 < (iSeg.v2)^1))
  and
  (((CTCS_Properties::start)^1 = (s)^1)
  or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1369]

. . . done spltting timed atoms  [23.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [23.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1371]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(((CTCS_Properties::start)^1 = (s)^1)
  or ((v)^1 < (iSeg.v2)^1))
  and
  (((CTCS_Properties::start)^1 = (s)^1)
  or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1369]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1373]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1371]

. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 1373]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1371]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 1373]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1371]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1375]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1373]

. . . done spltting timed atoms  [24.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1375]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1373]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1377]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1375]

. . . done Normalizing Unsolved Proof Obligations [24.2 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 1377]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1375]


Done completely distributing ^ and @, round 3.
Distributing carets . .

This Proof Obligation:

[serial 1377]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1375]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1379]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
  (iSeg.e)^1)))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1377]

. . . done spltting timed atoms  [24.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.2 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1379]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
  (iSeg.e)^1)))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1377]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1381]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1379]

. . . done Normalizing Unsolved Proof Obligations [24.3 seconds ]
After "completely distribute ^ and @" round 4 remaining 
Obligations:

[serial 1381]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1379]


Done completely distributing ^ and @, round 4.
Distributing carets . .
. . . done spltting timed atoms  [24.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.3 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.3 seconds ]
****atomic****
applying atomic actions . . .
solving assignment on line 200
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iSeg'" with "iSeg"
makes:  <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "v^1" with "v"
makes:  <<(s^1 = CTCS_Properties::start or v < iSeg.v2)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "s^1" with "s"
makes:  <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b^1*s*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "b^1" with "b"
makes:  <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]^1+(b*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iMA'" with "iMA"
makes:  <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>

This Proof Obligation:

[serial 1381]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1379]

Has applied simultaneous assignmnet to get:

[serial 1384]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1381]

. . . done applying atomic actions [24.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 1384]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1381]



[serial 1384]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1381]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1384]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1381]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1386]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1384]


This Proof Obligation:

[serial 1384]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1381]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1388]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1384]

. . . done Normalizing Unsolved Proof Obligations [24.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1386]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1384]



[serial 1388]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1384]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1386]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1384]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1388]: MA::Controller.impl
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200]->
Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1384]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [24.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1019]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not SBL() or not DSPV2())^1>>
Q [126] <<(not SBL() or not DSPV2())^1>>
  What for:  <<M(CSB) and x>> A <<M(SBI)>> for T8_SBI_Ok:CSB-[x]->SBI{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1019]  <<M(CSB) and x>> A <<M(SBI)>> for T8_SBI_Ok:CSB-[x]->SBI{A};
****reduce****

[serial 1391]: MA::Controller.impl
P [209] <<(not SBL() or not DSPV2())^1>>
S [126]->
Q [126] <<(not SBL() or not DSPV2())^1>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1019]


[serial 1392]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not SBL() or not DSPV2())^1>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1019]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1391]: MA::Controller.impl
P [209] <<(not SBL() or not DSPV2())^1>>
S [126]->
Q [126] <<(not SBL() or not DSPV2())^1>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1019]



[serial 1392]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not SBL() or not DSPV2())^1>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1019]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1391]: MA::Controller.impl
P [209] <<(not SBL() or not DSPV2())^1>>
S [126]->
Q [126] <<(not SBL() or not DSPV2())^1>>
Reason:  Identity (id):  P->P is tautology
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1019]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [24.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1392]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not SBL() or not DSPV2())^1>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1019]


Done trying to apply axioms
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1392]: MA::Controller.impl
P [127] <<(not SBL() or not DSPV2())
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not SBL() or not DSPV2())^1>>
Reason:  Substitution of Assertion Labels
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1019]

Has substituted Assertions' predicates for labels to get:

[serial 1393]: MA::Controller.impl
P [127] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
  What for: substituted Assertions' predicates for  labels  [serial 1392]

. . . done Substituting Assertions for Labels [24.7 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1393]: MA::Controller.impl
P [127] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1392]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1395]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1393]

. . . done Normalizing Unsolved Proof Obligations [24.7 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1395]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1393]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [24.8 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.8 seconds ]
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1395]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1393]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1398]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<((not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1395]

. . . done spltting timed atoms  [24.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.8 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1398]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<((not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1395]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1400]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1398]

. . . done Normalizing Unsolved Proof Obligations [24.9 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1400]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for:   normalization of [serial 1398]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1400]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1398]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1402]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not ((CTCS_Properties::start = s or v < iSeg.v2))^1
or not ((CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1400]

. . . done spltting timed atoms  [24.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1402]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not ((CTCS_Properties::start = s or v < iSeg.v2))^1
or not ((CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1400]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1404]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)^1
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1402]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1404]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)^1
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1402]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 1404]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)^1
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1402]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1406]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not ((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
or not ((CTCS_Properties::start = s)^1
or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1404]

. . . done spltting timed atoms  [25.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.0 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 1406]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not ((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
or not ((CTCS_Properties::start = s)^1
or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1404]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 1406]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not ((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
or not ((CTCS_Properties::start = s)^1
or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1404]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1408]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (((CTCS_Properties::start)^1 = (s)^1)
or ((v)^1 < (iSeg.v2)^1))
or not (((CTCS_Properties::start)^1 = (s)^1)
or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1406]

. . . done spltting timed atoms  [25.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1408]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (((CTCS_Properties::start)^1 = (s)^1)
or ((v)^1 < (iSeg.v2)^1))
or not (((CTCS_Properties::start)^1 = (s)^1)
or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1406]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1410]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1408]

. . . done Normalizing Unsolved Proof Obligations [25.1 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 1410]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
  What for:   normalization of [serial 1408]


Done completely distributing ^ and @, round 3.
Distributing carets . .

This Proof Obligation:

[serial 1410]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1408]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1412]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1410]

. . . done spltting timed atoms  [25.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.2 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1412]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1410]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1414]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1412]

. . . done Normalizing Unsolved Proof Obligations [25.2 seconds ]
After "completely distribute ^ and @" round 4 remaining 
Obligations:

[serial 1414]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
  What for:   normalization of [serial 1412]


Done completely distributing ^ and @, round 4.
Distributing carets . .

This Proof Obligation:

[serial 1414]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1412]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1416]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
(iSeg.e)^1)))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1414]

. . . done spltting timed atoms  [25.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.3 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1416]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
(iSeg.e)^1)))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1414]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1418]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1416]

. . . done Normalizing Unsolved Proof Obligations [25.4 seconds ]
After "completely distribute ^ and @" round 5 remaining 
Obligations:

[serial 1418]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
  What for:   normalization of [serial 1416]


Done completely distributing ^ and @, round 5.
Distributing carets . .
. . . done spltting timed atoms  [25.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.4 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [25.4 seconds ]
****atomic****
applying atomic actions . . .
solving assignment on line 208
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iSeg'" with "iSeg"
makes:  <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "v^1" with "v"
makes:  <<not (s^1 = CTCS_Properties::start or v < iSeg.v2)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "s^1" with "s"
makes:  <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b^1*s*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "b^1" with "b"
makes:  <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]^1+(b*iSeg.e*2)))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iMA'" with "iMA"
makes:  <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>

This Proof Obligation:

[serial 1418]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1416]

Has applied simultaneous assignmnet to get:

[serial 1421]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1418]

. . . done applying atomic actions [25.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1421]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1418]



[serial 1421]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
  What for: applied wp for simultaneous assignment [serial 1418]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1421]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1418]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1423]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1421]


This Proof Obligation:

[serial 1421]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1418]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1425]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1421]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1423]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1421]



[serial 1425]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
  What for:   normalization of [serial 1421]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1423]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1421]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1425]: MA::Controller.impl
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208]->
Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1421]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1020]: MA::Controller.impl
P [122] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = )>>
S [213]->
Q [123] <<(i = 0) and (s = CTCS_Properties::start)>>
  What for:  <<M(CMA) and x>> -> <<M(RETRY)>> for T9_MA_NotOk:CMA-[x]->RETRY{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1020]  <<M(CMA) and x>> A <<M(RETRY)>> for T9_MA_NotOk:CMA-[x]->RETRY{A};
****reduce****
No reduction made
****atomic****
applying atomic actions . . .
. . . done applying atomic actions [25.7 seconds ]
After "atomic", no change 
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1020]: MA::Controller.impl
P [122] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = )>>
S [213]->
Q [123] <<(i = 0) and (s = CTCS_Properties::start)>>
Reason:  Normalization
  What for:  <<M(CMA) and x>> -> <<M(RETRY)>> for T9_MA_NotOk:CMA-[x]->RETRY{};

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1429]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and iMA = >>
S [213]->
Q [123] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1020]

. . . done Normalizing Unsolved Proof Obligations [25.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1429]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and iMA = >>
S [213]->
Q [123] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1020]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1429]: MA::Controller.impl
P [122] <<CTCS_Properties::start = s and i = 0 and iMA = >>
S [213]->
Q [123] <<CTCS_Properties::start = s and i = 0>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for:   normalization of [serial 1020]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [25.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1021]: MA::Controller.impl
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((i = 0) and (s = CTCS_Properties::start))^1>>
  What for:  <<M(RETRY)>> A <<M(GMA)>> for T10_MA_Retry:RETRY-[ ]->GMA{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
****assume present****
Assume Present P=P^0=P@now
. . . done replacing P@now and P^0 with P  [25.7 seconds ]
After assuming present, no change 
****laws****
Applying Laws . . .
. . . done Applying Laws [25.7 seconds ]
After applying laws, no change 
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [25.7 seconds ]
After applying axioms, no change 
#[serial 1021]  <<M(RETRY)>> A <<M(GMA)>> for T10_MA_Retry:RETRY-[ ]->GMA{A};
****reduce****

[serial 1431]: MA::Controller.impl
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((i = 0) and (s = CTCS_Properties::start))^1>>
  What for: as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1021]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1431]: MA::Controller.impl
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((i = 0) and (s = CTCS_Properties::start))^1>>
  What for: as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1021]


done reducing composite actions
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1431]: MA::Controller.impl
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((i = 0) and (s = CTCS_Properties::start))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1021]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1432]: MA::Controller.impl
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((i = 0)^1 and (s = CTCS_Properties::start)^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1431]

. . . done spltting timed atoms  [25.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.8 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1432]: MA::Controller.impl
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((i = 0)^1 and (s = CTCS_Properties::start)^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1431]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1434]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<(CTCS_Properties::start = s)^1 and (i = 0)^1>>
  What for:   normalization of [serial 1432]

. . . done Normalizing Unsolved Proof Obligations [25.8 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1434]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<(CTCS_Properties::start = s)^1 and (i = 0)^1>>
  What for:   normalization of [serial 1432]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1434]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<(CTCS_Properties::start = s)^1 and (i = 0)^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1432]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1436]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((CTCS_Properties::start)^1 = (s)^1)
  and
  ((i)^1 = (0)^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1434]

. . . done spltting timed atoms  [25.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.8 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1436]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((CTCS_Properties::start)^1 = (s)^1)
  and
  ((i)^1 = (0)^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1434]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Constants are always the same

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1438]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
  What for:   normalization of [serial 1436]

. . . done Normalizing Unsolved Proof Obligations [25.8 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1438]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
  What for:   normalization of [serial 1436]


Done completely distributing ^ and @, round 1.
Distributing carets . .
. . . done spltting timed atoms  [25.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.8 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [25.8 seconds ]
****atomic****
applying atomic actions . . .
solving assignment on line 215
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "i^1" with "i"
makes:  <<i = 0 and s^1 = CTCS_Properties::start>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "s^1" with "s"
makes:  <<i = 0 and s = CTCS_Properties::start>>

This Proof Obligation:

[serial 1438]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1436]

Has applied simultaneous assignmnet to get:

[serial 1441]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<i = 0 and s = CTCS_Properties::start>>
  What for: applied wp for simultaneous assignment [serial 1438]

. . . done applying atomic actions [25.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1441]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<i = 0 and s = CTCS_Properties::start>>
  What for: applied wp for simultaneous assignment [serial 1438]



[serial 1441]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<i = 0 and s = CTCS_Properties::start>>
  What for: applied wp for simultaneous assignment [serial 1438]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1441]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<i = 0 and s = CTCS_Properties::start>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1438]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1443]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1441]


This Proof Obligation:

[serial 1441]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<i = 0 and s = CTCS_Properties::start>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1438]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1445]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1441]

. . . done Normalizing Unsolved Proof Obligations [25.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1443]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1441]



[serial 1445]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<CTCS_Properties::start = s and i = 0>>
  What for:   normalization of [serial 1441]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1443]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<CTCS_Properties::start = s and i = 0>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1441]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1445]: MA::Controller.impl
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215]->
Q [121] <<CTCS_Properties::start = s and i = 0>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1441]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [25.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1022]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [219]<<not EBL() or not DSPV1()>>
ca!(- b)
;
<<not EBL() or not DSPV1()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not EBL() or not DSPV1())^1>>
Q [128] <<(not EBL() or not DSPV1())^1>>
  What for:  <<M(CMF) and x>> A <<M(EBI)>> for T11_EBI_Point:CMF-[x]->EBI{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1022]  <<M(CMF) and x>> A <<M(EBI)>> for T11_EBI_Point:CMF-[x]->EBI{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [25.9 seconds ]
After applying axioms, no change 
****reduce****
This proof obligation:

[serial 1022]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [219]<<not EBL() or not DSPV1()>>
ca!(- b)
;
<<not EBL() or not DSPV1()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not EBL() or not DSPV1())^1>>
Q [128] <<(not EBL() or not DSPV1())^1>>
  What for:  <<M(CMF) and x>> A <<M(EBI)>> for T11_EBI_Point:CMF-[x]->EBI{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1448]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [125]->
Q [219] <<not EBL() or not DSPV1()>>
  What for: P -> P1 in sequential composition for [serial 1022]


[serial 1449]: MA::Controller.impl
P [221] <<(not EBL() or not DSPV1())^1>>
S [128]->
Q [91] <<(not EBL() or not DSPV1())^1>>
  What for: Q1 -> Q in sequential composition for [serial 1022]


[serial 1450]: MA::Controller.impl
P [219] <<not EBL() or not DSPV1()>>
S [219]ca!(- b)
Q [219] <<not EBL() or not DSPV1()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1022]


[serial 1451]: MA::Controller.impl
P [219] <<not EBL() or not DSPV1()>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not EBL() or not DSPV1())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1022]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1448]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [125]->
Q [219] <<not EBL() or not DSPV1()>>
  What for: P -> P1 in sequential composition for [serial 1022]



[serial 1449]: MA::Controller.impl
P [221] <<(not EBL() or not DSPV1())^1>>
S [128]->
Q [91] <<(not EBL() or not DSPV1())^1>>
  What for: Q1 -> Q in sequential composition for [serial 1022]



[serial 1450]: MA::Controller.impl
P [219] <<not EBL() or not DSPV1()>>
S [219]ca!(- b)
Q [219] <<not EBL() or not DSPV1()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1022]



[serial 1451]: MA::Controller.impl
P [219] <<not EBL() or not DSPV1()>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not EBL() or not DSPV1())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1022]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1449]: MA::Controller.impl
P [221] <<(not EBL() or not DSPV1())^1>>
S [128]->
Q [91] <<(not EBL() or not DSPV1())^1>>
Reason:  Identity (id):  P->P is tautology
  What for: Q1 -> Q in sequential composition for [serial 1022]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [25.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1448]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [125]->
Q [219] <<not EBL() or not DSPV1()>>
  What for: P -> P1 in sequential composition for [serial 1022]



[serial 1450]: MA::Controller.impl
P [219] <<not EBL() or not DSPV1()>>
S [219]ca!(- b)
Q [219] <<not EBL() or not DSPV1()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1022]



[serial 1451]: MA::Controller.impl
P [219] <<not EBL() or not DSPV1()>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not EBL() or not DSPV1())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1022]


Done trying to apply axioms
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1448]: MA::Controller.impl
P [125] <<SBL()
  and
  DSPV2()
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [125]->
Q [219] <<not EBL() or not DSPV1()>>
Reason:  Substitution of Assertion Labels
  What for: P -> P1 in sequential composition for [serial 1022]

Has substituted Assertions' predicates for labels to get:

[serial 1452]: MA::Controller.impl
P [125] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [125]->
Q [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
  What for: substituted Assertions' predicates for  labels  [serial 1448]


This Proof Obligation:

[serial 1450]: MA::Controller.impl
P [219] <<not EBL() or not DSPV1()>>
S [219]ca!(- b)
Q [219] <<not EBL() or not DSPV1()>>
Reason:  Substitution of Assertion Labels
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1022]

Has substituted Assertions' predicates for labels to get:

[serial 1453]: MA::Controller.impl
P [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
S [219]ca!(- b)
Q [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
  What for: substituted Assertions' predicates for  labels  [serial 1450]


This Proof Obligation:

[serial 1451]: MA::Controller.impl
P [219] <<not EBL() or not DSPV1()>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not EBL() or not DSPV1())^1>>
Reason:  Substitution of Assertion Labels
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1022]

Has substituted Assertions' predicates for labels to get:

[serial 1454]: MA::Controller.impl
P [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))^1>>
  What for: substituted Assertions' predicates for  labels  [serial 1451]

. . . done Substituting Assertions for Labels [26.0 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1452]: MA::Controller.impl
P [125] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [125]->
Q [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1448]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Multiplication: a*b=b*a

    Reflexivity of Disjunction: (m or k) = (k or m)

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1452]


This Proof Obligation:

[serial 1453]: MA::Controller.impl
P [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
S [219]ca!(- b)
Q [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1450]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1458]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]ca!(- b)
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1453]


This Proof Obligation:

[serial 1454]: MA::Controller.impl
P [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))^1>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1451]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1460]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1454]

. . . done Normalizing Unsolved Proof Obligations [26.1 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1452]



[serial 1458]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]ca!(- b)
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1453]



[serial 1460]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1454]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [26.1 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1460]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1454]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1467]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<((not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1460]

. . . done spltting timed atoms  [26.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.2 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1467]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<((not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1460]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1471]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1467]

. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1452]



[serial 1458]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]ca!(- b)
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1453]



[serial 1471]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1467]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1471]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1467]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1473]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not (v < iSeg.v1)^1
or not (((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1471]

. . . done spltting timed atoms  [26.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.3 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [26.3 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1452]



[serial 1458]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]ca!(- b)
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1453]



[serial 1473]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not (v < iSeg.v1)^1
or not (((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1471]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 1473]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not (v < iSeg.v1)^1
or not (((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1471]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1477]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not ((v)^1 < (iSeg.v1)^1)
or not (((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1473]

. . . done spltting timed atoms  [26.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.3 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1477]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not ((v)^1 < (iSeg.v1)^1)
or not (((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1473]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1481]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1>>
  What for:   normalization of [serial 1477]

. . . done Normalizing Unsolved Proof Obligations [26.4 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1452]



[serial 1458]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]ca!(- b)
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1453]



[serial 1481]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1>>
  What for:   normalization of [serial 1477]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 1481]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1477]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1483]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v1])^1+(b*2*iSeg.e)^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1481]

. . . done spltting timed atoms  [26.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.4 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1483]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v1])^1+(b*2*iSeg.e)^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1481]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1487]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v1]^1+(b*2*iSeg.e)^1)>>
  What for:   normalization of [serial 1483]

. . . done Normalizing Unsolved Proof Obligations [26.4 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1452]



[serial 1458]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]ca!(- b)
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1453]



[serial 1487]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v1]^1+(b*2*iSeg.e)^1)>>
  What for:   normalization of [serial 1483]


Done completely distributing ^ and @, round 3.
Distributing carets . .

This Proof Obligation:

[serial 1487]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v1]^1+(b*2*iSeg.e)^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1483]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1489]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v1]^1+((b)^1*(2)^1*
(iSeg.e)^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1487]

. . . done spltting timed atoms  [26.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.5 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1489]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v1]^1+((b)^1*(2)^1*
(iSeg.e)^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1487]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1493]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e^1*2))>>
  What for:   normalization of [serial 1489]

. . . done Normalizing Unsolved Proof Obligations [26.5 seconds ]
After "completely distribute ^ and @" round 4 remaining 
Obligations:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1452]



[serial 1458]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]ca!(- b)
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1453]



[serial 1493]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e^1*2))>>
  What for:   normalization of [serial 1489]


Done completely distributing ^ and @, round 4.
Distributing carets . .
. . . done spltting timed atoms  [26.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.6 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [26.6 seconds ]
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[192] ^(LABEL Acceleration ) ^(CONDITIONAL_FUNCTION[101] ^(-> ^(( ^(INVOKE[101] NOCHANGE ) ) ) 0 ) ^(-> ^(( ^(or ^(not ^(INVOKE[102] SBL ) ) ^(not ^(INVOKE[102] DSPV2 ) ) ) ) ) ^(:: CTCS_Properties SB_Rate ) ) ^(-> ^(( ^(or ^(not ^(INVOKE[103] EBL ) ) ^(not ^(INVOKE[103] DSPV1 ) ) ) ) ) ^(- b ) ) ^(-> ^(( ^(and ^(INVOKE[104] SBL ) ^(INVOKE[104] DSPV2 ) ) ) ) xl ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  (NOCHANGE()) -> 0, (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate, 
  (not EBL() or not DSPV1()) ->  -b, (SBL() and DSPV2()) -> xl
Thread "Controller.impl" has Dispatch_Protocol property Periodic

This Proof Obligation:

[serial 1458]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]ca!(- b)
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for:   normalization of [serial 1453]

Has applied <<pre and (ca=- b)^0>> -> <<post>> for  <<pre>> ca!(-) <<post>> to get:

[serial 1498]: MA::Controller.impl
P [219] <<(not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))
  and
  (ca = ( -b))^0>>
S [219]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for: applied port output <<pre and (ca=- b)^0>> -> <<post>> [serial 1458]

Has applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>>where (not EBL() or not DSPV1()) -> - b for ca!(- b) to get:

[serial 1499]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<(not EBL() or not DSPV1())>>
  What for: applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>> where (not EBL() or not DSPV1()) -> - b for ca!(- b) 
[serial 1458]

solving assignment on line 220
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iSeg'" with "iSeg"
makes:  <<not v^1 < iSeg.v1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e*2))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "v^1" with "v"
makes:  <<not v < iSeg.v1
or not ((v**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e*2))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "s^1" with "s"
makes:  <<not v < iSeg.v1
or not ((v**2)+(b^1*s*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e*2))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "b^1" with "b"
makes:  <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]^1+(b*iSeg.e*2))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iMA'" with "iMA"
makes:  <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>

This Proof Obligation:

[serial 1493]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e^1*2))>>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1489]

Has applied simultaneous assignmnet to get:

[serial 1500]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
  What for: applied wp for simultaneous assignment [serial 1493]

. . . done applying atomic actions [26.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1452]



[serial 1498]: MA::Controller.impl
P [219] <<(not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))
  and
  (ca = ( -b))^0>>
S [219]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for: applied port output <<pre and (ca=- b)^0>> -> <<post>> [serial 1458]



[serial 1499]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<(not EBL() or not DSPV1())>>
  What for: applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>> where (not EBL() or not DSPV1()) -> - b for ca!(- b) 
[serial 1458]



[serial 1500]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
  What for: applied wp for simultaneous assignment [serial 1493]



[serial 1500]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
  What for: applied wp for simultaneous assignment [serial 1493]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1498]: MA::Controller.impl
P [219] <<(not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))
  and
  (ca = ( -b))^0>>
S [219]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  Normalization
  What for: applied port output <<pre and (ca=- b)^0>> -> <<post>> [serial 1458]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1503]: MA::Controller.impl
P [219] <<(ca = ( -b))^0
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [219]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1498]


This Proof Obligation:

[serial 1499]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<(not EBL() or not DSPV1())>>
Reason:  Normalization
  What for: applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>> where (not EBL() or not DSPV1()) -> - b for ca!(- b) 
[serial 1458]

  Normalization Axioms:

    Reflexivity of Disjunction: (m or k) = (k or m)

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1505]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not DSPV1() or not EBL()>>
  What for:   normalization of [serial 1499]


This Proof Obligation:

[serial 1500]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1493]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1507]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1500]


This Proof Obligation:

[serial 1500]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1493]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1509]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1500]

. . . done Normalizing Unsolved Proof Obligations [26.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1452]



[serial 1503]: MA::Controller.impl
P [219] <<(ca = ( -b))^0
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [219]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1498]



[serial 1505]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not DSPV1() or not EBL()>>
  What for:   normalization of [serial 1499]



[serial 1507]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1500]



[serial 1509]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1500]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1456]: MA::Controller.impl
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1452]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1503]: MA::Controller.impl
P [219] <<(ca = ( -b))^0
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [219]->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1498]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1507]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1500]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1509]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220]->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1500]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [27.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1505]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not DSPV1() or not EBL()>>
  What for:   normalization of [serial 1499]


Done trying to apply axioms
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1505]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not DSPV1() or not EBL()>>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1499]

Has substituted Assertions' predicates for labels to get:

[serial 1514]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))
or not ((v < iSeg.v1))>>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1505]

. . . done Substituting Assertions for Labels [27.0 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1514]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))
or not ((v < iSeg.v1))>>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1505]


Done substituting Assertion labels in postconditions.
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1514]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))
or not ((v < iSeg.v1))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1505]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Reflexivity of Disjunction: (m or k) = (k or m)

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1516]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1514]

. . . done Normalizing Unsolved Proof Obligations [27.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1516]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1514]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1516]: MA::Controller.impl
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219]->
Q [103] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1514]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [27.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1023]: MA::Controller.impl
P [128] <<(not EBL() or not DSPV1()) and (v = 0)>>
S [223]->
Q [129] <<(not EBL() or not DSPV1()) and v = 0>>
  What for:  <<M(EBI) and x>> -> <<M(STOP)>> for T12_Stop:EBI-[x]->STOP{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1023]  <<M(EBI) and x>> -> <<M(STOP)>> for T12_stop:EBI-[x]->STOP{};
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1023]: MA::Controller.impl
P [128] <<(not EBL() or not DSPV1()) and (v = 0)>>
S [223]->
Q [129] <<(not EBL() or not DSPV1()) and v = 0>>
Reason:  Normalization
  What for:  <<M(EBI) and x>> -> <<M(STOP)>> for T12_Stop:EBI-[x]->STOP{};

  Normalization Axioms:

    Reflexivity of Disjunction: (m or k) = (k or m)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1519]: MA::Controller.impl
P [128] <<v = 0 and (not DSPV1() or not EBL())>>
S [223]->
Q [129] <<v = 0 and (not DSPV1() or not EBL())>>
  What for:   normalization of [serial 1023]

. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1519]: MA::Controller.impl
P [128] <<v = 0 and (not DSPV1() or not EBL())>>
S [223]->
Q [129] <<v = 0 and (not DSPV1() or not EBL())>>
  What for:   normalization of [serial 1023]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1519]: MA::Controller.impl
P [128] <<v = 0 and (not DSPV1() or not EBL())>>
S [223]->
Q [129] <<v = 0 and (not DSPV1() or not EBL())>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1023]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [27.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1024]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [227]<<not EBL() or not DSPV1()>>
ca!(- b)
;
<<not EBL() or not DSPV1()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not EBL() or not DSPV1())^1>>
Q [128] <<(not EBL() or not DSPV1())^1>>
  What for:  <<M(SBI) and x>> A <<M(EBI)>> for T13_EBI_Point:SBI-[x]->EBI{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1024]  <<M(SBI) and x>> A <<M(EBI)>> for T13_EBI_Point:SBI-[x]->EBI{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [27.1 seconds ]
After applying axioms, no change 
****reduce****
This proof obligation:

[serial 1024]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [227]<<not EBL() or not DSPV1()>>
ca!(- b)
;
<<not EBL() or not DSPV1()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not EBL() or not DSPV1())^1>>
Q [128] <<(not EBL() or not DSPV1())^1>>
  What for:  <<M(SBI) and x>> A <<M(EBI)>> for T13_EBI_Point:SBI-[x]->EBI{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1521]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126]->
Q [227] <<not EBL() or not DSPV1()>>
  What for: P -> P1 in sequential composition for [serial 1024]


[serial 1522]: MA::Controller.impl
P [229] <<(not EBL() or not DSPV1())^1>>
S [128]->
Q [91] <<(not EBL() or not DSPV1())^1>>
  What for: Q1 -> Q in sequential composition for [serial 1024]


[serial 1523]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [227]ca!(- b)
Q [227] <<not EBL() or not DSPV1()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1024]


[serial 1524]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not EBL() or not DSPV1())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1024]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1521]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126]->
Q [227] <<not EBL() or not DSPV1()>>
  What for: P -> P1 in sequential composition for [serial 1024]



[serial 1522]: MA::Controller.impl
P [229] <<(not EBL() or not DSPV1())^1>>
S [128]->
Q [91] <<(not EBL() or not DSPV1())^1>>
  What for: Q1 -> Q in sequential composition for [serial 1024]



[serial 1523]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [227]ca!(- b)
Q [227] <<not EBL() or not DSPV1()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1024]



[serial 1524]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not EBL() or not DSPV1())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1024]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1522]: MA::Controller.impl
P [229] <<(not EBL() or not DSPV1())^1>>
S [128]->
Q [91] <<(not EBL() or not DSPV1())^1>>
Reason:  Identity (id):  P->P is tautology
  What for: Q1 -> Q in sequential composition for [serial 1024]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [27.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1521]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126]->
Q [227] <<not EBL() or not DSPV1()>>
  What for: P -> P1 in sequential composition for [serial 1024]



[serial 1523]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [227]ca!(- b)
Q [227] <<not EBL() or not DSPV1()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1024]



[serial 1524]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not EBL() or not DSPV1())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1024]


Done trying to apply axioms
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
****make-an****
Making obligation 31
Obligations:

[serial 1521]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126]->
Q [227] <<not EBL() or not DSPV1()>>
  What for: P -> P1 in sequential composition for [serial 1024]


Done making obligation 31
#MA::Controller.impl
#[serial 1520] P -> P1 in sequential composition for [serial 1024]
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1521]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126]->
Q [227] <<not EBL() or not DSPV1()>>
Reason:  Substitution of Assertion Labels
  What for: P -> P1 in sequential composition for [serial 1024]

Has substituted Assertions' predicates for labels to get:

[serial 1525]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126]->
Q [227] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1521]

. . . done Substituting Assertions for Labels [27.2 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1525]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126]->
Q [227] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1521]


Done substituting Assertion labels in postconditions.
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1525]: MA::Controller.impl
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126]->
Q [227] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1521]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Reflexivity of Disjunction: (m or k) = (k or m)

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1527]: MA::Controller.impl
P [126] <<(not DSPV2() or not SBL())
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [126]->
Q [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1525]

. . . done Normalizing Unsolved Proof Obligations [27.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1527]: MA::Controller.impl
P [126] <<(not DSPV2() or not SBL())
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [126]->
Q [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1525]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1527]: MA::Controller.impl
P [126] <<(not DSPV2() or not SBL())
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [126]->
Q [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1525]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1523]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [227]ca!(- b)
Q [227] <<not EBL() or not DSPV1()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1024]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1522] <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1024]
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[192] ^(LABEL Acceleration ) ^(CONDITIONAL_FUNCTION[101] ^(-> ^(( ^(INVOKE[101] NOCHANGE ) ) ) 0 ) ^(-> ^(( ^(or ^(not ^(INVOKE[102] SBL ) ) ^(not ^(INVOKE[102] DSPV2 ) ) ) ) ) ^(:: CTCS_Properties SB_Rate ) ) ^(-> ^(( ^(or ^(not ^(INVOKE[103] EBL ) ) ^(not ^(INVOKE[103] DSPV1 ) ) ) ) ) ^(- b ) ) ^(-> ^(( ^(and ^(INVOKE[104] SBL ) ^(INVOKE[104] DSPV2 ) ) ) ) xl ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] Acceleration ) )
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  (NOCHANGE()) -> 0, (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate, 
  (not EBL() or not DSPV1()) ->  -b, (SBL() and DSPV2()) -> xl
Thread "Controller.impl" has Dispatch_Protocol property Periodic

This Proof Obligation:

[serial 1523]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [227]ca!(- b)
Q [227] <<not EBL() or not DSPV1()>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1024]

Has applied <<pre and (ca=- b)^0>> -> <<post>> for  <<pre>> ca!(-) <<post>> to get:

[serial 1529]: MA::Controller.impl
P [227] <<(not EBL() or not DSPV1())
  and
  (ca = ( -b))^0>>
S [227]->
Q [227] <<not EBL() or not DSPV1()>>
  What for: applied port output <<pre and (ca=- b)^0>> -> <<post>> [serial 1523]

Has applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>>where (not EBL() or not DSPV1()) -> - b for ca!(- b) to get:

[serial 1530]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [227]->
Q [103] <<(not EBL() or not DSPV1())>>
  What for: applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>> where (not EBL() or not DSPV1()) -> - b for ca!(- b) 
[serial 1523]

. . . done applying atomic actions [27.3 seconds ]
After "atomic" remaining 
Obligations:

[serial 1529]: MA::Controller.impl
P [227] <<(not EBL() or not DSPV1())
  and
  (ca = ( -b))^0>>
S [227]->
Q [227] <<not EBL() or not DSPV1()>>
  What for: applied port output <<pre and (ca=- b)^0>> -> <<post>> [serial 1523]



[serial 1530]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [227]->
Q [103] <<(not EBL() or not DSPV1())>>
  What for: applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>> where (not EBL() or not DSPV1()) -> - b for ca!(- b) 
[serial 1523]


Done reducing atomic actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1529]: MA::Controller.impl
P [227] <<(not EBL() or not DSPV1())
  and
  (ca = ( -b))^0>>
S [227]->
Q [227] <<not EBL() or not DSPV1()>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: applied port output <<pre and (ca=- b)^0>> -> <<post>> [serial 1523]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1530]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [227]->
Q [103] <<(not EBL() or not DSPV1())>>
  What for: applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>> where (not EBL() or not DSPV1()) -> - b for ca!(- b) 
[serial 1523]


Done trying to apply axioms
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1530]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [227]->
Q [103] <<(not EBL() or not DSPV1())>>
Reason:  Normalization
  What for: applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>> where (not EBL() or not DSPV1()) -> - b for ca!(- b) 
[serial 1523]

  Normalization Axioms:

    Reflexivity of Disjunction: (m or k) = (k or m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1532]: MA::Controller.impl
P [227] <<not DSPV1() or not EBL()>>
S [227]->
Q [103] <<not DSPV1() or not EBL()>>
  What for:   normalization of [serial 1530]

. . . done Normalizing Unsolved Proof Obligations [27.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1532]: MA::Controller.impl
P [227] <<not DSPV1() or not EBL()>>
S [227]->
Q [103] <<not DSPV1() or not EBL()>>
  What for:   normalization of [serial 1530]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1532]: MA::Controller.impl
P [227] <<not DSPV1() or not EBL()>>
S [227]->
Q [103] <<not DSPV1() or not EBL()>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1530]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [27.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1524]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not EBL() or not DSPV1())^1>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1024]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1523] <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1024]
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1524]: MA::Controller.impl
P [227] <<not EBL() or not DSPV1()>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not EBL() or not DSPV1())^1>>
Reason:  Substitution of Assertion Labels
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1024]

Has substituted Assertions' predicates for labels to get:

[serial 1534]: MA::Controller.impl
P [227] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))^1>>
  What for: substituted Assertions' predicates for  labels  [serial 1524]

. . . done Substituting Assertions for Labels [27.4 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1534]: MA::Controller.impl
P [227] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))^1>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1524]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1536]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1534]

. . . done Normalizing Unsolved Proof Obligations [27.4 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1536]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1534]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [27.4 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [27.4 seconds ]
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1536]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1534]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1539]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<((not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1536]

. . . done spltting timed atoms  [27.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.4 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1539]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<((not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1536]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1541]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1539]

. . . done Normalizing Unsolved Proof Obligations [27.4 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1541]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for:   normalization of [serial 1539]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1541]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1539]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1543]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not (v < iSeg.v1)^1
or not (((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1541]

. . . done spltting timed atoms  [27.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.5 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [27.5 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1543]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not (v < iSeg.v1)^1
or not (((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1541]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 1543]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not (v < iSeg.v1)^1
or not (((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1541]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1545]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not ((v)^1 < (iSeg.v1)^1)
or not (((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1543]

. . . done spltting timed atoms  [27.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.5 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1545]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not ((v)^1 < (iSeg.v1)^1)
or not (((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1543]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1547]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1>>
  What for:   normalization of [serial 1545]

. . . done Normalizing Unsolved Proof Obligations [27.5 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 1547]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1>>
  What for:   normalization of [serial 1545]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 1547]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1545]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1549]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v1])^1+(b*2*iSeg.e)^1)>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1547]

. . . done spltting timed atoms  [27.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1549]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v1])^1+(b*2*iSeg.e)^1)>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1547]

  Normalization Axioms:

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1551]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v1]^1+(b*2*iSeg.e)^1)>>
  What for:   normalization of [serial 1549]

. . . done Normalizing Unsolved Proof Obligations [27.6 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 1551]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v1]^1+(b*2*iSeg.e)^1)>>
  What for:   normalization of [serial 1549]


Done completely distributing ^ and @, round 3.
Distributing carets . .

This Proof Obligation:

[serial 1551]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v1]^1+(b*2*iSeg.e)^1)>>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1549]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1553]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v1]^1+((b)^1*(2)^1*
(iSeg.e)^1))>>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1551]

. . . done spltting timed atoms  [27.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1553]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v1]^1+((b)^1*(2)^1*
(iSeg.e)^1))>>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1551]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Constants are always the same

    Zero is unique element: x+0 = x      x-0 = x

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1555]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e^1*2))>>
  What for:   normalization of [serial 1553]

. . . done Normalizing Unsolved Proof Obligations [27.6 seconds ]
After "completely distribute ^ and @" round 4 remaining 
Obligations:

[serial 1555]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e^1*2))>>
  What for:   normalization of [serial 1553]


Done completely distributing ^ and @, round 4.
Distributing carets . .
. . . done spltting timed atoms  [27.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.7 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [27.7 seconds ]
****atomic****
applying atomic actions . . .
solving assignment on line 228
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iSeg'" with "iSeg"
makes:  <<not v^1 < iSeg.v1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e*2))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "v^1" with "v"
makes:  <<not v < iSeg.v1
or not ((v**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e*2))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "s^1" with "s"
makes:  <<not v < iSeg.v1
or not ((v**2)+(b^1*s*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e*2))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
replacing "b^1" with "b"
makes:  <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]^1+(b*iSeg.e*2))>>
Thread "Controller.impl" has Dispatch_Protocol property Periodic
array assignment: replacing "iMA'" with "iMA"
makes:  <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>

This Proof Obligation:

[serial 1555]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e^1*2))>>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1553]

Has applied simultaneous assignmnet to get:

[serial 1558]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
  What for: applied wp for simultaneous assignment [serial 1555]

. . . done applying atomic actions [27.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 1558]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
  What for: applied wp for simultaneous assignment [serial 1555]



[serial 1558]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
  What for: applied wp for simultaneous assignment [serial 1555]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1558]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1555]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1560]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1558]


This Proof Obligation:

[serial 1558]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1555]

  Normalization Axioms:

    Reflexivity of Multiplication: a*b=b*a

    Zero is unique element: x+0 = x      x-0 = x
Has been normalized to get:

[serial 1562]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1558]

. . . done Normalizing Unsolved Proof Obligations [27.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1560]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1558]



[serial 1562]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
  What for:   normalization of [serial 1558]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1560]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1558]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1562]: MA::Controller.impl
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228]->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1558]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [27.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
There are no more unsolved proof obligations.
All proof obligations have been solved.  Q.E.D.
Theorem (1)                               [serial 1003] 
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [107] ->
Q [107] <<true>>
by True Conclusion Schema (tc): P->true


Theorem (2)                               [serial 1004] 
P [124] <<SBL() and DSPV2()>>
S [107] ->
Q [107] <<true>>
by True Conclusion Schema (tc): P->true


Theorem (3)                               [serial 1005] 
P [126] <<not SBL() or not DSPV2()>>
S [107] ->
Q [107] <<true>>
by True Conclusion Schema (tc): P->true


Theorem (4)                               [serial 1006] 
P [128] <<not EBL() or not DSPV1()>>
S [107] ->
Q [107] <<true>>
by True Conclusion Schema (tc): P->true


Theorem (5)                               [serial 1025] 
P [127] <<not SBL() or not DSPV2()>>
S [127] ->
Q [127] <<true>>
by True Conclusion Schema (tc): P->true


Theorem (6)                               [serial 1007] 
P [127] <<not SBL() or not DSPV2()>>
S [127] ->
Q [127] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))
or (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
by Law of Excluded Middle: P or not P is tautology
and theorem 5:
Theorem (5) [serial 1025] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1007]
 


Theorem (7)                               [serial 1027] 
P [125] <<SBL() and DSPV2()>>
S [125] ->
Q [125] <<true>>
by True Conclusion Schema (tc): P->true


Theorem (8)                               [serial 1026] 
P [125] <<SBL() and DSPV2()>>
S [125] ->
Q [125] <<not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))
or ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))
or not (v < iSeg.v1)
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
by Law of Excluded Middle: P or not P is tautology
and theorem 7:
Theorem (7) [serial 1027] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1026]
 


Theorem (9)                               [serial 1008] 
P [125] <<SBL() and DSPV2()>>
S [125] ->
Q [125] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))
or (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))
or (not (v < iSeg.v1)
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
by Associativity: (b.c).a = a.b.c
and theorem 8:
Theorem (8) [serial 1026] used for:
  Associativity: (b.c).a = a.b.c [serial 1008]
 


Theorem (10)                               [serial 1009] 
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [123] ->
Q [123] <<true>>
by True Conclusion Schema (tc): P->true


Theorem (11)                               [serial 1028] 
P [122] <<(i = 0) and (s = CTCS_Properties::start)>>
S [122] ->
Q [122] <<true>>
by True Conclusion Schema (tc): P->true


Theorem (12)                               [serial 1010] 
P [122] <<(i = 0) and (s = CTCS_Properties::start)>>
S [122] ->
Q [122] <<(not (iMA = )) or (iMA = )>>
by Law of Excluded Middle: P or not P is tautology
and theorem 11:
Theorem (11) [serial 1028] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1010]
 


Theorem (13)                               [serial 1029] 
P [120] <<(i = 0) and (s = CTCS_Properties::start)>>
S [120] ->
Q [133] <<(i = 0) and (s = CTCS_Properties::start)>>
by Identity (id):  P->P is tautology


Theorem (14)                               [serial 1048] 
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121] ->
Q [91] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
by Identity (id):  P->P is tautology


Theorem (15)                               [serial 1044] 
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121] ->
Q [91] <<((CTCS_Properties::start)^1 = (s)^1)
  and
  ((i)^1 = (0)^1)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Constants are always the same
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 14:
Theorem (14) [serial 1048] used for:
    normalization of [serial 1044]
 


Theorem (16)                               [serial 1038] 
P [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
S [121] ->
Q [91] <<(CTCS_Properties::start = s)^1 and (i = 0)^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 15:
Theorem (15) [serial 1044] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1038]
 


Theorem (17)                               [serial 1033] 
P [137] <<((i)^1 = 0)
  and
  ((s)^1 = CTCS_Properties::start)>>
S [121] ->
Q [91] <<((i = 0)^1 and (s = CTCS_Properties::start)^1)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 16:
Theorem (16) [serial 1038] used for:
    normalization of [serial 1033]
 


Theorem (18)                               [serial 1030] 
P [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
S [121] ->
Q [91] <<((i = 0) and (s = CTCS_Properties::start))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 17:
Theorem (17) [serial 1033] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1030]
 


Theorem (19)                               [serial 1057] 
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134] ->
Q [1] <<(e-SR) <= s or CTCS_Properties::start = s>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (20)                               [serial 1053] 
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134] ->
Q [1] <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Zero is unique element: x+0 = x      x-0 = x
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 19:
Theorem (19) [serial 1057] used for:
    normalization of [serial 1053]
 


Theorem (21)                               [serial 1059] 
P [134] <<r^0 and (CTCS_Properties::start = s and i = 0)>>
S [134] ->
Q [135] <<CTCS_Properties::start = s and i = 0>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (22)                               [serial 1054] 
P [134] <<(CTCS_Properties::start = s and i = 0) and r^0>>
S [134] ->
Q [135] <<CTCS_Properties::start = s and i = 0>>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 21:
Theorem (21) [serial 1059] used for:
    normalization of [serial 1054]
 


Theorem (23)                               [serial 1036] 
P [133] <<CTCS_Properties::start = s and i = 0>>
S [134] r!
Q [135] <<CTCS_Properties::start = s and i = 0>>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 20 22:
Theorem (20) [serial 1053] used for:
  applied port output <<pre>> -> <<M(r)>> [serial 1036]
 
Theorem (22) [serial 1054] used for:
  applied port output <<pre and r^0>> -> <<post>> [serial 1036]
 


Theorem (24)                               [serial 1031] 
P [133] <<(i = 0) and (s = CTCS_Properties::start)>>
S [134] r!
Q [135] <<(i = 0) and (s = CTCS_Properties::start)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 23:
Theorem (23) [serial 1036] used for:
    normalization of [serial 1031]
 


Theorem (25)                               [serial 1061] 
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136] ->
Q [137] <<CTCS_Properties::start = s and i = 0>>
by Identity (id):  P->P is tautology


Theorem (26)                               [serial 1063] 
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136] ->
Q [137] <<CTCS_Properties::start = s and i = 0>>
by Identity (id):  P->P is tautology


Theorem (27)                               [serial 1055] 
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136] ->
Q [137] <<i = 0 and s = CTCS_Properties::start>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorems 25 26:
Theorem (25) [serial 1061] used for:
    normalization of [serial 1055]
 
Theorem (26) [serial 1063] used for:
    normalization of [serial 1055]
 


Theorem (28)                               [serial 1040] 
P [135] <<CTCS_Properties::start = s and i = 0>>
S [136] ( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
by Simultaneous Assignment
and theorem 27:
Theorem (27) [serial 1055] used for:
  applied wp for simultaneous assignment [serial 1040]
 


Theorem (29)                               [serial 1034] 
P [135] <<(i = 0) and (s = CTCS_Properties::start)>>
S [136] ( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<((i)^1 = 0)
  and
  ((s)^1 = CTCS_Properties::start)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 28:
Theorem (28) [serial 1040] used for:
    normalization of [serial 1034]
 


Theorem (30)                               [serial 1032] 
P [135] <<(i = 0) and (s = CTCS_Properties::start)>>
S [136] ( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [137] <<(i' = 0) and (s' = CTCS_Properties::start)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 29:
Theorem (29) [serial 1034] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1032]
 


Theorem (31)                               [serial 1011] 
P [120] <<(i = 0) and (s = CTCS_Properties::start)>>
S [134] <<(i = 0) and (s = CTCS_Properties::start)>>
r!
;
<<(i = 0) and (s = CTCS_Properties::start)>>
( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

<<(i' = 0) and (s' = CTCS_Properties::start)>>
Q [121] <<((i = 0) and (s = CTCS_Properties::start))^1>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 13 18 24 30:
Theorem (13) [serial 1029] used for:
  P -> P1 in sequential composition for [serial 1011]
 
Theorem (18) [serial 1030] used for:
  Q1 -> Q in sequential composition for [serial 1011]
 
Theorem (24) [serial 1031] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1011]
 
Theorem (30) [serial 1032] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1011]
 


Theorem (32)                               [serial 1073] 
P [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
S [122] ->
Q [122] <<CTCS_Properties::start = s and i = 0>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (33)                               [serial 1069] 
P [142] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
S [122] ->
Q [122] <<(i = 0) and (s = CTCS_Properties::start)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 32:
Theorem (32) [serial 1073] used for:
    normalization of [serial 1069]
 


Theorem (34)                               [serial 1089] 
P [141] <<CTCS_Properties::start = s and i = 0 and IMA = iMA>>
S [141] ->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (35)                               [serial 1084] 
P [141] <<IMA = iMA and (CTCS_Properties::start = s and i = 0)>>
S [141] ->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
by Associativity: (b.c).a = a.b.c
and theorem 34:
Theorem (34) [serial 1089] used for:
  Associativity: (b.c).a = a.b.c [serial 1084]
 


Theorem (36)                               [serial 1081] 
P [141] <<(CTCS_Properties::start = s and i = 0) and iMA = IMA>>
S [141] ->
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 35:
Theorem (35) [serial 1084] used for:
    normalization of [serial 1081]
 


Theorem (37)                               [serial 1075] 
P [121] <<CTCS_Properties::start = s and i = 0>>
S [141] m?(iMA)
Q [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
by Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
and theorem 36:
Theorem (36) [serial 1081] used for:
  applied port input of value <<pre and iMA=M(m)>> -> <<post>> [serial 1075]
 


Theorem (38)                               [serial 1070] 
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [141] m?(iMA)
Q [141] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 37:
Theorem (37) [serial 1075] used for:
    normalization of [serial 1070]
 


Theorem (39)                               [serial 1090] 
P [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0 and e = ea>>
S [142] ->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (40)                               [serial 1086] 
P [142] <<e = ea and (CTCS_Properties::start = s and IMA = iMA and i = 0)>>
S [142] ->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
by Associativity: (b.c).a = a.b.c
and theorem 39:
Theorem (39) [serial 1090] used for:
  Associativity: (b.c).a = a.b.c [serial 1086]
 


Theorem (41)                               [serial 1082] 
P [142] <<(CTCS_Properties::start = s and IMA = iMA and i = 0) and e = ea>>
S [142] ->
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 40:
Theorem (40) [serial 1086] used for:
    normalization of [serial 1082]
 


Theorem (42)                               [serial 1077] 
P [141] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
S [142] ea?(e)
Q [142] <<CTCS_Properties::start = s and IMA = iMA and i = 0>>
by Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
and theorem 41:
Theorem (41) [serial 1082] used for:
  applied port input of value <<pre and e=M(ea)>> -> <<post>> [serial 1077]
 


Theorem (43)                               [serial 1071] 
P [141] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
S [142] ea?(e)
Q [142] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 42:
Theorem (42) [serial 1077] used for:
    normalization of [serial 1071]
 


Theorem (44)                               [serial 1012] 
P [121] <<(i = 0) and (s = CTCS_Properties::start)>>
S [141] m?(iMA)
;
<<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
ea?(e)
<<(i = 0) and (s = CTCS_Properties::start) and (iMA = IMA)>>
Q [122] <<(i = 0) and (s = CTCS_Properties::start)>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 33 38 43:
Theorem (33) [serial 1069] used for:
  Q1 -> Q in sequential composition for [serial 1012]
 
Theorem (38) [serial 1070] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1012]
 
Theorem (43) [serial 1071] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1012]
 


Theorem (45)                               [serial 1091] 
P [148] <<(SBL() and DSPV2())^1>>
S [124] ->
Q [124] <<(SBL() and DSPV2())^1>>
by Identity (id):  P->P is tautology


Theorem (46)                               [serial 1129] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (47)                               [serial 1124] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [95] <<(CTCS_Properties::start = s or v < iSeg.v2)>>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 46:
Theorem (46) [serial 1129] used for:
    normalization of [serial 1124]
 


Theorem (48)                               [serial 1131] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (49)                               [serial 1125] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [98] <<(CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 48:
Theorem (48) [serial 1131] used for:
    normalization of [serial 1125]
 


Theorem (50)                               [serial 1119] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 47 49:
Theorem (47) [serial 1124] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1119]
 
Theorem (49) [serial 1125] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1119]
 


Theorem (51)                               [serial 1133] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (52)                               [serial 1126] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [95] <<(CTCS_Properties::start = s or v < iSeg.v2)>>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 51:
Theorem (51) [serial 1133] used for:
    normalization of [serial 1126]
 


Theorem (53)                               [serial 1135] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (54)                               [serial 1127] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [98] <<(CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 53:
Theorem (53) [serial 1135] used for:
    normalization of [serial 1127]
 


Theorem (55)                               [serial 1121] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 52 54:
Theorem (52) [serial 1126] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1121]
 
Theorem (54) [serial 1127] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1121]
 


Theorem (56)                               [serial 1117] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ->
Q [148] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
and theorems 50 55:
Theorem (50) [serial 1119] used for:
    normalization of [serial 1117]
 
Theorem (55) [serial 1121] used for:
    normalization of [serial 1117]
 


Theorem (57)                               [serial 1114] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
by Simultaneous Assignment
and theorem 56:
Theorem (56) [serial 1117] used for:
  applied wp for simultaneous assignment [serial 1114]
 


Theorem (58)                               [serial 1112] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
  (iSeg.e)^1)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 57:
Theorem (57) [serial 1114] used for:
    normalization of [serial 1112]
 


Theorem (59)                               [serial 1110] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 58:
Theorem (58) [serial 1112] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1110]
 


Theorem (60)                               [serial 1108] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 59:
Theorem (59) [serial 1110] used for:
    normalization of [serial 1108]
 


Theorem (61)                               [serial 1106] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 60:
Theorem (60) [serial 1108] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1106]
 


Theorem (62)                               [serial 1104] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(((CTCS_Properties::start)^1 = (s)^1)
  or ((v)^1 < (iSeg.v2)^1))
  and
  (((CTCS_Properties::start)^1 = (s)^1)
  or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 61:
Theorem (61) [serial 1106] used for:
    normalization of [serial 1104]
 


Theorem (63)                               [serial 1102] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 62:
Theorem (62) [serial 1104] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1102]
 


Theorem (64)                               [serial 1100] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 63:
Theorem (63) [serial 1102] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1100]
 


Theorem (65)                               [serial 1098] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 64:
Theorem (64) [serial 1100] used for:
    normalization of [serial 1098]
 


Theorem (66)                               [serial 1095] 
P [122] <<CTCS_Properties::start = s and i = 0 and not iMA = >>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 65:
Theorem (65) [serial 1098] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1095]
 


Theorem (67)                               [serial 1093] 
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 66:
Theorem (66) [serial 1095] used for:
    normalization of [serial 1093]
 


Theorem (68)                               [serial 1092] 
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [148] <<(SBL() and DSPV2())^1>>
by Substitution of Assertion Labels
and theorem 67:
Theorem (67) [serial 1093] used for:
  substituted Assertions' predicates for  labels  [serial 1092]
 


Theorem (69)                               [serial 1013] 
P [122] <<(i = 0)
  and
  (s = CTCS_Properties::start)
  and
  (not (iMA = ))>>
S [147] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(SBL() and DSPV2())^1>>
Q [124] <<(SBL() and DSPV2())^1>>
by Introduction of Existential Quantification (bl.aapost)
and theorems 45 68:
Theorem (45) [serial 1091] used for:
  as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1013]
 
Theorem (68) [serial 1092] used for:
  as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1013]
 


Theorem (70)                               [serial 1140] 
P [167] <<SBL() and DSPV2()>>
S [125] ->
Q [125] <<SBL() and DSPV2()>>
by Identity (id):  P->P is tautology


Theorem (71)                               [serial 1154] 
P [124] <<DSPV2() and SBL()>>
S [153] ->
Q [153] <<DSPV2() and SBL()>>
by Identity (id):  P->P is tautology


Theorem (72)                               [serial 1143] 
P [124] <<SBL() and DSPV2()>>
S [153] ->
Q [153] <<SBL() and DSPV2()>>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 71:
Theorem (71) [serial 1154] used for:
    normalization of [serial 1143]
 


Theorem (73)                               [serial 1187] 
P [153] <<DSPV2() and SBL()>>
S [153] ->
Q [153] <<DSPV2() and SBL()>>
by Identity (id):  P->P is tautology


Theorem (74)                               [serial 1201] 
P [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
S [154] ->
Q [154] <<POSITION = s and VELOCITY = v and DSPV2() and SBL()>>
by Identity (id):  P->P is tautology


Theorem (75)                               [serial 1188] 
P [154] <<(POSITION = s) and (VELOCITY = v) and (DSPV2()) and (SBL())>>
S [154] ->
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
by Normalization
  Normalization Axioms:
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 74:
Theorem (74) [serial 1201] used for:
    normalization of [serial 1188]
 


Theorem (76)                               [serial 1212] 
P [154] <<DSPV2() and SBL() and POSITION = s>>
S [154] ->
Q [154] <<POSITION = s>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (77)                               [serial 1203] 
P [154] <<POSITION = s and (DSPV2() and SBL())>>
S [154] ->
Q [154] <<POSITION = s>>
by Associativity: (b.c).a = a.b.c
and theorem 76:
Theorem (76) [serial 1212] used for:
  Associativity: (b.c).a = a.b.c [serial 1203]
 


Theorem (78)                               [serial 1194] 
P [154] <<(DSPV2() and SBL()) and s = POSITION>>
S [154] ->
Q [154] <<POSITION = s>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 77:
Theorem (77) [serial 1203] used for:
    normalization of [serial 1194]
 


Theorem (79)                               [serial 1189] 
P [153] <<DSPV2() and SBL()>>
S [154] cs?(s)
Q [154] <<POSITION = s>>
by Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
and theorem 78:
Theorem (78) [serial 1194] used for:
  applied port input of value <<pre and s=M(cs)>> -> <<post>> [serial 1189]
 


Theorem (80)                               [serial 1213] 
P [154] <<DSPV2() and SBL() and VELOCITY = v>>
S [154] ->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (81)                               [serial 1205] 
P [154] <<VELOCITY = v and (DSPV2() and SBL())>>
S [154] ->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
by Associativity: (b.c).a = a.b.c
and theorem 80:
Theorem (80) [serial 1213] used for:
  Associativity: (b.c).a = a.b.c [serial 1205]
 


Theorem (82)                               [serial 1195] 
P [154] <<(DSPV2() and SBL()) and v = VELOCITY>>
S [154] ->
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 81:
Theorem (81) [serial 1205] used for:
    normalization of [serial 1195]
 


Theorem (83)                               [serial 1190] 
P [153] <<DSPV2() and SBL()>>
S [154] cv?(v)
Q [154] <<VELOCITY = v and DSPV2() and SBL()>>
by Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
and theorem 82:
Theorem (82) [serial 1195] used for:
  applied port input of value <<pre and v=M(cv)>> -> <<post>> [serial 1190]
 


Theorem (84)                               [serial 1183] 
P [153] <<DSPV2() and SBL()>>
S [154] <<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
by Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>> (bl.cck)
and theorems 73 75 79 83:
Theorem (73) [serial 1187] used for:
  P -> P1 in concurrent composition for [serial 1183]
 
Theorem (75) [serial 1188] used for:
  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1183]
 
Theorem (79) [serial 1189] used for:
  <<P1>> S1 <<Q1>> in concurrent composition for [serial 1183]
 
Theorem (83) [serial 1190] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1183]
 


Theorem (85)                               [serial 1156] 
P [153] <<DSPV2() and SBL()>>
S [154] <<DSPV2() and SBL()>>
cs?(s)
<<POSITION = s>>
&
cv?(v)
<<VELOCITY = v and DSPV2() and SBL()>>
Q [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
by Associativity: (b.c).a = a.b.c
and theorem 84:
Theorem (84) [serial 1183] used for:
  Associativity: (b.c).a = a.b.c [serial 1156]
 


Theorem (86)                               [serial 1144] 
P [153] <<SBL() and DSPV2()>>
S [154] <<SBL() and DSPV2()>>
cs?(s)
<<s = POSITION>>
&
cv?(v)
<<SBL() and DSPV2() and v = VELOCITY>>
Q [154] <<(s = POSITION) and (SBL() and DSPV2() and v = VELOCITY)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 85:
Theorem (85) [serial 1156] used for:
    normalization of [serial 1144]
 


Theorem (87)                               [serial 1184] 
P [154] <<VELOCITY = v and DSPV2() and SBL() and POSITION = s>>
S [153] ->
Q [156] <<DSPV2() and SBL()>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (88)                               [serial 1158] 
P [154] <<POSITION = s and (VELOCITY = v and DSPV2() and SBL())>>
S [153] ->
Q [156] <<DSPV2() and SBL()>>
by Associativity: (b.c).a = a.b.c
and theorem 87:
Theorem (87) [serial 1184] used for:
  Associativity: (b.c).a = a.b.c [serial 1158]
 


Theorem (89)                               [serial 1145] 
P [154] <<(s = POSITION) and (SBL() and DSPV2() and v = VELOCITY)>>
S [153] ->
Q [156] <<SBL() and DSPV2()>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 88:
Theorem (88) [serial 1158] used for:
    normalization of [serial 1145]
 


Theorem (90)                               [serial 1141] 
P [124] <<SBL() and DSPV2()>>
S [153] {
 <<SBL() and DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<SBL() and DSPV2() and v = VELOCITY>>
} 
Q [156] <<SBL() and DSPV2()>>
by Introduction of Existential Quantification (bl.elq)
and theorems 72 86 89:
Theorem (72) [serial 1143] used for:
  <<P and x=e>> -> <<A>> in existential lattice quantification for [serial 1141]
 
Theorem (86) [serial 1144] used for:
  {A} T {B} in existential lattice quantification for [serial 1141]
 
Theorem (89) [serial 1145] used for:
  <<B>> -> <<Q>> in existential lattice quantification for [serial 1141]
 


Theorem (91)                               [serial 1185] 
P [156] <<DSPV2() and SBL()>>
S [157] ->
Q [157] <<true>>
by True Conclusion Schema (tc): P->true


Theorem (92)                               [serial 1160] 
P [156] <<DSPV2() and SBL()>>
S [157] ->
Q [157] <<(e-SR) <= s or not (e-SR) <= s>>
by Law of Excluded Middle: P or not P is tautology
and theorem 91:
Theorem (91) [serial 1185] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1160]
 


Theorem (93)                               [serial 1146] 
P [156] <<SBL() and DSPV2()>>
S [157] ->
Q [157] <<(s >= (e-SR))
or (not (s >= (e-SR)))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 92:
Theorem (92) [serial 1160] used for:
    normalization of [serial 1146]
 


Theorem (94)                               [serial 1186] 
P [157] <<DSPV2() and SBL() and (e-SR) <= s>>
S [157] ->
Q [158] <<(e-SR) <= s and DSPV2() and SBL()>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (95)                               [serial 1162] 
P [157] <<(e-SR) <= s and (DSPV2() and SBL())>>
S [157] ->
Q [158] <<(e-SR) <= s and DSPV2() and SBL()>>
by Associativity: (b.c).a = a.b.c
and theorem 94:
Theorem (94) [serial 1186] used for:
  Associativity: (b.c).a = a.b.c [serial 1162]
 


Theorem (96)                               [serial 1147] 
P [157] <<(SBL() and DSPV2()) and (s >= (e-SR))>>
S [157] ->
Q [158] <<SBL() and DSPV2() and (s >= (e-SR))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 95:
Theorem (95) [serial 1162] used for:
    normalization of [serial 1147]
 


Theorem (97)                               [serial 1197] 
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159] ->
Q [1] <<(e-SR) <= s or CTCS_Properties::start = s>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (98)                               [serial 1191] 
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159] ->
Q [1] <<(s = CTCS_Properties::start) or (s >= (e-SR))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Zero is unique element: x+0 = x      x-0 = x
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 97:
Theorem (97) [serial 1197] used for:
    normalization of [serial 1191]
 


Theorem (99)                               [serial 1211] 
P [159] <<(e-SR) <= s and DSPV2() and SBL() and r^0>>
S [159] ->
Q [160] <<DSPV2() and SBL()>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (100)                               [serial 1199] 
P [159] <<r^0 and ((e-SR) <= s and DSPV2() and SBL())>>
S [159] ->
Q [160] <<DSPV2() and SBL()>>
by Associativity: (b.c).a = a.b.c
and theorem 99:
Theorem (99) [serial 1211] used for:
  Associativity: (b.c).a = a.b.c [serial 1199]
 


Theorem (101)                               [serial 1192] 
P [159] <<((e-SR) <= s and DSPV2() and SBL()) and r^0>>
S [159] ->
Q [160] <<DSPV2() and SBL()>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 100:
Theorem (100) [serial 1199] used for:
    normalization of [serial 1192]
 


Theorem (102)                               [serial 1164] 
P [158] <<(e-SR) <= s and DSPV2() and SBL()>>
S [159] r!
Q [160] <<DSPV2() and SBL()>>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 98 101:
Theorem (98) [serial 1191] used for:
  applied port output <<pre>> -> <<M(r)>> [serial 1164]
 
Theorem (101) [serial 1192] used for:
  applied port output <<pre and r^0>> -> <<post>> [serial 1164]
 


Theorem (103)                               [serial 1148] 
P [158] <<SBL() and DSPV2() and (s >= (e-SR))>>
S [159] r!
Q [160] <<SBL() and DSPV2()>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 102:
Theorem (102) [serial 1164] used for:
    normalization of [serial 1148]
 


Theorem (104)                               [serial 1166] 
P [160] <<DSPV2() and SBL()>>
S [157] ->
Q [167] <<DSPV2() and SBL()>>
by Identity (id):  P->P is tautology


Theorem (105)                               [serial 1149] 
P [160] <<SBL() and DSPV2()>>
S [157] ->
Q [167] <<SBL() and DSPV2()>>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 104:
Theorem (104) [serial 1166] used for:
    normalization of [serial 1149]
 


Theorem (106)                               [serial 1168] 
P [157] <<not (e-SR) <= s and (DSPV2() and SBL())>>
S [157] ->
Q [163] <<DSPV2() and SBL()>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (107)                               [serial 1150] 
P [157] <<(SBL() and DSPV2())
  and
  (not (s >= (e-SR)))>>
S [157] ->
Q [163] <<SBL() and DSPV2()>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 106:
Theorem (106) [serial 1168] used for:
    normalization of [serial 1150]
 


Theorem (108)                               [serial 1193] 
P [163] <<DSPV2() and SBL()>>
S [164] ->
Q [165] <<DSPV2() and SBL()>>
by Identity (id):  P->P is tautology


Theorem (109)                               [serial 1170] 
P [163] <<DSPV2() and SBL()>>
S [164] skip
Q [165] <<DSPV2() and SBL()>>
by Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>> (bl.skip)
and theorem 108:
Theorem (108) [serial 1193] used for:
    <<P>> -> <<Q>>
  for [serial 1170]
 


Theorem (110)                               [serial 1151] 
P [163] <<SBL() and DSPV2()>>
S [164] skip
Q [165] <<SBL() and DSPV2()>>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 109:
Theorem (109) [serial 1170] used for:
    normalization of [serial 1151]
 


Theorem (111)                               [serial 1172] 
P [165] <<DSPV2() and SBL()>>
S [157] ->
Q [167] <<DSPV2() and SBL()>>
by Identity (id):  P->P is tautology


Theorem (112)                               [serial 1152] 
P [165] <<SBL() and DSPV2()>>
S [157] ->
Q [167] <<SBL() and DSPV2()>>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 111:
Theorem (111) [serial 1172] used for:
    normalization of [serial 1152]
 


Theorem (113)                               [serial 1142] 
P [156] <<SBL() and DSPV2()>>
S [157] if 
(s >= (e-SR))~> 
  <<SBL() and DSPV2() and (s >= (e-SR))>>
  r!
  <<SBL() and DSPV2()>> 
[]
(not (s >= (e-SR)))~> 
  <<SBL() and DSPV2()>>
  skip
  <<SBL() and DSPV2()>> 
fi
Q [167] <<SBL() and DSPV2()>>
by Alternative Rule:
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<B1 and P1>> S1 <<Q1>>, <<B2 and P2>> S2 <<Q2>>, . . . , <<Bn and Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 93 96 103 105 107 110 112:
Theorem (93) [serial 1146] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 1142]
 
Theorem (96) [serial 1147] used for:
    <<P and B0>> -> <<P0>>  for [serial 1142]
 
Theorem (103) [serial 1148] used for:
    <<P0>> S0 <<Q0>>  for [serial 1142]
 
Theorem (105) [serial 1149] used for:
    <<Q0>> -> <<Q>>  for [serial 1142]
 
Theorem (107) [serial 1150] used for:
    <<P and B1>> -> <<P1>>  for [serial 1142]
 
Theorem (110) [serial 1151] used for:
    <<P1>> S1 <<Q1>>  for [serial 1142]
 
Theorem (112) [serial 1152] used for:
    <<Q1>> -> <<Q>>  for [serial 1142]
 


Theorem (114)                               [serial 1014] 
P [124] <<SBL() and DSPV2()>>
S [154] {
 <<SBL() and DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<SBL() and DSPV2() and v = VELOCITY>>
} 
;
<<SBL() and DSPV2()>>
if 
(s >= (e-SR))~> 
  <<SBL() and DSPV2() and (s >= (e-SR))>>
  r!
  <<SBL() and DSPV2()>> 
[]
(not (s >= (e-SR)))~> 
  <<SBL() and DSPV2()>>
  skip
  <<SBL() and DSPV2()>> 
fi
<<SBL() and DSPV2()>>
Q [125] <<SBL() and DSPV2()>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 70 90 113:
Theorem (70) [serial 1140] used for:
  Q1 -> Q in sequential composition for [serial 1014]
 
Theorem (90) [serial 1141] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1014]
 
Theorem (113) [serial 1142] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1014]
 


Theorem (115)                               [serial 1220] 
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [125] ->
Q [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (116)                               [serial 1218] 
P [125] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [125] ->
Q [174] <<not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 115:
Theorem (115) [serial 1220] used for:
    normalization of [serial 1218]
 


Theorem (117)                               [serial 1214] 
P [125] <<SBL()
  and
  DSPV2()
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [125] ->
Q [174] <<not SBL() or not DSPV2()>>
by Substitution of Assertion Labels
and theorem 116:
Theorem (116) [serial 1218] used for:
  substituted Assertions' predicates for  labels  [serial 1214]
 


Theorem (118)                               [serial 1215] 
P [176] <<(not SBL() or not DSPV2())^1>>
S [126] ->
Q [91] <<(not SBL() or not DSPV2())^1>>
by Identity (id):  P->P is tautology


Theorem (119)                               [serial 1225] 
P [174] <<CTCS_Properties::SB_Rate = ca and (not DSPV2() or not SBL())>>
S [174] ->
Q [174] <<not DSPV2() or not SBL()>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (120)                               [serial 1223] 
P [174] <<(not SBL() or not DSPV2())
  and
  (ca = (CTCS_Properties::SB_Rate))^0>>
S [174] ->
Q [174] <<not SBL() or not DSPV2()>>
by Assume Present:  P = P@now = P^0 
and theorem 119:
Theorem (119) [serial 1225] used for:
  Assume Present:  P = P@now = P^0  [serial 1223]
 


Theorem (121)                               [serial 1227] 
P [174] <<not DSPV2() or not SBL()>>
S [174] ->
Q [102] <<not DSPV2() or not SBL()>>
by Identity (id):  P->P is tautology


Theorem (122)                               [serial 1224] 
P [174] <<not SBL() or not DSPV2()>>
S [174] ->
Q [102] <<(not SBL() or not DSPV2())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Disjunction: (m or k) = (k or m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 121:
Theorem (121) [serial 1227] used for:
    normalization of [serial 1224]
 


Theorem (123)                               [serial 1216] 
P [174] <<not SBL() or not DSPV2()>>
S [174] ca!(CTCS_Properties::SB_Rate)
Q [174] <<not SBL() or not DSPV2()>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 120 122:
Theorem (120) [serial 1223] used for:
  applied port output <<pre and (ca=CTCS_Properties::SB_Rate)^0>> -> <<post>> [serial 1216]
 
Theorem (122) [serial 1224] used for:
  applied port output of conditional expression <<pre>> -> <<(not SBL() or not DSPV2())>> where (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate for ca!(CTCS_Properties::SB_Rate) 
[serial 1216]
 


Theorem (124)                               [serial 1260] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ->
Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Identity (id):  P->P is tautology


Theorem (125)                               [serial 1262] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ->
Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Identity (id):  P->P is tautology


Theorem (126)                               [serial 1258] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ->
Q [176] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
and theorems 124 125:
Theorem (124) [serial 1260] used for:
    normalization of [serial 1258]
 
Theorem (125) [serial 1262] used for:
    normalization of [serial 1258]
 


Theorem (127)                               [serial 1255] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
by Simultaneous Assignment
and theorem 126:
Theorem (126) [serial 1258] used for:
  applied wp for simultaneous assignment [serial 1255]
 


Theorem (128)                               [serial 1253] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
(iSeg.e)^1)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 127:
Theorem (127) [serial 1255] used for:
    normalization of [serial 1253]
 


Theorem (129)                               [serial 1251] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 128:
Theorem (128) [serial 1253] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1251]
 


Theorem (130)                               [serial 1249] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 129:
Theorem (129) [serial 1251] used for:
    normalization of [serial 1249]
 


Theorem (131)                               [serial 1247] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 130:
Theorem (130) [serial 1249] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1247]
 


Theorem (132)                               [serial 1245] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (((CTCS_Properties::start)^1 = (s)^1)
or ((v)^1 < (iSeg.v2)^1))
or not (((CTCS_Properties::start)^1 = (s)^1)
or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 131:
Theorem (131) [serial 1247] used for:
    normalization of [serial 1245]
 


Theorem (133)                               [serial 1243] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not ((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
or not ((CTCS_Properties::start = s)^1
or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 132:
Theorem (132) [serial 1245] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1243]
 


Theorem (134)                               [serial 1241] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not (CTCS_Properties::start = s or v < iSeg.v2)^1
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 133:
Theorem (133) [serial 1243] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1241]
 


Theorem (135)                               [serial 1239] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<not ((CTCS_Properties::start = s or v < iSeg.v2))^1
or not ((CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 134:
Theorem (134) [serial 1241] used for:
    normalization of [serial 1239]
 


Theorem (136)                               [serial 1237] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 135:
Theorem (135) [serial 1239] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1237]
 


Theorem (137)                               [serial 1235] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<((not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 136:
Theorem (136) [serial 1237] used for:
    normalization of [serial 1235]
 


Theorem (138)                               [serial 1232] 
P [174] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 137:
Theorem (137) [serial 1235] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1232]
 


Theorem (139)                               [serial 1230] 
P [174] <<not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 138:
Theorem (138) [serial 1232] used for:
    normalization of [serial 1230]
 


Theorem (140)                               [serial 1217] 
P [174] <<not SBL() or not DSPV2()>>
S [175] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [176] <<(not SBL() or not DSPV2())^1>>
by Substitution of Assertion Labels
and theorem 139:
Theorem (139) [serial 1230] used for:
  substituted Assertions' predicates for  labels  [serial 1217]
 


Theorem (141)                               [serial 1015] 
P [125] <<SBL()
  and
  DSPV2()
  and
  (not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [174] <<not SBL() or not DSPV2()>>
ca!(CTCS_Properties::SB_Rate)
;
<<not SBL() or not DSPV2()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not SBL() or not DSPV2())^1>>
Q [126] <<(not SBL() or not DSPV2())^1>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 117 118 123 140:
Theorem (117) [serial 1214] used for:
  P -> P1 in sequential composition for [serial 1015]
 
Theorem (118) [serial 1215] used for:
  Q1 -> Q in sequential composition for [serial 1015]
 
Theorem (123) [serial 1216] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]
 
Theorem (140) [serial 1217] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]
 


Theorem (142)                               [serial 1265] 
P [125] <<SBL()
  and
  DSPV2()
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [125] ->
Q [181] <<SBL() and DSPV2()>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (143)                               [serial 1266] 
P [183] <<(SBL() and DSPV2())^1>>
S [124] ->
Q [91] <<(SBL() and DSPV2())^1>>
by Identity (id):  P->P is tautology


Theorem (144)                               [serial 1272] 
P [181] <<ca = xl and (DSPV2() and SBL())>>
S [181] ->
Q [181] <<DSPV2() and SBL()>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (145)                               [serial 1270] 
P [181] <<(SBL() and DSPV2()) and (ca = xl)^0>>
S [181] ->
Q [181] <<SBL() and DSPV2()>>
by Assume Present:  P = P@now = P^0 
and theorem 144:
Theorem (144) [serial 1272] used for:
  Assume Present:  P = P@now = P^0  [serial 1270]
 


Theorem (146)                               [serial 1274] 
P [181] <<DSPV2() and SBL()>>
S [181] ->
Q [104] <<DSPV2() and SBL()>>
by Identity (id):  P->P is tautology


Theorem (147)                               [serial 1271] 
P [181] <<SBL() and DSPV2()>>
S [181] ->
Q [104] <<(SBL() and DSPV2())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 146:
Theorem (146) [serial 1274] used for:
    normalization of [serial 1271]
 


Theorem (148)                               [serial 1267] 
P [181] <<SBL() and DSPV2()>>
S [181] ca!(xl)
Q [181] <<SBL() and DSPV2()>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 145 147:
Theorem (145) [serial 1270] used for:
  applied port output <<pre and (ca=xl)^0>> -> <<post>> [serial 1267]
 
Theorem (147) [serial 1271] used for:
  applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1267]
 


Theorem (149)                               [serial 1276] 
P [181] <<SBL() and DSPV2()>>
S [182] ->
Q [182] <<SBL() and DSPV2()>>
by Identity (id):  P->P is tautology


Theorem (150)                               [serial 1268] 
P [181] <<SBL() and DSPV2()>>
S [182] ( --begining of simultaneous assignment
 i,
 iSeg,
 nSeg
:=
 i+1,
 nSeg,
 iMA[i+2]
) --end of simultaneous assignment

Q [182] <<SBL() and DSPV2()>>
by Simultaneous Assignment
and theorem 149:
Theorem (149) [serial 1276] used for:
  applied wp for simultaneous assignment [serial 1268]
 


Theorem (151)                               [serial 1303] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ->
Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Identity (id):  P->P is tautology


Theorem (152)                               [serial 1305] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ->
Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Identity (id):  P->P is tautology


Theorem (153)                               [serial 1301] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ->
Q [183] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
and theorems 151 152:
Theorem (151) [serial 1303] used for:
    normalization of [serial 1301]
 
Theorem (152) [serial 1305] used for:
    normalization of [serial 1301]
 


Theorem (154)                               [serial 1298] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
by Simultaneous Assignment
and theorem 153:
Theorem (153) [serial 1301] used for:
  applied wp for simultaneous assignment [serial 1298]
 


Theorem (155)                               [serial 1296] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
  (iSeg.e)^1)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 154:
Theorem (154) [serial 1298] used for:
    normalization of [serial 1296]
 


Theorem (156)                               [serial 1294] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 155:
Theorem (155) [serial 1296] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1294]
 


Theorem (157)                               [serial 1292] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 156:
Theorem (156) [serial 1294] used for:
    normalization of [serial 1292]
 


Theorem (158)                               [serial 1290] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 157:
Theorem (157) [serial 1292] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1290]
 


Theorem (159)                               [serial 1288] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(((CTCS_Properties::start)^1 = (s)^1)
  or ((v)^1 < (iSeg.v2)^1))
  and
  (((CTCS_Properties::start)^1 = (s)^1)
  or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 158:
Theorem (158) [serial 1290] used for:
    normalization of [serial 1288]
 


Theorem (160)                               [serial 1286] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 159:
Theorem (159) [serial 1288] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1286]
 


Theorem (161)                               [serial 1284] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 160:
Theorem (160) [serial 1286] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1284]
 


Theorem (162)                               [serial 1282] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 161:
Theorem (161) [serial 1284] used for:
    normalization of [serial 1282]
 


Theorem (163)                               [serial 1279] 
P [182] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 162:
Theorem (162) [serial 1282] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1279]
 


Theorem (164)                               [serial 1277] 
P [182] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 163:
Theorem (163) [serial 1279] used for:
    normalization of [serial 1277]
 


Theorem (165)                               [serial 1269] 
P [182] <<SBL() and DSPV2()>>
S [183] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [183] <<(SBL() and DSPV2())^1>>
by Substitution of Assertion Labels
and theorem 164:
Theorem (164) [serial 1277] used for:
  substituted Assertions' predicates for  labels  [serial 1269]
 


Theorem (166)                               [serial 1016] 
P [125] <<SBL()
  and
  DSPV2()
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [181] <<SBL() and DSPV2()>>
ca!(xl)
;
<<SBL() and DSPV2()>>
( --begining of simultaneous assignment
 i,
 iSeg,
 nSeg
:=
 i+1,
 nSeg,
 iMA[i+2]
) --end of simultaneous assignment

;
<<SBL() and DSPV2()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(SBL() and DSPV2())^1>>
Q [124] <<(SBL() and DSPV2())^1>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 142 143 148 150 165:
Theorem (142) [serial 1265] used for:
  P -> P1 in sequential composition for [serial 1016]
 
Theorem (143) [serial 1266] used for:
  Q2 -> Q in sequential composition for [serial 1016]
 
Theorem (148) [serial 1267] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1016]
 
Theorem (150) [serial 1268] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
 
Theorem (165) [serial 1269] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1016]
 


Theorem (167)                               [serial 1309] 
P [126] <<not SBL() or not DSPV2()>>
S [188] ->
Q [188] <<not SBL() or not DSPV2()>>
by Identity (id):  P->P is tautology


Theorem (168)                               [serial 1312] 
P [188] <<not SBL() or not DSPV2()>>
S [188] ->
Q [188] <<not SBL() or not DSPV2()>>
by Identity (id):  P->P is tautology


Theorem (169)                               [serial 1328] 
P [189] <<POSITION = s and VELOCITY = v and (not DSPV2() or not SBL())>>
S [189] ->
Q [189] <<VELOCITY = v and (not DSPV2() or not SBL()) and POSITION = s>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (170)                               [serial 1317] 
P [189] <<POSITION = s and VELOCITY = v and (not DSPV2() or not SBL())>>
S [189] ->
Q [189] <<POSITION = s and (VELOCITY = v and (not DSPV2() or not SBL()))>>
by Associativity: (b.c).a = a.b.c
and theorem 169:
Theorem (169) [serial 1328] used for:
  Associativity: (b.c).a = a.b.c [serial 1317]
 


Theorem (171)                               [serial 1313] 
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()))
  and
  ((v = VELOCITY))>>
S [189] ->
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 170:
Theorem (170) [serial 1317] used for:
    normalization of [serial 1313]
 


Theorem (172)                               [serial 1333] 
P [189] <<POSITION = s and (not DSPV2() or not SBL())>>
S [189] ->
Q [189] <<POSITION = s>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (173)                               [serial 1330] 
P [189] <<(not DSPV2() or not SBL()) and s = POSITION>>
S [189] ->
Q [189] <<POSITION = s>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 172:
Theorem (172) [serial 1333] used for:
    normalization of [serial 1330]
 


Theorem (174)                               [serial 1319] 
P [188] <<not DSPV2() or not SBL()>>
S [189] cs?(s)
Q [189] <<POSITION = s>>
by Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
and theorem 173:
Theorem (173) [serial 1330] used for:
  applied port input of value <<pre and s=M(cs)>> -> <<post>> [serial 1319]
 


Theorem (175)                               [serial 1314] 
P [188] <<not SBL() or not DSPV2()>>
S [189] cs?(s)
Q [189] <<s = POSITION>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 174:
Theorem (174) [serial 1319] used for:
    normalization of [serial 1314]
 


Theorem (176)                               [serial 1335] 
P [189] <<VELOCITY = v and (not DSPV2() or not SBL())>>
S [189] ->
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
by Identity (id):  P->P is tautology


Theorem (177)                               [serial 1331] 
P [189] <<(not DSPV2() or not SBL()) and v = VELOCITY>>
S [189] ->
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 176:
Theorem (176) [serial 1335] used for:
    normalization of [serial 1331]
 


Theorem (178)                               [serial 1321] 
P [188] <<not DSPV2() or not SBL()>>
S [189] cv?(v)
Q [190] <<VELOCITY = v and (not DSPV2() or not SBL())>>
by Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>> (bl.pi)
and theorem 177:
Theorem (177) [serial 1331] used for:
  applied port input of value <<pre and v=M(cv)>> -> <<post>> [serial 1321]
 


Theorem (179)                               [serial 1315] 
P [188] <<not SBL() or not DSPV2()>>
S [189] cv?(v)
Q [190] <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 178:
Theorem (178) [serial 1321] used for:
    normalization of [serial 1315]
 


Theorem (180)                               [serial 1310] 
P [188] <<not SBL() or not DSPV2()>>
S [189] <<not SBL() or not DSPV2()>>
cs?(s)
<<s = POSITION>>
&
cv?(v)
<<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
Q [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
by Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>> (bl.cck)
and theorems 168 171 175 179:
Theorem (168) [serial 1312] used for:
  P -> P1 in concurrent composition for [serial 1310]
 
Theorem (171) [serial 1313] used for:
  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1310]
 
Theorem (175) [serial 1314] used for:
  <<P1>> S1 <<Q1>> in concurrent composition for [serial 1310]
 
Theorem (179) [serial 1315] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1310]
 


Theorem (181)                               [serial 1329] 
P [189] <<VELOCITY = v and (not DSPV2() or not SBL()) and POSITION = s>>
S [188] ->
Q [127] <<not DSPV2() or not SBL()>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (182)                               [serial 1323] 
P [189] <<POSITION = s and (VELOCITY = v and (not DSPV2() or not SBL()))>>
S [188] ->
Q [127] <<not DSPV2() or not SBL()>>
by Associativity: (b.c).a = a.b.c
and theorem 181:
Theorem (181) [serial 1329] used for:
  Associativity: (b.c).a = a.b.c [serial 1323]
 


Theorem (183)                               [serial 1311] 
P [189] <<(s = POSITION)
  and
  ((not SBL() or not DSPV2()) and (v = VELOCITY))>>
S [188] ->
Q [127] <<not SBL() or not DSPV2()>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 182:
Theorem (182) [serial 1323] used for:
    normalization of [serial 1311]
 


Theorem (184)                               [serial 1308] 
P [126] <<not SBL() or not DSPV2()>>
S [188] {
 <<not SBL() or not DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
} 
Q [127] <<not SBL() or not DSPV2()>>
by Introduction of Existential Quantification (bl.elq)
and theorems 167 180 183:
Theorem (167) [serial 1309] used for:
  <<P and x=e>> -> <<A>> in existential lattice quantification for [serial 1308]
 
Theorem (180) [serial 1310] used for:
  {A} T {B} in existential lattice quantification for [serial 1308]
 
Theorem (183) [serial 1311] used for:
  <<B>> -> <<Q>> in existential lattice quantification for [serial 1308]
 


Theorem (185)                               [serial 1017] 
P [126] <<not SBL() or not DSPV2()>>
S [188] {
 <<not SBL() or not DSPV2()>>
 cs?(s)
 <<s = POSITION>>
 &
 cv?(v)
 <<(not SBL() or not DSPV2()) and (v = VELOCITY)>>
} 
Q [127] <<not SBL() or not DSPV2()>>
by Introduction of Existential Quantification (bl.aanone)
and theorem 184:
Theorem (184) [serial 1308] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1017]
 


Theorem (186)                               [serial 1351] 
P [127] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not DSPV2() or not SBL())>>
S [127] ->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (187)                               [serial 1346] 
P [127] <<((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not DSPV2() or not SBL())>>
S [127] ->
Q [95] <<CTCS_Properties::start = s or v < iSeg.v2>>
by Associativity: (b.c).a = a.b.c
and theorem 186:
Theorem (186) [serial 1351] used for:
  Associativity: (b.c).a = a.b.c [serial 1346]
 


Theorem (188)                               [serial 1343] 
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127] ->
Q [95] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Disjunction: (m or k) = (k or m)
    Zero is unique element: x+0 = x      x-0 = x
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 187:
Theorem (187) [serial 1346] used for:
    normalization of [serial 1343]
 


Theorem (189)                               [serial 1352] 
P [127] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not DSPV2() or not SBL())>>
S [127] ->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (190)                               [serial 1348] 
P [127] <<((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not DSPV2() or not SBL())>>
S [127] ->
Q [98] <<CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))>>
by Associativity: (b.c).a = a.b.c
and theorem 189:
Theorem (189) [serial 1352] used for:
  Associativity: (b.c).a = a.b.c [serial 1348]
 


Theorem (191)                               [serial 1344] 
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127] ->
Q [98] <<((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Disjunction: (m or k) = (k or m)
    Zero is unique element: x+0 = x      x-0 = x
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 190:
Theorem (190) [serial 1348] used for:
    normalization of [serial 1344]
 


Theorem (192)                               [serial 1342] 
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127] ->
Q [197] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 188 191:
Theorem (188) [serial 1343] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1342]
 
Theorem (191) [serial 1344] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1342]
 


Theorem (193)                               [serial 1338] 
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [127] ->
Q [197] <<SBL() and DSPV2()>>
by Substitution of Assertion Labels
and theorem 192:
Theorem (192) [serial 1342] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1338]
 


Theorem (194)                               [serial 1339] 
P [201] <<(SBL() and DSPV2())^1>>
S [124] ->
Q [91] <<(SBL() and DSPV2())^1>>
by Identity (id):  P->P is tautology


Theorem (195)                               [serial 1355] 
P [198] <<ca = xl and (DSPV2() and SBL())>>
S [198] ->
Q [199] <<DSPV2() and SBL()>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (196)                               [serial 1353] 
P [198] <<(SBL() and DSPV2()) and (ca = xl)^0>>
S [198] ->
Q [199] <<SBL() and DSPV2()>>
by Assume Present:  P = P@now = P^0 
and theorem 195:
Theorem (195) [serial 1355] used for:
  Assume Present:  P = P@now = P^0  [serial 1353]
 


Theorem (197)                               [serial 1357] 
P [197] <<DSPV2() and SBL()>>
S [198] ->
Q [104] <<DSPV2() and SBL()>>
by Identity (id):  P->P is tautology


Theorem (198)                               [serial 1354] 
P [197] <<SBL() and DSPV2()>>
S [198] ->
Q [104] <<(SBL() and DSPV2())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 197:
Theorem (197) [serial 1357] used for:
    normalization of [serial 1354]
 


Theorem (199)                               [serial 1340] 
P [197] <<SBL() and DSPV2()>>
S [198] ca!(xl)
Q [199] <<SBL() and DSPV2()>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 196 198:
Theorem (196) [serial 1353] used for:
  applied port output <<pre and (ca=xl)^0>> -> <<post>> [serial 1340]
 
Theorem (198) [serial 1354] used for:
  applied port output of conditional expression <<pre>> -> <<(SBL() and DSPV2())>> where (SBL() and DSPV2()) -> xl for ca!(xl) 
[serial 1340]
 


Theorem (200)                               [serial 1386] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ->
Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Identity (id):  P->P is tautology


Theorem (201)                               [serial 1388] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ->
Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by Identity (id):  P->P is tautology


Theorem (202)                               [serial 1384] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ->
Q [201] <<(s = CTCS_Properties::start or v < iSeg.v2)
  and
  (s = CTCS_Properties::start
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
and theorems 200 201:
Theorem (200) [serial 1386] used for:
    normalization of [serial 1384]
 
Theorem (201) [serial 1388] used for:
    normalization of [serial 1384]
 


Theorem (203)                               [serial 1381] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
by Simultaneous Assignment
and theorem 202:
Theorem (202) [serial 1384] used for:
  applied wp for simultaneous assignment [serial 1381]
 


Theorem (204)                               [serial 1379] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
  (iSeg.e)^1)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 203:
Theorem (203) [serial 1381] used for:
    normalization of [serial 1379]
 


Theorem (205)                               [serial 1377] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 204:
Theorem (204) [serial 1379] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1377]
 


Theorem (206)                               [serial 1375] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 205:
Theorem (205) [serial 1377] used for:
    normalization of [serial 1375]
 


Theorem (207)                               [serial 1373] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
  and
  (s^1 = CTCS_Properties::start
  or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 206:
Theorem (206) [serial 1375] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1373]
 


Theorem (208)                               [serial 1371] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(((CTCS_Properties::start)^1 = (s)^1)
  or ((v)^1 < (iSeg.v2)^1))
  and
  (((CTCS_Properties::start)^1 = (s)^1)
  or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 207:
Theorem (207) [serial 1373] used for:
    normalization of [serial 1371]
 


Theorem (209)                               [serial 1369] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
  and
  ((CTCS_Properties::start = s)^1
  or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 208:
Theorem (208) [serial 1371] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1369]
 


Theorem (210)                               [serial 1367] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 209:
Theorem (209) [serial 1369] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1367]
 


Theorem (211)                               [serial 1365] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s or v < iSeg.v2)^1
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 210:
Theorem (210) [serial 1367] used for:
    normalization of [serial 1365]
 


Theorem (212)                               [serial 1362] 
P [199] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<((CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 211:
Theorem (211) [serial 1365] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1362]
 


Theorem (213)                               [serial 1360] 
P [199] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 212:
Theorem (212) [serial 1362] used for:
    normalization of [serial 1360]
 


Theorem (214)                               [serial 1341] 
P [199] <<SBL() and DSPV2()>>
S [200] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [201] <<(SBL() and DSPV2())^1>>
by Substitution of Assertion Labels
and theorem 213:
Theorem (213) [serial 1360] used for:
  substituted Assertions' predicates for  labels  [serial 1341]
 


Theorem (215)                               [serial 1018] 
P [127] <<(not SBL() or not DSPV2())
  and
  (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))))>>
S [198] <<SBL() and DSPV2()>>
ca!(xl)
;
<<SBL() and DSPV2()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(SBL() and DSPV2())^1>>
Q [124] <<(SBL() and DSPV2())^1>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 193 194 199 214:
Theorem (193) [serial 1338] used for:
  P -> P1 in sequential composition for [serial 1018]
 
Theorem (194) [serial 1339] used for:
  Q1 -> Q in sequential composition for [serial 1018]
 
Theorem (199) [serial 1340] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1018]
 
Theorem (214) [serial 1341] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1018]
 


Theorem (216)                               [serial 1391] 
P [209] <<(not SBL() or not DSPV2())^1>>
S [126] ->
Q [126] <<(not SBL() or not DSPV2())^1>>
by Identity (id):  P->P is tautology


Theorem (217)                               [serial 1423] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ->
Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (218)                               [serial 1425] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ->
Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (219)                               [serial 1421] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ->
Q [209] <<not (s = CTCS_Properties::start or v < iSeg.v2)
or not (s = CTCS_Properties::start
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*iSeg.e*2)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
and theorems 217 218:
Theorem (217) [serial 1423] used for:
    normalization of [serial 1421]
 
Theorem (218) [serial 1425] used for:
    normalization of [serial 1421]
 


Theorem (220)                               [serial 1418] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v2]^1+(b^1*iSeg.e^1*2)))>>
by Simultaneous Assignment
and theorem 219:
Theorem (219) [serial 1421] used for:
  applied wp for simultaneous assignment [serial 1418]
 


Theorem (221)                               [serial 1416] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v2]^1+((b)^1*(2)^1*
(iSeg.e)^1)))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 220:
Theorem (220) [serial 1418] used for:
    normalization of [serial 1416]
 


Theorem (222)                               [serial 1414] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v2]^1+(b*2*iSeg.e)^1))>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 221:
Theorem (221) [serial 1416] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1414]
 


Theorem (223)                               [serial 1412] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v2])^1+(b*2*iSeg.e)^1))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 222:
Theorem (222) [serial 1414] used for:
    normalization of [serial 1412]
 


Theorem (224)                               [serial 1410] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (s^1 = CTCS_Properties::start or v^1 < iSeg.v2^1)
or not (s^1 = CTCS_Properties::start
or ((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 223:
Theorem (223) [serial 1412] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1410]
 


Theorem (225)                               [serial 1408] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (((CTCS_Properties::start)^1 = (s)^1)
or ((v)^1 < (iSeg.v2)^1))
or not (((CTCS_Properties::start)^1 = (s)^1)
or (((v**2)+(b*s*2))^1 < (iMA[nSeg.v2]+(b*2*iSeg.e))^1))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 224:
Theorem (224) [serial 1410] used for:
    normalization of [serial 1408]
 


Theorem (226)                               [serial 1406] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not ((CTCS_Properties::start = s)^1 or (v < iSeg.v2)^1)
or not ((CTCS_Properties::start = s)^1
or (((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 225:
Theorem (225) [serial 1408] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1406]
 


Theorem (227)                               [serial 1404] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not (CTCS_Properties::start = s or v < iSeg.v2)^1
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 226:
Theorem (226) [serial 1406] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1404]
 


Theorem (228)                               [serial 1402] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<not ((CTCS_Properties::start = s or v < iSeg.v2))^1
or not ((CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 227:
Theorem (227) [serial 1404] used for:
    normalization of [serial 1402]
 


Theorem (229)                               [serial 1400] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 228:
Theorem (228) [serial 1402] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1400]
 


Theorem (230)                               [serial 1398] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<((not (CTCS_Properties::start = s or v < iSeg.v2))^1
or (not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 229:
Theorem (229) [serial 1400] used for:
    normalization of [serial 1398]
 


Theorem (231)                               [serial 1395] 
P [127] <<not ((CTCS_Properties::start = s or v < iSeg.v2)
    and
    (CTCS_Properties::start = s
    or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))
  and
  (not (CTCS_Properties::start = s or v < iSeg.v2)
  or not (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not (CTCS_Properties::start = s or v < iSeg.v2)
or not (CTCS_Properties::start = s
or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e))))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 230:
Theorem (230) [serial 1398] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1395]
 


Theorem (232)                               [serial 1393] 
P [127] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  or not ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not ((s = CTCS_Properties::start) or ((v < iSeg.v2)))
or not ((s = CTCS_Properties::start)
or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))^1>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 231:
Theorem (231) [serial 1395] used for:
    normalization of [serial 1393]
 


Theorem (233)                               [serial 1392] 
P [127] <<(not SBL() or not DSPV2())
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [209] <<(not SBL() or not DSPV2())^1>>
by Substitution of Assertion Labels
and theorem 232:
Theorem (232) [serial 1393] used for:
  substituted Assertions' predicates for  labels  [serial 1392]
 


Theorem (234)                               [serial 1019] 
P [127] <<(not SBL() or not DSPV2())
  and
  (not (((s = CTCS_Properties::start) or ((v < iSeg.v2)))
    and
    ((s = CTCS_Properties::start)
    or ((((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e)))))))>>
S [208] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not SBL() or not DSPV2())^1>>
Q [126] <<(not SBL() or not DSPV2())^1>>
by Introduction of Existential Quantification (bl.aapost)
and theorems 216 233:
Theorem (216) [serial 1391] used for:
  as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1019]
 
Theorem (233) [serial 1392] used for:
  as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1019]
 


Theorem (235)                               [serial 1429] 
P [122] <<CTCS_Properties::start = s and i = 0 and iMA = >>
S [213] ->
Q [123] <<CTCS_Properties::start = s and i = 0>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (236)                               [serial 1020] 
P [122] <<(i = 0) and (s = CTCS_Properties::start) and (iMA = )>>
S [213] ->
Q [123] <<(i = 0) and (s = CTCS_Properties::start)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 235:
Theorem (235) [serial 1429] used for:
    normalization of [serial 1020]
 


Theorem (237)                               [serial 1443] 
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215] ->
Q [121] <<CTCS_Properties::start = s and i = 0>>
by Identity (id):  P->P is tautology


Theorem (238)                               [serial 1445] 
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215] ->
Q [121] <<CTCS_Properties::start = s and i = 0>>
by Identity (id):  P->P is tautology


Theorem (239)                               [serial 1441] 
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215] ->
Q [121] <<i = 0 and s = CTCS_Properties::start>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorems 237 238:
Theorem (237) [serial 1443] used for:
    normalization of [serial 1441]
 
Theorem (238) [serial 1445] used for:
    normalization of [serial 1441]
 


Theorem (240)                               [serial 1438] 
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215] ( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<i^1 = 0 and s^1 = CTCS_Properties::start>>
by Simultaneous Assignment
and theorem 239:
Theorem (239) [serial 1441] used for:
  applied wp for simultaneous assignment [serial 1438]
 


Theorem (241)                               [serial 1436] 
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215] ( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((CTCS_Properties::start)^1 = (s)^1)
  and
  ((i)^1 = (0)^1)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Constants are always the same
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 240:
Theorem (240) [serial 1438] used for:
    normalization of [serial 1436]
 


Theorem (242)                               [serial 1434] 
P [123] <<CTCS_Properties::start = s and i = 0>>
S [215] ( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<(CTCS_Properties::start = s)^1 and (i = 0)^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 241:
Theorem (241) [serial 1436] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1434]
 


Theorem (243)                               [serial 1432] 
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [215] ( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((i = 0)^1 and (s = CTCS_Properties::start)^1)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 242:
Theorem (242) [serial 1434] used for:
    normalization of [serial 1432]
 


Theorem (244)                               [serial 1431] 
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [215] ( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((i = 0) and (s = CTCS_Properties::start))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 243:
Theorem (243) [serial 1432] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1431]
 


Theorem (245)                               [serial 1021] 
P [123] <<(i = 0) and (s = CTCS_Properties::start)>>
S [215] ( --begining of simultaneous assignment
 i',
 s'
:=
 i,
 s
) --end of simultaneous assignment

Q [121] <<((i = 0) and (s = CTCS_Properties::start))^1>>
by Introduction of Existential Quantification (bl.aanone)
and theorem 244:
Theorem (244) [serial 1431] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1021]
 


Theorem (246)                               [serial 1456] 
P [125] <<(CTCS_Properties::start = s or v < iSeg.v2)
  and
  (CTCS_Properties::start = s
  or ((v**2)+(b*s*2)) < (iMA[nSeg.v2]+(b*2*iSeg.e)))
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [125] ->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (247)                               [serial 1452] 
P [125] <<((s = CTCS_Properties::start) or ((v < iSeg.v2)))
  and
  ((s = CTCS_Properties::start)
  or (((v**2)+(2*b*s)) < (iMA[nSeg.v2]+(2*b*iSeg.e))))
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [125] ->
Q [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Disjunction: (m or k) = (k or m)
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 246:
Theorem (246) [serial 1456] used for:
    normalization of [serial 1452]
 


Theorem (248)                               [serial 1448] 
P [125] <<SBL()
  and
  DSPV2()
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [125] ->
Q [219] <<not EBL() or not DSPV1()>>
by Substitution of Assertion Labels
and theorem 247:
Theorem (247) [serial 1452] used for:
  substituted Assertions' predicates for  labels  [serial 1448]
 


Theorem (249)                               [serial 1449] 
P [221] <<(not EBL() or not DSPV1())^1>>
S [128] ->
Q [91] <<(not EBL() or not DSPV1())^1>>
by Identity (id):  P->P is tautology


Theorem (250)                               [serial 1503] 
P [219] <<(ca = ( -b))^0
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [219] ->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (251)                               [serial 1498] 
P [219] <<(not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))
  and
  (ca = ( -b))^0>>
S [219] ->
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 250:
Theorem (250) [serial 1503] used for:
    normalization of [serial 1498]
 


Theorem (252)                               [serial 1516] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219] ->
Q [103] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by Identity (id):  P->P is tautology


Theorem (253)                               [serial 1514] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219] ->
Q [103] <<not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))
or not ((v < iSeg.v1))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Disjunction: (m or k) = (k or m)
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 252:
Theorem (252) [serial 1516] used for:
    normalization of [serial 1514]
 


Theorem (254)                               [serial 1505] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219] ->
Q [103] <<not DSPV1() or not EBL()>>
by Substitution of Assertion Labels
and theorem 253:
Theorem (253) [serial 1514] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1505]
 


Theorem (255)                               [serial 1499] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219] ->
Q [103] <<(not EBL() or not DSPV1())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Disjunction: (m or k) = (k or m)
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 254:
Theorem (254) [serial 1505] used for:
    normalization of [serial 1499]
 


Theorem (256)                               [serial 1458] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [219] ca!(- b)
Q [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 251 255:
Theorem (251) [serial 1498] used for:
  applied port output <<pre and (ca=- b)^0>> -> <<post>> [serial 1458]
 
Theorem (255) [serial 1499] used for:
  applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>> where (not EBL() or not DSPV1()) -> - b for ca!(- b) 
[serial 1458]
 


Theorem (257)                               [serial 1453] 
P [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
S [219] ca!(- b)
Q [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 256:
Theorem (256) [serial 1458] used for:
    normalization of [serial 1453]
 


Theorem (258)                               [serial 1450] 
P [219] <<not EBL() or not DSPV1()>>
S [219] ca!(- b)
Q [219] <<not EBL() or not DSPV1()>>
by Substitution of Assertion Labels
and theorem 257:
Theorem (257) [serial 1453] used for:
  substituted Assertions' predicates for  labels  [serial 1450]
 


Theorem (259)                               [serial 1507] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by Identity (id):  P->P is tautology


Theorem (260)                               [serial 1509] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by Identity (id):  P->P is tautology


Theorem (261)                               [serial 1500] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ->
Q [221] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
and theorems 259 260:
Theorem (259) [serial 1507] used for:
    normalization of [serial 1500]
 
Theorem (260) [serial 1509] used for:
    normalization of [serial 1500]
 


Theorem (262)                               [serial 1493] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e^1*2))>>
by Simultaneous Assignment
and theorem 261:
Theorem (261) [serial 1500] used for:
  applied wp for simultaneous assignment [serial 1493]
 


Theorem (263)                               [serial 1489] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v1]^1+((b)^1*(2)^1*
(iSeg.e)^1))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 262:
Theorem (262) [serial 1493] used for:
    normalization of [serial 1489]
 


Theorem (264)                               [serial 1487] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v1]^1+(b*2*iSeg.e)^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 263:
Theorem (263) [serial 1489] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1487]
 


Theorem (265)                               [serial 1483] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v1])^1+(b*2*iSeg.e)^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 264:
Theorem (264) [serial 1487] used for:
    normalization of [serial 1483]
 


Theorem (266)                               [serial 1481] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not v^1 < iSeg.v1^1
or not ((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 265:
Theorem (265) [serial 1483] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1481]
 


Theorem (267)                               [serial 1477] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not ((v)^1 < (iSeg.v1)^1)
or not (((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 266:
Theorem (266) [serial 1481] used for:
    normalization of [serial 1477]
 


Theorem (268)                               [serial 1473] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<not (v < iSeg.v1)^1
or not (((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 267:
Theorem (267) [serial 1477] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1473]
 


Theorem (269)                               [serial 1471] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 268:
Theorem (268) [serial 1473] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1471]
 


Theorem (270)                               [serial 1467] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<((not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 269:
Theorem (269) [serial 1471] used for:
    normalization of [serial 1467]
 


Theorem (271)                               [serial 1460] 
P [219] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 270:
Theorem (270) [serial 1467] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1460]
 


Theorem (272)                               [serial 1454] 
P [219] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))^1>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 271:
Theorem (271) [serial 1460] used for:
    normalization of [serial 1454]
 


Theorem (273)                               [serial 1451] 
P [219] <<not EBL() or not DSPV1()>>
S [220] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [221] <<(not EBL() or not DSPV1())^1>>
by Substitution of Assertion Labels
and theorem 272:
Theorem (272) [serial 1454] used for:
  substituted Assertions' predicates for  labels  [serial 1451]
 


Theorem (274)                               [serial 1022] 
P [125] <<SBL()
  and
  DSPV2()
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [219] <<not EBL() or not DSPV1()>>
ca!(- b)
;
<<not EBL() or not DSPV1()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not EBL() or not DSPV1())^1>>
Q [128] <<(not EBL() or not DSPV1())^1>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 248 249 258 273:
Theorem (248) [serial 1448] used for:
  P -> P1 in sequential composition for [serial 1022]
 
Theorem (249) [serial 1449] used for:
  Q1 -> Q in sequential composition for [serial 1022]
 
Theorem (258) [serial 1450] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1022]
 
Theorem (273) [serial 1451] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1022]
 


Theorem (275)                               [serial 1519] 
P [128] <<v = 0 and (not DSPV1() or not EBL())>>
S [223] ->
Q [129] <<v = 0 and (not DSPV1() or not EBL())>>
by Identity (id):  P->P is tautology


Theorem (276)                               [serial 1023] 
P [128] <<(not EBL() or not DSPV1()) and (v = 0)>>
S [223] ->
Q [129] <<(not EBL() or not DSPV1()) and v = 0>>
by Normalization
  Normalization Axioms:
    Reflexivity of Disjunction: (m or k) = (k or m)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 275:
Theorem (275) [serial 1519] used for:
    normalization of [serial 1023]
 


Theorem (277)                               [serial 1527] 
P [126] <<(not DSPV2() or not SBL())
  and
  (not v < iSeg.v1
  or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))>>
S [126] ->
Q [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (278)                               [serial 1525] 
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126] ->
Q [227] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Reflexivity of Disjunction: (m or k) = (k or m)
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 277:
Theorem (277) [serial 1527] used for:
    normalization of [serial 1525]
 


Theorem (279)                               [serial 1521] 
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [126] ->
Q [227] <<not EBL() or not DSPV1()>>
by Substitution of Assertion Labels
and theorem 278:
Theorem (278) [serial 1525] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1521]
 


Theorem (280)                               [serial 1522] 
P [229] <<(not EBL() or not DSPV1())^1>>
S [128] ->
Q [91] <<(not EBL() or not DSPV1())^1>>
by Identity (id):  P->P is tautology


Theorem (281)                               [serial 1529] 
P [227] <<(not EBL() or not DSPV1())
  and
  (ca = ( -b))^0>>
S [227] ->
Q [227] <<not EBL() or not DSPV1()>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (282)                               [serial 1532] 
P [227] <<not DSPV1() or not EBL()>>
S [227] ->
Q [103] <<not DSPV1() or not EBL()>>
by Identity (id):  P->P is tautology


Theorem (283)                               [serial 1530] 
P [227] <<not EBL() or not DSPV1()>>
S [227] ->
Q [103] <<(not EBL() or not DSPV1())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Disjunction: (m or k) = (k or m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 282:
Theorem (282) [serial 1532] used for:
    normalization of [serial 1530]
 


Theorem (284)                               [serial 1523] 
P [227] <<not EBL() or not DSPV1()>>
S [227] ca!(- b)
Q [227] <<not EBL() or not DSPV1()>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 281 283:
Theorem (281) [serial 1529] used for:
  applied port output <<pre and (ca=- b)^0>> -> <<post>> [serial 1523]
 
Theorem (283) [serial 1530] used for:
  applied port output of conditional expression <<pre>> -> <<(not EBL() or not DSPV1())>> where (not EBL() or not DSPV1()) -> - b for ca!(- b) 
[serial 1523]
 


Theorem (285)                               [serial 1560] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by Identity (id):  P->P is tautology


Theorem (286)                               [serial 1562] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
by Identity (id):  P->P is tautology


Theorem (287)                               [serial 1558] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ->
Q [229] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*iSeg.e*2))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
and theorems 285 286:
Theorem (285) [serial 1560] used for:
    normalization of [serial 1558]
 
Theorem (286) [serial 1562] used for:
    normalization of [serial 1558]
 


Theorem (288)                               [serial 1555] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v^1**2)+(b^1*s^1*2)) < (iMA[nSeg.v1]^1+(b^1*iSeg.e^1*2))>>
by Simultaneous Assignment
and theorem 287:
Theorem (287) [serial 1558] used for:
  applied wp for simultaneous assignment [serial 1555]
 


Theorem (289)                               [serial 1553] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not (((v)^1**(2)^1)+((b)^1*(s)^1*(2)^1)) < (iMA[nSeg.v1]^1+((b)^1*(2)^1*
(iSeg.e)^1))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Constants are always the same
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 288:
Theorem (288) [serial 1555] used for:
    normalization of [serial 1553]
 


Theorem (290)                               [serial 1551] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < (iMA[nSeg.v1]^1+(b*2*iSeg.e)^1)>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 289:
Theorem (289) [serial 1553] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1551]
 


Theorem (291)                               [serial 1549] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)^1+(b*s*2)^1) < ((iMA[nSeg.v1])^1+(b*2*iSeg.e)^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 290:
Theorem (290) [serial 1551] used for:
    normalization of [serial 1549]
 


Theorem (292)                               [serial 1547] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not v^1 < iSeg.v1^1
or not ((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 291:
Theorem (291) [serial 1549] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1547]
 


Theorem (293)                               [serial 1545] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not ((v)^1 < (iSeg.v1)^1)
or not (((v**2)+(b*s*2))^1 < (iMA[nSeg.v1]+(b*2*iSeg.e))^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 292:
Theorem (292) [serial 1547] used for:
    normalization of [serial 1545]
 


Theorem (294)                               [serial 1543] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<not (v < iSeg.v1)^1
or not (((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 293:
Theorem (293) [serial 1545] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1543]
 


Theorem (295)                               [serial 1541] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 294:
Theorem (294) [serial 1543] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1541]
 


Theorem (296)                               [serial 1539] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<((not v < iSeg.v1)^1
or (not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1)>>
by Normalization
  Normalization Axioms:
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 295:
Theorem (295) [serial 1541] used for:
    normalization of [serial 1539]
 


Theorem (297)                               [serial 1536] 
P [227] <<not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not v < iSeg.v1
or not ((v**2)+(b*s*2)) < (iMA[nSeg.v1]+(b*2*iSeg.e)))^1>>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 296:
Theorem (296) [serial 1539] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1536]
 


Theorem (298)                               [serial 1534] 
P [227] <<not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e))))>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not ((v < iSeg.v1))
or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))^1>>
by Normalization
  Normalization Axioms:
    Reflexivity of Multiplication: a*b=b*a
    Zero is unique element: x+0 = x      x-0 = x
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 297:
Theorem (297) [serial 1536] used for:
    normalization of [serial 1534]
 


Theorem (299)                               [serial 1524] 
P [227] <<not EBL() or not DSPV1()>>
S [228] ( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

Q [229] <<(not EBL() or not DSPV1())^1>>
by Substitution of Assertion Labels
and theorem 298:
Theorem (298) [serial 1534] used for:
  substituted Assertions' predicates for  labels  [serial 1524]
 


Theorem (300)                               [serial 1024] 
P [126] <<(not SBL() or not DSPV2())
  and
  (not (v < iSeg.v1)
  or not ((((v**2)+(2*b*s)) < (iMA[nSeg.v1]+(2*b*iSeg.e)))))>>
S [227] <<not EBL() or not DSPV1()>>
ca!(- b)
;
<<not EBL() or not DSPV1()>>
( --begining of simultaneous assignment
 iSeg',
 nSeg',
 i',
 v',
 s',
 b',
 iMA'
:=
 iSeg,
 nSeg,
 i,
 v,
 s,
 b,
 iMA
) --end of simultaneous assignment

<<(not EBL() or not DSPV1())^1>>
Q [128] <<(not EBL() or not DSPV1())^1>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 279 280 284 299:
Theorem (279) [serial 1521] used for:
  P -> P1 in sequential composition for [serial 1024]
 
Theorem (280) [serial 1522] used for:
  Q1 -> Q in sequential composition for [serial 1024]
 
Theorem (284) [serial 1523] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1024]
 
Theorem (299) [serial 1524] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1024]
 


Theorem (301)                               [serial 1002] 
P [119] << >>
S [107] ->
Q [119] <<Controller.impl proof obligations>>
by Initial Thread Obligations
and theorems 1 2 3 4 6 9 10 12 31 44 69 114 141 166 185 215 234 236 245 274 276 300:
Theorem (1) [serial 1003] used for:
  <<M(GMA)>> -> <<I>> from invariant I when complete state GMA has Assertion <<M(GMA)>> in its definition.
 
Theorem (2) [serial 1004] used for:
  <<M(MFR)>> -> <<I>> from invariant I when complete state MFR has Assertion <<M(MFR)>> in its definition.
 
Theorem (3) [serial 1005] used for:
  <<M(SBI)>> -> <<I>> from invariant I when complete state SBI has Assertion <<M(SBI)>> in its definition.
 
Theorem (4) [serial 1006] used for:
  <<M(EBI)>> -> <<I>> from invariant I when complete state EBI has Assertion <<M(EBI)>> in its definition.
 
Theorem (6) [serial 1007] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CSB, <<M(CSB)>> -> <<e1 or e2 or . . . en>>
 
Theorem (9) [serial 1008] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CMF, <<M(CMF)>> -> <<e1 or e2 or . . . en>>
 
Theorem (10) [serial 1009] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state RETRY, <<M(RETRY)>> -> <<e1 or e2 or . . . en>>
 
Theorem (12) [serial 1010] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CMA, <<M(CMA)>> -> <<e1 or e2 or . . . en>>
 
Theorem (31) [serial 1011] used for:
   <<M(READY)>> A <<M(GMA)>> for T0_go:READY-[ ]->GMA{A};
 
Theorem (44) [serial 1012] used for:
   <<M(GMA) and x>> A <<M(CMA)>> for T1_MA_Check:GMA-[x]->CMA{A};
 
Theorem (69) [serial 1013] used for:
   <<M(CMA) and x>> A <<M(MFR)>> for T2_MA_Ok:CMA-[x]->MFR{A};
 
Theorem (114) [serial 1014] used for:
   <<M(MFR) and x>> A <<M(CMF)>> for T3_Move_Check:MFR-[x]->CMF{A};
 
Theorem (141) [serial 1015] used for:
   <<M(CMF) and x>> A <<M(SBI)>> for T4_SBI_Point:CMF-[x]->SBI{A};
 
Theorem (166) [serial 1016] used for:
   <<M(CMF) and x>> A <<M(MFR)>> for T5_Move_Ok:CMF-[x]->MFR{A};
 
Theorem (185) [serial 1017] used for:
   <<M(SBI) and x>> A <<M(CSB)>> for T6_SBI_Check:SBI-[x]->CSB{A};
 
Theorem (215) [serial 1018] used for:
   <<M(CSB) and x>> A <<M(MFR)>> for T7_SBI_Out:CSB-[x]->MFR{A};
 
Theorem (234) [serial 1019] used for:
   <<M(CSB) and x>> A <<M(SBI)>> for T8_SBI_Ok:CSB-[x]->SBI{A};
 
Theorem (236) [serial 1020] used for:
   <<M(CMA) and x>> -> <<M(RETRY)>> for T9_MA_NotOk:CMA-[x]->RETRY{};
 
Theorem (245) [serial 1021] used for:
   <<M(RETRY)>> A <<M(GMA)>> for T10_MA_Retry:RETRY-[ ]->GMA{A};
 
Theorem (274) [serial 1022] used for:
   <<M(CMF) and x>> A <<M(EBI)>> for T11_EBI_Point:CMF-[x]->EBI{A};
 
Theorem (276) [serial 1023] used for:
   <<M(EBI) and x>> -> <<M(STOP)>> for T12_Stop:EBI-[x]->STOP{};
 
Theorem (300) [serial 1024] used for:
   <<M(SBI) and x>> A <<M(EBI)>> for T13_EBI_Point:SBI-[x]->EBI{A};
 


Theorem (302)                               [serial 1001] 
P     
S     
Q     
by Initial Thread Obligations
and theorem 301:
Theorem (301) [serial 1002] used for:
  Initial proof obligations for Controller.impl
 


proof duration:  30.1 seconds 

done step:  axioms
Done executing proof script
closing dump.txt
closing dump.txt file "E:\AADL\BHA\osate2\dump.txt"
closing dump.txt file; 