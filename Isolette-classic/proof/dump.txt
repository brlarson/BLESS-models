opening dump file "/Applications/OSATE-for-HAMR-and-BLESS/Eclipse-OfHaB.app/Contents/MacOS/dump.txt" Sun Jul 09 06:50:26 CDT 2023
opening proof script file "/Applications/OSATE-for-HAMR-and-BLESS/Eclipse-OfHaB.app/Contents/MacOS/script.txt"

Declarative Model has been Loaded.

 extracting initial proof obligation(s) for a package:  "Iso_Types"
  no proof obligations created for "lower_desired_range"
  no proof obligations created for "lower_alarm_temperature.i"
  no proof obligations created for "lower_desired_temp"
  no proof obligations created for "desired_range.i"
  no proof obligations created for "lower_alarm_temperature"
  no proof obligations created for "lower_desired_temp.i"
  no proof obligations created for "Time"
  no proof obligations created for "valid_flag"
  no proof obligations created for "lower_alarm_range"
  no proof obligations created for "upper_alarm_temperature"
  no proof obligations created for "current_temperature"
  no proof obligations created for "regulator_mode"
  no proof obligations created for "upper_alarm_range"
  no proof obligations created for "lower_desired_temperature"
  no proof obligations created for "monitor_mode"
  no proof obligations created for "current_temperature.i"
  no proof obligations created for "measured_temperature_range"
  no proof obligations created for "alarm_range"
  no proof obligations created for "upper_desired_temp.i"
  no proof obligations created for "upper_alarm_temp"
  no proof obligations created for "desired_range"
  no proof obligations created for "on_off"
  no proof obligations created for "upper_desired_temperature"
  no proof obligations created for "lower_alarm_temp"
  no proof obligations created for "upper_desired_temp"
  no proof obligations created for "lower_desired_temperature.i"
  no proof obligations created for "upper_desired_temperature.i"
  no proof obligations created for "upper_desired_range"
  no proof obligations created for "alarm_range.i"
  no proof obligations created for "upper_alarm_temperature.i"
  no proof obligations created for "status"
 extracting initial proof obligation(s) for a package:  "Assertions"
 extracting initial proof obligation(s) for a package:  "Monitor"
  creating proof obligations for "manage_monitor_interface"
  no proof obligations created for "monitor_temperature"
  creating proof obligations for "manage_monitor_mode"
  creating proof obligations for "manage_alarm"
  creating proof obligations for "manage_monitor_interface.impl"
  creating proof obligations for "manage_monitor_mode.impl"
[source=init destination=check_init dispatch condition=true, source=normal destination=check_normal dispatch condition=true]
extracting proof obligations for "manage_monitor_mode.impl"

[serial 1002]: Monitor::manage_monitor_mode.impl
P [158] <<   >>
S [158]->
Q [158] << manage_monitor_mode.impl proof obligations >>
What for:  Initial proof obligations for manage_monitor_mode.impl
Reason solved:  Component verification conditions
making initial obligations for complete states

[serial 1003]: Monitor::manage_monitor_mode.impl
P [167] << true >>
S [158]->
Q [158] << true >>
What for:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.

[serial 1004]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [158]->
Q [158] << true >>
What for:  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
making Serban's theorems

[serial 1005]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
S [169]->
Q [169] << ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>

[serial 1006]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [166]->
Q [166] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>

[serial 1007]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [173]->
Q [173] << ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
making initial proof obligations for transitions

[serial 1008]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]  start_time := now
  << ( start_time = now )
    and AXIOM_TOGT0()
    and AXIOM_ST() >>
  ;
  monitor_mode!(mmode'Init) 
Q [167] << ( true )^1 >>
What for:   <<M(start)>> A <<M(init)>> for mmm1: start-[ ]->init{A};

[serial 1009]: Monitor::manage_monitor_mode.impl
P [167] << true >>
S [188]  current_temperature?(temperature)
  ;
  current_temperature_status := temperature.status
  << current_temperature_status = temperature.status >> 
Q [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
What for:   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};

[serial 1010]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [198]<< not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( current_temperature_status = status'Valid )
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST()
  and AXIOM_CTS() >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:   <<M(check_init) and x>> A <<M(failed)>> for mmm: check_init-[x]->failed{A};

[serial 1011]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [209]<< MONITOR_OK()
  and RUN() >>
monitor_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [172] << ( RUN() )^1 >>
What for:   <<M(check_init) and x>> A <<M(normal)>> for mmm2: check_init-[x]->normal{A};

[serial 1012]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
S [213]->
Q [167] << ( true )^1 >>
What for:   <<M(check_init) and x>> -> <<M(init)>> for mmm2x: check_init-[x]->init{};

[serial 1013]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [219]  << RUN() >>
  current_temperature?(temperature)
  ;
  << temperature = CURRENT_TEMP
    and RUN() >>
  current_temperature_status := temperature.status
  << current_temperature_status = temperature.status
    and RUN() >> 
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};

[serial 1014]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [229]<< MONITOR_OK()
  and RUN() >>
monitor_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [172] << ( RUN() )^1 >>
What for:   <<M(check_normal) and x>> A <<M(normal)>> for mmm3: check_normal-[x]->normal{A};

[serial 1015]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [237]<< not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:   <<M(check_normal) and x>> A <<M(failed)>> for mmm3x: check_normal-[x]->failed{A};
  creating proof obligations for "manage_alarm.impl"
[source=run destination=check_mode dispatch condition=true]
extracting proof obligations for "manage_alarm.impl"

[serial 1016]: Monitor::manage_alarm.impl
P [289] <<   >>
S [303]->
Q [289] << manage_alarm.impl proof obligations >>
What for:  Initial proof obligations for manage_alarm.impl
Reason solved:  Component verification conditions
making initial obligations for complete states

[serial 1017]: Monitor::manage_alarm.impl
P [310] << INVMA() >>
S [303]->
Q [303] << alarm_previous_period = alarm_control^-1 >>
What for:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
making Serban's theorems

[serial 1018]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
S [312]->
Q [312] << ( ( current_temperature.t < lower_alarm_temperature.t )
   or ( current_temperature.t > upper_alarm_temperature.t ) )
   or ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) )
   or ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>

[serial 1019]: Monitor::manage_alarm.impl
P [309] << alarm_previous_period = cntrl'Off
  and ( INVMA() )^1 >>
S [309]->
Q [309] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>

[serial 1020]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON() >>
S [313]->
Q [313] << ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>

[serial 1021]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( not MONITOR_OK()
  and RUN() )
   or ( INI() )
   or ( MONITOR_OK()
  and RUN() ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
making initial proof obligations for transitions

[serial 1022]: Monitor::manage_alarm.impl
P [309] << alarm_previous_period = cntrl'Off
  and ( INVMA() )^1 >>
S [316]->
Q [310] << ( INVMA() )^1 >>
What for:   <<M(poweron)>> -> <<M(run)>> for maPo: poweron-[ ]->run{};

[serial 1023]: Monitor::manage_alarm.impl
P [310] << INVMA() >>
S [317]->
Q [311] << INVMA() >>
What for:   <<M(run) and x>> -> <<M(check_mode)>> for maRun: run-[x]->check_mode{};

[serial 1024]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [320]  << REQMA5() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for maFailed: check_mode-[x]->run{A};

[serial 1025]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( INI() ) >>
S [328]  << REQMA1() >>
  alarm_control!(cntrl'Off)
  ;
  << alarm_control = cntrl'Off >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for maInit: check_mode-[x]->run{A};

[serial 1026]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
What for:   <<M(check_mode) and x>> -> <<M(check_temp)>> for maNormal: check_mode-[x]->check_temp{};

[serial 1027]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t < lower_alarm_temperature.t )
   or ( current_temperature.t > upper_alarm_temperature.t ) ) >>
S [339]  << REQMA2()
    and not REQMA1() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for maOor: check_temp-[x]->run{A};

[serial 1028]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [348]  << REQMA4()
    and not REQMA1()
    and AXIOM_AR() >>
  alarm_control!(cntrl'Off)
  ;
  << REQMA4()
    and not REQMA1()
    and AXIOM_AR()
    and ( alarm_control = cntrl'Off ) >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for maIr: check_temp-[x]->run{A};

[serial 1029]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON() >>
What for:   <<M(check_temp) and x>> -> <<M(check_hyst)>> for maHys: check_temp-[x]->check_hyst{};

[serial 1030]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'O_n ) >>
S [361]  << REQMA3()
    and AXIOM_AC()
    and ( alarm_previous_period = cntrl'O_n )
    and INVMA() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for maHysOn: check_hyst-[x]->run{A};

[serial 1031]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'Off ) >>
S [370]  << REQMA3()
    and AXIOM_AC()
    and ( alarm_previous_period = cntrl'Off )
    and INVMA() >>
  alarm_control!(cntrl'Off)
  ;
  << alarm_control = cntrl'Off >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for maHysOff: check_hyst-[x]->run{A};
 extracting initial proof obligation(s) for a package:  "KSU_Isolette"
  creating proof obligations for "thermostat_dual_sensor"
  creating proof obligations for "isolette"
  creating proof obligations for "thermostat_single_sensor"
  creating proof obligations for "operator_interface"
  creating proof obligations for "thermostat_single_sensor.impl"
  creating proof obligations for "operator_interface.impl"
  creating proof obligations for "isolette.dual_sensor"
  creating proof obligations for "isolette.single_sensor"
  creating proof obligations for "thermostat_dual_sensor.impl"
 extracting initial proof obligation(s) for a package:  "Nursery"
  no proof obligations created for "Heat"
  no proof obligations created for "Interface_Interaction"
  no proof obligations created for "Infant"
  no proof obligations created for "Air_Interaction"
  creating proof obligations for "Air"
  creating proof obligations for "Room"
  no proof obligations created for "Nurse"
  creating proof obligations for "Room.Normal_Operation"
 extracting initial proof obligation(s) for a package:  "Devices"
  creating proof obligations for "temperature_sensor"
  creating proof obligations for "heat_source"
  creating proof obligations for "detect_regulator_failure"
  creating proof obligations for "detect_monitor_failure"
  creating proof obligations for "heat_source.impl"
  creating proof obligations for "detect_monitor_failure.impl"
  creating proof obligations for "detect_regulator_failure.impl"
  creating proof obligations for "temperature_sensor.impl"
 extracting initial proof obligation(s) for a package:  "Regulate"
  no proof obligations created for "regulate_temperature"
  creating proof obligations for "manage_regulator_mode"
  creating proof obligations for "manage_regulator_interface_mri"
  creating proof obligations for "manage_heat_source"
  creating proof obligations for "manage_regulator_mode.impl"
[source=init destination=check_init dispatch condition=true, source=normal destination=check_normal dispatch condition=true]
extracting proof obligations for "manage_regulator_mode.impl"

[serial 1032]: Regulate::manage_regulator_mode.impl
P [204] <<   >>
S [204]->
Q [204] << manage_regulator_mode.impl proof obligations >>
What for:  Initial proof obligations for manage_regulator_mode.impl
Reason solved:  Component verification conditions
making initial obligations for complete states

[serial 1033]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [204]->
Q [204] << true >>
What for:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.

[serial 1034]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [204]->
Q [204] << true >>
What for:  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
making Serban's theorems

[serial 1035]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>

[serial 1036]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [212]->
Q [212] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>

[serial 1037]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [219]->
Q [219] << ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
making initial proof obligations for transitions

[serial 1038]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]  start_time := now
  << ( start_time = now )
    and AXIOM_TOGT0()
    and AXIOM_STR() >>
  ;
  regulator_mode!(mmode'Init) 
Q [213] << ( true )^1 >>
What for:   <<M(start)>> A <<M(init)>> for mrm1: start-[ ]->init{A};

[serial 1039]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [235]  current_temperature?(temperature)
  ;
  current_temperature_status := temperature.status 
Q [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};

[serial 1040]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [244]<< not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:   <<M(check_init) and x>> A <<M(failed)>> for mrm: check_init-[x]->failed{A};

[serial 1041]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [253]<< REGULATOR_OK()
  and RUN() >>
regulator_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [217] << ( RUN() )^1 >>
What for:   <<M(check_init) and x>> A <<M(normal)>> for mrm2: check_init-[x]->normal{A};

[serial 1042]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
S [257]->
Q [213] << ( true )^1 >>
What for:   <<M(check_init) and x>> -> <<M(init)>> for mrm2x: check_init-[x]->init{};

[serial 1043]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [262]  << RUN() >>
  current_temperature?(temperature)
  ;
  << temperature = CURRENT_TEMP
    and RUN() >>
  current_temperature_status := temperature.status
  << ( current_temperature_status = temperature.status )
    and ( temperature = CURRENT_TEMP )
    and RUN() >> 
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};

[serial 1044]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [273]<< REGULATOR_OK()
  and RUN() >>
regulator_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [217] << ( RUN() )^1 >>
What for:   <<M(check_normal) and x>> A <<M(normal)>> for mrm3: check_normal-[x]->normal{A};

[serial 1045]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [281]<< ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:   <<M(check_normal) and x>> A <<M(failed)>> for mrm3x: check_normal-[x]->failed{A};
  creating proof obligations for "manage_heat_source.impl"
[source=run destination=check_mode dispatch condition=true]
extracting proof obligations for "manage_heat_source.impl"

[serial 1046]: Regulate::manage_heat_source.impl
P [331] <<   >>
S [336]->
Q [331] << manage_heat_source.impl proof obligations >>
What for:  Initial proof obligations for manage_heat_source.impl
Reason solved:  Component verification conditions
making initial obligations for complete states

[serial 1047]: Regulate::manage_heat_source.impl
P [341] << INVMHS() >>
S [336]->
Q [336] << heat_previous_period = heat_control^-1 >>
What for:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
making Serban's theorems

[serial 1048]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT() >>
S [343]->
Q [343] << ( current_temperature.t <= lower_desired_temperature.t )
   or ( current_temperature.t >= upper_desired_temperature.t )
   or ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>

[serial 1049]: Regulate::manage_heat_source.impl
P [340] << heat_previous_period = cntrl'Off
  and ( INVMHS() )^1 >>
S [340]->
Q [340] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>

[serial 1050]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT() >>
S [344]->
Q [344] << ( ( heat_previous_period = cntrl'O_n ) )
   or ( heat_previous_period = cntrl'Off ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>

[serial 1051]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( not REGULATOR_OK()
  and RUN() )
   or ( INI() )
   or ( REGULATOR_OK()
  and RUN() ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
making initial proof obligations for transitions

[serial 1052]: Regulate::manage_heat_source.impl
P [340] << heat_previous_period = cntrl'Off
  and ( INVMHS() )^1 >>
S [347]->
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(poweron)>> -> <<M(run)>> for mhsPo: poweron-[ ]->run{};

[serial 1053]: Regulate::manage_heat_source.impl
P [341] << INVMHS() >>
S [348]->
Q [342] << INVMHS() >>
What for:   <<M(run) and x>> -> <<M(check_mode)>> for mhsRun: run-[x]->check_mode{};

[serial 1054]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [351]  << REQMHS5() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for mhsFailed: check_mode-[x]->run{A};

[serial 1055]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [359]  << REQMHS1() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for mhsInit: check_mode-[x]->run{A};

[serial 1056]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [365]->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT() >>
What for:   <<M(check_mode) and x>> -> <<M(check_temp)>> for mhsNormal: check_mode-[x]->check_temp{};

[serial 1057]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [369]  << REQMHS2()
    and not REQMHS1() >>
  heat_control!(cntrl'O_n)
  ;
  << heat_control = cntrl'O_n >>
  heat_previous_period' := cntrl'O_n
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for mhsBelow: check_temp-[x]->run{A};

[serial 1058]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [377]  << REQMHS3()
    and not REQMHS1() >>
  heat_control!(cntrl'Off)
  ;
  << REQMHS3()
    and not REQMHS1()
    and ( heat_control = cntrl'Off ) >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for mhsAbove: check_temp-[x]->run{A};

[serial 1059]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383]->
Q [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT() >>
What for:   <<M(check_temp) and x>> -> <<M(check_hyst)>> for mhsHys: check_temp-[x]->check_hyst{};

[serial 1060]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( ( heat_previous_period = cntrl'O_n ) ) >>
S [388]  << TEMP_IN_DESIRED_RANGE()
    and REGULATOR_MODE(x : mmode'Normal)
    and AXIOM_HC()
    and ( heat_previous_period = cntrl'O_n )
    and INVMHS() >>
  heat_control!(cntrl'O_n)
  ;
  << heat_control = cntrl'O_n >>
  heat_previous_period' := cntrl'O_n
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOn: check_hyst-[x]->run{A};

[serial 1061]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [397]  << TEMP_IN_DESIRED_RANGE()
    and REGULATOR_MODE(x : mmode'Normal)
    and AXIOM_HC()
    and ( heat_previous_period = cntrl'Off )
    and INVMHS() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOff: check_hyst-[x]->run{A};
  creating proof obligations for "manage_regulator_interface_mri.impl"
source Assertion of manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure:  << REGULATOR_INTERFACE_FAILURE >>
destination Assertion of manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure:  << REGULATOR_INTERFACE_FAILURE >>

[serial 1062]: manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure
P [1] << REGULATOR_INTERFACE_FAILURE >>
S [2]->
Q [1] << REGULATOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure:
 interface_failure -> interface_failure
source Assertion of manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode:  << +=> REGULATOR_MODE(x : regulator_mode) >>
destination Assertion of manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode:  << +=> REGULATOR_MODE(x : regulator_mode) >>

[serial 1063]: manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode
P [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [2]->
Q [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode:
 regulator_mode -> regulator_mode
source Assertion of manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode:  << +=> REGULATOR_MODE(x : regulator_mode) >>
destination Assertion of manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode:  << +=> REGULATOR_MODE(x : regulator_mode) >>

[serial 1064]: manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode
P [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [2]->
Q [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode:
 regulator_mode -> regulator_mode
source Assertion of manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure:  << MONITOR_INTERFACE_FAILURE >>
destination Assertion of manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure:  << MONITOR_INTERFACE_FAILURE >>

[serial 1065]: manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure
P [1] << MONITOR_INTERFACE_FAILURE >>
S [2]->
Q [1] << MONITOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure:
 interface_failure -> interface_failure
source Assertion of manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode:  << +=> MONITOR_MODE(x : monitor_mode) >>
destination Assertion of manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode:  << +=> MONITOR_MODE(x : monitor_mode) >>

[serial 1066]: manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode
P [1] << +=> MONITOR_MODE(x : monitor_mode) >>
S [2]->
Q [1] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode:
 monitor_mode -> monitor_mode
source Assertion of manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode:  << +=> MONITOR_MODE(x : monitor_mode) >>
destination Assertion of manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode:  << +=> MONITOR_MODE(x : monitor_mode) >>

[serial 1067]: manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode
P [1] << +=> MONITOR_MODE(x : monitor_mode) >>
S [2]->
Q [1] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode:
 monitor_mode -> monitor_mode
source Assertion of detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure:  << INTERNAL_FAILURE >>
destination Assertion of detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure:  << INTERNAL_FAILURE >>

[serial 1068]: detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure
P [1] << INTERNAL_FAILURE >>
S [2]->
Q [1] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure:
 internal_failure -> internal_failure
source Assertion of air_temperature -> temperature_sensor.air:  << air_temperature_air = CURRENT_TEMP >>
destination Assertion of air_temperature -> temperature_sensor.air:  << air_temperature_air = CURRENT_TEMP >>

[serial 1069]: air_temperature -> temperature_sensor.air
P [1] << air_temperature_air = CURRENT_TEMP >>
S [2]->
Q [1] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection air_temperature -> temperature_sensor.air:
 air_temperature -> air
source Assertion of temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature:  << current_temperature = CURRENT_TEMP >>
destination Assertion of temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature:  << current_temperature = CURRENT_TEMP >>

[serial 1070]: temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature:
 current_temperature -> current_temperature
source Assertion of temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature:  << current_temperature = CURRENT_TEMP >>
destination Assertion of temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature:  << current_temperature = CURRENT_TEMP >>

[serial 1071]: temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature:
 current_temperature -> current_temperature
source Assertion of temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature:  << current_temperature = CURRENT_TEMP >>
destination Assertion of temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature:  << current_temperature = CURRENT_TEMP >>

[serial 1072]: temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature:
 current_temperature -> current_temperature
source Assertion of temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature:  << current_temperature = CURRENT_TEMP >>
destination Assertion of temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature:  << current_temperature = CURRENT_TEMP >>

[serial 1073]: temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature:
 current_temperature -> current_temperature
source Assertion of temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature:  << current_temperature = CURRENT_TEMP >>
destination Assertion of temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature:  << current_temperature = CURRENT_TEMP >>

[serial 1074]: temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature:
 current_temperature -> current_temperature
source Assertion of temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature:  << current_temperature = CURRENT_TEMP >>
destination Assertion of temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature:  << current_temperature = CURRENT_TEMP >>

[serial 1075]: temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature:
 current_temperature -> current_temperature
source Assertion of thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status:  << +=> REGULATOR_STATUS(x : regulator_status) >>
destination Assertion of thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status:  << +=> REGULATOR_STATUS(x : regulator_status) >>

[serial 1076]: thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status
P [1] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [2]->
Q [1] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status:
 regulator_status -> regulator_status
source Assertion of thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature:  << displayed_temp_display_temperature = CURRENT_TEMP >>
destination Assertion of thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature:  << displayed_temp_display_temperature = CURRENT_TEMP >>

[serial 1077]: thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature
P [1] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << displayed_temp_display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature:
 displayed_temp -> display_temperature
source Assertion of thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control:  << +=> HEAT_CONTROL(x : heat_control) >>
destination Assertion of thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control:  << +=> HEAT_CONTROL(x : heat_control) >>

[serial 1078]: thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control
P [1] << +=> HEAT_CONTROL(x : heat_control) >>
S [2]->
Q [1] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control:
 heat_control -> heat_control
source Assertion of thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
destination Assertion of thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>

[serial 1079]: thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm
P [1] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [2]->
Q [1] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm:
 alarm_control -> alarm
source Assertion of thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status:  << monitor_status = MONITOR_STATUS() >>
destination Assertion of thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status:  << monitor_status = MONITOR_STATUS() >>

[serial 1080]: thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status
P [1] << monitor_status = MONITOR_STATUS() >>
S [2]->
Q [1] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status:
 monitor_status -> monitor_status
source Assertion of operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp:  << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
destination Assertion of operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp:  << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>

[serial 1081]: operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp
P [1] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
S [2]->
Q [1] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp:
 lower_desired_temperature -> lower_desired_temp
source Assertion of operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>
destination Assertion of operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>

[serial 1082]: operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature
P [1] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [2]->
Q [1] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature:
 lower_desired_temperature -> lower_desired_temperature
source Assertion of operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp:  << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
destination Assertion of operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp:  << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>

[serial 1083]: operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp
P [1] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
S [2]->
Q [1] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp:
 upper_desired_temperature -> upper_desired_temp
source Assertion of operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>
destination Assertion of operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>

[serial 1084]: operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature
P [1] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [2]->
Q [1] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature:
 upper_desired_temperature -> upper_desired_temperature
source Assertion of operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>
destination Assertion of operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>

[serial 1085]: operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature
P [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [2]->
Q [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature
source Assertion of operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>
destination Assertion of operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>

[serial 1086]: operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature
P [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [2]->
Q [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature
source Assertion of operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>
destination Assertion of operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>

[serial 1087]: operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature
P [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [2]->
Q [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature
source Assertion of operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>
destination Assertion of operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>

[serial 1088]: operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature
P [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [2]->
Q [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature
27 instance model connection assume-guarantee verification conditions generated.
source Assertion of mcti:  << current_temperature = CURRENT_TEMP >>
destination Assertion of mcti:  << current_temperature = CURRENT_TEMP >>

[serial 1089]: Monitor::monitor_temperature.impl.mcti
P [9] << current_temperature = CURRENT_TEMP >>
S [42]->
Q [77] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcti:
 current_temperature -> current_temperature
source Assertion of mcta:  << current_temperature = CURRENT_TEMP >>
destination Assertion of mcta:  << current_temperature = CURRENT_TEMP >>

[serial 1090]: Monitor::monitor_temperature.impl.mcta
P [9] << current_temperature = CURRENT_TEMP >>
S [43]->
Q [259] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcta:
 current_temperature -> current_temperature
source Assertion of mctm:  << current_temperature = CURRENT_TEMP >>
destination Assertion of mctm:  << current_temperature = CURRENT_TEMP >>

[serial 1091]: Monitor::monitor_temperature.impl.mctm
P [9] << current_temperature = CURRENT_TEMP >>
S [44]->
Q [126] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mctm:
 current_temperature -> current_temperature
source Assertion of muat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>
destination Assertion of muat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>

[serial 1092]: Monitor::monitor_temperature.impl.muat
P [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [46]->
Q [81] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.muat:
 upper_alarm_temperature -> upper_alarm_temperature
source Assertion of mlat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>
destination Assertion of mlat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>

[serial 1093]: Monitor::monitor_temperature.impl.mlat
P [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [47]->
Q [83] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mlat:
 lower_alarm_temperature -> lower_alarm_temperature
source Assertion of maul:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>
destination Assertion of maul:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>

[serial 1094]: Monitor::monitor_temperature.impl.maul
P [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [48]->
Q [257] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.maul:
 upper_alarm_temperature -> upper_alarm_temperature
source Assertion of mall:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>
destination Assertion of mall:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>

[serial 1095]: Monitor::monitor_temperature.impl.mall
P [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [49]->
Q [255] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mall:
 lower_alarm_temperature -> lower_alarm_temperature
source Assertion of malrm:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
destination Assertion of malrm:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>

[serial 1096]: Monitor::monitor_temperature.impl.malrm
P [251] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [51]->
Q [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.malrm:
 alarm_control -> alarm_control
source Assertion of mms:  << monitor_status = MONITOR_STATUS() >>
destination Assertion of mms:  << monitor_status = MONITOR_STATUS() >>

[serial 1097]: Monitor::monitor_temperature.impl.mms
P [85] << monitor_status = MONITOR_STATUS() >>
S [53]->
Q [17] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mms:
 monitor_status -> monitor_status
source Assertion of intff:  << MONITOR_INTERFACE_FAILURE >>
destination Assertion of intff:  << MONITOR_INTERFACE_FAILURE >>

[serial 1098]: Monitor::monitor_temperature.impl.intff
P [87] << MONITOR_INTERFACE_FAILURE >>
S [54]->
Q [122] << MONITOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.intff:
 interface_failure -> interface_failure
source Assertion of mf:  << INTERNAL_FAILURE >>
destination Assertion of mf:  << INTERNAL_FAILURE >>

[serial 1099]: Monitor::monitor_temperature.impl.mf
P [19] << INTERNAL_FAILURE >>
S [56]->
Q [124] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mf:
 regulator_failure -> internal_failure
source Assertion of mmmi:  << +=> MONITOR_MODE(x : monitor_mode) >>
destination Assertion of mmmi:  << +=> MONITOR_MODE(x : monitor_mode) >>

[serial 1100]: Monitor::monitor_temperature.impl.mmmi
P [120] << +=> MONITOR_MODE(x : monitor_mode) >>
S [57]->
Q [79] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmmi:
 monitor_mode -> monitor_mode
source Assertion of mmma:  << +=> MONITOR_MODE(x : monitor_mode) >>
destination Assertion of mmma:  << +=> MONITOR_MODE(x : monitor_mode) >>

[serial 1101]: Monitor::monitor_temperature.impl.mmma
P [120] << +=> MONITOR_MODE(x : monitor_mode) >>
S [58]->
Q [253] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmma:
 monitor_mode -> monitor_mode
source Assertion of a2ts:  << air_temperature_air = CURRENT_TEMP >>
destination Assertion of a2ts:  << air_temperature_air = CURRENT_TEMP >>

[serial 1102]: KSU_Isolette::isolette.single_sensor.a2ts
P [136] << air_temperature_air = CURRENT_TEMP >>
S [173]->
Q [93] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.a2ts:
 air_temperature -> air
source Assertion of ct:  << current_temperature = CURRENT_TEMP >>
destination Assertion of ct:  << current_temperature = CURRENT_TEMP >>

[serial 1103]: KSU_Isolette::isolette.single_sensor.ct
P [95] << current_temperature = CURRENT_TEMP >>
S [175]->
Q [288] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ct:
 current_temperature -> current_temperature
source Assertion of hc:  << +=> HEAT_CONTROL(x : heat_control) >>
destination Assertion of hc:  << +=> HEAT_CONTROL(x : heat_control) >>

[serial 1104]: KSU_Isolette::isolette.single_sensor.hc
P [290] << +=> HEAT_CONTROL(x : heat_control) >>
S [177]->
Q [156] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.hc:
 heat_control -> heat_control
source Assertion of ldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>
destination Assertion of ldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>

[serial 1105]: KSU_Isolette::isolette.single_sensor.ldt
P [442] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [183]->
Q [292] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature
source Assertion of udt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>
destination Assertion of udt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>

[serial 1106]: KSU_Isolette::isolette.single_sensor.udt
P [444] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [185]->
Q [294] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature
source Assertion of lat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>
destination Assertion of lat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>

[serial 1107]: KSU_Isolette::isolette.single_sensor.lat
P [446] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [187]->
Q [296] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature
source Assertion of uat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>
destination Assertion of uat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>

[serial 1108]: KSU_Isolette::isolette.single_sensor.uat
P [448] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [189]->
Q [298] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature
source Assertion of rs:  << +=> REGULATOR_STATUS(x : regulator_status) >>
destination Assertion of rs:  << +=> REGULATOR_STATUS(x : regulator_status) >>

[serial 1109]: KSU_Isolette::isolette.single_sensor.rs
P [300] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [191]->
Q [451] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.rs:
 regulator_status -> regulator_status
source Assertion of ms:  << monitor_status = MONITOR_STATUS() >>
destination Assertion of ms:  << monitor_status = MONITOR_STATUS() >>

[serial 1110]: KSU_Isolette::isolette.single_sensor.ms
P [302] << monitor_status = MONITOR_STATUS() >>
S [193]->
Q [453] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ms:
 monitor_status -> monitor_status
source Assertion of dt:  << display_temperature = CURRENT_TEMP >>
destination Assertion of dt:  << display_temperature = CURRENT_TEMP >>

[serial 1111]: KSU_Isolette::isolette.single_sensor.dt
P [304] << display_temperature = CURRENT_TEMP >>
S [195]->
Q [455] << display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.dt:
 display_temperature -> display_temperature
source Assertion of al:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
destination Assertion of al:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>

[serial 1112]: KSU_Isolette::isolette.single_sensor.al
P [306] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [197]->
Q [457] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.al:
 alarm_control -> alarm
source Assertion of a2cs:  << air_temperature_air = CURRENT_TEMP >>
destination Assertion of a2cs:  << air_temperature_air = CURRENT_TEMP >>

[serial 1113]: KSU_Isolette::isolette.dual_sensor.a2cs
P [136] << air_temperature_air = CURRENT_TEMP >>
S [260]->
Q [93] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2cs:
 air_temperature -> air
source Assertion of a2ms:  << air_temperature_air = CURRENT_TEMP >>
destination Assertion of a2ms:  << air_temperature_air = CURRENT_TEMP >>

[serial 1114]: KSU_Isolette::isolette.dual_sensor.a2ms
P [136] << air_temperature_air = CURRENT_TEMP >>
S [261]->
Q [93] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2ms:
 air_temperature -> air
source Assertion of cont:  << current_temperature_control_temp = CURRENT_TEMP >>
destination Assertion of cont:  << current_temperature_control_temp = CURRENT_TEMP >>

[serial 1115]: KSU_Isolette::isolette.dual_sensor.cont
P [95] << current_temperature_control_temp = CURRENT_TEMP >>
S [266]->
Q [368] << current_temperature_control_temp = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.cont:
 current_temperature -> control_temp
source Assertion of ct:  << current_temperature_monitor_temp = CURRENT_TEMP >>
destination Assertion of ct:  << current_temperature_monitor_temp = CURRENT_TEMP >>

[serial 1116]: KSU_Isolette::isolette.dual_sensor.ct
P [95] << current_temperature_monitor_temp = CURRENT_TEMP >>
S [267]->
Q [371] << current_temperature_monitor_temp = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ct:
 current_temperature -> monitor_temp
source Assertion of hc:  << +=> HEAT_CONTROL(x : heat_control) >>
destination Assertion of hc:  << +=> HEAT_CONTROL(x : heat_control) >>

[serial 1117]: KSU_Isolette::isolette.dual_sensor.hc
P [373] << +=> HEAT_CONTROL(x : heat_control) >>
S [268]->
Q [156] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.hc:
 heat_control -> heat_control
source Assertion of ldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>
destination Assertion of ldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>

[serial 1118]: KSU_Isolette::isolette.dual_sensor.ldt
P [442] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [269]->
Q [375] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature
source Assertion of udt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>
destination Assertion of udt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>

[serial 1119]: KSU_Isolette::isolette.dual_sensor.udt
P [444] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [270]->
Q [377] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature
source Assertion of lat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>
destination Assertion of lat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>

[serial 1120]: KSU_Isolette::isolette.dual_sensor.lat
P [446] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [271]->
Q [379] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature
source Assertion of uat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>
destination Assertion of uat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>

[serial 1121]: KSU_Isolette::isolette.dual_sensor.uat
P [448] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [272]->
Q [381] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature
source Assertion of rs:  << +=> REGULATOR_STATUS(x : regulator_status) >>
destination Assertion of rs:  << +=> REGULATOR_STATUS(x : regulator_status) >>

[serial 1122]: KSU_Isolette::isolette.dual_sensor.rs
P [383] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [273]->
Q [451] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.rs:
 regulator_status -> regulator_status
source Assertion of ms:  << monitor_status = MONITOR_STATUS() >>
destination Assertion of ms:  << monitor_status = MONITOR_STATUS() >>

[serial 1123]: KSU_Isolette::isolette.dual_sensor.ms
P [385] << monitor_status = MONITOR_STATUS() >>
S [274]->
Q [453] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ms:
 monitor_status -> monitor_status
source Assertion of dt:  << display_temperature = CURRENT_TEMP >>
destination Assertion of dt:  << display_temperature = CURRENT_TEMP >>

[serial 1124]: KSU_Isolette::isolette.dual_sensor.dt
P [387] << display_temperature = CURRENT_TEMP >>
S [275]->
Q [455] << display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.dt:
 display_temperature -> display_temperature
source Assertion of al:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
destination Assertion of al:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>

[serial 1125]: KSU_Isolette::isolette.dual_sensor.al
P [389] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [276]->
Q [457] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.al:
 alarm_control -> alarm
source Assertion of tctm:  << current_temperature = CURRENT_TEMP >>
destination Assertion of tctm:  << current_temperature = CURRENT_TEMP >>

[serial 1126]: KSU_Isolette::thermostat_single_sensor.impl.tctm
P [288] << current_temperature = CURRENT_TEMP >>
S [337]->
Q [9] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctm:
 current_temperature -> current_temperature
source Assertion of tctr:  << current_temperature = CURRENT_TEMP >>
destination Assertion of tctr:  << current_temperature = CURRENT_TEMP >>

[serial 1127]: KSU_Isolette::thermostat_single_sensor.impl.tctr
P [288] << current_temperature = CURRENT_TEMP >>
S [338]->
Q [19] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctr:
 current_temperature -> current_temperature
source Assertion of thc:  << +=> HEAT_CONTROL(x : heat_control) >>
destination Assertion of thc:  << +=> HEAT_CONTROL(x : heat_control) >>

[serial 1128]: KSU_Isolette::thermostat_single_sensor.impl.thc
P [21] << +=> HEAT_CONTROL(x : heat_control) >>
S [339]->
Q [290] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.thc:
 heat_control -> heat_control
source Assertion of tudt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>
destination Assertion of tudt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>

[serial 1129]: KSU_Isolette::thermostat_single_sensor.impl.tudt
P [294] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [340]->
Q [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature
source Assertion of tldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>
destination Assertion of tldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>

[serial 1130]: KSU_Isolette::thermostat_single_sensor.impl.tldt
P [292] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [341]->
Q [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature
source Assertion of tuat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>
destination Assertion of tuat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>

[serial 1131]: KSU_Isolette::thermostat_single_sensor.impl.tuat
P [298] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [342]->
Q [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature
source Assertion of tlat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>
destination Assertion of tlat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>

[serial 1132]: KSU_Isolette::thermostat_single_sensor.impl.tlat
P [296] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [343]->
Q [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature
source Assertion of trs:  << +=> REGULATOR_STATUS(x : regulator_status) >>
destination Assertion of trs:  << +=> REGULATOR_STATUS(x : regulator_status) >>

[serial 1133]: KSU_Isolette::thermostat_single_sensor.impl.trs
P [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [344]->
Q [300] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.trs:
 regulator_status -> regulator_status
source Assertion of tdt:  << displayed_temp_display_temperature = CURRENT_TEMP >>
destination Assertion of tdt:  << displayed_temp_display_temperature = CURRENT_TEMP >>

[serial 1134]: KSU_Isolette::thermostat_single_sensor.impl.tdt
P [17] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [345]->
Q [304] << displayed_temp_display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tdt:
 displayed_temp -> display_temperature
source Assertion of tms:  << monitor_status = MONITOR_STATUS() >>
destination Assertion of tms:  << monitor_status = MONITOR_STATUS() >>

[serial 1135]: KSU_Isolette::thermostat_single_sensor.impl.tms
P [17] << monitor_status = MONITOR_STATUS() >>
S [346]->
Q [302] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tms:
 monitor_status -> monitor_status
source Assertion of ta:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
destination Assertion of ta:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>

[serial 1136]: KSU_Isolette::thermostat_single_sensor.impl.ta
P [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [347]->
Q [306] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.ta:
 alarm_control -> alarm_control
source Assertion of tf:  << INTERNAL_FAILURE >>
destination Assertion of tf:  << INTERNAL_FAILURE >>

[serial 1137]: KSU_Isolette::thermostat_single_sensor.impl.tf
P [10] << INTERNAL_FAILURE >>
S [348]->
Q [19] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tf:
 internal_failure -> regulator_failure
source Assertion of tctm:  << monitor_temp_current_temperature = CURRENT_TEMP >>
destination Assertion of tctm:  << monitor_temp_current_temperature = CURRENT_TEMP >>

[serial 1138]: KSU_Isolette::thermostat_dual_sensor.impl.tctm
P [371] << monitor_temp_current_temperature = CURRENT_TEMP >>
S [416]->
Q [9] << monitor_temp_current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctm:
 monitor_temp -> current_temperature
source Assertion of tctr:  << control_temp_current_temperature = CURRENT_TEMP >>
destination Assertion of tctr:  << control_temp_current_temperature = CURRENT_TEMP >>

[serial 1139]: KSU_Isolette::thermostat_dual_sensor.impl.tctr
P [368] << control_temp_current_temperature = CURRENT_TEMP >>
S [417]->
Q [19] << control_temp_current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctr:
 control_temp -> current_temperature
source Assertion of thc:  << +=> HEAT_CONTROL(x : heat_control) >>
destination Assertion of thc:  << +=> HEAT_CONTROL(x : heat_control) >>

[serial 1140]: KSU_Isolette::thermostat_dual_sensor.impl.thc
P [21] << +=> HEAT_CONTROL(x : heat_control) >>
S [418]->
Q [373] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.thc:
 heat_control -> heat_control
source Assertion of tudt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>
destination Assertion of tudt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>

[serial 1141]: KSU_Isolette::thermostat_dual_sensor.impl.tudt
P [377] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [419]->
Q [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature
source Assertion of tldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>
destination Assertion of tldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>

[serial 1142]: KSU_Isolette::thermostat_dual_sensor.impl.tldt
P [375] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [420]->
Q [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature
source Assertion of tuat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>
destination Assertion of tuat:  << upper_alarm_temperature = UPPER_ALARM_TEMP >>

[serial 1143]: KSU_Isolette::thermostat_dual_sensor.impl.tuat
P [381] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [421]->
Q [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature
source Assertion of tlat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>
destination Assertion of tlat:  << lower_alarm_temperature = LOWER_ALARM_TEMP >>

[serial 1144]: KSU_Isolette::thermostat_dual_sensor.impl.tlat
P [379] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [422]->
Q [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature
source Assertion of trs:  << +=> REGULATOR_STATUS(x : regulator_status) >>
destination Assertion of trs:  << +=> REGULATOR_STATUS(x : regulator_status) >>

[serial 1145]: KSU_Isolette::thermostat_dual_sensor.impl.trs
P [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [423]->
Q [383] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.trs:
 regulator_status -> regulator_status
source Assertion of tdt:  << displayed_temp_display_temperature = CURRENT_TEMP >>
destination Assertion of tdt:  << displayed_temp_display_temperature = CURRENT_TEMP >>

[serial 1146]: KSU_Isolette::thermostat_dual_sensor.impl.tdt
P [17] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [424]->
Q [387] << displayed_temp_display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tdt:
 displayed_temp -> display_temperature
source Assertion of tms:  << monitor_status = MONITOR_STATUS() >>
destination Assertion of tms:  << monitor_status = MONITOR_STATUS() >>

[serial 1147]: KSU_Isolette::thermostat_dual_sensor.impl.tms
P [17] << monitor_status = MONITOR_STATUS() >>
S [425]->
Q [385] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tms:
 monitor_status -> monitor_status
source Assertion of ta:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
destination Assertion of ta:  << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>

[serial 1148]: KSU_Isolette::thermostat_dual_sensor.impl.ta
P [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [426]->
Q [389] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.ta:
 alarm_control -> alarm_control
source Assertion of tf:  << INTERNAL_FAILURE >>
destination Assertion of tf:  << INTERNAL_FAILURE >>

[serial 1149]: KSU_Isolette::thermostat_dual_sensor.impl.tf
P [10] << INTERNAL_FAILURE >>
S [427]->
Q [19] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tf:
 internal_failure -> regulator_failure
source Assertion of tmp:  << air_temperature = CURRENT_TEMP >>
destination Assertion of tmp:  << air_temperature = CURRENT_TEMP >>

[serial 1150]: Nursery::Room.Normal_Operation.tmp
P [19] << air_temperature = CURRENT_TEMP >>
S [124]->
Q [136] << air_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Nursery::Room.Normal_Operation.tmp:
 air_temperature -> air_temperature
source Assertion of rudt:  << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
destination Assertion of rudt:  << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>

[serial 1151]: Regulate::regulate_temperature.impl.rudt
P [13] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
S [49]->
Q [88] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rudt:
 upper_desired_temperature -> upper_desired_temp
source Assertion of rldt:  << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
destination Assertion of rldt:  << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>

[serial 1152]: Regulate::regulate_temperature.impl.rldt
P [11] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
S [50]->
Q [86] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rldt:
 lower_desired_temperature -> lower_desired_temp
source Assertion of mudt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>
destination Assertion of mudt:  << upper_desired_temperature = UPPER_DESIRED_TEMP >>

[serial 1153]: Regulate::regulate_temperature.impl.mudt
P [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [51]->
Q [301] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mudt:
 upper_desired_temperature -> upper_desired_temperature
source Assertion of mldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>
destination Assertion of mldt:  << lower_desired_temperature = LOWER_DESIRED_TEMP >>

[serial 1154]: Regulate::regulate_temperature.impl.mldt
P [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [52]->
Q [299] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mldt:
 lower_desired_temperature -> lower_desired_temperature
source Assertion of rrs:  << +=> REGULATOR_STATUS(x : regulator_status) >>
destination Assertion of rrs:  << +=> REGULATOR_STATUS(x : regulator_status) >>

[serial 1155]: Regulate::regulate_temperature.impl.rrs
P [84] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [54]->
Q [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrs:
 regulator_status -> regulator_status
source Assertion of rdt:  << displayed_temp = CURRENT_TEMP >>
destination Assertion of rdt:  << displayed_temp = CURRENT_TEMP >>

[serial 1156]: Regulate::regulate_temperature.impl.rdt
P [92] << displayed_temp = CURRENT_TEMP >>
S [56]->
Q [17] << displayed_temp = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rdt:
 displayed_temp -> displayed_temp
source Assertion of rcti:  << current_temperature = CURRENT_TEMP >>
destination Assertion of rcti:  << current_temperature = CURRENT_TEMP >>

[serial 1157]: Regulate::regulate_temperature.impl.rcti
P [19] << current_temperature = CURRENT_TEMP >>
S [58]->
Q [90] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcti:
 current_temperature -> current_temperature
source Assertion of rcth:  << current_temperature = CURRENT_TEMP >>
destination Assertion of rcth:  << current_temperature = CURRENT_TEMP >>

[serial 1158]: Regulate::regulate_temperature.impl.rcth
P [19] << current_temperature = CURRENT_TEMP >>
S [59]->
Q [297] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcth:
 current_temperature -> current_temperature
source Assertion of rhc:  << +=> HEAT_CONTROL(x : heat_control) >>
destination Assertion of rhc:  << +=> HEAT_CONTROL(x : heat_control) >>

[serial 1159]: Regulate::regulate_temperature.impl.rhc
P [295] << +=> HEAT_CONTROL(x : heat_control) >>
S [61]->
Q [21] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rhc:
 heat_control -> heat_control
source Assertion of rrmh:  << +=> REGULATOR_MODE(x : regulator_mode) >>
destination Assertion of rrmh:  << +=> REGULATOR_MODE(x : regulator_mode) >>

[serial 1160]: Regulate::regulate_temperature.impl.rrmh
P [161] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [62]->
Q [303] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmh:
 regulator_mode -> regulator_mode
source Assertion of rrmi:  << +=> REGULATOR_MODE(x : regulator_mode) >>
destination Assertion of rrmi:  << +=> REGULATOR_MODE(x : regulator_mode) >>

[serial 1161]: Regulate::regulate_temperature.impl.rrmi
P [161] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [63]->
Q [94] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmi:
 regulator_mode -> regulator_mode
source Assertion of rctm:  << current_temperature = CURRENT_TEMP >>
destination Assertion of rctm:  << current_temperature = CURRENT_TEMP >>

[serial 1162]: Regulate::regulate_temperature.impl.rctm
P [19] << current_temperature = CURRENT_TEMP >>
S [64]->
Q [163] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rctm:
 current_temperature -> current_temperature
source Assertion of rif:  << REGULATOR_INTERFACE_FAILURE >>
destination Assertion of rif:  << REGULATOR_INTERFACE_FAILURE >>

[serial 1163]: Regulate::regulate_temperature.impl.rif
P [96] << REGULATOR_INTERFACE_FAILURE >>
S [65]->
Q [165] << REGULATOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rif:
 interface_failure -> interface_failure
75 declarative model connection assume-guarantee verification conditions generated.
There were 3 instance model connections lacking a BLESS::Assertion property on both ends.
There were 8 Declarative model connections lacking a BLESS::Assertion property on both ends.
No errors found.
Executing proof script . . .
You chose proof script: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/Isolette.ps
step:  1
#proof script for isolette.aadl
step:  2
#manage_monitor_mode_mmm.impl
step:  3
****subscript****
You chose proof subscript: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/subscripts/mmm.ps
step:  1
#  You chose proof script: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/subscripts/mmm.ps
step:  2
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  3
****sort-by-component****
sorting proof obligations for Monitor::manage_monitor_mode.impl
Monitor::manage_monitor_mode.impl  [serial 1003]  
Monitor::manage_monitor_mode.impl  [serial 1004]  
Monitor::manage_monitor_mode.impl  [serial 1005]  
Monitor::manage_monitor_mode.impl  [serial 1006]  
Monitor::manage_monitor_mode.impl  [serial 1007]  
Monitor::manage_monitor_mode.impl  [serial 1008]  
Monitor::manage_monitor_mode.impl  [serial 1009]  
Monitor::manage_monitor_mode.impl  [serial 1010]  
Monitor::manage_monitor_mode.impl  [serial 1011]  
Monitor::manage_monitor_mode.impl  [serial 1012]  
Monitor::manage_monitor_mode.impl  [serial 1013]  
Monitor::manage_monitor_mode.impl  [serial 1014]  
Monitor::manage_monitor_mode.impl  [serial 1015]  
Monitor::manage_alarm.impl  [serial 1017]  
Monitor::manage_alarm.impl  [serial 1018]  
Monitor::manage_alarm.impl  [serial 1019]  
Monitor::manage_alarm.impl  [serial 1020]  
Monitor::manage_alarm.impl  [serial 1021]  
Monitor::manage_alarm.impl  [serial 1022]  
Monitor::manage_alarm.impl  [serial 1023]  
Monitor::manage_alarm.impl  [serial 1024]  
Monitor::manage_alarm.impl  [serial 1025]  
Monitor::manage_alarm.impl  [serial 1026]  
Monitor::manage_alarm.impl  [serial 1027]  
Monitor::manage_alarm.impl  [serial 1028]  
Monitor::manage_alarm.impl  [serial 1029]  
Monitor::manage_alarm.impl  [serial 1030]  
Monitor::manage_alarm.impl  [serial 1031]  
Regulate::manage_regulator_mode.impl  [serial 1033]  
Regulate::manage_regulator_mode.impl  [serial 1034]  
Regulate::manage_regulator_mode.impl  [serial 1035]  
Regulate::manage_regulator_mode.impl  [serial 1036]  
Regulate::manage_regulator_mode.impl  [serial 1037]  
Regulate::manage_regulator_mode.impl  [serial 1038]  
Regulate::manage_regulator_mode.impl  [serial 1039]  
Regulate::manage_regulator_mode.impl  [serial 1040]  
Regulate::manage_regulator_mode.impl  [serial 1041]  
Regulate::manage_regulator_mode.impl  [serial 1042]  
Regulate::manage_regulator_mode.impl  [serial 1043]  
Regulate::manage_regulator_mode.impl  [serial 1044]  
Regulate::manage_regulator_mode.impl  [serial 1045]  
Regulate::manage_heat_source.impl  [serial 1047]  
Regulate::manage_heat_source.impl  [serial 1048]  
Regulate::manage_heat_source.impl  [serial 1049]  
Regulate::manage_heat_source.impl  [serial 1050]  
Regulate::manage_heat_source.impl  [serial 1051]  
Regulate::manage_heat_source.impl  [serial 1052]  
Regulate::manage_heat_source.impl  [serial 1053]  
Regulate::manage_heat_source.impl  [serial 1054]  
Regulate::manage_heat_source.impl  [serial 1055]  
Regulate::manage_heat_source.impl  [serial 1056]  
Regulate::manage_heat_source.impl  [serial 1057]  
Regulate::manage_heat_source.impl  [serial 1058]  
Regulate::manage_heat_source.impl  [serial 1059]  
Regulate::manage_heat_source.impl  [serial 1060]  
Regulate::manage_heat_source.impl  [serial 1061]  
manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure  [serial 1062]  
manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode  [serial 1063]  
manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode  [serial 1064]  
manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure  [serial 1065]  
manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode  [serial 1066]  
manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode  [serial 1067]  
detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure  [serial 1068]  
air_temperature -> temperature_sensor.air  [serial 1069]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature  [serial 1070]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature  [serial 1071]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature  [serial 1072]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature  [serial 1073]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature  [serial 1074]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature  [serial 1075]  
thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status  [serial 1076]  
thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature  [serial 1077]  
thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control  [serial 1078]  
thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm  [serial 1079]  
thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status  [serial 1080]  
operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp  [serial 1081]  
operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature  [serial 1082]  
operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp  [serial 1083]  
operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature  [serial 1084]  
operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature  [serial 1085]  
operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature  [serial 1086]  
operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature  [serial 1087]  
operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature  [serial 1088]  
Monitor::monitor_temperature.impl.mcti  [serial 1089]  
Monitor::monitor_temperature.impl.mcta  [serial 1090]  
Monitor::monitor_temperature.impl.mctm  [serial 1091]  
Monitor::monitor_temperature.impl.muat  [serial 1092]  
Monitor::monitor_temperature.impl.mlat  [serial 1093]  
Monitor::monitor_temperature.impl.maul  [serial 1094]  
Monitor::monitor_temperature.impl.mall  [serial 1095]  
Monitor::monitor_temperature.impl.malrm  [serial 1096]  
Monitor::monitor_temperature.impl.mms  [serial 1097]  
Monitor::monitor_temperature.impl.intff  [serial 1098]  
Monitor::monitor_temperature.impl.mf  [serial 1099]  
Monitor::monitor_temperature.impl.mmmi  [serial 1100]  
Monitor::monitor_temperature.impl.mmma  [serial 1101]  
KSU_Isolette::isolette.single_sensor.a2ts  [serial 1102]  
KSU_Isolette::isolette.single_sensor.ct  [serial 1103]  
KSU_Isolette::isolette.single_sensor.hc  [serial 1104]  
KSU_Isolette::isolette.single_sensor.ldt  [serial 1105]  
KSU_Isolette::isolette.single_sensor.udt  [serial 1106]  
KSU_Isolette::isolette.single_sensor.lat  [serial 1107]  
KSU_Isolette::isolette.single_sensor.uat  [serial 1108]  
KSU_Isolette::isolette.single_sensor.rs  [serial 1109]  
KSU_Isolette::isolette.single_sensor.ms  [serial 1110]  
KSU_Isolette::isolette.single_sensor.dt  [serial 1111]  
KSU_Isolette::isolette.single_sensor.al  [serial 1112]  
KSU_Isolette::isolette.dual_sensor.a2cs  [serial 1113]  
KSU_Isolette::isolette.dual_sensor.a2ms  [serial 1114]  
KSU_Isolette::isolette.dual_sensor.cont  [serial 1115]  
KSU_Isolette::isolette.dual_sensor.ct  [serial 1116]  
KSU_Isolette::isolette.dual_sensor.hc  [serial 1117]  
KSU_Isolette::isolette.dual_sensor.ldt  [serial 1118]  
KSU_Isolette::isolette.dual_sensor.udt  [serial 1119]  
KSU_Isolette::isolette.dual_sensor.lat  [serial 1120]  
KSU_Isolette::isolette.dual_sensor.uat  [serial 1121]  
KSU_Isolette::isolette.dual_sensor.rs  [serial 1122]  
KSU_Isolette::isolette.dual_sensor.ms  [serial 1123]  
KSU_Isolette::isolette.dual_sensor.dt  [serial 1124]  
KSU_Isolette::isolette.dual_sensor.al  [serial 1125]  
KSU_Isolette::thermostat_single_sensor.impl.tctm  [serial 1126]  
KSU_Isolette::thermostat_single_sensor.impl.tctr  [serial 1127]  
KSU_Isolette::thermostat_single_sensor.impl.thc  [serial 1128]  
KSU_Isolette::thermostat_single_sensor.impl.tudt  [serial 1129]  
KSU_Isolette::thermostat_single_sensor.impl.tldt  [serial 1130]  
KSU_Isolette::thermostat_single_sensor.impl.tuat  [serial 1131]  
KSU_Isolette::thermostat_single_sensor.impl.tlat  [serial 1132]  
KSU_Isolette::thermostat_single_sensor.impl.trs  [serial 1133]  
KSU_Isolette::thermostat_single_sensor.impl.tdt  [serial 1134]  
KSU_Isolette::thermostat_single_sensor.impl.tms  [serial 1135]  
KSU_Isolette::thermostat_single_sensor.impl.ta  [serial 1136]  
KSU_Isolette::thermostat_single_sensor.impl.tf  [serial 1137]  
KSU_Isolette::thermostat_dual_sensor.impl.tctm  [serial 1138]  
KSU_Isolette::thermostat_dual_sensor.impl.tctr  [serial 1139]  
KSU_Isolette::thermostat_dual_sensor.impl.thc  [serial 1140]  
KSU_Isolette::thermostat_dual_sensor.impl.tudt  [serial 1141]  
KSU_Isolette::thermostat_dual_sensor.impl.tldt  [serial 1142]  
KSU_Isolette::thermostat_dual_sensor.impl.tuat  [serial 1143]  
KSU_Isolette::thermostat_dual_sensor.impl.tlat  [serial 1144]  
KSU_Isolette::thermostat_dual_sensor.impl.trs  [serial 1145]  
KSU_Isolette::thermostat_dual_sensor.impl.tdt  [serial 1146]  
KSU_Isolette::thermostat_dual_sensor.impl.tms  [serial 1147]  
KSU_Isolette::thermostat_dual_sensor.impl.ta  [serial 1148]  
KSU_Isolette::thermostat_dual_sensor.impl.tf  [serial 1149]  
Nursery::Room.Normal_Operation.tmp  [serial 1150]  
Regulate::regulate_temperature.impl.rudt  [serial 1151]  
Regulate::regulate_temperature.impl.rldt  [serial 1152]  
Regulate::regulate_temperature.impl.mudt  [serial 1153]  
Regulate::regulate_temperature.impl.mldt  [serial 1154]  
Regulate::regulate_temperature.impl.rrs  [serial 1155]  
Regulate::regulate_temperature.impl.rdt  [serial 1156]  
Regulate::regulate_temperature.impl.rcti  [serial 1157]  
Regulate::regulate_temperature.impl.rcth  [serial 1158]  
Regulate::regulate_temperature.impl.rhc  [serial 1159]  
Regulate::regulate_temperature.impl.rrmh  [serial 1160]  
Regulate::regulate_temperature.impl.rrmi  [serial 1161]  
Regulate::regulate_temperature.impl.rctm  [serial 1162]  
Regulate::regulate_temperature.impl.rif  [serial 1163]  
After sort-by-component[Monitor::manage_monitor_mode.impl], no change. 
step:  4
#Monitor::manage_monitor_mode.impl
step:  5
#[serial 1003] <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definitio
step:  6
****make-an****
Making obligation 0
Obligations:

[serial 1003]: Monitor::manage_monitor_mode.impl
P [167] << true >>
S [158]->
Q [158] << true >>
What for:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.
Done making obligation 0
step:  7
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1003]: Monitor::manage_monitor_mode.impl
P [167] << true >>
S [158]->
Q [158] << true >>
What for:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1004]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [158]->
Q [158] << true >>
What for:  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  8
#[serial 1004] <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
step:  9
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1004]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [158]->
Q [158] << true >>
What for:  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1005]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
S [169]->
Q [169] << ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  10
#[serial 1005] Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>
step:  11
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1005]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
S [169]->
Q [169] << ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1165]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
   or ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1005]
. . . done Normalizing Unsolved Proof Obligations [7.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1165]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
   or ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1005]
Done Normalizing
step:  12
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1165]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
   or ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1005]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1167]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1165]
. . . Substituting <= with not < [7.6 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1167]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1165]
Done replacing a<=b with (not b<a)
step:  13
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1167]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1165]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1169]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1167]
. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1169]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1167]
Done Normalizing
step:  14
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1169]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1167]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1171]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Associativity: (b.c).a = a.b.c [serial 1169]
. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1171]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Associativity: (b.c).a = a.b.c [serial 1169]
Done applying laws
step:  15
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1171]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Associativity: (b.c).a = a.b.c [serial 1169]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1172]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and not ( not ( status'Valid = current_temperature_status ) ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1171]
. . . done applying DeMorgan's Law  [7.7 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1172]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and not ( not ( status'Valid = current_temperature_status ) ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1171]
step:  16
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1172]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and not ( not ( status'Valid = current_temperature_status ) ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1171]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1174]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1172]
. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1174]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1172]
Done Normalizing
step:  17
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1174]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1172]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1176]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Associativity: (b.c).a = a.b.c [serial 1174]
. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1176]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Associativity: (b.c).a = a.b.c [serial 1174]
Done applying laws
step:  18
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1176]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Associativity: (b.c).a = a.b.c [serial 1174]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 1177]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( status'Valid = current_temperature_status
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not INTERNAL_FAILURE^0
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( status'Valid = current_temperature_status
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not INTERNAL_FAILURE^0
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1176]
. . . done putting into conjunctive normal form [7.7 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1177]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( status'Valid = current_temperature_status
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not INTERNAL_FAILURE^0
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( status'Valid = current_temperature_status
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not INTERNAL_FAILURE^0
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1176]
Done making conjunctive normal forms.
step:  19
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1177]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( status'Valid = current_temperature_status
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not INTERNAL_FAILURE^0
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( status'Valid = current_temperature_status
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not INTERNAL_FAILURE^0
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1176]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1178]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1177]

This Proof Obligation:

[serial 1178]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1177]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1179]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1178]

This Proof Obligation:

[serial 1179]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1178]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1180]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1179]

This Proof Obligation:

[serial 1180]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1179]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1181]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1180]
. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1181]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1180]
Done applying laws
step:  20
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1181]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1180]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1183]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << true >>
What for:    normalization of [serial 1181]
. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1183]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << true >>
What for:    normalization of [serial 1181]
Done Normalizing
step:  21
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1183]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [169] << true >>
What for:    normalization of [serial 1181]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1006]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [166]->
Q [166] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  22
#[serial 1006] Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
step:  23
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1006]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [166]->
Q [166] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1007]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [173]->
Q [173] << ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  24
#[serial 1007] Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
step:  25
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1007]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [173]->
Q [173] << ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1186]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:    normalization of [serial 1007]
. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1186]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:    normalization of [serial 1007]
Done Normalizing
step:  26
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1186]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:    normalization of [serial 1007]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1188]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 ) ) )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1186]
. . . done applying DeMorgan's Law  [7.7 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1188]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 ) ) )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1186]
step:  27
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1188]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 ) ) )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1186]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1189]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1188]
. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1189]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1188]
Done applying laws
step:  28
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1189]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1188]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1191]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1189]
. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1191]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1189]
Done Normalizing
step:  29
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1191]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1189]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 1193]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1191]
. . . done putting into conjunctive normal form [7.7 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1193]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1191]
Done making conjunctive normal forms.
step:  30
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1193]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1191]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1194]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1193]

This Proof Obligation:

[serial 1194]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1193]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1195]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1194]

This Proof Obligation:

[serial 1195]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1194]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1196]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1195]
. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1196]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1195]
Done applying laws
step:  31
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1196]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1195]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1198]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << true >>
What for:    normalization of [serial 1196]
. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1198]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << true >>
What for:    normalization of [serial 1196]
Done Normalizing
step:  32
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1198]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [173] << true >>
What for:    normalization of [serial 1196]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1008]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]  start_time := now
  << ( start_time = now )
    and AXIOM_TOGT0()
    and AXIOM_ST() >>
  ;
  monitor_mode!(mmode'Init) 
Q [167] << ( true )^1 >>
What for:   <<M(start)>> A <<M(init)>> for mmm1: start-[ ]->init{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  33
#[serial 1008]  <<M(start)>> A <<M(init)>> for mmm1: start-[ ]->init{A};
step:  34
****reduce****
This proof obligation:

[serial 1008]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]  start_time := now
  << ( start_time = now )
    and AXIOM_TOGT0()
    and AXIOM_ST() >>
  ;
  monitor_mode!(mmode'Init) 
Q [167] << ( true )^1 >>
What for:   <<M(start)>> A <<M(init)>> for mmm1: start-[ ]->init{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1200]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]start_time := now
Q [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1008]

[serial 1201]: Monitor::manage_monitor_mode.impl
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183]monitor_mode!(mmode'Init)
Q [302] << ( true )^1 >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1008]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1200]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]start_time := now
Q [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1008]

[serial 1201]: Monitor::manage_monitor_mode.impl
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183]monitor_mode!(mmode'Init)
Q [302] << ( true )^1 >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1008]
done reducing composite actions
step:  35
****atomic****
applying atomic actions . . .
solving assignment on line 180
replacing "start_time" with "now"
makes:  << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>

This Proof Obligation:

[serial 1200]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]start_time := now
Q [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1008]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1202]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
What for:  applied wp for assignment [serial 1200]
Proof.reducePortOutput portValue=<< +=> MONITOR_MODE(x : monitor_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<MONITOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> MONITOR_OK()
    and RUN(),
    Failed -> not MONITOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Init" is:  
^{INVOKE[INI] INI}

This Proof Obligation:

[serial 1201]: Monitor::manage_monitor_mode.impl
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183]monitor_mode!(mmode'Init)
Q [302] << ( true )^1 >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1008]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> monitor_mode!(') <<post>> to get:

[serial 1203]: Monitor::manage_monitor_mode.impl
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183]->
Q [78] << INI() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1201]

The Same Proof Obligation:
Has applied <<pre and (monitor_mode=mmode'Init)^0>> -> <<post>> for  <<pre>> monitor_mode!(') <<post>> to get:

[serial 1204]: Monitor::manage_monitor_mode.impl
P [183] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Init )^0 >>
S [183]->
Q [302] << ( true )^1 >>
What for:  applied port output <<pre and (monitor_mode=mmode'Init)^0>> -> <<post>> [serial 1201]

[serial 1204]: Monitor::manage_monitor_mode.impl
P [183] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Init )^0 >>
S [183]->
Q [302] << ( true )^1 >>
What for:  applied port output <<pre and (monitor_mode=mmode'Init)^0>> -> <<post>> [serial 1201]
. . . done applying atomic actions [7.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 1202]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
What for:  applied wp for assignment [serial 1200]

[serial 1203]: Monitor::manage_monitor_mode.impl
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183]->
Q [78] << INI() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1201]

[serial 1204]: Monitor::manage_monitor_mode.impl
P [183] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Init )^0 >>
S [183]->
Q [302] << ( true )^1 >>
What for:  applied port output <<pre and (monitor_mode=mmode'Init)^0>> -> <<post>> [serial 1201]
Done reducing atomic actions
step:  36
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1202]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
What for:  applied wp for assignment [serial 1200]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1205]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << ( true )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1202]

This Proof Obligation:

[serial 1204]: Monitor::manage_monitor_mode.impl
P [183] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Init )^0 >>
S [183]->
Q [302] << ( true )^1 >>
What for:  applied port output <<pre and (monitor_mode=mmode'Init)^0>> -> <<post>> [serial 1201]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1206]: Monitor::manage_monitor_mode.impl
P [183] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST()
  and ( monitor_mode = mmode'Init )^0 >>
S [183]->
Q [302] << ( true )^1 >>
What for:  Associativity: (b.c).a = a.b.c [serial 1204]
. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1203]: Monitor::manage_monitor_mode.impl
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183]->
Q [78] << INI() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1201]

[serial 1205]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << ( true )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1202]

[serial 1206]: Monitor::manage_monitor_mode.impl
P [183] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST()
  and ( monitor_mode = mmode'Init )^0 >>
S [183]->
Q [302] << ( true )^1 >>
What for:  Associativity: (b.c).a = a.b.c [serial 1204]
Done applying laws
step:  37
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1205]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << ( true )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1202]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1207]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << ( true )
  and true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [7.7 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1203]: Monitor::manage_monitor_mode.impl
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183]->
Q [78] << INI() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1201]

[serial 1206]: Monitor::manage_monitor_mode.impl
P [183] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST()
  and ( monitor_mode = mmode'Init )^0 >>
S [183]->
Q [302] << ( true )^1 >>
What for:  Associativity: (b.c).a = a.b.c [serial 1204]

[serial 1207]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << ( true )
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  38
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1203]: Monitor::manage_monitor_mode.impl
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183]->
Q [78] << INI() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1201]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1209]: Monitor::manage_monitor_mode.impl
P [181] << now = start_time
  and AXIOM_ST()
  and AXIOM_TOGT0() >>
S [183]->
Q [78] << INI() >>
What for:    normalization of [serial 1203]

This Proof Obligation:

[serial 1206]: Monitor::manage_monitor_mode.impl
P [183] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST()
  and ( monitor_mode = mmode'Init )^0 >>
S [183]->
Q [302] << ( true )^1 >>
What for:  Associativity: (b.c).a = a.b.c [serial 1204]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Constants are always the same
Has been normalized to get:

[serial 1211]: Monitor::manage_monitor_mode.impl
P [183] << now = start_time
  and AXIOM_ST()
  and AXIOM_TOGT0()
  and ( mmode'Init = monitor_mode )^0 >>
S [183]->
Q [302] << true >>
What for:    normalization of [serial 1206]

This Proof Obligation:

[serial 1207]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << ( true )
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1213]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true
  and true
  and true >>
What for:    normalization of [serial 1207]
. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1209]: Monitor::manage_monitor_mode.impl
P [181] << now = start_time
  and AXIOM_ST()
  and AXIOM_TOGT0() >>
S [183]->
Q [78] << INI() >>
What for:    normalization of [serial 1203]

[serial 1211]: Monitor::manage_monitor_mode.impl
P [183] << now = start_time
  and AXIOM_ST()
  and AXIOM_TOGT0()
  and ( mmode'Init = monitor_mode )^0 >>
S [183]->
Q [302] << true >>
What for:    normalization of [serial 1206]

[serial 1213]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true
  and true
  and true >>
What for:    normalization of [serial 1207]
Done Normalizing
step:  39
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1211]: Monitor::manage_monitor_mode.impl
P [183] << now = start_time
  and AXIOM_ST()
  and AXIOM_TOGT0()
  and ( mmode'Init = monitor_mode )^0 >>
S [183]->
Q [302] << true >>
What for:    normalization of [serial 1206]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 1209]: Monitor::manage_monitor_mode.impl
P [181] << now = start_time
  and AXIOM_ST()
  and AXIOM_TOGT0() >>
S [183]->
Q [78] << INI() >>
What for:    normalization of [serial 1203]

[serial 1213]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true
  and true
  and true >>
What for:    normalization of [serial 1207]
Done trying to apply axioms
step:  40
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1209]: Monitor::manage_monitor_mode.impl
P [181] << now = start_time
  and AXIOM_ST()
  and AXIOM_TOGT0() >>
S [183]->
Q [78] << INI() >>
What for:    normalization of [serial 1203]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1217]: Monitor::manage_monitor_mode.impl
P [181] << now = start_time
  and ( start_time = START_TIME )
  and ( 0 < #Iso_Properties::Initialization_Timeout ) >>
S [183]->
Q [78] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 1209]
. . . done substituting assertions' for Labels [7.7 seconds ]
After "substitute" remaining 
Obligations:

[serial 1213]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true
  and true
  and true >>
What for:    normalization of [serial 1207]

[serial 1217]: Monitor::manage_monitor_mode.impl
P [181] << now = start_time
  and ( start_time = START_TIME )
  and ( 0 < #Iso_Properties::Initialization_Timeout ) >>
S [183]->
Q [78] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 1209]
Done substituting Assertion labels.
step:  41
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1217]: Monitor::manage_monitor_mode.impl
P [181] << now = start_time
  and ( start_time = START_TIME )
  and ( 0 < #Iso_Properties::Initialization_Timeout ) >>
S [183]->
Q [78] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 1209]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1220]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1217]
. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1213]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true
  and true
  and true >>
What for:    normalization of [serial 1207]

[serial 1220]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1217]
Done Normalizing
step:  42
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1213]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true
  and true
  and true >>
What for:    normalization of [serial 1207]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1222]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 1213]
. . . done Applying Laws [7.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1220]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1217]

[serial 1222]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 1213]
Done applying laws
step:  43
****guided-sub-equals****
guided substitution of equals "START_TIME" . . .
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 1220]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1217]
Reason solved:  Guided Substitution of Equals
Has substituted 
"START_TIME" with its = "start_time"
 to get:

[serial 1223]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1220]
. . . done guided substitution of equals  [7.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1222]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 1213]

[serial 1223]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1220]
Done guided substituting an equals
step:  44
****guided-sub-equals****
guided substitution of equals "start_time" . . .
equality selected for substitution:  now = start_time

This Proof Obligation:

[serial 1223]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1220]
Reason solved:  Guided Substitution of Equals
Has substituted 
"start_time" with its = "now"
 to get:

[serial 1224]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - now < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "start_time" with its = "now" in its postcondition [serial 1223]
. . . done guided substitution of equals  [7.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1222]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 1213]

[serial 1224]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - now < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "start_time" with its = "now" in its postcondition [serial 1223]
Done guided substituting an equals
step:  45
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1224]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << now - now < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "start_time" with its = "now" in its postcondition [serial 1223]
Has been normalized to get:

[serial 1227]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << 0 < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1224]
. . . done Normalizing Unsolved Proof Obligations [7.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1222]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 1213]

[serial 1227]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << 0 < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1224]
Done Normalizing
step:  46
Removing units . . .
removing units . . .

This Proof Obligation:

[serial 1227]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << 0 < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1224]
Reason solved:  Remove units from quantities
Has applied Remove units from quantities  to get:

[serial 1229]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << 0 < #Iso_Properties::Initialization_Timeout >>
What for:  Remove units from quantities  [serial 1227]
. . . done removing units  [7.7 seconds ]
After removing units remaining 
Obligations:

[serial 1222]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 1213]

[serial 1229]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << 0 < #Iso_Properties::Initialization_Timeout >>
What for:  Remove units from quantities  [serial 1227]
Done extending tops to now.
step:  47
Removing units . . .
removing units . . .
. . . done removing units  [7.7 seconds ]
After removing units, no changes.. 
step:  48
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1222]: Monitor::manage_monitor_mode.impl
P [166] << true >>
S [180]->
Q [181] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 1213]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1229]: Monitor::manage_monitor_mode.impl
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183]->
Q [78] << 0 < #Iso_Properties::Initialization_Timeout >>
What for:  Remove units from quantities  [serial 1227]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1009]: Monitor::manage_monitor_mode.impl
P [167] << true >>
S [188]  current_temperature?(temperature)
  ;
  current_temperature_status := temperature.status
  << current_temperature_status = temperature.status >> 
Q [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
What for:   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  49
#[serial 1009]  <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};
step:  50
****reduce****
This proof obligation:

[serial 1009]: Monitor::manage_monitor_mode.impl
P [167] << true >>
S [188]  current_temperature?(temperature)
  ;
  current_temperature_status := temperature.status
  << current_temperature_status = temperature.status >> 
Q [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
What for:   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1230]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1009]

[serial 1231]: Monitor::manage_monitor_mode.impl
P [167] << true >>
S [188]current_temperature?(temperature)
Q [188] << true >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1009]

[serial 1232]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]current_temperature_status := temperature.status
Q [191] << current_temperature_status = temperature.status >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1009]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1230]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1009]

[serial 1231]: Monitor::manage_monitor_mode.impl
P [167] << true >>
S [188]current_temperature?(temperature)
Q [188] << true >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1009]

[serial 1232]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]current_temperature_status := temperature.status
Q [191] << current_temperature_status = temperature.status >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1009]
done reducing composite actions
step:  51
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1231]: Monitor::manage_monitor_mode.impl
P [167] << true >>
S [188]current_temperature?(temperature)
Q [188] << true >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1009]
Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(current_temperature)>> -> <<post>> for <<pre>> current_temperature?(temperature) <<post>> to get:

[serial 1233]: Monitor::manage_monitor_mode.impl
P [188] << ( true )
  and temperature = CURRENT_TEMP >>
S [188]->
Q [188] << true >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1231]
solving assignment on line 190
replacing "current_temperature_status" with "temperature.status"
makes:  << temperature.status = temperature.status >>

This Proof Obligation:

[serial 1232]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]current_temperature_status := temperature.status
Q [191] << current_temperature_status = temperature.status >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1009]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1234]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]->
Q [191] << temperature.status = temperature.status >>
What for:  applied wp for assignment [serial 1232]
. . . done applying atomic actions [7.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1230]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1009]

[serial 1233]: Monitor::manage_monitor_mode.impl
P [188] << ( true )
  and temperature = CURRENT_TEMP >>
S [188]->
Q [188] << true >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1231]

[serial 1234]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]->
Q [191] << temperature.status = temperature.status >>
What for:  applied wp for assignment [serial 1232]
Done reducing atomic actions
step:  52
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1230]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1009]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1236]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:    normalization of [serial 1230]

This Proof Obligation:

[serial 1233]: Monitor::manage_monitor_mode.impl
P [188] << ( true )
  and temperature = CURRENT_TEMP >>
S [188]->
Q [188] << true >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1231]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1238]: Monitor::manage_monitor_mode.impl
P [188] << CURRENT_TEMP = temperature
  and true >>
S [188]->
Q [188] << true >>
What for:    normalization of [serial 1233]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1234]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]->
Q [191] << temperature.status = temperature.status >>
What for:  applied wp for assignment [serial 1232]

[serial 1236]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:    normalization of [serial 1230]

[serial 1238]: Monitor::manage_monitor_mode.impl
P [188] << CURRENT_TEMP = temperature
  and true >>
S [188]->
Q [188] << true >>
What for:    normalization of [serial 1233]
Done Normalizing
step:  53
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1238]: Monitor::manage_monitor_mode.impl
P [188] << CURRENT_TEMP = temperature
  and true >>
S [188]->
Q [188] << true >>
What for:    normalization of [serial 1233]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1234]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]->
Q [191] << temperature.status = temperature.status >>
What for:  applied wp for assignment [serial 1232]

[serial 1236]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:    normalization of [serial 1230]
Done trying to apply axioms
step:  54
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1234]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]->
Q [191] << temperature.status = temperature.status >>
What for:  applied wp for assignment [serial 1232]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1242]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]->
Q [191] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1234]
. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1236]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:    normalization of [serial 1230]

[serial 1242]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]->
Q [191] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1234]
Done applying laws
step:  55
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1242]: Monitor::manage_monitor_mode.impl
P [188] << true >>
S [190]->
Q [191] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1234]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1236]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:    normalization of [serial 1230]
Done trying to apply axioms
step:  56
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1236]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:    normalization of [serial 1230]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1243]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [7.8 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1243]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  57
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1243]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1244]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << ( current_temperature_status = temperature.status ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1243]
. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1244]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << ( current_temperature_status = temperature.status ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1243]
Done applying laws
step:  58
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1244]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << ( current_temperature_status = temperature.status ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1243]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1246]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status >>
What for:    normalization of [serial 1244]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1246]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status >>
What for:    normalization of [serial 1244]
Done Normalizing
step:  59
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1246]: Monitor::manage_monitor_mode.impl
P [191] << current_temperature_status = temperature.status >>
S [169]->
Q [169] << current_temperature_status = temperature.status >>
What for:    normalization of [serial 1244]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [7.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1010]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [198]<< not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( current_temperature_status = status'Valid )
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST()
  and AXIOM_CTS() >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:   <<M(check_init) and x>> A <<M(failed)>> for mmm: check_init-[x]->failed{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  60
#[serial 1010]  <<M(check_init) and x>> A <<M(failed)>> for mmm: check_init-[x]->failed{A};
step:  61
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1010]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [198]<< not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( current_temperature_status = status'Valid )
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST()
  and AXIOM_CTS() >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:   <<M(check_init) and x>> A <<M(failed)>> for mmm: check_init-[x]->failed{A};
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1249]: Monitor::manage_monitor_mode.impl
P [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [198]<< AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:    normalization of [serial 1010]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1249]: Monitor::manage_monitor_mode.impl
P [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [198]<< AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:    normalization of [serial 1010]
Done Normalizing
step:  62
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1249]: Monitor::manage_monitor_mode.impl
P [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [198]<< AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:    normalization of [serial 1010]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1251]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [198]<< AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 1249]
. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1251]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [198]<< AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 1249]
Done applying laws
step:  63
****normalize****
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize", no change. 
step:  64
****reduce****

[serial 1253]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1251]

[serial 1254]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1251]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1253]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1251]

[serial 1254]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1251]
done reducing composite actions
step:  65
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> MONITOR_MODE(x : monitor_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<MONITOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> MONITOR_OK()
    and RUN(),
    Failed -> not MONITOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Failed" is:  
^{and 
 ^{not 
  ^{INVOKE[MONITOR_OK] MONITOR_OK}} 
 ^{INVOKE[RUN] RUN}}

This Proof Obligation:

[serial 1254]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1251]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> monitor_mode!(') <<post>> to get:

[serial 1255]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1254]

The Same Proof Obligation:
Has applied <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> for  <<pre>> monitor_mode!(') <<post>> to get:

[serial 1256]: Monitor::manage_monitor_mode.impl
P [202] << ( AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( monitor_mode = mmode'Failed )^0 >>
S [202]->
Q [175] << true >>
What for:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1254]

[serial 1256]: Monitor::manage_monitor_mode.impl
P [202] << ( AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( monitor_mode = mmode'Failed )^0 >>
S [202]->
Q [175] << true >>
What for:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1254]
. . . done applying atomic actions [7.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1253]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1251]

[serial 1255]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1254]

[serial 1256]: Monitor::manage_monitor_mode.impl
P [202] << ( AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( monitor_mode = mmode'Failed )^0 >>
S [202]->
Q [175] << true >>
What for:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1254]
Done reducing atomic actions
step:  66
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1256]: Monitor::manage_monitor_mode.impl
P [202] << ( AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( monitor_mode = mmode'Failed )^0 >>
S [202]->
Q [175] << true >>
What for:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1254]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1253]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1251]

[serial 1255]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1254]
Done trying to apply axioms
step:  67
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1253]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1251]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1257]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << true
  and true
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [7.8 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1255]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1254]

[serial 1257]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << true
  and true
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  68
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1257]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << true
  and true
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:   add user-defined axioms to postcondition
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1258]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and true
  and true >>
What for:  Assume Present:  P = P@now = P^0   [serial 1257]
. . . done replacing P@now and P^0 with P  [7.8 seconds ]
After assuming present remaining 
Obligations:

[serial 1255]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1254]

[serial 1258]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and true
  and true >>
What for:  Assume Present:  P = P@now = P^0   [serial 1257]
Done assuming present.
step:  69
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1258]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and true
  and true >>
What for:  Assume Present:  P = P@now = P^0   [serial 1257]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1259]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1258]
. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1255]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1254]

[serial 1259]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1258]
Done applying laws
step:  70
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1255]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1254]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1260]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( status'Valid = current_temperature_status )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1255]

This Proof Obligation:

[serial 1259]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1258]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1261]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( status'Valid = current_temperature_status )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1259]
. . . done applying DeMorgan's Law  [7.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1260]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( status'Valid = current_temperature_status )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1255]

[serial 1261]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( status'Valid = current_temperature_status )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1259]
step:  71
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1260]: Monitor::manage_monitor_mode.impl
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( status'Valid = current_temperature_status )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) ) >>
S [202]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1255]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1263]: Monitor::manage_monitor_mode.impl
P [198] << ( ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1260]

This Proof Obligation:

[serial 1261]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( status'Valid = current_temperature_status )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1259]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1265]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1261]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1263]: Monitor::manage_monitor_mode.impl
P [198] << ( ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1260]

[serial 1265]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1261]
Done Normalizing
step:  72
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1263]: Monitor::manage_monitor_mode.impl
P [198] << ( ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1260]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1268]: Monitor::manage_monitor_mode.impl
P [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1263]
. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1265]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1261]

[serial 1268]: Monitor::manage_monitor_mode.impl
P [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1263]
Done applying laws
step:  73
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1265]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1261]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1269]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1265]

This Proof Obligation:

[serial 1268]: Monitor::manage_monitor_mode.impl
P [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1263]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1270]: Monitor::manage_monitor_mode.impl
P [198] << ( not ( status'Valid = current_temperature_status )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1268]
. . . done applying DeMorgan's Law  [7.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1269]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1265]

[serial 1270]: Monitor::manage_monitor_mode.impl
P [198] << ( not ( status'Valid = current_temperature_status )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1268]
step:  74
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1269]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1265]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1272]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1269]

This Proof Obligation:

[serial 1270]: Monitor::manage_monitor_mode.impl
P [198] << ( not ( status'Valid = current_temperature_status )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1268]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1274]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1270]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1272]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1269]

[serial 1274]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1270]
Done Normalizing
step:  75
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1272]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1269]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1277]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]

[serial 1278]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]

This Proof Obligation:

[serial 1274]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1270]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1279]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1280]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]
. . . done splitting postcondition  [7.8 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1277]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]

[serial 1278]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]

[serial 1279]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1280]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]
Done splitting postcondition
step:  76
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1277]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1282]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1277]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1278]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]

[serial 1279]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1280]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1282]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1277]
Done Normalizing
step:  77
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1278]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1287]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1278]

This Proof Obligation:

[serial 1282]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1277]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1288]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1282]
. . . Substituting <= with not < [7.8 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1279]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1280]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1287]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1278]

[serial 1288]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1282]
Done replacing a<=b with (not b<a)
step:  78
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1287]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1278]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1292]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1287]

This Proof Obligation:

[serial 1288]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1282]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1294]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1288]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1279]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1280]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1292]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1287]

[serial 1294]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1288]
Done Normalizing
step:  79
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1292]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1287]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1279]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1280]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]

[serial 1294]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1288]
Done trying to apply axioms
step:  80
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1279]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1297]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 1279]

This Proof Obligation:

[serial 1280]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1298]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1280]

This Proof Obligation:

[serial 1294]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1288]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1299]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Substituted assertions' predicates for labels  [serial 1294]
. . . done substituting assertions' for Labels [7.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 1297]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 1279]

[serial 1298]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1280]

[serial 1299]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Substituted assertions' predicates for labels  [serial 1294]
Done substituting Assertion labels.
step:  81
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1297]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 1279]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1301]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1297]

This Proof Obligation:

[serial 1298]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1280]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1303]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1298]

This Proof Obligation:

[serial 1299]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Substituted assertions' predicates for labels  [serial 1294]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1305]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1299]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1301]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1297]

[serial 1303]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1298]

[serial 1305]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1299]
Done Normalizing
step:  82
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1301]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1297]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1309]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 1301]

This Proof Obligation:

[serial 1303]: Monitor::manage_monitor_mode.impl
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1298]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1310]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1303]

This Proof Obligation:

[serial 1305]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 1299]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1311]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1305]
. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1309]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 1301]

[serial 1310]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1303]

[serial 1311]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1305]
Done applying laws
step:  83
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1311]: Monitor::manage_monitor_mode.impl
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169]->
Q [198] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1305]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1309]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 1301]

[serial 1310]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1303]
Done trying to apply axioms
step:  84
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1309]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 1301]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1312]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309]
. . . Substituting <= with not < [7.8 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1310]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1303]

[serial 1312]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309]
Done replacing a<=b with (not b<a)
step:  85
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1310]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1303]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1313]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1310]
. . . done applying DeMorgan's Law  [7.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1312]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309]

[serial 1313]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1310]
step:  86
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1312]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1315]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1312]

This Proof Obligation:

[serial 1313]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1310]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1317]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1313]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1315]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1312]

[serial 1317]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1313]
Done Normalizing
step:  87
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1317]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1313]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1320]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1317]
. . . done applying DeMorgan's Law  [7.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1315]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1312]

[serial 1320]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1317]
step:  88
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1320]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1317]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1323]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 1320]
. . . done Normalizing Unsolved Proof Obligations [7.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1315]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1312]

[serial 1323]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 1320]
Done Normalizing
step:  89
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1323]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 1320]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1325]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1323]
. . . done Applying Laws [7.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1315]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1312]

[serial 1325]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1323]
Done applying laws
step:  90
****guided-sub-equals****
guided substitution of equals "CURRENT_TEMPERATURE_STATUS" . . .
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 1325]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1323]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 1326]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1325]
. . . done guided substitution of equals  [7.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1315]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1312]
Reason solved:  Guided Substitution of Equals

[serial 1326]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1325]
Done guided substituting an equals
step:  91
****guided-sub-equals****
guided substitution of equals "START_TIME" . . .
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 1315]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1312]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
Has substituted 
"START_TIME" with its = "start_time"
 to get:

[serial 1327]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1315]
equality selected for substitution:  START_TIME = start_time
. . . done guided substitution of equals  [7.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1326]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1325]
Reason solved:  Guided Substitution of Equals

[serial 1327]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1315]
Done guided substituting an equals
step:  92
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1326]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1325]
Reasons solved:  
   Guided Substitution of Equals
   And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1327]: Monitor::manage_monitor_mode.impl
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202]->
Q [80] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1315]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1011]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [209]<< MONITOR_OK()
  and RUN() >>
monitor_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [172] << ( RUN() )^1 >>
What for:   <<M(check_init) and x>> A <<M(normal)>> for mmm2: check_init-[x]->normal{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  93
#[serial 1011]  <<M(check_init) and x>> A <<M(normal)>> for mmm2: check_init-[x]->normal{A};
step:  94
****reduce****

[serial 1328]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169]->
Q [209] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1011]

[serial 1329]: Monitor::manage_monitor_mode.impl
P [211] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]

[serial 1330]: Monitor::manage_monitor_mode.impl
P [209] << MONITOR_OK()
  and RUN() >>
S [210]monitor_mode!(mmode'Normal)
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1328]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169]->
Q [209] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1011]

[serial 1329]: Monitor::manage_monitor_mode.impl
P [211] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]

[serial 1330]: Monitor::manage_monitor_mode.impl
P [209] << MONITOR_OK()
  and RUN() >>
S [210]monitor_mode!(mmode'Normal)
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]
done reducing composite actions
step:  95
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> MONITOR_MODE(x : monitor_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<MONITOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> MONITOR_OK()
    and RUN(),
    Failed -> not MONITOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Normal" is:  
^{and 
 ^{INVOKE[MONITOR_OK] MONITOR_OK} 
 ^{INVOKE[RUN] RUN}}

This Proof Obligation:

[serial 1330]: Monitor::manage_monitor_mode.impl
P [209] << MONITOR_OK()
  and RUN() >>
S [210]monitor_mode!(mmode'Normal)
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> monitor_mode!(') <<post>> to get:

[serial 1331]: Monitor::manage_monitor_mode.impl
P [209] << MONITOR_OK()
  and RUN() >>
S [210]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1330]

The Same Proof Obligation:
Has applied <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> for  <<pre>> monitor_mode!(') <<post>> to get:

[serial 1332]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1330]

[serial 1332]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1330]
. . . done applying atomic actions [7.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 1328]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169]->
Q [209] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1011]

[serial 1329]: Monitor::manage_monitor_mode.impl
P [211] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]

[serial 1331]: Monitor::manage_monitor_mode.impl
P [209] << MONITOR_OK()
  and RUN() >>
S [210]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1330]

[serial 1332]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1330]
Done reducing atomic actions
step:  96
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  97
#Monitor::manage_monitor_mode.impl
step:  98
#[serial 1332] as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 101
step:  99
****make-an****
Making obligation 9
Obligations:

[serial 1328]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169]->
Q [209] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1011]
Done making obligation 9
step:  100
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1328]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169]->
Q [209] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1011]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1333]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and ( start_time = START_TIME )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169]->
Q [209] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 1328]
. . . done substituting assertions' for Labels [7.9 seconds ]
After "substitute" remaining 
Obligations:

[serial 1333]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and ( start_time = START_TIME )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169]->
Q [209] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 1328]
Done substituting Assertion labels.
step:  101
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1333]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and ( start_time = START_TIME )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169]->
Q [209] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 1328]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1335]: Monitor::manage_monitor_mode.impl
P [169] << ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1333]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1335]: Monitor::manage_monitor_mode.impl
P [169] << ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1333]
Done Normalizing
step:  102
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1335]: Monitor::manage_monitor_mode.impl
P [169] << ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1333]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1337]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 1335]
. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1337]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 1335]
Done applying laws
step:  103
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1337]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 1335]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1339]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1337]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1339]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1337]
Done Normalizing
step:  104
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1339]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1337]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1341]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and not ( not ( status'Valid = current_temperature_status ) ) ) >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1339]
. . . done applying DeMorgan's Law  [7.9 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1341]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and not ( not ( status'Valid = current_temperature_status ) ) ) >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1339]
step:  105
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1341]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and not ( not ( status'Valid = current_temperature_status ) ) ) >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1339]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1343]: Monitor::manage_monitor_mode.impl
P [169] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:    normalization of [serial 1341]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1343]: Monitor::manage_monitor_mode.impl
P [169] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:    normalization of [serial 1341]
Done Normalizing
step:  106
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1343]: Monitor::manage_monitor_mode.impl
P [169] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:    normalization of [serial 1341]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1345]: Monitor::manage_monitor_mode.impl
P [169] << status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Associativity: (b.c).a = a.b.c [serial 1343]
. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1345]: Monitor::manage_monitor_mode.impl
P [169] << status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Associativity: (b.c).a = a.b.c [serial 1343]
Done applying laws
step:  107
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1345]: Monitor::manage_monitor_mode.impl
P [169] << status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169]->
Q [209] << not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Associativity: (b.c).a = a.b.c [serial 1343]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1346]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
What for:  Assume Present:  P = P@now = P^0   [serial 1345]
. . . done replacing P@now and P^0 with P  [7.9 seconds ]
After assuming present remaining 
Obligations:

[serial 1346]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
What for:  Assume Present:  P = P@now = P^0   [serial 1345]
Done assuming present.
step:  108
****guided-sub-equals****
guided substitution of equals "CURRENT_TEMPERATURE_STATUS" . . .
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 1346]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
What for:  Assume Present:  P = P@now = P^0   [serial 1345]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 1347]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1346]
. . . done guided substitution of equals  [7.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1347]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1346]
Done guided substituting an equals
step:  109
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1347]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1346]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1348]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]

[serial 1349]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [70] << status'Valid = current_temperature_status >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]

[serial 1350]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [69] << not INTERNAL_FAILURE >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]

[serial 1351]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [69] << not MONITOR_INTERFACE_FAILURE >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
. . . done splitting postcondition  [7.9 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1348]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]

[serial 1349]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [70] << status'Valid = current_temperature_status >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]

[serial 1350]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [69] << not INTERNAL_FAILURE >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]

[serial 1351]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [69] << not MONITOR_INTERFACE_FAILURE >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Done splitting postcondition
step:  110
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1349]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [70] << status'Valid = current_temperature_status >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1350]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [69] << not INTERNAL_FAILURE >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1351]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [69] << not MONITOR_INTERFACE_FAILURE >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1348]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Done trying to apply axioms
step:  111
****guided-sub-equals****
guided substitution of equals "START_TIME" . . .
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 1348]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Reason solved:  Guided Substitution of Equals
Has substituted 
"START_TIME" with its = "start_time"
 to get:

[serial 1352]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1348]
. . . done guided substitution of equals  [7.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1352]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1348]
Done guided substituting an equals
step:  112
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1352]: Monitor::manage_monitor_mode.impl
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1348]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1329]: Monitor::manage_monitor_mode.impl
P [211] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  113
#[serial 1333] as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]
step:  114
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1329]: Monitor::manage_monitor_mode.impl
P [211] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1353]: Monitor::manage_monitor_mode.impl
P [211] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( ( now - START_TIME ) <= ( now - START_TIME )^1 ) >>
S [172]->
Q [172] << ( ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )^1 >>
What for:  Substituted assertions' predicates for labels  [serial 1329]
. . . done substituting assertions' for Labels [7.9 seconds ]
After "substitute" remaining 
Obligations:

[serial 1353]: Monitor::manage_monitor_mode.impl
P [211] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( ( now - START_TIME ) <= ( now - START_TIME )^1 ) >>
S [172]->
Q [172] << ( ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )^1 >>
What for:  Substituted assertions' predicates for labels  [serial 1329]
Done substituting Assertion labels.
step:  115
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1353]: Monitor::manage_monitor_mode.impl
P [211] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( ( now - START_TIME ) <= ( now - START_TIME )^1 ) >>
S [172]->
Q [172] << ( ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )^1 >>
What for:  Substituted assertions' predicates for labels  [serial 1329]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1355]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 1353]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1355]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 1353]
Done Normalizing
step:  116
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  #Iso_Properties::Initialization_Timeout s <= now - START_TIME and now - START_TIME <= ( now - START_TIME )^1 -> #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1

This Proof Obligation:

[serial 1355]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 1353]
Reason solved:  Transitivity: x<y and y<z -> x<z
Has applied Transitivity: x<y and y<z -> x<z  to get:

[serial 1357]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [172]->
Q [172] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1355]
. . . done adding transitive terms [7.9 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 1357]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [172]->
Q [172] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1355]
Done adding transitive relations
step:  117
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1357]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [172]->
Q [172] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1355]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1358]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [172]->
Q [172] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1357]
. . . done spltting timed atoms  [7.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [7.9 seconds ]
After "dist^" remaining 
Obligations:

[serial 1358]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [172]->
Q [172] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1357]
Done distributing ^ and @.
step:  118
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1358]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [172]->
Q [172] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1357]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Constants are always the same
Has been normalized to get:

[serial 1360]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 1358]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1360]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 1358]
Done Normalizing
step:  119
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1360]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 1358]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1362]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1360]
. . . done spltting timed atoms  [7.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [7.9 seconds ]
After "dist^" remaining 
Obligations:

[serial 1362]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1360]
Done distributing ^ and @.
step:  120
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1362]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1360]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1364]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 1362]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1364]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 1362]
Done Normalizing
step:  121
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1364]: Monitor::manage_monitor_mode.impl
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 1362]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1331]: Monitor::manage_monitor_mode.impl
P [209] << MONITOR_OK()
  and RUN() >>
S [210]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1330]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  122
#[serial 1335] applied port output of enumeration type  monitor_mode!(') [serial 1334]
step:  123
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1331]: Monitor::manage_monitor_mode.impl
P [209] << MONITOR_OK()
  and RUN() >>
S [210]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1330]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1332]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1330]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  124
#[serial 1336] applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1334]
step:  125
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1332]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1330]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1366]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [7.9 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1366]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  126
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1366]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1367]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1366]

This Proof Obligation:

[serial 1367]: Monitor::manage_monitor_mode.impl
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1366]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1368]: Monitor::manage_monitor_mode.impl
P [210] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1367]
. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1368]: Monitor::manage_monitor_mode.impl
P [210] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1367]
Done applying laws
step:  127
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1368]: Monitor::manage_monitor_mode.impl
P [210] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [210]->
Q [211] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1367]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1012]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
S [213]->
Q [167] << ( true )^1 >>
What for:   <<M(check_init) and x>> -> <<M(init)>> for mmm2x: check_init-[x]->init{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  128
#[serial 1012]  <<M(check_init) and x>> -> <<M(init)>> for mmm2x: check_init-[x]->init{};
step:  129
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1012]: Monitor::manage_monitor_mode.impl
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
S [213]->
Q [167] << ( true )^1 >>
What for:   <<M(check_init) and x>> -> <<M(init)>> for mmm2x: check_init-[x]->init{};
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Constants are always the same
Has been normalized to get:

[serial 1370]: Monitor::manage_monitor_mode.impl
P [169] << now - start_time < #Iso_Properties::Initialization_Timeout s
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [213]->
Q [167] << true >>
What for:    normalization of [serial 1012]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1370]: Monitor::manage_monitor_mode.impl
P [169] << now - start_time < #Iso_Properties::Initialization_Timeout s
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [213]->
Q [167] << true >>
What for:    normalization of [serial 1012]
Done Normalizing
step:  130
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1370]: Monitor::manage_monitor_mode.impl
P [169] << now - start_time < #Iso_Properties::Initialization_Timeout s
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [213]->
Q [167] << true >>
What for:    normalization of [serial 1012]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1013]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [219]  << RUN() >>
  current_temperature?(temperature)
  ;
  << temperature = CURRENT_TEMP
    and RUN() >>
  current_temperature_status := temperature.status
  << current_temperature_status = temperature.status
    and RUN() >> 
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  131
#[serial 1013]  <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};
step:  132
****reduce****
This proof obligation:

[serial 1013]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [219]  << RUN() >>
  current_temperature?(temperature)
  ;
  << temperature = CURRENT_TEMP
    and RUN() >>
  current_temperature_status := temperature.status
  << current_temperature_status = temperature.status
    and RUN() >> 
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1372]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [172]->
Q [219] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1013]

[serial 1373]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1013]

[serial 1374]: Monitor::manage_monitor_mode.impl
P [219] << RUN() >>
S [220]current_temperature?(temperature)
Q [221] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1013]

[serial 1375]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]current_temperature_status := temperature.status
Q [223] << current_temperature_status = temperature.status
  and RUN() >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1013]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1372]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [172]->
Q [219] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1013]

[serial 1373]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1013]

[serial 1374]: Monitor::manage_monitor_mode.impl
P [219] << RUN() >>
S [220]current_temperature?(temperature)
Q [221] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1013]

[serial 1375]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]current_temperature_status := temperature.status
Q [223] << current_temperature_status = temperature.status
  and RUN() >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1013]
done reducing composite actions
step:  133
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1374]: Monitor::manage_monitor_mode.impl
P [219] << RUN() >>
S [220]current_temperature?(temperature)
Q [221] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1013]
Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(current_temperature)>> -> <<post>> for <<pre>> current_temperature?(temperature) <<post>> to get:

[serial 1376]: Monitor::manage_monitor_mode.impl
P [220] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [220]->
Q [221] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1374]
solving assignment on line 222
replacing "current_temperature_status" with "temperature.status"
makes:  << temperature.status = temperature.status
  and RUN() >>

This Proof Obligation:

[serial 1375]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]current_temperature_status := temperature.status
Q [223] << current_temperature_status = temperature.status
  and RUN() >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1013]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1377]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]->
Q [223] << temperature.status = temperature.status
  and RUN() >>
What for:  applied wp for assignment [serial 1375]
. . . done applying atomic actions [7.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 1372]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [172]->
Q [219] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1013]

[serial 1373]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1013]

[serial 1376]: Monitor::manage_monitor_mode.impl
P [220] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [220]->
Q [221] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1374]

[serial 1377]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]->
Q [223] << temperature.status = temperature.status
  and RUN() >>
What for:  applied wp for assignment [serial 1375]
Done reducing atomic actions
step:  134
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1377]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]->
Q [223] << temperature.status = temperature.status
  and RUN() >>
What for:  applied wp for assignment [serial 1375]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1378]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]->
Q [223] << true
  and RUN() >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1377]

This Proof Obligation:

[serial 1378]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]->
Q [223] << true
  and RUN() >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1377]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1379]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]->
Q [223] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1378]
. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1372]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [172]->
Q [219] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1013]

[serial 1373]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1013]

[serial 1376]: Monitor::manage_monitor_mode.impl
P [220] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [220]->
Q [221] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1374]

[serial 1379]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]->
Q [223] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1378]
Done applying laws
step:  135
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1373]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1013]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1382]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
What for:    normalization of [serial 1373]

This Proof Obligation:

[serial 1376]: Monitor::manage_monitor_mode.impl
P [220] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [220]->
Q [221] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1374]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1384]: Monitor::manage_monitor_mode.impl
P [220] << CURRENT_TEMP = temperature
  and RUN() >>
S [220]->
Q [221] << CURRENT_TEMP = temperature
  and RUN() >>
What for:    normalization of [serial 1376]

This Proof Obligation:

[serial 1379]: Monitor::manage_monitor_mode.impl
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222]->
Q [223] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1378]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1386]: Monitor::manage_monitor_mode.impl
P [221] << CURRENT_TEMP = temperature
  and RUN() >>
S [222]->
Q [223] << RUN() >>
What for:    normalization of [serial 1379]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1372]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [172]->
Q [219] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1013]

[serial 1382]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
What for:    normalization of [serial 1373]

[serial 1384]: Monitor::manage_monitor_mode.impl
P [220] << CURRENT_TEMP = temperature
  and RUN() >>
S [220]->
Q [221] << CURRENT_TEMP = temperature
  and RUN() >>
What for:    normalization of [serial 1376]

[serial 1386]: Monitor::manage_monitor_mode.impl
P [221] << CURRENT_TEMP = temperature
  and RUN() >>
S [222]->
Q [223] << RUN() >>
What for:    normalization of [serial 1379]
Done Normalizing
step:  136
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1372]: Monitor::manage_monitor_mode.impl
P [172] << RUN() >>
S [172]->
Q [219] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1013]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1384]: Monitor::manage_monitor_mode.impl
P [220] << CURRENT_TEMP = temperature
  and RUN() >>
S [220]->
Q [221] << CURRENT_TEMP = temperature
  and RUN() >>
What for:    normalization of [serial 1376]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1386]: Monitor::manage_monitor_mode.impl
P [221] << CURRENT_TEMP = temperature
  and RUN() >>
S [222]->
Q [223] << RUN() >>
What for:    normalization of [serial 1379]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1382]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
What for:    normalization of [serial 1373]
Done trying to apply axioms
step:  137
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1382]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
What for:    normalization of [serial 1373]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1390]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and true
  and true
  and RUN() >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [7.9 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1390]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and true
  and true
  and RUN() >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  138
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1390]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and true
  and true
  and RUN() >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1391]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 1390]
. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1391]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 1390]
Done applying laws
step:  139
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1391]: Monitor::manage_monitor_mode.impl
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173]->
Q [173] << current_temperature_status = temperature.status
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 1390]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1014]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [229]<< MONITOR_OK()
  and RUN() >>
monitor_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [172] << ( RUN() )^1 >>
What for:   <<M(check_normal) and x>> A <<M(normal)>> for mmm3: check_normal-[x]->normal{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  140
#[serial 1014]  <<M(check_normal) and x>> A <<M(normal)>> for mmm3: check_normal-[x]->normal{A};
step:  141
****reduce****

[serial 1392]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1014]

[serial 1393]: Monitor::manage_monitor_mode.impl
P [231] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]

[serial 1394]: Monitor::manage_monitor_mode.impl
P [229] << MONITOR_OK()
  and RUN() >>
S [230]monitor_mode!(mmode'Normal)
Q [231] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1392]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1014]

[serial 1393]: Monitor::manage_monitor_mode.impl
P [231] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]

[serial 1394]: Monitor::manage_monitor_mode.impl
P [229] << MONITOR_OK()
  and RUN() >>
S [230]monitor_mode!(mmode'Normal)
Q [231] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]
done reducing composite actions
step:  142
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> MONITOR_MODE(x : monitor_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<MONITOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> MONITOR_OK()
    and RUN(),
    Failed -> not MONITOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Normal" is:  
^{and 
 ^{INVOKE[MONITOR_OK] MONITOR_OK} 
 ^{INVOKE[RUN] RUN}}

This Proof Obligation:

[serial 1394]: Monitor::manage_monitor_mode.impl
P [229] << MONITOR_OK()
  and RUN() >>
S [230]monitor_mode!(mmode'Normal)
Q [231] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> monitor_mode!(') <<post>> to get:

[serial 1395]: Monitor::manage_monitor_mode.impl
P [229] << MONITOR_OK()
  and RUN() >>
S [230]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1394]

The Same Proof Obligation:
Has applied <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> for  <<pre>> monitor_mode!(') <<post>> to get:

[serial 1396]: Monitor::manage_monitor_mode.impl
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1394]

[serial 1396]: Monitor::manage_monitor_mode.impl
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1394]
. . . done applying atomic actions [7.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 1392]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1014]

[serial 1393]: Monitor::manage_monitor_mode.impl
P [231] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]

[serial 1395]: Monitor::manage_monitor_mode.impl
P [229] << MONITOR_OK()
  and RUN() >>
S [230]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1394]

[serial 1396]: Monitor::manage_monitor_mode.impl
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1394]
Done reducing atomic actions
step:  143
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1396]: Monitor::manage_monitor_mode.impl
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1394]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1397]: Monitor::manage_monitor_mode.impl
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [7.9 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1392]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1014]

[serial 1393]: Monitor::manage_monitor_mode.impl
P [231] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]

[serial 1395]: Monitor::manage_monitor_mode.impl
P [229] << MONITOR_OK()
  and RUN() >>
S [230]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1394]

[serial 1397]: Monitor::manage_monitor_mode.impl
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  144
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1392]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1014]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1398]: Monitor::manage_monitor_mode.impl
P [173] << not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid )
  and current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1392]

This Proof Obligation:

[serial 1397]: Monitor::manage_monitor_mode.impl
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1399]: Monitor::manage_monitor_mode.impl
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1397]

This Proof Obligation:

[serial 1399]: Monitor::manage_monitor_mode.impl
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1397]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1400]: Monitor::manage_monitor_mode.impl
P [230] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1399]
. . . done Applying Laws [7.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1393]: Monitor::manage_monitor_mode.impl
P [231] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]

[serial 1395]: Monitor::manage_monitor_mode.impl
P [229] << MONITOR_OK()
  and RUN() >>
S [230]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1394]

[serial 1398]: Monitor::manage_monitor_mode.impl
P [173] << not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid )
  and current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1392]

[serial 1400]: Monitor::manage_monitor_mode.impl
P [230] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1399]
Done applying laws
step:  145
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1393]: Monitor::manage_monitor_mode.impl
P [231] << RUN()
  and AXIOM_PAST_INIT() >>
S [172]->
Q [172] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1402]: Monitor::manage_monitor_mode.impl
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172]->
Q [172] << RUN()^1 >>
What for:    normalization of [serial 1393]

This Proof Obligation:

[serial 1398]: Monitor::manage_monitor_mode.impl
P [173] << not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid )
  and current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1392]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1405]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1398]

This Proof Obligation:

[serial 1400]: Monitor::manage_monitor_mode.impl
P [230] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [230]->
Q [231] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1399]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1407]: Monitor::manage_monitor_mode.impl
P [230] << MONITOR_OK()
  and RUN()
  and ( mmode'Normal = monitor_mode )^0 >>
S [230]->
Q [231] << RUN() >>
What for:    normalization of [serial 1400]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1395]: Monitor::manage_monitor_mode.impl
P [229] << MONITOR_OK()
  and RUN() >>
S [230]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1394]

[serial 1402]: Monitor::manage_monitor_mode.impl
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172]->
Q [172] << RUN()^1 >>
What for:    normalization of [serial 1393]

[serial 1405]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1398]

[serial 1407]: Monitor::manage_monitor_mode.impl
P [230] << MONITOR_OK()
  and RUN()
  and ( mmode'Normal = monitor_mode )^0 >>
S [230]->
Q [231] << RUN() >>
What for:    normalization of [serial 1400]
Done Normalizing
step:  146
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1395]: Monitor::manage_monitor_mode.impl
P [229] << MONITOR_OK()
  and RUN() >>
S [230]->
Q [79] << MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1394]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1407]: Monitor::manage_monitor_mode.impl
P [230] << MONITOR_OK()
  and RUN()
  and ( mmode'Normal = monitor_mode )^0 >>
S [230]->
Q [231] << RUN() >>
What for:    normalization of [serial 1400]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [7.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1402]: Monitor::manage_monitor_mode.impl
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172]->
Q [172] << RUN()^1 >>
What for:    normalization of [serial 1393]

[serial 1405]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1398]
Done trying to apply axioms
step:  147
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  148
#Monitor::manage_monitor_mode.impl
step:  149
#[serial 1406]   normalization of [serial 139
step:  150
****make-an****
Making obligation 16
Obligations:

[serial 1402]: Monitor::manage_monitor_mode.impl
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172]->
Q [172] << RUN()^1 >>
What for:    normalization of [serial 1393]
Done making obligation 16
step:  151
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1402]: Monitor::manage_monitor_mode.impl
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172]->
Q [172] << RUN()^1 >>
What for:    normalization of [serial 1393]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1411]: Monitor::manage_monitor_mode.impl
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172]->
Q [172] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1402]
. . . done substituting assertions' for Labels [7.9 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1411]: Monitor::manage_monitor_mode.impl
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172]->
Q [172] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1402]
Done substituting Assertion labels in postconditions.
step:  152
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1411]: Monitor::manage_monitor_mode.impl
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172]->
Q [172] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1402]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1412]: Monitor::manage_monitor_mode.impl
P [231] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [172]->
Q [172] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1411]
. . . done substituting assertions' for Labels [7.9 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1412]: Monitor::manage_monitor_mode.impl
P [231] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [172]->
Q [172] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1411]
Done substituting Assertion labels in preconditions
step:  153
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1412]: Monitor::manage_monitor_mode.impl
P [231] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [172]->
Q [172] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1411]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1413]: Monitor::manage_monitor_mode.impl
P [231] << ( ( now - START_TIME ) <= ( ( now )^1 - ( START_TIME )^1 ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [172]->
Q [172] << ( ( now - START_TIME )^1 >= ( #Iso_Properties::Initialization_Timeout s )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1412]
. . . done spltting timed atoms  [7.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [7.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1413]: Monitor::manage_monitor_mode.impl
P [231] << ( ( now - START_TIME ) <= ( ( now )^1 - ( START_TIME )^1 ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [172]->
Q [172] << ( ( now - START_TIME )^1 >= ( #Iso_Properties::Initialization_Timeout s )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1412]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Constants are always the same
Has been normalized to get:

[serial 1415]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 1413]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1415]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 1413]
Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1415]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 1413]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1417]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1415]
. . . done spltting timed atoms  [7.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [7.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1417]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1415]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1419]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 1417]
. . . done Normalizing Unsolved Proof Obligations [7.9 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1419]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 1417]
Done completely distributing ^ and @, round 1.
Distributing carets . .
. . . done spltting timed atoms  [8.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.0 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
step:  154
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  #Iso_Properties::Initialization_Timeout s <= now - START_TIME and now - START_TIME <= now^1 - START_TIME^1 -> #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1

This Proof Obligation:

[serial 1419]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 1417]
Reason solved:  Transitivity: x<y and y<z -> x<z
Has applied Transitivity: x<y and y<z -> x<z  to get:

[serial 1422]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1419]
. . . done adding transitive terms [8.0 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 1422]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1419]
Done adding transitive relations
step:  155
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1422]: Monitor::manage_monitor_mode.impl
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
S [172]->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1419]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1405]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1398]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  156
#[serial 1409]   normalization of [serial 1402]
step:  157
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1405]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1398]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1423]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405]

[serial 1424]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405]
. . . done splitting postcondition  [8.0 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1423]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405]

[serial 1424]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405]
Done splitting postcondition
step:  158
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1424]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1423]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405]
Done trying to apply axioms
step:  159
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1423]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1425]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1423]
. . . done substituting assertions' for Labels [8.0 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1425]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1423]
Done substituting Assertion labels in postconditions.
step:  160
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1425]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1423]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1427]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1425]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1427]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1425]
Done Normalizing
step:  161
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1427]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [229] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1425]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1429]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427]

[serial 1430]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [69] << not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427]
. . . done splitting postcondition  [8.0 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1429]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427]

[serial 1430]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [69] << not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427]
Done splitting postcondition
step:  162
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1429]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1431]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Assume Present:  P = P@now = P^0   [serial 1429]

This Proof Obligation:

[serial 1430]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173]->
Q [69] << not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1432]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [69] << not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 1430]
. . . done replacing P@now and P^0 with P  [8.0 seconds ]
After assuming present remaining 
Obligations:

[serial 1431]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Assume Present:  P = P@now = P^0   [serial 1429]

[serial 1432]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [69] << not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 1430]
Done assuming present.
step:  163
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1432]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [69] << not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 1430]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1431]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Assume Present:  P = P@now = P^0   [serial 1429]
Done trying to apply axioms
step:  164
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1431]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Assume Present:  P = P@now = P^0   [serial 1429]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1433]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1431]
. . . done substituting assertions' for Labels [8.0 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1433]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1431]
Done substituting Assertion labels in preconditions
step:  165
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1433]: Monitor::manage_monitor_mode.impl
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1431]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1435]: Monitor::manage_monitor_mode.impl
P [173] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:    normalization of [serial 1433]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1435]: Monitor::manage_monitor_mode.impl
P [173] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:    normalization of [serial 1433]
Done Normalizing
step:  166
****guided-sub-equals****
guided substitution of equals "CURRENT_TEMPERATURE_STATUS" . . .
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 1435]: Monitor::manage_monitor_mode.impl
P [173] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:    normalization of [serial 1433]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 1437]: Monitor::manage_monitor_mode.impl
P [173] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = current_temperature_status >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1435]
. . . done guided substitution of equals  [8.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1437]: Monitor::manage_monitor_mode.impl
P [173] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = current_temperature_status >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1435]
Done guided substituting an equals
step:  167
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1437]: Monitor::manage_monitor_mode.impl
P [173] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173]->
Q [70] << status'Valid = current_temperature_status >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1435]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1015]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [237]<< not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:   <<M(check_normal) and x>> A <<M(failed)>> for mmm3x: check_normal-[x]->failed{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  168
#[serial 1015]  <<M(check_normal) and x>> A <<M(failed)>> for mmm3x: check_normal-[x]->failed{A};
step:  169
****reduce****

[serial 1438]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173]->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1015]

[serial 1439]: Monitor::manage_monitor_mode.impl
P [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
S [238]monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1015]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1438]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173]->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1015]

[serial 1439]: Monitor::manage_monitor_mode.impl
P [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
S [238]monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1015]
done reducing composite actions
step:  170
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> MONITOR_MODE(x : monitor_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<MONITOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> MONITOR_OK()
    and RUN(),
    Failed -> not MONITOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Failed" is:  
^{and 
 ^{not 
  ^{INVOKE[MONITOR_OK] MONITOR_OK}} 
 ^{INVOKE[RUN] RUN}}

This Proof Obligation:

[serial 1439]: Monitor::manage_monitor_mode.impl
P [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
S [238]monitor_mode!(mmode'Failed)
Q [175] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1015]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> monitor_mode!(') <<post>> to get:

[serial 1440]: Monitor::manage_monitor_mode.impl
P [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1439]

The Same Proof Obligation:
Has applied <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> for  <<pre>> monitor_mode!(') <<post>> to get:

[serial 1441]: Monitor::manage_monitor_mode.impl
P [238] << ( not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Failed )^0 >>
S [238]->
Q [175] << true >>
What for:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1439]

[serial 1441]: Monitor::manage_monitor_mode.impl
P [238] << ( not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Failed )^0 >>
S [238]->
Q [175] << true >>
What for:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1439]
. . . done applying atomic actions [8.0 seconds ]
After "atomic" remaining 
Obligations:

[serial 1438]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173]->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1015]

[serial 1440]: Monitor::manage_monitor_mode.impl
P [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1439]

[serial 1441]: Monitor::manage_monitor_mode.impl
P [238] << ( not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Failed )^0 >>
S [238]->
Q [175] << true >>
What for:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1439]
Done reducing atomic actions
step:  171
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1438]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173]->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1015]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1442]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173]->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.0 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1440]: Monitor::manage_monitor_mode.impl
P [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1439]

[serial 1441]: Monitor::manage_monitor_mode.impl
P [238] << ( not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Failed )^0 >>
S [238]->
Q [175] << true >>
What for:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1439]

[serial 1442]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173]->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  172
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1440]: Monitor::manage_monitor_mode.impl
P [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  monitor_mode!(') [serial 1439]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1444]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1440]

This Proof Obligation:

[serial 1441]: Monitor::manage_monitor_mode.impl
P [238] << ( not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Failed )^0 >>
S [238]->
Q [175] << true >>
What for:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1439]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1446]: Monitor::manage_monitor_mode.impl
P [238] << ( AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) )
  and ( mmode'Failed = monitor_mode )^0 >>
S [238]->
Q [175] << true >>
What for:    normalization of [serial 1441]

This Proof Obligation:

[serial 1442]: Monitor::manage_monitor_mode.impl
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173]->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and true >>
What for:   add user-defined axioms to postcondition
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1448]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() )
  and true >>
What for:    normalization of [serial 1442]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1444]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1440]

[serial 1446]: Monitor::manage_monitor_mode.impl
P [238] << ( AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) )
  and ( mmode'Failed = monitor_mode )^0 >>
S [238]->
Q [175] << true >>
What for:    normalization of [serial 1441]

[serial 1448]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() )
  and true >>
What for:    normalization of [serial 1442]
Done Normalizing
step:  173
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1446]: Monitor::manage_monitor_mode.impl
P [238] << ( AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) )
  and ( mmode'Failed = monitor_mode )^0 >>
S [238]->
Q [175] << true >>
What for:    normalization of [serial 1441]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1452]: Monitor::manage_monitor_mode.impl
P [238] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() )
  and ( mmode'Failed = monitor_mode )^0 >>
S [238]->
Q [175] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 1446]

This Proof Obligation:

[serial 1448]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() )
  and true >>
What for:    normalization of [serial 1442]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1453]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1448]
. . . done Applying Laws [8.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1444]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1440]

[serial 1452]: Monitor::manage_monitor_mode.impl
P [238] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() )
  and ( mmode'Failed = monitor_mode )^0 >>
S [238]->
Q [175] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 1446]

[serial 1453]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1448]
Done applying laws
step:  174
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1452]: Monitor::manage_monitor_mode.impl
P [238] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() )
  and ( mmode'Failed = monitor_mode )^0 >>
S [238]->
Q [175] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 1446]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1456]: Monitor::manage_monitor_mode.impl
P [238] << AXIOM_ST()
  and ( mmode'Failed = monitor_mode )^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238]->
Q [175] << true >>
What for:    normalization of [serial 1452]

This Proof Obligation:

[serial 1453]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1448]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1458]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
What for:    normalization of [serial 1453]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1444]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1440]

[serial 1456]: Monitor::manage_monitor_mode.impl
P [238] << AXIOM_ST()
  and ( mmode'Failed = monitor_mode )^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238]->
Q [175] << true >>
What for:    normalization of [serial 1452]

[serial 1458]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
What for:    normalization of [serial 1453]
Done Normalizing
step:  175
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1456]: Monitor::manage_monitor_mode.impl
P [238] << AXIOM_ST()
  and ( mmode'Failed = monitor_mode )^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238]->
Q [175] << true >>
What for:    normalization of [serial 1452]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1444]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1440]

[serial 1458]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
What for:    normalization of [serial 1453]
Done trying to apply axioms
step:  176
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1444]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1440]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1461]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( MONITOR_OK() ) ) >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1444]

This Proof Obligation:

[serial 1458]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
What for:    normalization of [serial 1453]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1462]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( MONITOR_OK() ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1458]
. . . done applying DeMorgan's Law  [8.0 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1461]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( MONITOR_OK() ) ) >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1444]

[serial 1462]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( MONITOR_OK() ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1458]
step:  177
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1461]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( MONITOR_OK() ) ) >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1444]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1464]: Monitor::manage_monitor_mode.impl
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1461]

This Proof Obligation:

[serial 1462]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( MONITOR_OK() ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1458]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1466]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
What for:    normalization of [serial 1462]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1464]: Monitor::manage_monitor_mode.impl
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1461]

[serial 1466]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
What for:    normalization of [serial 1462]
Done Normalizing
step:  178
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1464]: Monitor::manage_monitor_mode.impl
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1461]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1469]: Monitor::manage_monitor_mode.impl
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464]

[serial 1470]: Monitor::manage_monitor_mode.impl
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464]

This Proof Obligation:

[serial 1466]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
What for:    normalization of [serial 1462]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1471]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1472]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]
. . . done splitting postcondition  [8.0 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1469]: Monitor::manage_monitor_mode.impl
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464]

[serial 1470]: Monitor::manage_monitor_mode.impl
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464]

[serial 1471]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1472]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]
Done splitting postcondition
step:  179
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1469]: Monitor::manage_monitor_mode.impl
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1473]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1469]

This Proof Obligation:

[serial 1470]: Monitor::manage_monitor_mode.impl
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1474]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1470]
. . . done Applying Laws [8.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1471]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1472]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1473]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1469]

[serial 1474]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1470]
Done applying laws
step:  180
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1474]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << not MONITOR_OK() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1470]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1471]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1472]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1473]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1469]
Done trying to apply axioms
step:  181
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1472]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1475]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1472]

This Proof Obligation:

[serial 1473]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1469]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1476]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1473]
. . . done substituting assertions' for Labels [8.0 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1471]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1475]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1472]

[serial 1476]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1473]
Done substituting Assertion labels in postconditions.
step:  182
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1475]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1472]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1479]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1475]

This Proof Obligation:

[serial 1476]: Monitor::manage_monitor_mode.impl
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238]->
Q [80] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1473]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1481]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1476]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1471]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1479]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1475]

[serial 1481]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1476]
Done Normalizing
step:  183
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1481]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238]->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1476]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1484]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238]->
Q [80] << ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1481]
. . . Substituting <= with not < [8.0 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1471]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1479]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1475]

[serial 1484]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238]->
Q [80] << ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1481]
Done replacing a<=b with (not b<a)
step:  184
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1484]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238]->
Q [80] << ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1481]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1488]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1484]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1471]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]

[serial 1479]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1475]

[serial 1488]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1484]
Done Normalizing
step:  185
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1471]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1490]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1471]

This Proof Obligation:

[serial 1479]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1475]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1491]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1479]

This Proof Obligation:

[serial 1488]: Monitor::manage_monitor_mode.impl
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1484]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1492]: Monitor::manage_monitor_mode.impl
P [237] << ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
S [238]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1488]
. . . done substituting assertions' for Labels [8.0 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1490]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1471]

[serial 1491]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1479]

[serial 1492]: Monitor::manage_monitor_mode.impl
P [237] << ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
S [238]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1488]
Done substituting Assertion labels in preconditions
step:  186
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1490]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1471]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1494]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1490]

This Proof Obligation:

[serial 1491]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1479]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1496]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1491]

This Proof Obligation:

[serial 1492]: Monitor::manage_monitor_mode.impl
P [237] << ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
S [238]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1488]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1498]: Monitor::manage_monitor_mode.impl
P [237] << START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [238]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1492]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1494]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1490]

[serial 1496]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1491]

[serial 1498]: Monitor::manage_monitor_mode.impl
P [237] << START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [238]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1492]
Done Normalizing
step:  187
****guided-sub-equals****
guided substitution of equals "START_TIME" . . .
equality selected for substitution:  START_TIME = start_time
equality selected for substitution:  START_TIME = start_time
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 1498]: Monitor::manage_monitor_mode.impl
P [237] << START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [238]->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1492]
Reason solved:  Guided Substitution of Equals
Has substituted 
"START_TIME" with its = "start_time"
 to get:

[serial 1502]: Monitor::manage_monitor_mode.impl
P [237] << START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [238]->
Q [80] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1498]
. . . done guided substitution of equals  [8.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1494]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1490]
Reason solved:  Guided Substitution of Equals

[serial 1496]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1491]
Reason solved:  Guided Substitution of Equals

[serial 1502]: Monitor::manage_monitor_mode.impl
P [237] << START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [238]->
Q [80] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1498]
Done guided substituting an equals
step:  188
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1502]: Monitor::manage_monitor_mode.impl
P [237] << START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [238]->
Q [80] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1498]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1494]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1490]
Reason solved:  Guided Substitution of Equals

[serial 1496]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1491]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  189
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1494]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1490]
Reasons solved:  
   Guided Substitution of Equals
   Assume Present:  P = P@now = P^0 
Has applied Guided Substitution of Equals Assume Present:  P = P@now = P^0   to get:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]

This Proof Obligation:

[serial 1496]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 1491]
Reasons solved:  
   Guided Substitution of Equals
   Assume Present:  P = P@now = P^0 
Has applied Guided Substitution of Equals Assume Present:  P = P@now = P^0   to get:

[serial 1504]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1496]
. . . done replacing P@now and P^0 with P  [8.0 seconds ]
After assuming present remaining 
Obligations:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]

[serial 1504]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1496]
Done assuming present.
step:  190
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1504]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1496]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1505]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1504]
. . . done applying DeMorgan's Law  [8.0 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]

[serial 1505]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1504]
step:  191
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1505]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1504]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1508]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1505]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]

[serial 1508]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1505]
Done Normalizing
step:  192
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1508]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1505]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1510]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1508]
. . . done applying DeMorgan's Law  [8.0 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]

[serial 1510]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1508]
step:  193
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1510]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1508]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1513]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 1510]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]

[serial 1513]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 1510]
Done Normalizing
step:  194
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1513]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 1510]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1515]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1513]
. . . done Applying Laws [8.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]

[serial 1515]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1513]
Done applying laws
step:  195
****guided-sub-equals****
guided substitution of equals "CURRENT_TEMPERATURE_STATUS" . . .
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 1515]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1513]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 1516]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1515]
. . . done guided substitution of equals  [8.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]
Reason solved:  Guided Substitution of Equals

[serial 1516]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1515]
Done guided substituting an equals
step:  196
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1516]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1515]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  197
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1503]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]
Reasons solved:  
   Guided Substitution of Equals
   At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied Guided Substitution of Equals At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1517]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1503]
. . . Substituting <= with not < [8.0 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1517]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1503]
Done replacing a<=b with (not b<a)
step:  198
****guided-sub-equals****
guided substitution of equals "start_time" . . .
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 1517]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1503]
Reason solved:  Guided Substitution of Equals
Has substituted 
"start_time" with its = "START_TIME"
 to get:

[serial 1518]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 1517]
. . . done guided substitution of equals  [8.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1518]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 1517]
Done guided substituting an equals
step:  199
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1518]: Monitor::manage_monitor_mode.impl
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173]->
Q [237] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 1517]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1017]: Monitor::manage_alarm.impl
P [310] << INVMA() >>
S [303]->
Q [303] << alarm_previous_period = alarm_control^-1 >>
What for:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
Main proof script resumed.
step:  4
#manage_alarm.impl
step:  5
****subscript****
You chose proof subscript: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/subscripts/ma.ps
step:  1
#  You chose proof script: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/subscripts/ma.ps
step:  2
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  3
****sort-by-component****
sorting proof obligations for Monitor::manage_alarm.impl
Monitor::manage_alarm.impl  [serial 1017]  
Monitor::manage_alarm.impl  [serial 1018]  
Monitor::manage_alarm.impl  [serial 1019]  
Monitor::manage_alarm.impl  [serial 1020]  
Monitor::manage_alarm.impl  [serial 1021]  
Monitor::manage_alarm.impl  [serial 1022]  
Monitor::manage_alarm.impl  [serial 1023]  
Monitor::manage_alarm.impl  [serial 1024]  
Monitor::manage_alarm.impl  [serial 1025]  
Monitor::manage_alarm.impl  [serial 1026]  
Monitor::manage_alarm.impl  [serial 1027]  
Monitor::manage_alarm.impl  [serial 1028]  
Monitor::manage_alarm.impl  [serial 1029]  
Monitor::manage_alarm.impl  [serial 1030]  
Monitor::manage_alarm.impl  [serial 1031]  
Regulate::manage_regulator_mode.impl  [serial 1033]  
Regulate::manage_regulator_mode.impl  [serial 1034]  
Regulate::manage_regulator_mode.impl  [serial 1035]  
Regulate::manage_regulator_mode.impl  [serial 1036]  
Regulate::manage_regulator_mode.impl  [serial 1037]  
Regulate::manage_regulator_mode.impl  [serial 1038]  
Regulate::manage_regulator_mode.impl  [serial 1039]  
Regulate::manage_regulator_mode.impl  [serial 1040]  
Regulate::manage_regulator_mode.impl  [serial 1041]  
Regulate::manage_regulator_mode.impl  [serial 1042]  
Regulate::manage_regulator_mode.impl  [serial 1043]  
Regulate::manage_regulator_mode.impl  [serial 1044]  
Regulate::manage_regulator_mode.impl  [serial 1045]  
Regulate::manage_heat_source.impl  [serial 1047]  
Regulate::manage_heat_source.impl  [serial 1048]  
Regulate::manage_heat_source.impl  [serial 1049]  
Regulate::manage_heat_source.impl  [serial 1050]  
Regulate::manage_heat_source.impl  [serial 1051]  
Regulate::manage_heat_source.impl  [serial 1052]  
Regulate::manage_heat_source.impl  [serial 1053]  
Regulate::manage_heat_source.impl  [serial 1054]  
Regulate::manage_heat_source.impl  [serial 1055]  
Regulate::manage_heat_source.impl  [serial 1056]  
Regulate::manage_heat_source.impl  [serial 1057]  
Regulate::manage_heat_source.impl  [serial 1058]  
Regulate::manage_heat_source.impl  [serial 1059]  
Regulate::manage_heat_source.impl  [serial 1060]  
Regulate::manage_heat_source.impl  [serial 1061]  
manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure  [serial 1062]  
manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode  [serial 1063]  
manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode  [serial 1064]  
manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure  [serial 1065]  
manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode  [serial 1066]  
manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode  [serial 1067]  
detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure  [serial 1068]  
air_temperature -> temperature_sensor.air  [serial 1069]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature  [serial 1070]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature  [serial 1071]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature  [serial 1072]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature  [serial 1073]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature  [serial 1074]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature  [serial 1075]  
thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status  [serial 1076]  
thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature  [serial 1077]  
thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control  [serial 1078]  
thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm  [serial 1079]  
thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status  [serial 1080]  
operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp  [serial 1081]  
operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature  [serial 1082]  
operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp  [serial 1083]  
operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature  [serial 1084]  
operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature  [serial 1085]  
operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature  [serial 1086]  
operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature  [serial 1087]  
operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature  [serial 1088]  
Monitor::monitor_temperature.impl.mcti  [serial 1089]  
Monitor::monitor_temperature.impl.mcta  [serial 1090]  
Monitor::monitor_temperature.impl.mctm  [serial 1091]  
Monitor::monitor_temperature.impl.muat  [serial 1092]  
Monitor::monitor_temperature.impl.mlat  [serial 1093]  
Monitor::monitor_temperature.impl.maul  [serial 1094]  
Monitor::monitor_temperature.impl.mall  [serial 1095]  
Monitor::monitor_temperature.impl.malrm  [serial 1096]  
Monitor::monitor_temperature.impl.mms  [serial 1097]  
Monitor::monitor_temperature.impl.intff  [serial 1098]  
Monitor::monitor_temperature.impl.mf  [serial 1099]  
Monitor::monitor_temperature.impl.mmmi  [serial 1100]  
Monitor::monitor_temperature.impl.mmma  [serial 1101]  
KSU_Isolette::isolette.single_sensor.a2ts  [serial 1102]  
KSU_Isolette::isolette.single_sensor.ct  [serial 1103]  
KSU_Isolette::isolette.single_sensor.hc  [serial 1104]  
KSU_Isolette::isolette.single_sensor.ldt  [serial 1105]  
KSU_Isolette::isolette.single_sensor.udt  [serial 1106]  
KSU_Isolette::isolette.single_sensor.lat  [serial 1107]  
KSU_Isolette::isolette.single_sensor.uat  [serial 1108]  
KSU_Isolette::isolette.single_sensor.rs  [serial 1109]  
KSU_Isolette::isolette.single_sensor.ms  [serial 1110]  
KSU_Isolette::isolette.single_sensor.dt  [serial 1111]  
KSU_Isolette::isolette.single_sensor.al  [serial 1112]  
KSU_Isolette::isolette.dual_sensor.a2cs  [serial 1113]  
KSU_Isolette::isolette.dual_sensor.a2ms  [serial 1114]  
KSU_Isolette::isolette.dual_sensor.cont  [serial 1115]  
KSU_Isolette::isolette.dual_sensor.ct  [serial 1116]  
KSU_Isolette::isolette.dual_sensor.hc  [serial 1117]  
KSU_Isolette::isolette.dual_sensor.ldt  [serial 1118]  
KSU_Isolette::isolette.dual_sensor.udt  [serial 1119]  
KSU_Isolette::isolette.dual_sensor.lat  [serial 1120]  
KSU_Isolette::isolette.dual_sensor.uat  [serial 1121]  
KSU_Isolette::isolette.dual_sensor.rs  [serial 1122]  
KSU_Isolette::isolette.dual_sensor.ms  [serial 1123]  
KSU_Isolette::isolette.dual_sensor.dt  [serial 1124]  
KSU_Isolette::isolette.dual_sensor.al  [serial 1125]  
KSU_Isolette::thermostat_single_sensor.impl.tctm  [serial 1126]  
KSU_Isolette::thermostat_single_sensor.impl.tctr  [serial 1127]  
KSU_Isolette::thermostat_single_sensor.impl.thc  [serial 1128]  
KSU_Isolette::thermostat_single_sensor.impl.tudt  [serial 1129]  
KSU_Isolette::thermostat_single_sensor.impl.tldt  [serial 1130]  
KSU_Isolette::thermostat_single_sensor.impl.tuat  [serial 1131]  
KSU_Isolette::thermostat_single_sensor.impl.tlat  [serial 1132]  
KSU_Isolette::thermostat_single_sensor.impl.trs  [serial 1133]  
KSU_Isolette::thermostat_single_sensor.impl.tdt  [serial 1134]  
KSU_Isolette::thermostat_single_sensor.impl.tms  [serial 1135]  
KSU_Isolette::thermostat_single_sensor.impl.ta  [serial 1136]  
KSU_Isolette::thermostat_single_sensor.impl.tf  [serial 1137]  
KSU_Isolette::thermostat_dual_sensor.impl.tctm  [serial 1138]  
KSU_Isolette::thermostat_dual_sensor.impl.tctr  [serial 1139]  
KSU_Isolette::thermostat_dual_sensor.impl.thc  [serial 1140]  
KSU_Isolette::thermostat_dual_sensor.impl.tudt  [serial 1141]  
KSU_Isolette::thermostat_dual_sensor.impl.tldt  [serial 1142]  
KSU_Isolette::thermostat_dual_sensor.impl.tuat  [serial 1143]  
KSU_Isolette::thermostat_dual_sensor.impl.tlat  [serial 1144]  
KSU_Isolette::thermostat_dual_sensor.impl.trs  [serial 1145]  
KSU_Isolette::thermostat_dual_sensor.impl.tdt  [serial 1146]  
KSU_Isolette::thermostat_dual_sensor.impl.tms  [serial 1147]  
KSU_Isolette::thermostat_dual_sensor.impl.ta  [serial 1148]  
KSU_Isolette::thermostat_dual_sensor.impl.tf  [serial 1149]  
Nursery::Room.Normal_Operation.tmp  [serial 1150]  
Regulate::regulate_temperature.impl.rudt  [serial 1151]  
Regulate::regulate_temperature.impl.rldt  [serial 1152]  
Regulate::regulate_temperature.impl.mudt  [serial 1153]  
Regulate::regulate_temperature.impl.mldt  [serial 1154]  
Regulate::regulate_temperature.impl.rrs  [serial 1155]  
Regulate::regulate_temperature.impl.rdt  [serial 1156]  
Regulate::regulate_temperature.impl.rcti  [serial 1157]  
Regulate::regulate_temperature.impl.rcth  [serial 1158]  
Regulate::regulate_temperature.impl.rhc  [serial 1159]  
Regulate::regulate_temperature.impl.rrmh  [serial 1160]  
Regulate::regulate_temperature.impl.rrmi  [serial 1161]  
Regulate::regulate_temperature.impl.rctm  [serial 1162]  
Regulate::regulate_temperature.impl.rif  [serial 1163]  
After sort-by-component[Monitor::manage_alarm.impl], no change. 
step:  4
#Monitor::manage_alarm.impl
step:  5
#[serial 1017] <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definitio
step:  6
****make-an****
Making obligation 20
Obligations:

[serial 1017]: Monitor::manage_alarm.impl
P [310] << INVMA() >>
S [303]->
Q [303] << alarm_previous_period = alarm_control^-1 >>
What for:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Done making obligation 20
step:  7
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1017]: Monitor::manage_alarm.impl
P [310] << INVMA() >>
S [303]->
Q [303] << alarm_previous_period = alarm_control^-1 >>
What for:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1519]: Monitor::manage_alarm.impl
P [310] << ( alarm_previous_period = alarm_control^-1 ) >>
S [303]->
Q [303] << alarm_previous_period = alarm_control^-1 >>
What for:  Substituted assertions' predicates for labels  [serial 1017]
. . . done substituting assertions' for Labels [8.0 seconds ]
After "substitute" remaining 
Obligations:

[serial 1519]: Monitor::manage_alarm.impl
P [310] << ( alarm_previous_period = alarm_control^-1 ) >>
S [303]->
Q [303] << alarm_previous_period = alarm_control^-1 >>
What for:  Substituted assertions' predicates for labels  [serial 1017]
Done substituting Assertion labels.
step:  8
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1519]: Monitor::manage_alarm.impl
P [310] << ( alarm_previous_period = alarm_control^-1 ) >>
S [303]->
Q [303] << alarm_previous_period = alarm_control^-1 >>
What for:  Substituted assertions' predicates for labels  [serial 1017]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1521]: Monitor::manage_alarm.impl
P [310] << alarm_control^-1 = alarm_previous_period >>
S [303]->
Q [303] << alarm_control^-1 = alarm_previous_period >>
What for:    normalization of [serial 1519]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1521]: Monitor::manage_alarm.impl
P [310] << alarm_control^-1 = alarm_previous_period >>
S [303]->
Q [303] << alarm_control^-1 = alarm_previous_period >>
What for:    normalization of [serial 1519]
Done Normalizing
step:  9
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1521]: Monitor::manage_alarm.impl
P [310] << alarm_control^-1 = alarm_previous_period >>
S [303]->
Q [303] << alarm_control^-1 = alarm_previous_period >>
What for:    normalization of [serial 1519]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1018]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
S [312]->
Q [312] << ( ( current_temperature.t < lower_alarm_temperature.t )
   or ( current_temperature.t > upper_alarm_temperature.t ) )
   or ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) )
   or ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  10
#[serial 1018] Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>
step:  11
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1018]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
S [312]->
Q [312] << ( ( current_temperature.t < lower_alarm_temperature.t )
   or ( current_temperature.t > upper_alarm_temperature.t ) )
   or ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) )
   or ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1524]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F )
   or ( ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and lower_alarm_temperature.t <= current_temperature.t ) )
   or ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
What for:    normalization of [serial 1018]
. . . done Normalizing Unsolved Proof Obligations [8.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1524]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F )
   or ( ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and lower_alarm_temperature.t <= current_temperature.t ) )
   or ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
What for:    normalization of [serial 1018]
Done Normalizing
step:  12
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1524]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F )
   or ( ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and lower_alarm_temperature.t <= current_temperature.t ) )
   or ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
What for:    normalization of [serial 1018]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1526]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( ( not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
  and ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t ) ) )
   or ( ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and ( not ( upper_alarm_temperature.t < current_temperature.t ) ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and ( not ( current_temperature.t < lower_alarm_temperature.t ) ) ) )
   or ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1524]
. . . Substituting <= with not < [8.1 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1526]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( ( not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
  and ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t ) ) )
   or ( ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and ( not ( upper_alarm_temperature.t < current_temperature.t ) ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and ( not ( current_temperature.t < lower_alarm_temperature.t ) ) ) )
   or ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1524]
Done replacing a<=b with (not b<a)
step:  13
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1526]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( ( not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
  and ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t ) ) )
   or ( ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and ( not ( upper_alarm_temperature.t < current_temperature.t ) ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and ( not ( current_temperature.t < lower_alarm_temperature.t ) ) ) )
   or ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1524]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1527]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and ( not ( upper_alarm_temperature.t < current_temperature.t ) ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and ( not ( current_temperature.t < lower_alarm_temperature.t ) ) )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t
   or ( ( not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
  and ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t ) ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1526]
. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1527]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and ( not ( upper_alarm_temperature.t < current_temperature.t ) ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and ( not ( current_temperature.t < lower_alarm_temperature.t ) ) )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t
   or ( ( not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
  and ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t ) ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1526]
Done applying laws
step:  14
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1527]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and ( not ( upper_alarm_temperature.t < current_temperature.t ) ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and ( not ( current_temperature.t < lower_alarm_temperature.t ) ) )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t
   or ( ( not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
  and ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t ) ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1526]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1529]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and not ( upper_alarm_temperature.t < current_temperature.t ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and not ( current_temperature.t < lower_alarm_temperature.t ) )
   or ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
  and not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t >>
What for:    normalization of [serial 1527]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1529]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and not ( upper_alarm_temperature.t < current_temperature.t ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and not ( current_temperature.t < lower_alarm_temperature.t ) )
   or ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
  and not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t >>
What for:    normalization of [serial 1527]
Done Normalizing
step:  15
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1529]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and not ( upper_alarm_temperature.t < current_temperature.t ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and not ( current_temperature.t < lower_alarm_temperature.t ) )
   or ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
  and not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t >>
What for:    normalization of [serial 1527]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 1531]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1529]
. . . done putting into conjunctive normal form [8.1 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1531]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1529]
Done making conjunctive normal forms.
step:  16
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1531]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1529]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1532]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1531]

This Proof Obligation:

[serial 1532]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1531]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1533]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1532]

This Proof Obligation:

[serial 1533]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1532]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1534]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1533]

This Proof Obligation:

[serial 1534]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1533]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1535]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1534]
. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1535]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1534]
Done applying laws
step:  17
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1535]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1534]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1537]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << true >>
What for:    normalization of [serial 1535]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1537]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << true >>
What for:    normalization of [serial 1535]
Done Normalizing
step:  18
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1537]: Monitor::manage_alarm.impl
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [312] << true >>
What for:    normalization of [serial 1535]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1019]: Monitor::manage_alarm.impl
P [309] << alarm_previous_period = cntrl'Off
  and ( INVMA() )^1 >>
S [309]->
Q [309] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  19
#[serial 1019] Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>
step:  20
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1019]: Monitor::manage_alarm.impl
P [309] << alarm_previous_period = cntrl'Off
  and ( INVMA() )^1 >>
S [309]->
Q [309] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1020]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON() >>
S [313]->
Q [313] << ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  21
#[serial 1020] Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>
step:  22
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1020]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON() >>
S [313]->
Q [313] << ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1539]: Monitor::manage_alarm.impl
P [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) ) >>
S [313]->
Q [313] << ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1020]
. . . done substituting assertions' for Labels [8.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1539]: Monitor::manage_alarm.impl
P [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) ) >>
S [313]->
Q [313] << ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1020]
Done substituting Assertion labels in preconditions
step:  23
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1539]: Monitor::manage_alarm.impl
P [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) ) >>
S [313]->
Q [313] << ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1020]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1541]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [313] << cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period >>
What for:    normalization of [serial 1539]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1541]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [313] << cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period >>
What for:    normalization of [serial 1539]
Done Normalizing
step:  24
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1541]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [313] << cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period >>
What for:    normalization of [serial 1539]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1021]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( not MONITOR_OK()
  and RUN() )
   or ( INI() )
   or ( MONITOR_OK()
  and RUN() ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  25
#[serial 1021] Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
step:  26
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1021]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( not MONITOR_OK()
  and RUN() )
   or ( INI() )
   or ( MONITOR_OK()
  and RUN() ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1544]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( MONITOR_OK()
  and RUN() )
   or ( RUN()
  and not MONITOR_OK() )
   or INI() >>
What for:    normalization of [serial 1021]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1544]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( MONITOR_OK()
  and RUN() )
   or ( RUN()
  and not MONITOR_OK() )
   or INI() >>
What for:    normalization of [serial 1021]
Done Normalizing
step:  27
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1544]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( MONITOR_OK()
  and RUN() )
   or ( RUN()
  and not MONITOR_OK() )
   or INI() >>
What for:    normalization of [serial 1021]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1546]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
   or ( ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
   or ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1544]
. . . done substituting assertions' for Labels [8.1 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1546]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
   or ( ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
   or ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1544]
Done substituting Assertion labels in postconditions.
step:  28
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1546]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
   or ( ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
   or ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1544]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1548]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
   or ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1546]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1548]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
   or ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1546]
Done Normalizing
step:  29
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1548]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
   or ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1546]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1550]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1548]
. . . Substituting <= with not < [8.1 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1550]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1548]
Done replacing a<=b with (not b<a)
step:  30
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1550]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1548]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1552]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1550]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1552]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1550]
Done Normalizing
step:  31
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1552]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1550]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1554]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:  Associativity: (b.c).a = a.b.c [serial 1552]
. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1554]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:  Associativity: (b.c).a = a.b.c [serial 1552]
Done applying laws
step:  32
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1554]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:  Associativity: (b.c).a = a.b.c [serial 1552]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1556]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1554]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1556]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1554]
Done Normalizing
step:  33
****and-over-or-post****
Distributing postconditions and-over-or . . .

This Proof Obligation:

[serial 1556]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1554]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied distributing postconditions and-over-or to get:

[serial 1558]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Distributing Postcondition Or-Over-And [serial 1556]
. . . done distributing postconditions and-over-or  [8.1 seconds ]
After distributing and-over-or in postconditions remaining 
Obligations:

[serial 1558]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Distributing Postcondition Or-Over-And [serial 1556]
Done distributing and-over-or in postconditions
step:  34
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1558]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Distributing Postcondition Or-Over-And [serial 1556]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1559]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true )
  and ( true )
  and ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1558]

This Proof Obligation:

[serial 1559]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true )
  and ( true )
  and ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1558]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1560]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true )
  and ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1559]

This Proof Obligation:

[serial 1560]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true )
  and ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1559]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1561]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1560]
. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1561]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1560]
Done applying laws
step:  35
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1561]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1560]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1563]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and true
  and true >>
What for:    normalization of [serial 1561]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1563]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and true
  and true >>
What for:    normalization of [serial 1561]
Done Normalizing
step:  36
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1563]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and true
  and true >>
What for:    normalization of [serial 1561]
Reason solved:  Law of Or-Simplification: P or P is P
Has applied law "Law of Or-Simplification: P or P is P " to get:

[serial 1565]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 1563]
. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1565]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 1563]
Done applying laws
step:  37
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1565]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 1563]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1566]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) )
   or ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1565]
. . . done applying DeMorgan's Law  [8.1 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1566]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) )
   or ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1565]
step:  38
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1566]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) )
   or ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1565]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1568]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1566]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1568]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1566]
Done Normalizing
step:  39
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1568]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 1566]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1570]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1568]

This Proof Obligation:

[serial 1570]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1568]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1571]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1570]

This Proof Obligation:

[serial 1571]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1570]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1572]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1571]
. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1572]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1571]
Done applying laws
step:  40
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1572]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1571]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1574]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << true >>
What for:    normalization of [serial 1572]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1574]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << true >>
What for:    normalization of [serial 1572]
Done Normalizing
step:  41
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1574]: Monitor::manage_alarm.impl
P [311] << INVMA() >>
S [311]->
Q [311] << true >>
What for:    normalization of [serial 1572]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1022]: Monitor::manage_alarm.impl
P [309] << alarm_previous_period = cntrl'Off
  and ( INVMA() )^1 >>
S [316]->
Q [310] << ( INVMA() )^1 >>
What for:   <<M(poweron)>> -> <<M(run)>> for maPo: poweron-[ ]->run{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  42
#[serial 1022]  <<M(poweron)>> -> <<M(run)>> for maPo: poweron-[ ]->run{};
step:  43
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1022]: Monitor::manage_alarm.impl
P [309] << alarm_previous_period = cntrl'Off
  and ( INVMA() )^1 >>
S [316]->
Q [310] << ( INVMA() )^1 >>
What for:   <<M(poweron)>> -> <<M(run)>> for maPo: poweron-[ ]->run{};
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1023]: Monitor::manage_alarm.impl
P [310] << INVMA() >>
S [317]->
Q [311] << INVMA() >>
What for:   <<M(run) and x>> -> <<M(check_mode)>> for maRun: run-[x]->check_mode{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  44
#[serial 1023]  <<M(run) and x>> -> <<M(check_mode)>> for maRun: run-[x]->check_mode{};
step:  45
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1023]: Monitor::manage_alarm.impl
P [310] << INVMA() >>
S [317]->
Q [311] << INVMA() >>
What for:   <<M(run) and x>> -> <<M(check_mode)>> for maRun: run-[x]->check_mode{};
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1024]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [320]  << REQMA5() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for maFailed: check_mode-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  46
#[serial 1024]  <<M(check_mode) and x>> A <<M(run)>> for maFailed: check_mode-[x]->run{A};
step:  47
****reduce****
This proof obligation:

[serial 1024]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [320]  << REQMA5() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for maFailed: check_mode-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1576]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [311]->
Q [320] << REQMA5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1024]

[serial 1577]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1024]

[serial 1578]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]alarm_control!(cntrl'O_n)
Q [322] << alarm_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024]

[serial 1579]: Monitor::manage_alarm.impl
P [322] << alarm_control = cntrl'O_n >>
S [323]alarm_previous_period' := cntrl'O_n
Q [324] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1024]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1576]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [311]->
Q [320] << REQMA5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1024]

[serial 1577]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1024]

[serial 1578]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]alarm_control!(cntrl'O_n)
Q [322] << alarm_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024]

[serial 1579]: Monitor::manage_alarm.impl
P [322] << alarm_control = cntrl'O_n >>
S [323]alarm_previous_period' := cntrl'O_n
Q [324] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1024]
done reducing composite actions
step:  48
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<TEMP_OUT_OF_RANGE: x ~ cntrl 
  +=> O_n -> REQMA2()
     or REQMA5()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMA1()
     or REQMA4()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'O_n" is:  
^{or 
 ^{INVOKE[REQMA2] REQMA2} 
 ^{INVOKE[REQMA5] REQMA5} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMA3] REQMA3} 
   ^{( 
    ^{= 
     ^{^ ALARM_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl O_n}} )}} )}}

This Proof Obligation:

[serial 1578]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]alarm_control!(cntrl'O_n)
Q [322] << alarm_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> alarm_control!(') <<post>> to get:

[serial 1580]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1578]

The Same Proof Obligation:
Has applied <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> for  <<pre>> alarm_control!(') <<post>> to get:

[serial 1581]: Monitor::manage_alarm.impl
P [321] << ( REQMA5() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [321]->
Q [322] << alarm_control = cntrl'O_n >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1578]

[serial 1581]: Monitor::manage_alarm.impl
P [321] << ( REQMA5() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [321]->
Q [322] << alarm_control = cntrl'O_n >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1578]
solving assignment on line 323
replacing "alarm_previous_period'" with "cntrl'O_n"
makes:  << ( cntrl'O_n ) = alarm_control >>

This Proof Obligation:

[serial 1579]: Monitor::manage_alarm.impl
P [322] << alarm_control = cntrl'O_n >>
S [323]alarm_previous_period' := cntrl'O_n
Q [324] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1024]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1582]: Monitor::manage_alarm.impl
P [322] << alarm_control = cntrl'O_n >>
S [323]->
Q [324] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1579]
. . . done applying atomic actions [8.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1576]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [311]->
Q [320] << REQMA5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1024]

[serial 1577]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1024]

[serial 1580]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1578]

[serial 1581]: Monitor::manage_alarm.impl
P [321] << ( REQMA5() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [321]->
Q [322] << alarm_control = cntrl'O_n >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1578]

[serial 1582]: Monitor::manage_alarm.impl
P [322] << alarm_control = cntrl'O_n >>
S [323]->
Q [324] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1579]
Done reducing atomic actions
step:  49
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1577]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1024]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1583]: Monitor::manage_alarm.impl
P [324] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1577]

This Proof Obligation:

[serial 1581]: Monitor::manage_alarm.impl
P [321] << ( REQMA5() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [321]->
Q [322] << alarm_control = cntrl'O_n >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1578]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1584]: Monitor::manage_alarm.impl
P [321] << ( REQMA5() )
  and ( ( alarm_control )^0 = ( cntrl'O_n )^0 ) >>
S [321]->
Q [322] << alarm_control = cntrl'O_n >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1581]
. . . done spltting timed atoms  [8.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.1 seconds ]
After "dist^" remaining 
Obligations:

[serial 1576]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [311]->
Q [320] << REQMA5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1024]

[serial 1580]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1578]

[serial 1582]: Monitor::manage_alarm.impl
P [322] << alarm_control = cntrl'O_n >>
S [323]->
Q [324] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1579]

[serial 1583]: Monitor::manage_alarm.impl
P [324] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1577]

[serial 1584]: Monitor::manage_alarm.impl
P [321] << ( REQMA5() )
  and ( ( alarm_control )^0 = ( cntrl'O_n )^0 ) >>
S [321]->
Q [322] << alarm_control = cntrl'O_n >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1581]
Done distributing ^ and @.
step:  50
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1576]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [311]->
Q [320] << REQMA5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1024]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1586]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << REQMA5() >>
What for:    normalization of [serial 1576]

This Proof Obligation:

[serial 1580]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1578]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1588]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1580]

This Proof Obligation:

[serial 1582]: Monitor::manage_alarm.impl
P [322] << alarm_control = cntrl'O_n >>
S [323]->
Q [324] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1579]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1590]: Monitor::manage_alarm.impl
P [322] << cntrl'O_n = alarm_control >>
S [323]->
Q [324] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1582]

This Proof Obligation:

[serial 1583]: Monitor::manage_alarm.impl
P [324] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1577]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1592]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1583]

This Proof Obligation:

[serial 1584]: Monitor::manage_alarm.impl
P [321] << ( REQMA5() )
  and ( ( alarm_control )^0 = ( cntrl'O_n )^0 ) >>
S [321]->
Q [322] << alarm_control = cntrl'O_n >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1581]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1594]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1584]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1586]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << REQMA5() >>
What for:    normalization of [serial 1576]

[serial 1588]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1580]

[serial 1590]: Monitor::manage_alarm.impl
P [322] << cntrl'O_n = alarm_control >>
S [323]->
Q [324] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1582]

[serial 1592]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1583]

[serial 1594]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1584]
Done Normalizing
step:  51
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1588]: Monitor::manage_alarm.impl
P [320] << REQMA5() >>
S [321]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1580]
Reason solved:  Or Introduction Schema (orcwl):  X->(X or Y)
Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)

This Proof Obligation:

[serial 1590]: Monitor::manage_alarm.impl
P [322] << cntrl'O_n = alarm_control >>
S [323]->
Q [324] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1582]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1586]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << REQMA5() >>
What for:    normalization of [serial 1576]

[serial 1592]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1583]

[serial 1594]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1584]
Done trying to apply axioms
step:  52
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1586]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << REQMA5() >>
What for:    normalization of [serial 1576]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1600]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << ( MONITOR_MODE(x : mmode'Failed) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1586]

This Proof Obligation:

[serial 1592]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1583]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1601]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1592]
. . . done substituting assertions' for Labels [8.1 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1594]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1584]

[serial 1600]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << ( MONITOR_MODE(x : mmode'Failed) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1586]

[serial 1601]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1592]
Done substituting Assertion labels in postconditions.
step:  53
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1600]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << ( MONITOR_MODE(x : mmode'Failed) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1586]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1604]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 1600]

This Proof Obligation:

[serial 1601]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1592]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1606]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1601]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1594]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1584]

[serial 1604]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 1600]

[serial 1606]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1601]
Done Normalizing
step:  54
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1604]: Monitor::manage_alarm.impl
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 1600]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1609]: Monitor::manage_alarm.impl
P [311] << RUN()
  and not MONITOR_OK()
  and INVMA() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1604]
. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1594]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1584]

[serial 1606]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1601]

[serial 1609]: Monitor::manage_alarm.impl
P [311] << RUN()
  and not MONITOR_OK()
  and INVMA() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1604]
Done applying laws
step:  55
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1606]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1601]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1610]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1606]
. . . done spltting timed atoms  [8.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.1 seconds ]
After "dist^" remaining 
Obligations:

[serial 1594]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1584]

[serial 1609]: Monitor::manage_alarm.impl
P [311] << RUN()
  and not MONITOR_OK()
  and INVMA() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1604]

[serial 1610]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1606]
Done distributing ^ and @.
step:  56
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1609]: Monitor::manage_alarm.impl
P [311] << RUN()
  and not MONITOR_OK()
  and INVMA() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1604]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1613]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 1609]

This Proof Obligation:

[serial 1610]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1606]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1615]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1610]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1594]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1584]

[serial 1613]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 1609]

[serial 1615]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1610]
Done Normalizing
step:  57
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1594]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1584]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1618]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n = alarm_control
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1594]

This Proof Obligation:

[serial 1615]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1610]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1619]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1615]
. . . done replacing P@now and P^0 with P  [8.1 seconds ]
After assuming present remaining 
Obligations:

[serial 1613]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 1609]

[serial 1618]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n = alarm_control
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1594]

[serial 1619]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1615]
Done assuming present.
step:  58
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1618]: Monitor::manage_alarm.impl
P [321] << cntrl'O_n = alarm_control
  and REQMA5() >>
S [321]->
Q [322] << cntrl'O_n = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1594]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1619]: Monitor::manage_alarm.impl
P [324] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1615]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1613]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 1609]
Done trying to apply axioms
step:  59
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1613]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 1609]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1620]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << ( not MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1613]
. . . done substituting assertions' for Labels [8.1 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1620]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << ( not MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1613]
Done substituting Assertion labels in postconditions.
step:  60
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1620]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << ( not MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1613]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1622]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1620]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1622]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1620]
Done Normalizing
step:  61
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1622]: Monitor::manage_alarm.impl
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311]->
Q [320] << RUN()
  and not MONITOR_OK() >>
What for:    normalization of [serial 1620]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1025]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( INI() ) >>
S [328]  << REQMA1() >>
  alarm_control!(cntrl'Off)
  ;
  << alarm_control = cntrl'Off >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for maInit: check_mode-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  62
#[serial 1025]  <<M(check_mode) and x>> A <<M(run)>> for maInit: check_mode-[x]->run{A};
step:  63
****reduce****
This proof obligation:

[serial 1025]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( INI() ) >>
S [328]  << REQMA1() >>
  alarm_control!(cntrl'Off)
  ;
  << alarm_control = cntrl'Off >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for maInit: check_mode-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1624]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( INI() ) >>
S [311]->
Q [328] << REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]

[serial 1625]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]

[serial 1626]: Monitor::manage_alarm.impl
P [328] << REQMA1() >>
S [329]alarm_control!(cntrl'Off)
Q [330] << alarm_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]

[serial 1627]: Monitor::manage_alarm.impl
P [330] << alarm_control = cntrl'Off >>
S [331]alarm_previous_period' := cntrl'Off
Q [332] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1624]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( INI() ) >>
S [311]->
Q [328] << REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]

[serial 1625]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]

[serial 1626]: Monitor::manage_alarm.impl
P [328] << REQMA1() >>
S [329]alarm_control!(cntrl'Off)
Q [330] << alarm_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]

[serial 1627]: Monitor::manage_alarm.impl
P [330] << alarm_control = cntrl'Off >>
S [331]alarm_previous_period' := cntrl'Off
Q [332] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
done reducing composite actions
step:  64
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<TEMP_OUT_OF_RANGE: x ~ cntrl 
  +=> O_n -> REQMA2()
     or REQMA5()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMA1()
     or REQMA4()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'Off" is:  
^{or 
 ^{INVOKE[REQMA1] REQMA1} 
 ^{INVOKE[REQMA4] REQMA4} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMA3] REQMA3} 
   ^{( 
    ^{= 
     ^{^ ALARM_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl Off}} )}} )}}

This Proof Obligation:

[serial 1626]: Monitor::manage_alarm.impl
P [328] << REQMA1() >>
S [329]alarm_control!(cntrl'Off)
Q [330] << alarm_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> alarm_control!(') <<post>> to get:

[serial 1628]: Monitor::manage_alarm.impl
P [328] << REQMA1() >>
S [329]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1626]

The Same Proof Obligation:
Has applied <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> for  <<pre>> alarm_control!(') <<post>> to get:

[serial 1629]: Monitor::manage_alarm.impl
P [329] << ( REQMA1() )
  and ( alarm_control = cntrl'Off )^0 >>
S [329]->
Q [330] << alarm_control = cntrl'Off >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1626]

[serial 1629]: Monitor::manage_alarm.impl
P [329] << ( REQMA1() )
  and ( alarm_control = cntrl'Off )^0 >>
S [329]->
Q [330] << alarm_control = cntrl'Off >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1626]
solving assignment on line 331
replacing "alarm_previous_period'" with "cntrl'Off"
makes:  << ( cntrl'Off ) = alarm_control >>

This Proof Obligation:

[serial 1627]: Monitor::manage_alarm.impl
P [330] << alarm_control = cntrl'Off >>
S [331]alarm_previous_period' := cntrl'Off
Q [332] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1630]: Monitor::manage_alarm.impl
P [330] << alarm_control = cntrl'Off >>
S [331]->
Q [332] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1627]
. . . done applying atomic actions [8.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1624]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( INI() ) >>
S [311]->
Q [328] << REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]

[serial 1625]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]

[serial 1628]: Monitor::manage_alarm.impl
P [328] << REQMA1() >>
S [329]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1626]

[serial 1629]: Monitor::manage_alarm.impl
P [329] << ( REQMA1() )
  and ( alarm_control = cntrl'Off )^0 >>
S [329]->
Q [330] << alarm_control = cntrl'Off >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1626]

[serial 1630]: Monitor::manage_alarm.impl
P [330] << alarm_control = cntrl'Off >>
S [331]->
Q [332] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1627]
Done reducing atomic actions
step:  65
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1624]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( INI() ) >>
S [311]->
Q [328] << REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1632]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << REQMA1() >>
What for:    normalization of [serial 1624]

This Proof Obligation:

[serial 1625]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1634]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1625]

This Proof Obligation:

[serial 1628]: Monitor::manage_alarm.impl
P [328] << REQMA1() >>
S [329]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1626]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1636]: Monitor::manage_alarm.impl
P [328] << REQMA1() >>
S [329]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1628]

This Proof Obligation:

[serial 1629]: Monitor::manage_alarm.impl
P [329] << ( REQMA1() )
  and ( alarm_control = cntrl'Off )^0 >>
S [329]->
Q [330] << alarm_control = cntrl'Off >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1626]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1638]: Monitor::manage_alarm.impl
P [329] << REQMA1()
  and ( cntrl'Off = alarm_control )^0 >>
S [329]->
Q [330] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1629]

This Proof Obligation:

[serial 1630]: Monitor::manage_alarm.impl
P [330] << alarm_control = cntrl'Off >>
S [331]->
Q [332] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1627]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1640]: Monitor::manage_alarm.impl
P [330] << cntrl'Off = alarm_control >>
S [331]->
Q [332] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1630]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1632]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << REQMA1() >>
What for:    normalization of [serial 1624]

[serial 1634]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1625]

[serial 1636]: Monitor::manage_alarm.impl
P [328] << REQMA1() >>
S [329]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1628]

[serial 1638]: Monitor::manage_alarm.impl
P [329] << REQMA1()
  and ( cntrl'Off = alarm_control )^0 >>
S [329]->
Q [330] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1629]

[serial 1640]: Monitor::manage_alarm.impl
P [330] << cntrl'Off = alarm_control >>
S [331]->
Q [332] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1630]
Done Normalizing
step:  66
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1636]: Monitor::manage_alarm.impl
P [328] << REQMA1() >>
S [329]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1628]
Reason solved:  Or Introduction Schema (orcwl):  X->(X or Y)
Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)

This Proof Obligation:

[serial 1640]: Monitor::manage_alarm.impl
P [330] << cntrl'Off = alarm_control >>
S [331]->
Q [332] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1630]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1632]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << REQMA1() >>
What for:    normalization of [serial 1624]

[serial 1634]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1625]

[serial 1638]: Monitor::manage_alarm.impl
P [329] << REQMA1()
  and ( cntrl'Off = alarm_control )^0 >>
S [329]->
Q [330] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1629]
Done trying to apply axioms
step:  67
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1638]: Monitor::manage_alarm.impl
P [329] << REQMA1()
  and ( cntrl'Off = alarm_control )^0 >>
S [329]->
Q [330] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1629]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1646]: Monitor::manage_alarm.impl
P [329] << cntrl'Off = alarm_control
  and REQMA1() >>
S [329]->
Q [330] << cntrl'Off = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1638]
. . . done replacing P@now and P^0 with P  [8.1 seconds ]
After assuming present remaining 
Obligations:

[serial 1632]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << REQMA1() >>
What for:    normalization of [serial 1624]

[serial 1634]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1625]

[serial 1646]: Monitor::manage_alarm.impl
P [329] << cntrl'Off = alarm_control
  and REQMA1() >>
S [329]->
Q [330] << cntrl'Off = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1638]
Done assuming present.
step:  68
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1646]: Monitor::manage_alarm.impl
P [329] << cntrl'Off = alarm_control
  and REQMA1() >>
S [329]->
Q [330] << cntrl'Off = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1638]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1632]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << REQMA1() >>
What for:    normalization of [serial 1624]

[serial 1634]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1625]
Done trying to apply axioms
step:  69
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1632]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << REQMA1() >>
What for:    normalization of [serial 1624]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1647]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1632]

This Proof Obligation:

[serial 1634]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1625]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1648]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1634]
. . . done substituting assertions' for Labels [8.1 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1647]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1632]

[serial 1648]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1634]
Done substituting Assertion labels in postconditions.
step:  70
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1647]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1632]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1650]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1647]

This Proof Obligation:

[serial 1648]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1634]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1652]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1648]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1650]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1647]

[serial 1652]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1648]
Done Normalizing
step:  71
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1652]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1648]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1655]: Monitor::manage_alarm.impl
P [332] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1652]
. . . done spltting timed atoms  [8.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1655]: Monitor::manage_alarm.impl
P [332] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1652]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1658]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1655]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1650]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1647]

[serial 1658]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1655]
Done completely distributing ^ and @, round 0.
Distributing carets . .
. . . done spltting timed atoms  [8.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.1 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
step:  72
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1650]: Monitor::manage_alarm.impl
P [311] << INI()
  and INVMA() >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1647]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1662]: Monitor::manage_alarm.impl
P [311] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( alarm_previous_period = alarm_control^-1 ) >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1650]
. . . done substituting assertions' for Labels [8.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1658]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1655]

[serial 1662]: Monitor::manage_alarm.impl
P [311] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( alarm_previous_period = alarm_control^-1 ) >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1650]
Done substituting Assertion labels in preconditions
step:  73
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1658]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1655]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1663]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1658]
. . . done replacing P@now and P^0 with P  [8.1 seconds ]
After assuming present remaining 
Obligations:

[serial 1662]: Monitor::manage_alarm.impl
P [311] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( alarm_previous_period = alarm_control^-1 ) >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1650]

[serial 1663]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1658]
Done assuming present.
step:  74
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1662]: Monitor::manage_alarm.impl
P [311] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( alarm_previous_period = alarm_control^-1 ) >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1650]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1665]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1662]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1663]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1658]

[serial 1665]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1662]
Done Normalizing
step:  75
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1663]: Monitor::manage_alarm.impl
P [332] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1658]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1665]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1662]
Done trying to apply axioms
step:  76
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1665]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1662]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1668]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1665]
. . . done substituting assertions' for Labels [8.1 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1668]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1665]
Done substituting Assertion labels in postconditions.
step:  77
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1668]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1665]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1669]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1668]
. . . done substituting assertions' for Labels [8.1 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1669]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1668]
Done substituting Assertion labels in postconditions.
step:  78
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1669]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1668]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1671]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1669]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1671]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1669]
Done Normalizing
step:  79
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1671]: Monitor::manage_alarm.impl
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311]->
Q [328] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1669]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1026]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
What for:   <<M(check_mode) and x>> -> <<M(check_temp)>> for maNormal: check_mode-[x]->check_temp{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  80
#[serial 1026]  <<M(check_mode) and x>> -> <<M(check_temp)>> for maNormal: check_mode-[x]->check_temp{};
step:  81
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1026]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
What for:   <<M(check_mode) and x>> -> <<M(check_temp)>> for maNormal: check_mode-[x]->check_temp{};
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1673]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.1 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1673]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  82
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1673]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1674]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 1673]

This Proof Obligation:

[serial 1674]: Monitor::manage_alarm.impl
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 1673]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1675]: Monitor::manage_alarm.impl
P [311] << MONITOR_OK()
  and RUN()
  and ( INVMA() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1674]
. . . done Applying Laws [8.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1675]: Monitor::manage_alarm.impl
P [311] << MONITOR_OK()
  and RUN()
  and ( INVMA() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1674]
Done applying laws
step:  83
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1675]: Monitor::manage_alarm.impl
P [311] << MONITOR_OK()
  and RUN()
  and ( INVMA() ) >>
S [334]->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1674]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1027]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t < lower_alarm_temperature.t )
   or ( current_temperature.t > upper_alarm_temperature.t ) ) >>
S [339]  << REQMA2()
    and not REQMA1() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for maOor: check_temp-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  84
#[serial 1027]  <<M(check_temp) and x>> A <<M(run)>> for maOor: check_temp-[x]->run{A};
step:  85
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1027]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t < lower_alarm_temperature.t )
   or ( current_temperature.t > upper_alarm_temperature.t ) ) >>
S [339]  << REQMA2()
    and not REQMA1() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for maOor: check_temp-[x]->run{A};
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1677]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [339]  << REQMA2()
    and not REQMA1() >>
  alarm_control!(cntrl'O_n)
  ;
  << cntrl'O_n = alarm_control >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << INVMA()^1 >>
What for:    normalization of [serial 1027]
. . . done Normalizing Unsolved Proof Obligations [8.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1677]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [339]  << REQMA2()
    and not REQMA1() >>
  alarm_control!(cntrl'O_n)
  ;
  << cntrl'O_n = alarm_control >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << INVMA()^1 >>
What for:    normalization of [serial 1027]
Done Normalizing
step:  86
****reduce****
This proof obligation:

[serial 1677]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [339]  << REQMA2()
    and not REQMA1() >>
  alarm_control!(cntrl'O_n)
  ;
  << cntrl'O_n = alarm_control >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << INVMA()^1 >>
What for:    normalization of [serial 1027]
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1679]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << REQMA2()
  and not REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1677]

[serial 1680]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1677]

[serial 1681]: Monitor::manage_alarm.impl
P [339] << REQMA2()
  and not REQMA1() >>
S [340]alarm_control!(cntrl'O_n)
Q [341] << cntrl'O_n = alarm_control >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1677]

[serial 1682]: Monitor::manage_alarm.impl
P [341] << cntrl'O_n = alarm_control >>
S [342]alarm_previous_period' := cntrl'O_n
Q [343] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1677]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1679]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << REQMA2()
  and not REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1677]

[serial 1680]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1677]

[serial 1681]: Monitor::manage_alarm.impl
P [339] << REQMA2()
  and not REQMA1() >>
S [340]alarm_control!(cntrl'O_n)
Q [341] << cntrl'O_n = alarm_control >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1677]

[serial 1682]: Monitor::manage_alarm.impl
P [341] << cntrl'O_n = alarm_control >>
S [342]alarm_previous_period' := cntrl'O_n
Q [343] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1677]
done reducing composite actions
step:  87
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<TEMP_OUT_OF_RANGE: x ~ cntrl 
  +=> O_n -> REQMA2()
     or REQMA5()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMA1()
     or REQMA4()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'O_n" is:  
^{or 
 ^{INVOKE[REQMA2] REQMA2} 
 ^{INVOKE[REQMA5] REQMA5} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMA3] REQMA3} 
   ^{( 
    ^{= 
     ^{^ ALARM_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl O_n}} )}} )}}

This Proof Obligation:

[serial 1681]: Monitor::manage_alarm.impl
P [339] << REQMA2()
  and not REQMA1() >>
S [340]alarm_control!(cntrl'O_n)
Q [341] << cntrl'O_n = alarm_control >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1677]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> alarm_control!(') <<post>> to get:

[serial 1683]: Monitor::manage_alarm.impl
P [339] << REQMA2()
  and not REQMA1() >>
S [340]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1681]

The Same Proof Obligation:
Has applied <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> for  <<pre>> alarm_control!(') <<post>> to get:

[serial 1684]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1681]

[serial 1684]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1681]
solving assignment on line 342
replacing "alarm_previous_period'" with "cntrl'O_n"
makes:  << ( cntrl'O_n ) = alarm_control >>

This Proof Obligation:

[serial 1682]: Monitor::manage_alarm.impl
P [341] << cntrl'O_n = alarm_control >>
S [342]alarm_previous_period' := cntrl'O_n
Q [343] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1677]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1685]: Monitor::manage_alarm.impl
P [341] << cntrl'O_n = alarm_control >>
S [342]->
Q [343] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1682]
. . . done applying atomic actions [8.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1679]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << REQMA2()
  and not REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1677]

[serial 1680]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1677]

[serial 1683]: Monitor::manage_alarm.impl
P [339] << REQMA2()
  and not REQMA1() >>
S [340]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1681]

[serial 1684]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1681]

[serial 1685]: Monitor::manage_alarm.impl
P [341] << cntrl'O_n = alarm_control >>
S [342]->
Q [343] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1682]
Done reducing atomic actions
step:  88
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1683]: Monitor::manage_alarm.impl
P [339] << REQMA2()
  and not REQMA1() >>
S [340]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1681]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1689]: Monitor::manage_alarm.impl
P [339] << REQMA2()
  and not REQMA1() >>
S [340]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1683]

This Proof Obligation:

[serial 1684]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1681]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1691]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1684]

This Proof Obligation:

[serial 1685]: Monitor::manage_alarm.impl
P [341] << cntrl'O_n = alarm_control >>
S [342]->
Q [343] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1682]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1693]: Monitor::manage_alarm.impl
P [341] << cntrl'O_n = alarm_control >>
S [342]->
Q [343] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1685]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1679]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << REQMA2()
  and not REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1677]

[serial 1680]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1677]

[serial 1689]: Monitor::manage_alarm.impl
P [339] << REQMA2()
  and not REQMA1() >>
S [340]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1683]

[serial 1691]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1684]

[serial 1693]: Monitor::manage_alarm.impl
P [341] << cntrl'O_n = alarm_control >>
S [342]->
Q [343] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1685]
Done Normalizing
step:  89
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 REQMA2()


This Proof Obligation:

[serial 1689]: Monitor::manage_alarm.impl
P [339] << REQMA2()
  and not REQMA1() >>
S [340]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1683]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1693]: Monitor::manage_alarm.impl
P [341] << cntrl'O_n = alarm_control >>
S [342]->
Q [343] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1685]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1679]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << REQMA2()
  and not REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1677]

[serial 1680]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1677]

[serial 1691]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1684]
Done trying to apply axioms
step:  90
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1679]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << REQMA2()
  and not REQMA1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1677]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1697]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or CURRENT_TEMP.t > UPPER_ALARM_TEMP.t ) )
  and not ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1679]

This Proof Obligation:

[serial 1680]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1677]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1698]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1680]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1691]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1684]

[serial 1697]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or CURRENT_TEMP.t > UPPER_ALARM_TEMP.t ) )
  and not ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1679]

[serial 1698]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1680]
Done substituting Assertion labels in postconditions.
step:  91
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1697]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or CURRENT_TEMP.t > UPPER_ALARM_TEMP.t ) )
  and not ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1679]
Reasons solved:  
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1701]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal) )
  and not MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1697]

This Proof Obligation:

[serial 1698]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1680]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1703]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1698]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1691]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1684]

[serial 1701]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal) )
  and not MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1697]

[serial 1703]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1698]
Done Normalizing
step:  92
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1691]: Monitor::manage_alarm.impl
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1684]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1706]: Monitor::manage_alarm.impl
P [340] << REQMA2()
  and not REQMA1()
  and ( cntrl'O_n = alarm_control )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 1691]

This Proof Obligation:

[serial 1701]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal) )
  and not MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1697]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1707]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal)
  and not MONITOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1701]
. . . done Applying Laws [8.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1703]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1698]

[serial 1706]: Monitor::manage_alarm.impl
P [340] << REQMA2()
  and not REQMA1()
  and ( cntrl'O_n = alarm_control )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 1691]

[serial 1707]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal)
  and not MONITOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1701]
Done applying laws
step:  93
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1706]: Monitor::manage_alarm.impl
P [340] << REQMA2()
  and not REQMA1()
  and ( cntrl'O_n = alarm_control )^0 >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 1691]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1710]: Monitor::manage_alarm.impl
P [340] << REQMA2()
  and ( cntrl'O_n = alarm_control )^0
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1706]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1703]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1698]

[serial 1707]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal)
  and not MONITOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1701]

[serial 1710]: Monitor::manage_alarm.impl
P [340] << REQMA2()
  and ( cntrl'O_n = alarm_control )^0
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1706]
Done Normalizing
step:  94
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1703]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
What for:    normalization of [serial 1698]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1713]: Monitor::manage_alarm.impl
P [343] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1703]

This Proof Obligation:

[serial 1710]: Monitor::manage_alarm.impl
P [340] << REQMA2()
  and ( cntrl'O_n = alarm_control )^0
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1706]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1714]: Monitor::manage_alarm.impl
P [340] << REQMA2()
  and ( ( cntrl'O_n )^0 = ( alarm_control )^0 )
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1710]
. . . done spltting timed atoms  [8.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.2 seconds ]
After "dist^" remaining 
Obligations:

[serial 1707]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal)
  and not MONITOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1701]

[serial 1713]: Monitor::manage_alarm.impl
P [343] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1703]

[serial 1714]: Monitor::manage_alarm.impl
P [340] << REQMA2()
  and ( ( cntrl'O_n )^0 = ( alarm_control )^0 )
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1710]
Done distributing ^ and @.
step:  95
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1713]: Monitor::manage_alarm.impl
P [343] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1703]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1717]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1713]

This Proof Obligation:

[serial 1714]: Monitor::manage_alarm.impl
P [340] << REQMA2()
  and ( ( cntrl'O_n )^0 = ( alarm_control )^0 )
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1710]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1719]: Monitor::manage_alarm.impl
P [340] << cntrl'O_n^0 = alarm_control^0
  and REQMA2()
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1714]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1707]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal)
  and not MONITOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1701]

[serial 1717]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1713]

[serial 1719]: Monitor::manage_alarm.impl
P [340] << cntrl'O_n^0 = alarm_control^0
  and REQMA2()
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1714]
Done Normalizing
step:  96
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1707]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal)
  and not MONITOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1701]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1722]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [49] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]

[serial 1723]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]

[serial 1724]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not MONITOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
. . . done splitting postcondition  [8.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1717]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1713]

[serial 1719]: Monitor::manage_alarm.impl
P [340] << cntrl'O_n^0 = alarm_control^0
  and REQMA2()
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1714]

[serial 1722]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [49] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]

[serial 1723]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]

[serial 1724]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not MONITOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
Done splitting postcondition
step:  97
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1717]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1713]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1725]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1717]

This Proof Obligation:

[serial 1719]: Monitor::manage_alarm.impl
P [340] << cntrl'O_n^0 = alarm_control^0
  and REQMA2()
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1714]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1726]: Monitor::manage_alarm.impl
P [340] << cntrl'O_n = alarm_control
  and REQMA2()
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1719]
. . . done replacing P@now and P^0 with P  [8.2 seconds ]
After assuming present remaining 
Obligations:

[serial 1722]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [49] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]

[serial 1723]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]

[serial 1724]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not MONITOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]

[serial 1725]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1717]

[serial 1726]: Monitor::manage_alarm.impl
P [340] << cntrl'O_n = alarm_control
  and REQMA2()
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1719]
Done assuming present.
step:  98
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1725]: Monitor::manage_alarm.impl
P [343] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1717]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1726]: Monitor::manage_alarm.impl
P [340] << cntrl'O_n = alarm_control
  and REQMA2()
  and not REQMA1() >>
S [340]->
Q [341] << cntrl'O_n = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1719]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1722]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [49] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]

[serial 1723]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]

[serial 1724]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not MONITOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
Done trying to apply axioms
step:  99
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  100
#Monitor::manage_alarm.impl
step:  101
#[serial 1367] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 135
step:  102
****make-an****
Making obligation 31
Obligations:

[serial 1722]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [49] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
Done making obligation 31
step:  103
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1722]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [49] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1728]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:    normalization of [serial 1722]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1728]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:    normalization of [serial 1722]
Done Normalizing
step:  104
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1728]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:    normalization of [serial 1722]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1730]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1728]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1730]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1728]
Done substituting Assertion labels in preconditions
step:  105
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1730]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1728]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1732]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:    normalization of [serial 1730]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1732]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:    normalization of [serial 1730]
Done Normalizing
step:  106
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1732]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:    normalization of [serial 1730]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1734]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1732]
. . . Substituting <= with not < [8.2 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1734]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1732]
Done replacing a<=b with (not b<a)
step:  107
****replace-port-value****
Replacing port names with BLESS::Value properties
Replacing port names with BLESS::Value properties.

This Proof Obligation:

[serial 1734]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1732]
Reason solved:  Replacing port names with BLESS::Value properties
Has applied Replacing port names with BLESS::Value properties  to get:

[serial 1735]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:  Replacing port names with BLESS::Value properties  [serial 1734]
done replacing port names with Assertions [8.2 seconds ]
After "Replacing port names with BLESS::Value properties" remaining 
Obligations:

[serial 1735]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:  Replacing port names with BLESS::Value properties  [serial 1734]
Done replacing port names with  BLESS::Value properties.
step:  108
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1735]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
What for:  Replacing port names with BLESS::Value properties  [serial 1734]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1723]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  109
#[serial 1368] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1352]
step:  110
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1723]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1736]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1723]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1736]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1723]
Done substituting Assertion labels in postconditions.
step:  111
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1736]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1723]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1738]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1736]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1738]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1736]
Done Normalizing
step:  112
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1738]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [48] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1736]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1724]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not MONITOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  113
#[serial 1369] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1352]
step:  114
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1724]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not MONITOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1740]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1724]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1740]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1724]
Done substituting Assertion labels in postconditions.
step:  115
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1740]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1724]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1742]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not INI() >>
What for:    normalization of [serial 1740]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1742]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not INI() >>
What for:    normalization of [serial 1740]
Done Normalizing
step:  116
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1742]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not INI() >>
What for:    normalization of [serial 1740]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1744]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1742]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1744]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1742]
Done substituting Assertion labels in postconditions.
step:  117
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1744]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [339] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1742]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1745]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [339] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1744]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1745]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [339] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1744]
Done substituting Assertion labels in preconditions
step:  118
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1745]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [339] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1744]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1747]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1745]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1747]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1745]
Done Normalizing
step:  119
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1747]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1745]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1749]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1747]
. . . Substituting <= with not < [8.2 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1749]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1747]
Done replacing a<=b with (not b<a)
step:  120
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1749]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1747]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1751]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and alarm_control^-1 = alarm_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1749]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1751]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and alarm_control^-1 = alarm_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1749]
Done Normalizing
step:  121
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1751]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and alarm_control^-1 = alarm_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1749]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1028]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [348]  << REQMA4()
    and not REQMA1()
    and AXIOM_AR() >>
  alarm_control!(cntrl'Off)
  ;
  << REQMA4()
    and not REQMA1()
    and AXIOM_AR()
    and ( alarm_control = cntrl'Off ) >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for maIr: check_temp-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  122
#[serial 1028]  <<M(check_temp) and x>> A <<M(run)>> for maIr: check_temp-[x]->run{A};
step:  123
****reduce****
This proof obligation:

[serial 1028]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [348]  << REQMA4()
    and not REQMA1()
    and AXIOM_AR() >>
  alarm_control!(cntrl'Off)
  ;
  << REQMA4()
    and not REQMA1()
    and AXIOM_AR()
    and ( alarm_control = cntrl'Off ) >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for maIr: check_temp-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1753]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]

[serial 1754]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1028]

[serial 1755]: Monitor::manage_alarm.impl
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349]alarm_control!(cntrl'Off)
Q [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]

[serial 1756]: Monitor::manage_alarm.impl
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351]alarm_previous_period' := cntrl'Off
Q [352] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1028]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1753]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]

[serial 1754]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1028]

[serial 1755]: Monitor::manage_alarm.impl
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349]alarm_control!(cntrl'Off)
Q [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]

[serial 1756]: Monitor::manage_alarm.impl
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351]alarm_previous_period' := cntrl'Off
Q [352] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1028]
done reducing composite actions
step:  124
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<TEMP_OUT_OF_RANGE: x ~ cntrl 
  +=> O_n -> REQMA2()
     or REQMA5()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMA1()
     or REQMA4()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'Off" is:  
^{or 
 ^{INVOKE[REQMA1] REQMA1} 
 ^{INVOKE[REQMA4] REQMA4} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMA3] REQMA3} 
   ^{( 
    ^{= 
     ^{^ ALARM_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl Off}} )}} )}}

This Proof Obligation:

[serial 1755]: Monitor::manage_alarm.impl
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349]alarm_control!(cntrl'Off)
Q [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> alarm_control!(') <<post>> to get:

[serial 1757]: Monitor::manage_alarm.impl
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1755]

The Same Proof Obligation:
Has applied <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> for  <<pre>> alarm_control!(') <<post>> to get:

[serial 1758]: Monitor::manage_alarm.impl
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1755]

[serial 1758]: Monitor::manage_alarm.impl
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1755]
solving assignment on line 351
replacing "alarm_previous_period'" with "cntrl'Off"
makes:  << ( cntrl'Off ) = alarm_control >>

This Proof Obligation:

[serial 1756]: Monitor::manage_alarm.impl
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351]alarm_previous_period' := cntrl'Off
Q [352] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1028]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1759]: Monitor::manage_alarm.impl
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351]->
Q [352] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1756]
. . . done applying atomic actions [8.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1753]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]

[serial 1754]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1028]

[serial 1757]: Monitor::manage_alarm.impl
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1755]

[serial 1758]: Monitor::manage_alarm.impl
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1755]

[serial 1759]: Monitor::manage_alarm.impl
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351]->
Q [352] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1756]
Done reducing atomic actions
step:  125
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1753]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1760]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1()
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

This proof obligation:

[serial 1758]: Monitor::manage_alarm.impl
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1755]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1761]: Monitor::manage_alarm.impl
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and true
  and ( alarm_control = cntrl'Off ) >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.2 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1754]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1028]

[serial 1757]: Monitor::manage_alarm.impl
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1755]

[serial 1759]: Monitor::manage_alarm.impl
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351]->
Q [352] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1756]

[serial 1760]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1()
  and true >>
What for:   add user-defined axioms to postcondition

[serial 1761]: Monitor::manage_alarm.impl
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and true
  and ( alarm_control = cntrl'Off ) >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  126
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1760]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1()
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1762]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1() >>
What for:  Law of And-Simplification:  P and true is P [serial 1760]

This Proof Obligation:

[serial 1761]: Monitor::manage_alarm.impl
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and true
  and ( alarm_control = cntrl'Off ) >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1763]: Monitor::manage_alarm.impl
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and ( alarm_control = cntrl'Off ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1761]

This Proof Obligation:

[serial 1762]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1() >>
What for:  Law of And-Simplification:  P and true is P [serial 1760]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1764]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) )
  and INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1762]

This Proof Obligation:

[serial 1763]: Monitor::manage_alarm.impl
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and ( alarm_control = cntrl'Off ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1761]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1765]: Monitor::manage_alarm.impl
P [349] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and ( alarm_control = cntrl'Off ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1763]
. . . done Applying Laws [8.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1754]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1028]

[serial 1757]: Monitor::manage_alarm.impl
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1755]

[serial 1759]: Monitor::manage_alarm.impl
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351]->
Q [352] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1756]

[serial 1764]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) )
  and INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1762]

[serial 1765]: Monitor::manage_alarm.impl
P [349] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and ( alarm_control = cntrl'Off ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1763]
Done applying laws
step:  127
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1754]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1028]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1767]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1754]

This Proof Obligation:

[serial 1757]: Monitor::manage_alarm.impl
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1755]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1769]: Monitor::manage_alarm.impl
P [348] << AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1757]

This Proof Obligation:

[serial 1759]: Monitor::manage_alarm.impl
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351]->
Q [352] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1756]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1771]: Monitor::manage_alarm.impl
P [350] << cntrl'Off = alarm_control
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [351]->
Q [352] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1759]

This Proof Obligation:

[serial 1764]: Monitor::manage_alarm.impl
P [312] << ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) )
  and INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1762]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1773]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1() >>
What for:    normalization of [serial 1764]

This Proof Obligation:

[serial 1765]: Monitor::manage_alarm.impl
P [349] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off )^0 >>
S [349]->
Q [350] << REQMA4()
  and not REQMA1()
  and ( alarm_control = cntrl'Off ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1763]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1775]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control
  and REQMA4()
  and not REQMA1() >>
What for:    normalization of [serial 1765]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1767]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1754]

[serial 1769]: Monitor::manage_alarm.impl
P [348] << AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1757]

[serial 1771]: Monitor::manage_alarm.impl
P [350] << cntrl'Off = alarm_control
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [351]->
Q [352] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1759]

[serial 1773]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1() >>
What for:    normalization of [serial 1764]

[serial 1775]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control
  and REQMA4()
  and not REQMA1() >>
What for:    normalization of [serial 1765]
Done Normalizing
step:  128
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 REQMA4()


This Proof Obligation:

[serial 1769]: Monitor::manage_alarm.impl
P [348] << AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1757]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1771]: Monitor::manage_alarm.impl
P [350] << cntrl'Off = alarm_control
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [351]->
Q [352] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1759]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1767]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1754]

[serial 1773]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1() >>
What for:    normalization of [serial 1764]

[serial 1775]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control
  and REQMA4()
  and not REQMA1() >>
What for:    normalization of [serial 1765]
Done trying to apply axioms
step:  129
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1773]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << REQMA4()
  and not REQMA1() >>
What for:    normalization of [serial 1764]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1781]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << REQMA4() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]

[serial 1782]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not REQMA1() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]

This Proof Obligation:

[serial 1775]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control
  and REQMA4()
  and not REQMA1() >>
What for:    normalization of [serial 1765]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1783]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]

[serial 1784]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << REQMA4() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]

[serial 1785]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << not REQMA1() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
. . . done splitting postcondition  [8.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1767]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1754]

[serial 1781]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << REQMA4() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]

[serial 1782]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not REQMA1() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]

[serial 1783]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]

[serial 1784]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << REQMA4() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]

[serial 1785]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << not REQMA1() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Done splitting postcondition
step:  130
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1784]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << REQMA4() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1785]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << not REQMA1() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1767]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1754]

[serial 1781]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << REQMA4() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]

[serial 1782]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not REQMA1() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]

[serial 1783]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Done trying to apply axioms
step:  131
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1767]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1754]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1786]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1767]

This Proof Obligation:

[serial 1781]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << REQMA4() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1787]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1781]

This Proof Obligation:

[serial 1782]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not REQMA1() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1788]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1782]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1783]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]

[serial 1786]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1767]

[serial 1787]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1781]

[serial 1788]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1782]
Done substituting Assertion labels in postconditions.
step:  132
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1783]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1789]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( ( cntrl'Off )^0 = ( alarm_control )^0 )
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1783]

This Proof Obligation:

[serial 1786]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1767]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1790]: Monitor::manage_alarm.impl
P [352] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1786]
. . . done spltting timed atoms  [8.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.2 seconds ]
After "dist^" remaining 
Obligations:

[serial 1787]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1781]

[serial 1788]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1782]

[serial 1789]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( ( cntrl'Off )^0 = ( alarm_control )^0 )
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1783]

[serial 1790]: Monitor::manage_alarm.impl
P [352] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1786]
Done distributing ^ and @.
step:  133
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1787]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1781]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1792]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << MONITOR_MODE(x : mmode'Normal)
  and CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:    normalization of [serial 1787]

This Proof Obligation:

[serial 1788]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( MONITOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1782]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1794]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1788]

This Proof Obligation:

[serial 1789]: Monitor::manage_alarm.impl
P [349] << AXIOM_AR()
  and REQMA4()
  and ( ( cntrl'Off )^0 = ( alarm_control )^0 )
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1783]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1796]: Monitor::manage_alarm.impl
P [349] << cntrl'Off^0 = alarm_control^0
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1789]

This Proof Obligation:

[serial 1790]: Monitor::manage_alarm.impl
P [352] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1786]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1798]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1790]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1792]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << MONITOR_MODE(x : mmode'Normal)
  and CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:    normalization of [serial 1787]

[serial 1794]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1788]

[serial 1796]: Monitor::manage_alarm.impl
P [349] << cntrl'Off^0 = alarm_control^0
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1789]

[serial 1798]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1790]
Done Normalizing
step:  134
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1796]: Monitor::manage_alarm.impl
P [349] << cntrl'Off^0 = alarm_control^0
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1789]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1803]: Monitor::manage_alarm.impl
P [349] << cntrl'Off = alarm_control
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1796]

This Proof Obligation:

[serial 1798]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1790]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1804]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1798]
. . . done replacing P@now and P^0 with P  [8.2 seconds ]
After assuming present remaining 
Obligations:

[serial 1792]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << MONITOR_MODE(x : mmode'Normal)
  and CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:    normalization of [serial 1787]

[serial 1794]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1788]

[serial 1803]: Monitor::manage_alarm.impl
P [349] << cntrl'Off = alarm_control
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1796]

[serial 1804]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1798]
Done assuming present.
step:  135
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1803]: Monitor::manage_alarm.impl
P [349] << cntrl'Off = alarm_control
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349]->
Q [350] << cntrl'Off = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1796]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1804]: Monitor::manage_alarm.impl
P [352] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1798]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1792]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << MONITOR_MODE(x : mmode'Normal)
  and CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:    normalization of [serial 1787]

[serial 1794]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1788]
Done trying to apply axioms
step:  136
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1792]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << MONITOR_MODE(x : mmode'Normal)
  and CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:    normalization of [serial 1787]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1805]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [62] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]

[serial 1806]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]
. . . done splitting postcondition  [8.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1794]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1788]

[serial 1805]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [62] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]

[serial 1806]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]
Done splitting postcondition
step:  137
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1794]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not MONITOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 1788]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1807]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1794]

This Proof Obligation:

[serial 1805]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [62] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1808]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [62] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1805]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1806]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]

[serial 1807]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1794]

[serial 1808]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [62] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1805]
Done substituting Assertion labels in postconditions.
step:  138
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1807]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1794]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1811]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:    normalization of [serial 1807]

This Proof Obligation:

[serial 1808]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [62] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1805]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1813]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [62] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1808]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1806]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]

[serial 1811]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:    normalization of [serial 1807]

[serial 1813]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [62] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1808]
Done Normalizing
step:  139
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1813]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [62] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1808]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1806]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]

[serial 1811]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:    normalization of [serial 1807]
Done trying to apply axioms
step:  140
****replace-port-value****
Replacing port names with BLESS::Value properties
Replacing port names with BLESS::Value properties.

This Proof Obligation:

[serial 1806]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]
Reason solved:  Replacing port names with BLESS::Value properties
Has applied Replacing port names with BLESS::Value properties  to get:

[serial 1816]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:  Replacing port names with BLESS::Value properties  [serial 1806]

This Proof Obligation:

[serial 1811]: Monitor::manage_alarm.impl
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:    normalization of [serial 1807]
Reason solved:  Replacing port names with BLESS::Value properties
Has applied Replacing port names with BLESS::Value properties  to get:

[serial 1817]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:  Replacing port names with BLESS::Value properties  [serial 1811]
done replacing port names with Assertions [8.2 seconds ]
After "Replacing port names with BLESS::Value properties" remaining 
Obligations:

[serial 1816]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:  Replacing port names with BLESS::Value properties  [serial 1806]

[serial 1817]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:  Replacing port names with BLESS::Value properties  [serial 1811]
Done replacing port names with  BLESS::Value properties.
step:  141
****range-exp****
Replacing Ranges with Boolean Expressions
replacing ranges with boolean expressions . . .

This Proof Obligation:

[serial 1816]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
What for:  Replacing port names with BLESS::Value properties  [serial 1806]
Reason solved:  Replace expression with range:   a<=x and x<=b  iff  x in a..b
Has applied Replace expression with range:   a<=x and x<=b  iff  x in a..b  to get:

[serial 1818]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << ( ( ( LOWER_ALARM_TEMP.t + 0.5 F ) ) <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= ( ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1816]
. . . done replacing ranges with boolean expressions  [8.2 seconds ]
After changing ranges to boolean expressions: 
Obligations:

[serial 1817]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:  Replacing port names with BLESS::Value properties  [serial 1811]

[serial 1818]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << ( ( ( LOWER_ALARM_TEMP.t + 0.5 F ) ) <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= ( ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1816]
Done changing ranges to boolean expressions
step:  142
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1817]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:  Replacing port names with BLESS::Value properties  [serial 1811]
Reason solved:  Reflexivity of Addition: a+b=b+a
Has been normalized to get:

[serial 1820]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:    normalization of [serial 1817]

This Proof Obligation:

[serial 1818]: Monitor::manage_alarm.impl
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << ( ( ( LOWER_ALARM_TEMP.t + 0.5 F ) ) <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= ( ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1816]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1822]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F >>
What for:    normalization of [serial 1818]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1820]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:    normalization of [serial 1817]

[serial 1822]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F >>
What for:    normalization of [serial 1818]
Done Normalizing
step:  143
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1822]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [63] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F >>
What for:    normalization of [serial 1818]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1820]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:    normalization of [serial 1817]
Done trying to apply axioms
step:  144
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1820]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not INI() >>
What for:    normalization of [serial 1817]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1825]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1820]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1825]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1820]
Done substituting Assertion labels in postconditions.
step:  145
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1825]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312]->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1820]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1826]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1825]
. . . done substituting assertions' for Labels [8.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1826]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1825]
Done substituting Assertion labels in preconditions
step:  146
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1826]: Monitor::manage_alarm.impl
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312]->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1825]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1828]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1826]
. . . done Normalizing Unsolved Proof Obligations [8.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1828]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1826]
Done Normalizing
step:  147
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1828]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 1826]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1830]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F ) )
  and ( not ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1828]
. . . Substituting <= with not < [8.2 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1830]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F ) )
  and ( not ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1828]
Done replacing a<=b with (not b<a)
step:  148
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1830]: Monitor::manage_alarm.impl
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F ) )
  and ( not ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312]->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1828]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1029]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON() >>
What for:   <<M(check_temp) and x>> -> <<M(check_hyst)>> for maHys: check_temp-[x]->check_hyst{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  149
#[serial 1029]  <<M(check_temp) and x>> -> <<M(check_hyst)>> for maHys: check_temp-[x]->check_hyst{};
step:  150
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1029]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON() >>
What for:   <<M(check_temp) and x>> -> <<M(check_hyst)>> for maHys: check_temp-[x]->check_hyst{};
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1831]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << EDGE_TEMP() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]

[serial 1832]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]

[serial 1833]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]

[serial 1834]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << INVMA() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]

[serial 1835]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << AXIOM_OFFON() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
. . . done splitting postcondition  [8.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1831]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << EDGE_TEMP() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]

[serial 1832]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]

[serial 1833]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]

[serial 1834]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << INVMA() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]

[serial 1835]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << AXIOM_OFFON() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Done splitting postcondition
step:  151
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1832]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << MONITOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1833]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1834]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << INVMA() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1835]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << AXIOM_OFFON() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1831]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << EDGE_TEMP() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Done trying to apply axioms
step:  152
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1831]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << EDGE_TEMP() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1836]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1831]
. . . done substituting assertions' for Labels [8.3 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1836]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1831]
Done substituting Assertion labels in postconditions.
step:  153
****replace-port-value****
Replacing port names with BLESS::Value properties
Replacing port names with BLESS::Value properties.

This Proof Obligation:

[serial 1836]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354]->
Q [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1831]
Reason solved:  Replacing port names with BLESS::Value properties
Has applied Replacing port names with BLESS::Value properties  to get:

[serial 1837]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( CURRENT_TEMP.t >= LOWER_ALARM_TEMP.t )
  and ( CURRENT_TEMP.t < ( LOWER_ALARM_TEMP.t + 0.5 F ) ) )
   or ( ( CURRENT_TEMP.t > ( UPPER_ALARM_TEMP.t - 0.5 F ) )
  and ( CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
S [354]->
Q [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Replacing port names with BLESS::Value properties  [serial 1836]
done replacing port names with Assertions [8.3 seconds ]
After "Replacing port names with BLESS::Value properties" remaining 
Obligations:

[serial 1837]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( CURRENT_TEMP.t >= LOWER_ALARM_TEMP.t )
  and ( CURRENT_TEMP.t < ( LOWER_ALARM_TEMP.t + 0.5 F ) ) )
   or ( ( CURRENT_TEMP.t > ( UPPER_ALARM_TEMP.t - 0.5 F ) )
  and ( CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
S [354]->
Q [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Replacing port names with BLESS::Value properties  [serial 1836]
Done replacing port names with  BLESS::Value properties.
step:  154
****range-exp****
Replacing Ranges with Boolean Expressions
replacing ranges with boolean expressions . . .

This Proof Obligation:

[serial 1837]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( CURRENT_TEMP.t >= LOWER_ALARM_TEMP.t )
  and ( CURRENT_TEMP.t < ( LOWER_ALARM_TEMP.t + 0.5 F ) ) )
   or ( ( CURRENT_TEMP.t > ( UPPER_ALARM_TEMP.t - 0.5 F ) )
  and ( CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
S [354]->
Q [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Replacing port names with BLESS::Value properties  [serial 1836]
Reason solved:  Replace expression with range:   a<=x and x<=b  iff  x in a..b
Has applied Replace expression with range:   a<=x and x<=b  iff  x in a..b  to get:

[serial 1838]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( CURRENT_TEMP.t >= LOWER_ALARM_TEMP.t )
  and ( CURRENT_TEMP.t < ( LOWER_ALARM_TEMP.t + 0.5 F ) ) )
   or ( ( CURRENT_TEMP.t > ( UPPER_ALARM_TEMP.t - 0.5 F ) )
  and ( CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
S [354]->
Q [313] << ( ( ( LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t < ( ( LOWER_ALARM_TEMP.t + 0.5 F ) ) ) )
   or ( ( ( ( UPPER_ALARM_TEMP.t - 0.5 F ) ) < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1837]
. . . done replacing ranges with boolean expressions  [8.3 seconds ]
After changing ranges to boolean expressions: 
Obligations:

[serial 1838]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( CURRENT_TEMP.t >= LOWER_ALARM_TEMP.t )
  and ( CURRENT_TEMP.t < ( LOWER_ALARM_TEMP.t + 0.5 F ) ) )
   or ( ( CURRENT_TEMP.t > ( UPPER_ALARM_TEMP.t - 0.5 F ) )
  and ( CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
S [354]->
Q [313] << ( ( ( LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t < ( ( LOWER_ALARM_TEMP.t + 0.5 F ) ) ) )
   or ( ( ( ( UPPER_ALARM_TEMP.t - 0.5 F ) ) < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1837]
Done changing ranges to boolean expressions
step:  155
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1838]: Monitor::manage_alarm.impl
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( CURRENT_TEMP.t >= LOWER_ALARM_TEMP.t )
  and ( CURRENT_TEMP.t < ( LOWER_ALARM_TEMP.t + 0.5 F ) ) )
   or ( ( CURRENT_TEMP.t > ( UPPER_ALARM_TEMP.t - 0.5 F ) )
  and ( CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
S [354]->
Q [313] << ( ( ( LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t < ( ( LOWER_ALARM_TEMP.t + 0.5 F ) ) ) )
   or ( ( ( ( UPPER_ALARM_TEMP.t - 0.5 F ) ) < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1837]
Reasons solved:  
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1840]: Monitor::manage_alarm.impl
P [312] << ( ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t )
   or ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F
  and LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t ) )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [354]->
Q [313] << ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t )
   or ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F
  and LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t ) >>
What for:    normalization of [serial 1838]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1840]: Monitor::manage_alarm.impl
P [312] << ( ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t )
   or ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F
  and LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t ) )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [354]->
Q [313] << ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t )
   or ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F
  and LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t ) >>
What for:    normalization of [serial 1838]
Done Normalizing
step:  156
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1840]: Monitor::manage_alarm.impl
P [312] << ( ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t )
   or ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F
  and LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t ) )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [354]->
Q [313] << ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t )
   or ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F
  and LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t ) >>
What for:    normalization of [serial 1838]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1030]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'O_n ) >>
S [361]  << REQMA3()
    and AXIOM_AC()
    and ( alarm_previous_period = cntrl'O_n )
    and INVMA() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for maHysOn: check_hyst-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  157
#[serial 1030]  <<M(check_hyst) and x>> A <<M(run)>> for maHysOn: check_hyst-[x]->run{A};
step:  158
****reduce****
This proof obligation:

[serial 1030]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'O_n ) >>
S [361]  << REQMA3()
    and AXIOM_AC()
    and ( alarm_previous_period = cntrl'O_n )
    and INVMA() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for maHysOn: check_hyst-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1842]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'O_n ) >>
S [313]->
Q [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1030]

[serial 1843]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1030]

[serial 1844]: Monitor::manage_alarm.impl
P [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
S [363]alarm_control!(cntrl'O_n)
Q [364] << alarm_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1030]

[serial 1845]: Monitor::manage_alarm.impl
P [364] << alarm_control = cntrl'O_n >>
S [365]alarm_previous_period' := cntrl'O_n
Q [366] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1030]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1842]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'O_n ) >>
S [313]->
Q [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1030]

[serial 1843]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1030]

[serial 1844]: Monitor::manage_alarm.impl
P [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
S [363]alarm_control!(cntrl'O_n)
Q [364] << alarm_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1030]

[serial 1845]: Monitor::manage_alarm.impl
P [364] << alarm_control = cntrl'O_n >>
S [365]alarm_previous_period' := cntrl'O_n
Q [366] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1030]
done reducing composite actions
step:  159
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<TEMP_OUT_OF_RANGE: x ~ cntrl 
  +=> O_n -> REQMA2()
     or REQMA5()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMA1()
     or REQMA4()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'O_n" is:  
^{or 
 ^{INVOKE[REQMA2] REQMA2} 
 ^{INVOKE[REQMA5] REQMA5} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMA3] REQMA3} 
   ^{( 
    ^{= 
     ^{^ ALARM_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl O_n}} )}} )}}

This Proof Obligation:

[serial 1844]: Monitor::manage_alarm.impl
P [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
S [363]alarm_control!(cntrl'O_n)
Q [364] << alarm_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1030]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> alarm_control!(') <<post>> to get:

[serial 1846]: Monitor::manage_alarm.impl
P [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
S [363]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1844]

The Same Proof Obligation:
Has applied <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> for  <<pre>> alarm_control!(') <<post>> to get:

[serial 1847]: Monitor::manage_alarm.impl
P [363] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [363]->
Q [364] << alarm_control = cntrl'O_n >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1844]

[serial 1847]: Monitor::manage_alarm.impl
P [363] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [363]->
Q [364] << alarm_control = cntrl'O_n >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1844]
solving assignment on line 365
replacing "alarm_previous_period'" with "cntrl'O_n"
makes:  << ( cntrl'O_n ) = alarm_control >>

This Proof Obligation:

[serial 1845]: Monitor::manage_alarm.impl
P [364] << alarm_control = cntrl'O_n >>
S [365]alarm_previous_period' := cntrl'O_n
Q [366] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1030]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1848]: Monitor::manage_alarm.impl
P [364] << alarm_control = cntrl'O_n >>
S [365]->
Q [366] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1845]
. . . done applying atomic actions [8.3 seconds ]
After "atomic" remaining 
Obligations:

[serial 1842]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'O_n ) >>
S [313]->
Q [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1030]

[serial 1843]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1030]

[serial 1846]: Monitor::manage_alarm.impl
P [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
S [363]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1844]

[serial 1847]: Monitor::manage_alarm.impl
P [363] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [363]->
Q [364] << alarm_control = cntrl'O_n >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1844]

[serial 1848]: Monitor::manage_alarm.impl
P [364] << alarm_control = cntrl'O_n >>
S [365]->
Q [366] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1845]
Done reducing atomic actions
step:  160
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1842]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'O_n ) >>
S [313]->
Q [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1030]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1850]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1842]

This Proof Obligation:

[serial 1843]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1030]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]

This Proof Obligation:

[serial 1846]: Monitor::manage_alarm.impl
P [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
S [363]->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1844]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]

This Proof Obligation:

[serial 1847]: Monitor::manage_alarm.impl
P [363] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [363]->
Q [364] << alarm_control = cntrl'O_n >>
What for:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1844]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1856]: Monitor::manage_alarm.impl
P [363] << ( cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [363]->
Q [364] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1847]

This Proof Obligation:

[serial 1848]: Monitor::manage_alarm.impl
P [364] << alarm_control = cntrl'O_n >>
S [365]->
Q [366] << ( cntrl'O_n ) = alarm_control >>
What for:  applied wp for assignment [serial 1845]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1858]: Monitor::manage_alarm.impl
P [364] << cntrl'O_n = alarm_control >>
S [365]->
Q [366] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1848]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1850]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1842]

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]

[serial 1856]: Monitor::manage_alarm.impl
P [363] << ( cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [363]->
Q [364] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1847]

[serial 1858]: Monitor::manage_alarm.impl
P [364] << cntrl'O_n = alarm_control >>
S [365]->
Q [366] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1848]
Done Normalizing
step:  161
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1858]: Monitor::manage_alarm.impl
P [364] << cntrl'O_n = alarm_control >>
S [365]->
Q [366] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1848]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1850]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1842]

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]

[serial 1856]: Monitor::manage_alarm.impl
P [363] << ( cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [363]->
Q [364] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1847]
Done trying to apply axioms
step:  162
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1856]: Monitor::manage_alarm.impl
P [363] << ( cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [363]->
Q [364] << cntrl'O_n = alarm_control >>
What for:    normalization of [serial 1847]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1864]: Monitor::manage_alarm.impl
P [363] << ( cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and cntrl'O_n = alarm_control >>
S [363]->
Q [364] << cntrl'O_n = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1856]
. . . done replacing P@now and P^0 with P  [8.3 seconds ]
After assuming present remaining 
Obligations:

[serial 1850]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1842]

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]

[serial 1864]: Monitor::manage_alarm.impl
P [363] << ( cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and cntrl'O_n = alarm_control >>
S [363]->
Q [364] << cntrl'O_n = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1856]
Done assuming present.
step:  163
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1864]: Monitor::manage_alarm.impl
P [363] << ( cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and cntrl'O_n = alarm_control >>
S [363]->
Q [364] << cntrl'O_n = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1856]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1850]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1842]

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]
Done trying to apply axioms
step:  164
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1850]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1842]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1865]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [362] << cntrl'O_n = alarm_previous_period >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]

[serial 1866]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << AXIOM_AC() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]

[serial 1867]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [362] << INVMA() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]

[serial 1868]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
. . . done splitting postcondition  [8.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]

[serial 1865]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [362] << cntrl'O_n = alarm_previous_period >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]

[serial 1866]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << AXIOM_AC() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]

[serial 1867]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [362] << INVMA() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]

[serial 1868]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Done splitting postcondition
step:  165
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1865]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [362] << cntrl'O_n = alarm_previous_period >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1867]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [362] << INVMA() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]

[serial 1866]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << AXIOM_AC() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]

[serial 1868]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Done trying to apply axioms
step:  166
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1866]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << AXIOM_AC() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1869]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.3 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]

[serial 1868]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]

[serial 1869]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  167
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1869]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << true >>
What for:   add user-defined axioms to postcondition
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]

[serial 1868]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Done trying to apply axioms
step:  168
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  169
#Monitor::manage_alarm.impl
step:  170
#[serial 1498]   normalization of [serial 148
step:  171
****make-an****
Making obligation 37
Obligations:

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]
Done making obligation 37
step:  172
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1852]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1843]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1870]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1852]
. . . done substituting assertions' for Labels [8.3 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1870]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1852]
Done substituting Assertion labels in postconditions.
step:  173
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1870]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1852]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1871]: Monitor::manage_alarm.impl
P [366] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1870]
. . . done spltting timed atoms  [8.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.3 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1871]: Monitor::manage_alarm.impl
P [366] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1870]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1873]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1871]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1873]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1871]
Done completely distributing ^ and @, round 0.
Distributing carets . .
. . . done spltting timed atoms  [8.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.3 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
step:  174
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1873]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1871]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1876]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1873]
. . . done replacing P@now and P^0 with P  [8.3 seconds ]
After assuming present remaining 
Obligations:

[serial 1876]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1873]
Done assuming present.
step:  175
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1876]: Monitor::manage_alarm.impl
P [366] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1873]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  176
#[serial 1500]   normalization of [serial 1492]
step:  177
****and-over-or-post****
Distributing postconditions and-over-or . . .

This Proof Obligation:

[serial 1854]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1846]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied distributing postconditions and-over-or to get:

[serial 1877]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() )
  and ( REQMA3()
   or REQMA2()
   or REQMA5() ) >>
What for:  Distributing Postcondition Or-Over-And [serial 1854]
. . . done distributing postconditions and-over-or  [8.3 seconds ]
After distributing and-over-or in postconditions remaining 
Obligations:

[serial 1877]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() )
  and ( REQMA3()
   or REQMA2()
   or REQMA5() ) >>
What for:  Distributing Postcondition Or-Over-And [serial 1854]
Done distributing and-over-or in postconditions
step:  178
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1877]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() )
  and ( REQMA3()
   or REQMA2()
   or REQMA5() ) >>
What for:  Distributing Postcondition Or-Over-And [serial 1854]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1878]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877]

[serial 1879]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( REQMA3()
   or REQMA2()
   or REQMA5() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877]
. . . done splitting postcondition  [8.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1878]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877]

[serial 1879]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( REQMA3()
   or REQMA2()
   or REQMA5() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877]
Done splitting postcondition
step:  179
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1878]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1881]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1878]

This Proof Obligation:

[serial 1879]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << ( REQMA3()
   or REQMA2()
   or REQMA5() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1883]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << REQMA2()
   or REQMA3()
   or REQMA5() >>
What for:    normalization of [serial 1879]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1881]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1878]

[serial 1883]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << REQMA2()
   or REQMA3()
   or REQMA5() >>
What for:    normalization of [serial 1879]
Done Normalizing
step:  180
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 REQMA3()


This Proof Obligation:

[serial 1883]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << REQMA2()
   or REQMA3()
   or REQMA5() >>
What for:    normalization of [serial 1879]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1881]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1878]
Done trying to apply axioms
step:  181
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1881]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363]->
Q [36] << cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:    normalization of [serial 1878]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1886]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363]->
Q [36] << cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1881]
. . . done substituting assertions' for Labels [8.3 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1886]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363]->
Q [36] << cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1881]
Done substituting Assertion labels in preconditions
step:  182
****guided-sub-equals****
guided substitution of equals "cntrl'O_n" . . .
equality selected for substitution:  cntrl'O_n = alarm_previous_period

This Proof Obligation:

[serial 1886]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363]->
Q [36] << cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1881]
Reason solved:  Guided Substitution of Equals
Has substituted 
"cntrl'O_n" with its = "alarm_previous_period"
 to get:

[serial 1887]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363]->
Q [36] << alarm_previous_period = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:  Guided Substitution of Equals 
 replacing "cntrl'O_n" with its = "alarm_previous_period" in its postcondition [serial 1886]
. . . done guided substitution of equals  [8.3 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1887]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363]->
Q [36] << alarm_previous_period = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:  Guided Substitution of Equals 
 replacing "cntrl'O_n" with its = "alarm_previous_period" in its postcondition [serial 1886]
Done guided substituting an equals
step:  183
****guided-sub-equals****
guided substitution of equals "ALARM_CONTROL^-1" . . .
equality selected for substitution:  ALARM_CONTROL^-1 = alarm_control^-1

This Proof Obligation:

[serial 1887]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363]->
Q [36] << alarm_previous_period = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
What for:  Guided Substitution of Equals 
 replacing "cntrl'O_n" with its = "alarm_previous_period" in its postcondition [serial 1886]
Reason solved:  Guided Substitution of Equals
Has substituted 
"ALARM_CONTROL^-1" with its = "alarm_control^-1"
 to get:

[serial 1888]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363]->
Q [36] << alarm_previous_period = alarm_control^-1
   or REQMA2()
   or REQMA5() >>
What for:  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1887]
. . . done guided substitution of equals  [8.3 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1888]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363]->
Q [36] << alarm_previous_period = alarm_control^-1
   or REQMA2()
   or REQMA5() >>
What for:  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1887]
Done guided substituting an equals
step:  184
****axioms****
Applying Axioms . . .
AXIOM.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 alarm_previous_period = alarm_control^-1


This Proof Obligation:

[serial 1888]: Monitor::manage_alarm.impl
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363]->
Q [36] << alarm_previous_period = alarm_control^-1
   or REQMA2()
   or REQMA5() >>
What for:  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1887]
Reason solved:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
Has been solved by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1868]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  185
#[serial 1514] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1496]
step:  186
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1868]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [361] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1889]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 
0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [313]->
Q [361] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1868]
. . . done substituting assertions' for Labels [8.3 seconds ]
After "substitute" remaining 
Obligations:

[serial 1889]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 
0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [313]->
Q [361] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1868]
Done substituting Assertion labels.
step:  187
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1889]: Monitor::manage_alarm.impl
P [313] << cntrl'O_n = alarm_previous_period
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 
0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [313]->
Q [361] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1868]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1891]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [361] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) >>
What for:    normalization of [serial 1889]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1891]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [361] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) >>
What for:    normalization of [serial 1889]
Done Normalizing
step:  188
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1891]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [361] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) >>
What for:    normalization of [serial 1889]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1893]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [56] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891]

[serial 1894]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891]
. . . done splitting postcondition  [8.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1893]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [56] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891]

[serial 1894]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891]
Done splitting postcondition
step:  189
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1893]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [56] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1894]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891]
Done trying to apply axioms
step:  190
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1894]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1895]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1894]
. . . done substituting assertions' for Labels [8.3 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1895]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1894]
Done substituting Assertion labels in postconditions.
step:  191
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1895]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1894]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1897]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1895]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1897]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1895]
Done Normalizing
step:  192
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1897]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_OK()
  and RUN() >>
What for:    normalization of [serial 1895]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1899]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1897]
. . . done substituting assertions' for Labels [8.3 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1899]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1897]
Done substituting Assertion labels in postconditions.
step:  193
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1899]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1897]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1901]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1899]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1901]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1899]
Done Normalizing
step:  194
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1901]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1899]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1031]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'Off ) >>
S [370]  << REQMA3()
    and AXIOM_AC()
    and ( alarm_previous_period = cntrl'Off )
    and INVMA() >>
  alarm_control!(cntrl'Off)
  ;
  << alarm_control = cntrl'Off >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for maHysOff: check_hyst-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  195
#[serial 1031]  <<M(check_hyst) and x>> A <<M(run)>> for maHysOff: check_hyst-[x]->run{A};
step:  196
****reduce****
This proof obligation:

[serial 1031]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'Off ) >>
S [370]  << REQMA3()
    and AXIOM_AC()
    and ( alarm_previous_period = cntrl'Off )
    and INVMA() >>
  alarm_control!(cntrl'Off)
  ;
  << alarm_control = cntrl'Off >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for maHysOff: check_hyst-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1903]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'Off ) >>
S [313]->
Q [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1031]

[serial 1904]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1031]

[serial 1905]: Monitor::manage_alarm.impl
P [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
S [372]alarm_control!(cntrl'Off)
Q [373] << alarm_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1031]

[serial 1906]: Monitor::manage_alarm.impl
P [373] << alarm_control = cntrl'Off >>
S [374]alarm_previous_period' := cntrl'Off
Q [375] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1031]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1903]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'Off ) >>
S [313]->
Q [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1031]

[serial 1904]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1031]

[serial 1905]: Monitor::manage_alarm.impl
P [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
S [372]alarm_control!(cntrl'Off)
Q [373] << alarm_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1031]

[serial 1906]: Monitor::manage_alarm.impl
P [373] << alarm_control = cntrl'Off >>
S [374]alarm_previous_period' := cntrl'Off
Q [375] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1031]
done reducing composite actions
step:  197
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<TEMP_OUT_OF_RANGE: x ~ cntrl 
  +=> O_n -> REQMA2()
     or REQMA5()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMA1()
     or REQMA4()
     or ( REQMA3()
    and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'Off" is:  
^{or 
 ^{INVOKE[REQMA1] REQMA1} 
 ^{INVOKE[REQMA4] REQMA4} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMA3] REQMA3} 
   ^{( 
    ^{= 
     ^{^ ALARM_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl Off}} )}} )}}

This Proof Obligation:

[serial 1905]: Monitor::manage_alarm.impl
P [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
S [372]alarm_control!(cntrl'Off)
Q [373] << alarm_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1031]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> alarm_control!(') <<post>> to get:

[serial 1907]: Monitor::manage_alarm.impl
P [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
S [372]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1905]

The Same Proof Obligation:
Has applied <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> for  <<pre>> alarm_control!(') <<post>> to get:

[serial 1908]: Monitor::manage_alarm.impl
P [372] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() )
  and ( alarm_control = cntrl'Off )^0 >>
S [372]->
Q [373] << alarm_control = cntrl'Off >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1905]

[serial 1908]: Monitor::manage_alarm.impl
P [372] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() )
  and ( alarm_control = cntrl'Off )^0 >>
S [372]->
Q [373] << alarm_control = cntrl'Off >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1905]
solving assignment on line 374
replacing "alarm_previous_period'" with "cntrl'Off"
makes:  << ( cntrl'Off ) = alarm_control >>

This Proof Obligation:

[serial 1906]: Monitor::manage_alarm.impl
P [373] << alarm_control = cntrl'Off >>
S [374]alarm_previous_period' := cntrl'Off
Q [375] << alarm_previous_period' = alarm_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1031]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1909]: Monitor::manage_alarm.impl
P [373] << alarm_control = cntrl'Off >>
S [374]->
Q [375] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1906]
. . . done applying atomic actions [8.3 seconds ]
After "atomic" remaining 
Obligations:

[serial 1903]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'Off ) >>
S [313]->
Q [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1031]

[serial 1904]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1031]

[serial 1907]: Monitor::manage_alarm.impl
P [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
S [372]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1905]

[serial 1908]: Monitor::manage_alarm.impl
P [372] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() )
  and ( alarm_control = cntrl'Off )^0 >>
S [372]->
Q [373] << alarm_control = cntrl'Off >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1905]

[serial 1909]: Monitor::manage_alarm.impl
P [373] << alarm_control = cntrl'Off >>
S [374]->
Q [375] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1906]
Done reducing atomic actions
step:  198
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1903]: Monitor::manage_alarm.impl
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'Off ) >>
S [313]->
Q [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1031]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1911]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1903]

This Proof Obligation:

[serial 1904]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( INVMA() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1031]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1913]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1904]

This Proof Obligation:

[serial 1907]: Monitor::manage_alarm.impl
P [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
S [372]->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  alarm_control!(') [serial 1905]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1915]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1907]

This Proof Obligation:

[serial 1908]: Monitor::manage_alarm.impl
P [372] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() )
  and ( alarm_control = cntrl'Off )^0 >>
S [372]->
Q [373] << alarm_control = cntrl'Off >>
What for:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1905]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1917]: Monitor::manage_alarm.impl
P [372] << ( cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'Off = alarm_control )^0 >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1908]

This Proof Obligation:

[serial 1909]: Monitor::manage_alarm.impl
P [373] << alarm_control = cntrl'Off >>
S [374]->
Q [375] << ( cntrl'Off ) = alarm_control >>
What for:  applied wp for assignment [serial 1906]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1919]: Monitor::manage_alarm.impl
P [373] << cntrl'Off = alarm_control >>
S [374]->
Q [375] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1909]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1911]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1903]

[serial 1913]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1904]

[serial 1915]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1907]

[serial 1917]: Monitor::manage_alarm.impl
P [372] << ( cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'Off = alarm_control )^0 >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1908]

[serial 1919]: Monitor::manage_alarm.impl
P [373] << cntrl'Off = alarm_control >>
S [374]->
Q [375] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1909]
Done Normalizing
step:  199
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1919]: Monitor::manage_alarm.impl
P [373] << cntrl'Off = alarm_control >>
S [374]->
Q [375] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1909]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1911]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1903]

[serial 1913]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1904]

[serial 1915]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1907]

[serial 1917]: Monitor::manage_alarm.impl
P [372] << ( cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'Off = alarm_control )^0 >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1908]
Done trying to apply axioms
step:  200
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1917]: Monitor::manage_alarm.impl
P [372] << ( cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'Off = alarm_control )^0 >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:    normalization of [serial 1908]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1925]: Monitor::manage_alarm.impl
P [372] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3()
  and ( cntrl'Off = alarm_control )^0 >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 1917]
. . . done Applying Laws [8.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1911]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1903]

[serial 1913]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1904]

[serial 1915]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1907]

[serial 1925]: Monitor::manage_alarm.impl
P [372] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3()
  and ( cntrl'Off = alarm_control )^0 >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 1917]
Done applying laws
step:  201
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  202
****make-an****
Making obligation 41
Obligations:

[serial 1911]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1903]
Done making obligation 41
step:  203
#Monitor::manage_alarm.impl
step:  204
#[serial 1557]   normalization of [serial 1549] 
step:  205
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1911]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
What for:    normalization of [serial 1903]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1926]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and true
  and INVMA()
  and REQMA3() >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.3 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1926]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and true
  and INVMA()
  and REQMA3() >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  206
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1926]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and true
  and INVMA()
  and REQMA3() >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1927]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and INVMA()
  and REQMA3() >>
What for:  Law of And-Simplification:  P and true is P [serial 1926]
. . . done Applying Laws [8.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1927]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and INVMA()
  and REQMA3() >>
What for:  Law of And-Simplification:  P and true is P [serial 1926]
Done applying laws
step:  207
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1927]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << cntrl'Off = alarm_previous_period
  and INVMA()
  and REQMA3() >>
What for:  Law of And-Simplification:  P and true is P [serial 1926]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1928]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [371] << cntrl'Off = alarm_previous_period >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]

[serial 1929]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [371] << INVMA() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]

[serial 1930]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
. . . done splitting postcondition  [8.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1928]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [371] << cntrl'Off = alarm_previous_period >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]

[serial 1929]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [371] << INVMA() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]

[serial 1930]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Done splitting postcondition
step:  208
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1928]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [371] << cntrl'Off = alarm_previous_period >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1929]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [371] << INVMA() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1930]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Done trying to apply axioms
step:  209
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1930]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313]->
Q [370] << REQMA3() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1931]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 
0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [313]->
Q [370] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1930]
. . . done substituting assertions' for Labels [8.3 seconds ]
After "substitute" remaining 
Obligations:

[serial 1931]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 
0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [313]->
Q [370] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1930]
Done substituting Assertion labels.
step:  210
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1931]: Monitor::manage_alarm.impl
P [313] << cntrl'Off = alarm_previous_period
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 
0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [313]->
Q [370] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1930]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1933]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [370] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) >>
What for:    normalization of [serial 1931]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1933]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [370] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) >>
What for:    normalization of [serial 1931]
Done Normalizing
step:  211
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1933]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [370] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) >>
What for:    normalization of [serial 1931]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1935]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [56] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]

[serial 1936]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]
. . . done splitting postcondition  [8.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1935]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [56] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]

[serial 1936]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]
Done splitting postcondition
step:  212
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1935]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [56] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1938]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [56] << CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) >>
What for:    normalization of [serial 1935]
. . . done Normalizing Unsolved Proof Obligations [8.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1936]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]

[serial 1938]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [56] << CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) >>
What for:    normalization of [serial 1935]
Done Normalizing
step:  213
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1938]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [56] << CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) >>
What for:    normalization of [serial 1935]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1936]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]
Done trying to apply axioms
step:  214
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1936]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1941]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1936]
. . . done substituting assertions' for Labels [8.3 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1941]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1936]
Done substituting Assertion labels in postconditions.
step:  215
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1941]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( MONITOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1936]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1942]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1941]
. . . done substituting assertions' for Labels [8.3 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1942]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1941]
Done substituting Assertion labels in postconditions.
step:  216
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1942]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1941]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1944]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1942]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1944]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1942]
Done Normalizing
step:  217
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1944]: Monitor::manage_alarm.impl
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313]->
Q [55] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 1942]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1913]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1904]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  218
#[serial 1559]   normalization of [serial 1550]
step:  219
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1913]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << INVMA()^1 >>
What for:    normalization of [serial 1904]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1946]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1913]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1946]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1913]
Done substituting Assertion labels in postconditions.
step:  220
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1946]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period' = alarm_control >>
S [310]->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1913]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 1947]: Monitor::manage_alarm.impl
P [375] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1946]
. . . done spltting timed atoms  [8.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.4 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1947]: Monitor::manage_alarm.impl
P [375] << ( alarm_previous_period )^1 = alarm_control >>
S [310]->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1946]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1949]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1947]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1949]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1947]
Done completely distributing ^ and @, round 0.
Distributing carets . .
. . . done spltting timed atoms  [8.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.4 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
step:  221
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1949]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
What for:    normalization of [serial 1947]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1952]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1949]
. . . done replacing P@now and P^0 with P  [8.4 seconds ]
After assuming present remaining 
Obligations:

[serial 1952]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1949]
Done assuming present.
step:  222
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1952]: Monitor::manage_alarm.impl
P [375] << alarm_previous_period^1 = alarm_control >>
S [310]->
Q [302] << alarm_previous_period^1 = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1949]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1915]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1907]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  223
#[serial 1561]   normalization of [serial 1553]
step:  224
****and-over-or-post****
Distributing postconditions and-over-or . . .

This Proof Obligation:

[serial 1915]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1907]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied distributing postconditions and-over-or to get:

[serial 1953]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() )
  and ( REQMA3()
   or REQMA1()
   or REQMA4() ) >>
What for:  Distributing Postcondition Or-Over-And [serial 1915]
. . . done distributing postconditions and-over-or  [8.4 seconds ]
After distributing and-over-or in postconditions remaining 
Obligations:

[serial 1953]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() )
  and ( REQMA3()
   or REQMA1()
   or REQMA4() ) >>
What for:  Distributing Postcondition Or-Over-And [serial 1915]
Done distributing and-over-or in postconditions
step:  225
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1953]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() )
  and ( REQMA3()
   or REQMA1()
   or REQMA4() ) >>
What for:  Distributing Postcondition Or-Over-And [serial 1915]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1954]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953]

[serial 1955]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( REQMA3()
   or REQMA1()
   or REQMA4() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953]
. . . done splitting postcondition  [8.4 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1954]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953]

[serial 1955]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( REQMA3()
   or REQMA1()
   or REQMA4() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953]
Done splitting postcondition
step:  226
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1954]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1957]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1954]

This Proof Obligation:

[serial 1955]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << ( REQMA3()
   or REQMA1()
   or REQMA4() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1959]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << REQMA1()
   or REQMA3()
   or REQMA4() >>
What for:    normalization of [serial 1955]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1957]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1954]

[serial 1959]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << REQMA1()
   or REQMA3()
   or REQMA4() >>
What for:    normalization of [serial 1955]
Done Normalizing
step:  227
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 REQMA3()


This Proof Obligation:

[serial 1959]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << REQMA1()
   or REQMA3()
   or REQMA4() >>
What for:    normalization of [serial 1955]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 1957]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1954]
Done trying to apply axioms
step:  228
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1957]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1954]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1962]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1957]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1962]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1957]
Done substituting Assertion labels in preconditions
step:  229
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1962]: Monitor::manage_alarm.impl
P [370] << cntrl'Off = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1957]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1964]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1962]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1964]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1962]
Done Normalizing
step:  230
****guided-sub-equals****
guided substitution of equals "cntrl'Off" . . .
equality selected for substitution:  cntrl'Off = alarm_previous_period

This Proof Obligation:

[serial 1964]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1962]
Reason solved:  Guided Substitution of Equals
Has substituted 
"cntrl'Off" with its = "alarm_previous_period"
 to get:

[serial 1966]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << alarm_previous_period = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:  Guided Substitution of Equals 
 replacing "cntrl'Off" with its = "alarm_previous_period" in its postcondition [serial 1964]
. . . done guided substitution of equals  [8.4 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1966]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << alarm_previous_period = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:  Guided Substitution of Equals 
 replacing "cntrl'Off" with its = "alarm_previous_period" in its postcondition [serial 1964]
Done guided substituting an equals
step:  231
****guided-sub-equals****
guided substitution of equals "ALARM_CONTROL^-1" . . .
equality selected for substitution:  ALARM_CONTROL^-1 = alarm_control^-1

This Proof Obligation:

[serial 1966]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << alarm_previous_period = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
What for:  Guided Substitution of Equals 
 replacing "cntrl'Off" with its = "alarm_previous_period" in its postcondition [serial 1964]
Reason solved:  Guided Substitution of Equals
Has substituted 
"ALARM_CONTROL^-1" with its = "alarm_control^-1"
 to get:

[serial 1967]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << alarm_previous_period = alarm_control^-1
   or REQMA1()
   or REQMA4() >>
What for:  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1966]
. . . done guided substitution of equals  [8.4 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1967]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << alarm_previous_period = alarm_control^-1
   or REQMA1()
   or REQMA4() >>
What for:  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1966]
Done guided substituting an equals
step:  232
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1967]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << alarm_previous_period = alarm_control^-1
   or REQMA1()
   or REQMA4() >>
What for:  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1966]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1969]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << alarm_control^-1 = alarm_previous_period
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1967]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1969]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << alarm_control^-1 = alarm_previous_period
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1967]
Done Normalizing
step:  233
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 alarm_control^-1 = alarm_previous_period


This Proof Obligation:

[serial 1969]: Monitor::manage_alarm.impl
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372]->
Q [39] << alarm_control^-1 = alarm_previous_period
   or REQMA1()
   or REQMA4() >>
What for:    normalization of [serial 1967]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1925]: Monitor::manage_alarm.impl
P [372] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3()
  and ( cntrl'Off = alarm_control )^0 >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 1917]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  234
#[serial 1571] Associativity: (b.c).a = a.b.c [serial 1563]
step:  235
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1925]: Monitor::manage_alarm.impl
P [372] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3()
  and ( cntrl'Off = alarm_control )^0 >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 1917]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 1971]: Monitor::manage_alarm.impl
P [372] << cntrl'Off = alarm_control
  and cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1925]
. . . done replacing P@now and P^0 with P  [8.4 seconds ]
After assuming present remaining 
Obligations:

[serial 1971]: Monitor::manage_alarm.impl
P [372] << cntrl'Off = alarm_control
  and cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1925]
Done assuming present.
step:  236
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1971]: Monitor::manage_alarm.impl
P [372] << cntrl'Off = alarm_control
  and cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372]->
Q [373] << cntrl'Off = alarm_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 1925]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1033]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [204]->
Q [204] << true >>
What for:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
Main proof script resumed.
step:  6
# manage_heat_source_mhs.impl
step:  7
****subscript****
You chose proof subscript: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/subscripts/mhs.ps
step:  1
#  You chose proof script: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/subscripts/mhs.ps
step:  2
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  3
****sort-by-component****
sorting proof obligations for Regulate::manage_heat_source.impl
Regulate::manage_heat_source.impl  [serial 1047]  
Regulate::manage_heat_source.impl  [serial 1048]  
Regulate::manage_heat_source.impl  [serial 1049]  
Regulate::manage_heat_source.impl  [serial 1050]  
Regulate::manage_heat_source.impl  [serial 1051]  
Regulate::manage_heat_source.impl  [serial 1052]  
Regulate::manage_heat_source.impl  [serial 1053]  
Regulate::manage_heat_source.impl  [serial 1054]  
Regulate::manage_heat_source.impl  [serial 1055]  
Regulate::manage_heat_source.impl  [serial 1056]  
Regulate::manage_heat_source.impl  [serial 1057]  
Regulate::manage_heat_source.impl  [serial 1058]  
Regulate::manage_heat_source.impl  [serial 1059]  
Regulate::manage_heat_source.impl  [serial 1060]  
Regulate::manage_heat_source.impl  [serial 1061]  
Regulate::manage_regulator_mode.impl  [serial 1033]  
Regulate::manage_regulator_mode.impl  [serial 1034]  
Regulate::manage_regulator_mode.impl  [serial 1035]  
Regulate::manage_regulator_mode.impl  [serial 1036]  
Regulate::manage_regulator_mode.impl  [serial 1037]  
Regulate::manage_regulator_mode.impl  [serial 1038]  
Regulate::manage_regulator_mode.impl  [serial 1039]  
Regulate::manage_regulator_mode.impl  [serial 1040]  
Regulate::manage_regulator_mode.impl  [serial 1041]  
Regulate::manage_regulator_mode.impl  [serial 1042]  
Regulate::manage_regulator_mode.impl  [serial 1043]  
Regulate::manage_regulator_mode.impl  [serial 1044]  
Regulate::manage_regulator_mode.impl  [serial 1045]  
manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure  [serial 1062]  
manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode  [serial 1063]  
manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode  [serial 1064]  
manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure  [serial 1065]  
manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode  [serial 1066]  
manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode  [serial 1067]  
detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure  [serial 1068]  
air_temperature -> temperature_sensor.air  [serial 1069]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature  [serial 1070]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature  [serial 1071]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature  [serial 1072]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature  [serial 1073]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature  [serial 1074]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature  [serial 1075]  
thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status  [serial 1076]  
thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature  [serial 1077]  
thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control  [serial 1078]  
thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm  [serial 1079]  
thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status  [serial 1080]  
operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp  [serial 1081]  
operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature  [serial 1082]  
operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp  [serial 1083]  
operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature  [serial 1084]  
operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature  [serial 1085]  
operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature  [serial 1086]  
operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature  [serial 1087]  
operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature  [serial 1088]  
Monitor::monitor_temperature.impl.mcti  [serial 1089]  
Monitor::monitor_temperature.impl.mcta  [serial 1090]  
Monitor::monitor_temperature.impl.mctm  [serial 1091]  
Monitor::monitor_temperature.impl.muat  [serial 1092]  
Monitor::monitor_temperature.impl.mlat  [serial 1093]  
Monitor::monitor_temperature.impl.maul  [serial 1094]  
Monitor::monitor_temperature.impl.mall  [serial 1095]  
Monitor::monitor_temperature.impl.malrm  [serial 1096]  
Monitor::monitor_temperature.impl.mms  [serial 1097]  
Monitor::monitor_temperature.impl.intff  [serial 1098]  
Monitor::monitor_temperature.impl.mf  [serial 1099]  
Monitor::monitor_temperature.impl.mmmi  [serial 1100]  
Monitor::monitor_temperature.impl.mmma  [serial 1101]  
KSU_Isolette::isolette.single_sensor.a2ts  [serial 1102]  
KSU_Isolette::isolette.single_sensor.ct  [serial 1103]  
KSU_Isolette::isolette.single_sensor.hc  [serial 1104]  
KSU_Isolette::isolette.single_sensor.ldt  [serial 1105]  
KSU_Isolette::isolette.single_sensor.udt  [serial 1106]  
KSU_Isolette::isolette.single_sensor.lat  [serial 1107]  
KSU_Isolette::isolette.single_sensor.uat  [serial 1108]  
KSU_Isolette::isolette.single_sensor.rs  [serial 1109]  
KSU_Isolette::isolette.single_sensor.ms  [serial 1110]  
KSU_Isolette::isolette.single_sensor.dt  [serial 1111]  
KSU_Isolette::isolette.single_sensor.al  [serial 1112]  
KSU_Isolette::isolette.dual_sensor.a2cs  [serial 1113]  
KSU_Isolette::isolette.dual_sensor.a2ms  [serial 1114]  
KSU_Isolette::isolette.dual_sensor.cont  [serial 1115]  
KSU_Isolette::isolette.dual_sensor.ct  [serial 1116]  
KSU_Isolette::isolette.dual_sensor.hc  [serial 1117]  
KSU_Isolette::isolette.dual_sensor.ldt  [serial 1118]  
KSU_Isolette::isolette.dual_sensor.udt  [serial 1119]  
KSU_Isolette::isolette.dual_sensor.lat  [serial 1120]  
KSU_Isolette::isolette.dual_sensor.uat  [serial 1121]  
KSU_Isolette::isolette.dual_sensor.rs  [serial 1122]  
KSU_Isolette::isolette.dual_sensor.ms  [serial 1123]  
KSU_Isolette::isolette.dual_sensor.dt  [serial 1124]  
KSU_Isolette::isolette.dual_sensor.al  [serial 1125]  
KSU_Isolette::thermostat_single_sensor.impl.tctm  [serial 1126]  
KSU_Isolette::thermostat_single_sensor.impl.tctr  [serial 1127]  
KSU_Isolette::thermostat_single_sensor.impl.thc  [serial 1128]  
KSU_Isolette::thermostat_single_sensor.impl.tudt  [serial 1129]  
KSU_Isolette::thermostat_single_sensor.impl.tldt  [serial 1130]  
KSU_Isolette::thermostat_single_sensor.impl.tuat  [serial 1131]  
KSU_Isolette::thermostat_single_sensor.impl.tlat  [serial 1132]  
KSU_Isolette::thermostat_single_sensor.impl.trs  [serial 1133]  
KSU_Isolette::thermostat_single_sensor.impl.tdt  [serial 1134]  
KSU_Isolette::thermostat_single_sensor.impl.tms  [serial 1135]  
KSU_Isolette::thermostat_single_sensor.impl.ta  [serial 1136]  
KSU_Isolette::thermostat_single_sensor.impl.tf  [serial 1137]  
KSU_Isolette::thermostat_dual_sensor.impl.tctm  [serial 1138]  
KSU_Isolette::thermostat_dual_sensor.impl.tctr  [serial 1139]  
KSU_Isolette::thermostat_dual_sensor.impl.thc  [serial 1140]  
KSU_Isolette::thermostat_dual_sensor.impl.tudt  [serial 1141]  
KSU_Isolette::thermostat_dual_sensor.impl.tldt  [serial 1142]  
KSU_Isolette::thermostat_dual_sensor.impl.tuat  [serial 1143]  
KSU_Isolette::thermostat_dual_sensor.impl.tlat  [serial 1144]  
KSU_Isolette::thermostat_dual_sensor.impl.trs  [serial 1145]  
KSU_Isolette::thermostat_dual_sensor.impl.tdt  [serial 1146]  
KSU_Isolette::thermostat_dual_sensor.impl.tms  [serial 1147]  
KSU_Isolette::thermostat_dual_sensor.impl.ta  [serial 1148]  
KSU_Isolette::thermostat_dual_sensor.impl.tf  [serial 1149]  
Nursery::Room.Normal_Operation.tmp  [serial 1150]  
Regulate::regulate_temperature.impl.rudt  [serial 1151]  
Regulate::regulate_temperature.impl.rldt  [serial 1152]  
Regulate::regulate_temperature.impl.mudt  [serial 1153]  
Regulate::regulate_temperature.impl.mldt  [serial 1154]  
Regulate::regulate_temperature.impl.rrs  [serial 1155]  
Regulate::regulate_temperature.impl.rdt  [serial 1156]  
Regulate::regulate_temperature.impl.rcti  [serial 1157]  
Regulate::regulate_temperature.impl.rcth  [serial 1158]  
Regulate::regulate_temperature.impl.rhc  [serial 1159]  
Regulate::regulate_temperature.impl.rrmh  [serial 1160]  
Regulate::regulate_temperature.impl.rrmi  [serial 1161]  
Regulate::regulate_temperature.impl.rctm  [serial 1162]  
Regulate::regulate_temperature.impl.rif  [serial 1163]  
After sort-by-component[Regulate::manage_heat_source.impl], no change. 
step:  4
#Regulate::manage_heat_source.impl
step:  5
#[serial 1047] <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definitio
step:  6
****make-an****
Making obligation 46
Obligations:

[serial 1047]: Regulate::manage_heat_source.impl
P [341] << INVMHS() >>
S [336]->
Q [336] << heat_previous_period = heat_control^-1 >>
What for:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Done making obligation 46
step:  7
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1047]: Regulate::manage_heat_source.impl
P [341] << INVMHS() >>
S [336]->
Q [336] << heat_previous_period = heat_control^-1 >>
What for:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1972]: Regulate::manage_heat_source.impl
P [341] << ( heat_previous_period = heat_control^-1 ) >>
S [336]->
Q [336] << heat_previous_period = heat_control^-1 >>
What for:  Substituted assertions' predicates for labels  [serial 1047]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute" remaining 
Obligations:

[serial 1972]: Regulate::manage_heat_source.impl
P [341] << ( heat_previous_period = heat_control^-1 ) >>
S [336]->
Q [336] << heat_previous_period = heat_control^-1 >>
What for:  Substituted assertions' predicates for labels  [serial 1047]
Done substituting Assertion labels.
step:  8
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1972]: Regulate::manage_heat_source.impl
P [341] << ( heat_previous_period = heat_control^-1 ) >>
S [336]->
Q [336] << heat_previous_period = heat_control^-1 >>
What for:  Substituted assertions' predicates for labels  [serial 1047]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1974]: Regulate::manage_heat_source.impl
P [341] << heat_control^-1 = heat_previous_period >>
S [336]->
Q [336] << heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 1972]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1974]: Regulate::manage_heat_source.impl
P [341] << heat_control^-1 = heat_previous_period >>
S [336]->
Q [336] << heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 1972]
Done Normalizing
step:  9
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1974]: Regulate::manage_heat_source.impl
P [341] << heat_control^-1 = heat_previous_period >>
S [336]->
Q [336] << heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 1972]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1048]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT() >>
S [343]->
Q [343] << ( current_temperature.t <= lower_desired_temperature.t )
   or ( current_temperature.t >= upper_desired_temperature.t )
   or ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  10
#[serial 1048] Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>
step:  11
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1048]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT() >>
S [343]->
Q [343] << ( current_temperature.t <= lower_desired_temperature.t )
   or ( current_temperature.t >= upper_desired_temperature.t )
   or ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1977]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
   or current_temperature.t <= lower_desired_temperature.t
   or upper_desired_temperature.t <= current_temperature.t >>
What for:    normalization of [serial 1048]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1977]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
   or current_temperature.t <= lower_desired_temperature.t
   or upper_desired_temperature.t <= current_temperature.t >>
What for:    normalization of [serial 1048]
Done Normalizing
step:  12
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1977]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
   or current_temperature.t <= lower_desired_temperature.t
   or upper_desired_temperature.t <= current_temperature.t >>
What for:    normalization of [serial 1048]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1979]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1977]
. . . Substituting <= with not < [8.4 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1979]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1977]
Done replacing a<=b with (not b<a)
step:  13
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1979]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1977]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 1980]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) )
  and ( lower_desired_temperature.t < current_temperature.t
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1979]
. . . done putting into conjunctive normal form [8.4 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1980]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) )
  and ( lower_desired_temperature.t < current_temperature.t
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1979]
Done making conjunctive normal forms.
step:  14
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1980]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) )
  and ( lower_desired_temperature.t < current_temperature.t
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1979]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1981]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1980]

This Proof Obligation:

[serial 1981]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1980]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1982]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1981]
. . . done Applying Laws [8.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1982]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1981]
Done applying laws
step:  15
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1982]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1981]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1984]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << true >>
What for:    normalization of [serial 1982]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1984]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << true >>
What for:    normalization of [serial 1982]
Done Normalizing
step:  16
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1984]: Regulate::manage_heat_source.impl
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [343] << true >>
What for:    normalization of [serial 1982]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1049]: Regulate::manage_heat_source.impl
P [340] << heat_previous_period = cntrl'Off
  and ( INVMHS() )^1 >>
S [340]->
Q [340] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  17
#[serial 1049] Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>
step:  18
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1049]: Regulate::manage_heat_source.impl
P [340] << heat_previous_period = cntrl'Off
  and ( INVMHS() )^1 >>
S [340]->
Q [340] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1050]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT() >>
S [344]->
Q [344] << ( ( heat_previous_period = cntrl'O_n ) )
   or ( heat_previous_period = cntrl'Off ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  19
#[serial 1050] Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>
step:  20
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1050]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT() >>
S [344]->
Q [344] << ( ( heat_previous_period = cntrl'O_n ) )
   or ( heat_previous_period = cntrl'Off ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1986]: Regulate::manage_heat_source.impl
P [344] << ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = heat_control^-1 )
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off ) >>
S [344]->
Q [344] << ( ( heat_previous_period = cntrl'O_n ) )
   or ( heat_previous_period = cntrl'Off ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1050]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1986]: Regulate::manage_heat_source.impl
P [344] << ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = heat_control^-1 )
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off ) >>
S [344]->
Q [344] << ( ( heat_previous_period = cntrl'O_n ) )
   or ( heat_previous_period = cntrl'Off ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1050]
Done substituting Assertion labels in preconditions
step:  21
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1986]: Regulate::manage_heat_source.impl
P [344] << ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = heat_control^-1 )
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off ) >>
S [344]->
Q [344] << ( ( heat_previous_period = cntrl'O_n ) )
   or ( heat_previous_period = cntrl'Off ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1050]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1988]: Regulate::manage_heat_source.impl
P [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [344] << cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period >>
What for:    normalization of [serial 1986]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1988]: Regulate::manage_heat_source.impl
P [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [344] << cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period >>
What for:    normalization of [serial 1986]
Done Normalizing
step:  22
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1988]: Regulate::manage_heat_source.impl
P [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [344] << cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period >>
What for:    normalization of [serial 1986]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1051]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( not REGULATOR_OK()
  and RUN() )
   or ( INI() )
   or ( REGULATOR_OK()
  and RUN() ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  23
#[serial 1051] Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
step:  24
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1051]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( not REGULATOR_OK()
  and RUN() )
   or ( INI() )
   or ( REGULATOR_OK()
  and RUN() ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1991]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( REGULATOR_OK()
  and RUN() )
   or ( RUN()
  and not REGULATOR_OK() )
   or INI() >>
What for:    normalization of [serial 1051]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1991]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( REGULATOR_OK()
  and RUN() )
   or ( RUN()
  and not REGULATOR_OK() )
   or INI() >>
What for:    normalization of [serial 1051]
Done Normalizing
step:  25
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1991]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( REGULATOR_OK()
  and RUN() )
   or ( RUN()
  and not REGULATOR_OK() )
   or INI() >>
What for:    normalization of [serial 1051]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 1993]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( REGULATOR_OK()
   or RUN()
   or INI() )
  and ( RUN()
   or RUN()
   or INI() )
  and ( REGULATOR_OK()
   or not REGULATOR_OK()
   or INI() )
  and ( RUN()
   or not REGULATOR_OK()
   or INI() ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1991]
. . . done putting into conjunctive normal form [8.4 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1993]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( REGULATOR_OK()
   or RUN()
   or INI() )
  and ( RUN()
   or RUN()
   or INI() )
  and ( REGULATOR_OK()
   or not REGULATOR_OK()
   or INI() )
  and ( RUN()
   or not REGULATOR_OK()
   or INI() ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1991]
Done making conjunctive normal forms.
step:  26
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1993]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( REGULATOR_OK()
   or RUN()
   or INI() )
  and ( RUN()
   or RUN()
   or INI() )
  and ( REGULATOR_OK()
   or not REGULATOR_OK()
   or INI() )
  and ( RUN()
   or not REGULATOR_OK()
   or INI() ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1991]
Reasons solved:  
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1995]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or REGULATOR_OK()
   or not REGULATOR_OK() )
  and ( INI()
   or RUN()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:    normalization of [serial 1993]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1995]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or REGULATOR_OK()
   or not REGULATOR_OK() )
  and ( INI()
   or RUN()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:    normalization of [serial 1993]
Done Normalizing
step:  27
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1995]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or REGULATOR_OK()
   or not REGULATOR_OK() )
  and ( INI()
   or RUN()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:    normalization of [serial 1993]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1997]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( true )
  and ( INI()
   or RUN()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1995]

This Proof Obligation:

[serial 1997]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( true )
  and ( INI()
   or RUN()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1995]
Reason solved:  Law of Or-Simplification: P or P is P
Has applied law "Law of Or-Simplification: P or P is P " to get:

[serial 1998]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( true )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:  Law of Or-Simplification: P or P is P [serial 1997]
. . . done Applying Laws [8.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1998]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( true )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:  Law of Or-Simplification: P or P is P [serial 1997]
Done applying laws
step:  28
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1998]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( true )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:  Law of Or-Simplification: P or P is P [serial 1997]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2000]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() )
  and true >>
What for:    normalization of [serial 1998]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2000]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() )
  and true >>
What for:    normalization of [serial 1998]
Done Normalizing
step:  29
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2000]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() )
  and true >>
What for:    normalization of [serial 1998]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2002]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2000]
. . . done Applying Laws [8.4 seconds ]
After "laws" remaining 
Obligations:

[serial 2002]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2000]
Done applying laws
step:  30
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2002]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2000]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2003]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
  and ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
  and ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2002]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2003]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
  and ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
  and ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2002]
Done substituting Assertion labels in postconditions.
step:  31
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2003]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
  and ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
  and ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2002]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2005]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) ) >>
What for:    normalization of [serial 2003]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2005]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) ) >>
What for:    normalization of [serial 2003]
Done Normalizing
step:  32
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 2005]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) ) >>
What for:    normalization of [serial 2003]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2007]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2005]
. . . Substituting <= with not < [8.4 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 2007]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2005]
Done replacing a<=b with (not b<a)
step:  33
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2007]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2005]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 2008]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2007]

This Proof Obligation:

[serial 2008]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2007]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 2009]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2008]

This Proof Obligation:

[serial 2009]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2008]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 2010]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2009]
. . . done Applying Laws [8.4 seconds ]
After "laws" remaining 
Obligations:

[serial 2010]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2009]
Done applying laws
step:  34
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2010]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2009]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2012]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << true >>
What for:    normalization of [serial 2010]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2012]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << true >>
What for:    normalization of [serial 2010]
Done Normalizing
step:  35
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2012]: Regulate::manage_heat_source.impl
P [342] << INVMHS() >>
S [342]->
Q [342] << true >>
What for:    normalization of [serial 2010]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1052]: Regulate::manage_heat_source.impl
P [340] << heat_previous_period = cntrl'Off
  and ( INVMHS() )^1 >>
S [347]->
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(poweron)>> -> <<M(run)>> for mhsPo: poweron-[ ]->run{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  36
#[serial 1052]  <<M(poweron)>> -> <<M(run)>> for mhsPo: poweron-[ ]->run{};
step:  37
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1052]: Regulate::manage_heat_source.impl
P [340] << heat_previous_period = cntrl'Off
  and ( INVMHS() )^1 >>
S [347]->
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(poweron)>> -> <<M(run)>> for mhsPo: poweron-[ ]->run{};
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1053]: Regulate::manage_heat_source.impl
P [341] << INVMHS() >>
S [348]->
Q [342] << INVMHS() >>
What for:   <<M(run) and x>> -> <<M(check_mode)>> for mhsRun: run-[x]->check_mode{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  38
#[serial 1053]  <<M(run) and x>> -> <<M(check_mode)>> for mhsRun: run-[x]->check_mode{};
step:  39
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1053]: Regulate::manage_heat_source.impl
P [341] << INVMHS() >>
S [348]->
Q [342] << INVMHS() >>
What for:   <<M(run) and x>> -> <<M(check_mode)>> for mhsRun: run-[x]->check_mode{};
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1054]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [351]  << REQMHS5() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for mhsFailed: check_mode-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  40
#[serial 1054]  <<M(check_mode) and x>> A <<M(run)>> for mhsFailed: check_mode-[x]->run{A};
step:  41
****reduce****
This proof obligation:

[serial 1054]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [351]  << REQMHS5() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for mhsFailed: check_mode-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 2014]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [342]->
Q [351] << REQMHS5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1054]

[serial 2015]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1054]

[serial 2016]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]heat_control!(cntrl'Off)
Q [353] << heat_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1054]

[serial 2017]: Regulate::manage_heat_source.impl
P [353] << heat_control = cntrl'Off >>
S [354]heat_previous_period' := cntrl'Off
Q [355] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1054]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2014]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [342]->
Q [351] << REQMHS5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1054]

[serial 2015]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1054]

[serial 2016]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]heat_control!(cntrl'Off)
Q [353] << heat_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1054]

[serial 2017]: Regulate::manage_heat_source.impl
P [353] << heat_control = cntrl'Off >>
S [354]heat_previous_period' := cntrl'Off
Q [355] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1054]
done reducing composite actions
step:  42
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> HEAT_CONTROL(x : heat_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<HEAT_CONTROL: x ~ cntrl 
  +=> O_n -> REQMHS2()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMHS1()
     or REQMHS3()
     or REQMHS5()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'Off" is:  
^{or 
 ^{INVOKE[REQMHS1] REQMHS1} 
 ^{INVOKE[REQMHS3] REQMHS3} 
 ^{INVOKE[REQMHS5] REQMHS5} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMHS4] REQMHS4} 
   ^{( 
    ^{= 
     ^{^ HEAT_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl Off}} )}} )}}

This Proof Obligation:

[serial 2016]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]heat_control!(cntrl'Off)
Q [353] << heat_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1054]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> heat_control!(') <<post>> to get:

[serial 2018]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2016]

The Same Proof Obligation:
Has applied <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> for  <<pre>> heat_control!(') <<post>> to get:

[serial 2019]: Regulate::manage_heat_source.impl
P [352] << ( REQMHS5() )
  and ( heat_control = cntrl'Off )^0 >>
S [352]->
Q [353] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2016]

[serial 2019]: Regulate::manage_heat_source.impl
P [352] << ( REQMHS5() )
  and ( heat_control = cntrl'Off )^0 >>
S [352]->
Q [353] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2016]
solving assignment on line 354
replacing "heat_previous_period'" with "cntrl'Off"
makes:  << ( cntrl'Off ) = heat_control >>

This Proof Obligation:

[serial 2017]: Regulate::manage_heat_source.impl
P [353] << heat_control = cntrl'Off >>
S [354]heat_previous_period' := cntrl'Off
Q [355] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1054]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 2020]: Regulate::manage_heat_source.impl
P [353] << heat_control = cntrl'Off >>
S [354]->
Q [355] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2017]
. . . done applying atomic actions [8.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 2014]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [342]->
Q [351] << REQMHS5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1054]

[serial 2015]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1054]

[serial 2018]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2016]

[serial 2019]: Regulate::manage_heat_source.impl
P [352] << ( REQMHS5() )
  and ( heat_control = cntrl'Off )^0 >>
S [352]->
Q [353] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2016]

[serial 2020]: Regulate::manage_heat_source.impl
P [353] << heat_control = cntrl'Off >>
S [354]->
Q [355] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2017]
Done reducing atomic actions
step:  43
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2015]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1054]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2021]: Regulate::manage_heat_source.impl
P [355] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2015]

This Proof Obligation:

[serial 2019]: Regulate::manage_heat_source.impl
P [352] << ( REQMHS5() )
  and ( heat_control = cntrl'Off )^0 >>
S [352]->
Q [353] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2016]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2022]: Regulate::manage_heat_source.impl
P [352] << ( REQMHS5() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [352]->
Q [353] << heat_control = cntrl'Off >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2019]
. . . done spltting timed atoms  [8.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.4 seconds ]
After "dist^" remaining 
Obligations:

[serial 2014]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [342]->
Q [351] << REQMHS5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1054]

[serial 2018]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2016]

[serial 2020]: Regulate::manage_heat_source.impl
P [353] << heat_control = cntrl'Off >>
S [354]->
Q [355] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2017]

[serial 2021]: Regulate::manage_heat_source.impl
P [355] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2015]

[serial 2022]: Regulate::manage_heat_source.impl
P [352] << ( REQMHS5() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [352]->
Q [353] << heat_control = cntrl'Off >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2019]
Done distributing ^ and @.
step:  44
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2014]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [342]->
Q [351] << REQMHS5() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1054]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2024]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << REQMHS5() >>
What for:    normalization of [serial 2014]

This Proof Obligation:

[serial 2018]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2016]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2026]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2018]

This Proof Obligation:

[serial 2020]: Regulate::manage_heat_source.impl
P [353] << heat_control = cntrl'Off >>
S [354]->
Q [355] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2017]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2028]: Regulate::manage_heat_source.impl
P [353] << cntrl'Off = heat_control >>
S [354]->
Q [355] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2020]

This Proof Obligation:

[serial 2021]: Regulate::manage_heat_source.impl
P [355] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2015]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2030]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2021]

This Proof Obligation:

[serial 2022]: Regulate::manage_heat_source.impl
P [352] << ( REQMHS5() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [352]->
Q [353] << heat_control = cntrl'Off >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2019]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2032]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2022]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2024]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << REQMHS5() >>
What for:    normalization of [serial 2014]

[serial 2026]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2018]

[serial 2028]: Regulate::manage_heat_source.impl
P [353] << cntrl'Off = heat_control >>
S [354]->
Q [355] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2020]

[serial 2030]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2021]

[serial 2032]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2022]
Done Normalizing
step:  45
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2026]: Regulate::manage_heat_source.impl
P [351] << REQMHS5() >>
S [352]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2018]
Reason solved:  Or Introduction Schema (orcwl):  X->(X or Y)
Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)

This Proof Obligation:

[serial 2028]: Regulate::manage_heat_source.impl
P [353] << cntrl'Off = heat_control >>
S [354]->
Q [355] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2020]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 2024]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << REQMHS5() >>
What for:    normalization of [serial 2014]

[serial 2030]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2021]

[serial 2032]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2022]
Done trying to apply axioms
step:  46
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2024]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << REQMHS5() >>
What for:    normalization of [serial 2014]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2038]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << ( REGULATOR_MODE(x : mmode'Failed) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2024]

This Proof Obligation:

[serial 2030]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2021]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2039]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2030]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2032]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2022]

[serial 2038]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << ( REGULATOR_MODE(x : mmode'Failed) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2024]

[serial 2039]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2030]
Done substituting Assertion labels in postconditions.
step:  47
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2038]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << ( REGULATOR_MODE(x : mmode'Failed) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2024]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2042]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 2038]

This Proof Obligation:

[serial 2039]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2030]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 2044]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2039]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2032]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2022]

[serial 2042]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 2038]

[serial 2044]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2039]
Done Normalizing
step:  48
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2042]: Regulate::manage_heat_source.impl
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 2038]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2047]: Regulate::manage_heat_source.impl
P [342] << RUN()
  and not REGULATOR_OK()
  and INVMHS() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2042]
. . . done Applying Laws [8.4 seconds ]
After "laws" remaining 
Obligations:

[serial 2032]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2022]

[serial 2044]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2039]

[serial 2047]: Regulate::manage_heat_source.impl
P [342] << RUN()
  and not REGULATOR_OK()
  and INVMHS() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2042]
Done applying laws
step:  49
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2044]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2039]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2048]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2044]
. . . done spltting timed atoms  [8.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.4 seconds ]
After "dist^" remaining 
Obligations:

[serial 2032]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2022]

[serial 2047]: Regulate::manage_heat_source.impl
P [342] << RUN()
  and not REGULATOR_OK()
  and INVMHS() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2042]

[serial 2048]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2044]
Done distributing ^ and @.
step:  50
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2047]: Regulate::manage_heat_source.impl
P [342] << RUN()
  and not REGULATOR_OK()
  and INVMHS() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2042]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2051]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 2047]

This Proof Obligation:

[serial 2048]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2044]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2053]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2048]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2032]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2022]

[serial 2051]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 2047]

[serial 2053]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2048]
Done Normalizing
step:  51
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2032]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2022]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2056]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off = heat_control
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2032]

This Proof Obligation:

[serial 2053]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2048]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2057]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2053]
. . . done replacing P@now and P^0 with P  [8.4 seconds ]
After assuming present remaining 
Obligations:

[serial 2051]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 2047]

[serial 2056]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off = heat_control
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2032]

[serial 2057]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2053]
Done assuming present.
step:  52
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2056]: Regulate::manage_heat_source.impl
P [352] << cntrl'Off = heat_control
  and REQMHS5() >>
S [352]->
Q [353] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2032]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2057]: Regulate::manage_heat_source.impl
P [355] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2053]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 2051]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 2047]
Done trying to apply axioms
step:  53
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2051]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
What for:    normalization of [serial 2047]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2058]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << ( not REGULATOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2051]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2058]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << ( not REGULATOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2051]
Done substituting Assertion labels in postconditions.
step:  54
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2058]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << ( not REGULATOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2051]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2060]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2058]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2060]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2058]
Done Normalizing
step:  55
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2060]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342]->
Q [351] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2058]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1055]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [359]  << REQMHS1() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for mhsInit: check_mode-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  56
#[serial 1055]  <<M(check_mode) and x>> A <<M(run)>> for mhsInit: check_mode-[x]->run{A};
step:  57
****reduce****
This proof obligation:

[serial 1055]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [359]  << REQMHS1() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_mode) and x>> A <<M(run)>> for mhsInit: check_mode-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 2062]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [342]->
Q [359] << REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1055]

[serial 2063]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1055]

[serial 2064]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]heat_control!(cntrl'Off)
Q [361] << heat_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1055]

[serial 2065]: Regulate::manage_heat_source.impl
P [361] << heat_control = cntrl'Off >>
S [362]heat_previous_period' := cntrl'Off
Q [363] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1055]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2062]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [342]->
Q [359] << REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1055]

[serial 2063]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1055]

[serial 2064]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]heat_control!(cntrl'Off)
Q [361] << heat_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1055]

[serial 2065]: Regulate::manage_heat_source.impl
P [361] << heat_control = cntrl'Off >>
S [362]heat_previous_period' := cntrl'Off
Q [363] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1055]
done reducing composite actions
step:  58
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> HEAT_CONTROL(x : heat_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<HEAT_CONTROL: x ~ cntrl 
  +=> O_n -> REQMHS2()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMHS1()
     or REQMHS3()
     or REQMHS5()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'Off" is:  
^{or 
 ^{INVOKE[REQMHS1] REQMHS1} 
 ^{INVOKE[REQMHS3] REQMHS3} 
 ^{INVOKE[REQMHS5] REQMHS5} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMHS4] REQMHS4} 
   ^{( 
    ^{= 
     ^{^ HEAT_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl Off}} )}} )}}

This Proof Obligation:

[serial 2064]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]heat_control!(cntrl'Off)
Q [361] << heat_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1055]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> heat_control!(') <<post>> to get:

[serial 2066]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2064]

The Same Proof Obligation:
Has applied <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> for  <<pre>> heat_control!(') <<post>> to get:

[serial 2067]: Regulate::manage_heat_source.impl
P [360] << ( REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [360]->
Q [361] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2064]

[serial 2067]: Regulate::manage_heat_source.impl
P [360] << ( REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [360]->
Q [361] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2064]
solving assignment on line 362
replacing "heat_previous_period'" with "cntrl'Off"
makes:  << ( cntrl'Off ) = heat_control >>

This Proof Obligation:

[serial 2065]: Regulate::manage_heat_source.impl
P [361] << heat_control = cntrl'Off >>
S [362]heat_previous_period' := cntrl'Off
Q [363] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1055]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 2068]: Regulate::manage_heat_source.impl
P [361] << heat_control = cntrl'Off >>
S [362]->
Q [363] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2065]
. . . done applying atomic actions [8.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 2062]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [342]->
Q [359] << REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1055]

[serial 2063]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1055]

[serial 2066]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2064]

[serial 2067]: Regulate::manage_heat_source.impl
P [360] << ( REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [360]->
Q [361] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2064]

[serial 2068]: Regulate::manage_heat_source.impl
P [361] << heat_control = cntrl'Off >>
S [362]->
Q [363] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2065]
Done reducing atomic actions
step:  59
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2063]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1055]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2069]: Regulate::manage_heat_source.impl
P [363] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2063]

This Proof Obligation:

[serial 2067]: Regulate::manage_heat_source.impl
P [360] << ( REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [360]->
Q [361] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2064]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2070]: Regulate::manage_heat_source.impl
P [360] << ( REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [360]->
Q [361] << heat_control = cntrl'Off >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2067]
. . . done spltting timed atoms  [8.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.4 seconds ]
After "dist^" remaining 
Obligations:

[serial 2062]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [342]->
Q [359] << REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1055]

[serial 2066]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2064]

[serial 2068]: Regulate::manage_heat_source.impl
P [361] << heat_control = cntrl'Off >>
S [362]->
Q [363] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2065]

[serial 2069]: Regulate::manage_heat_source.impl
P [363] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2063]

[serial 2070]: Regulate::manage_heat_source.impl
P [360] << ( REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [360]->
Q [361] << heat_control = cntrl'Off >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2067]
Done distributing ^ and @.
step:  60
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2062]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [342]->
Q [359] << REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1055]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2072]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << REQMHS1() >>
What for:    normalization of [serial 2062]

This Proof Obligation:

[serial 2066]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2064]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2074]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2066]

This Proof Obligation:

[serial 2068]: Regulate::manage_heat_source.impl
P [361] << heat_control = cntrl'Off >>
S [362]->
Q [363] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2065]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2076]: Regulate::manage_heat_source.impl
P [361] << cntrl'Off = heat_control >>
S [362]->
Q [363] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2068]

This Proof Obligation:

[serial 2069]: Regulate::manage_heat_source.impl
P [363] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2063]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2078]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2069]

This Proof Obligation:

[serial 2070]: Regulate::manage_heat_source.impl
P [360] << ( REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [360]->
Q [361] << heat_control = cntrl'Off >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2067]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2080]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and REQMHS1() >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2070]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2072]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << REQMHS1() >>
What for:    normalization of [serial 2062]

[serial 2074]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2066]

[serial 2076]: Regulate::manage_heat_source.impl
P [361] << cntrl'Off = heat_control >>
S [362]->
Q [363] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2068]

[serial 2078]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2069]

[serial 2080]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and REQMHS1() >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2070]
Done Normalizing
step:  61
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2074]: Regulate::manage_heat_source.impl
P [359] << REQMHS1() >>
S [360]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2066]
Reason solved:  Or Introduction Schema (orcwl):  X->(X or Y)
Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)

This Proof Obligation:

[serial 2076]: Regulate::manage_heat_source.impl
P [361] << cntrl'Off = heat_control >>
S [362]->
Q [363] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2068]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 2072]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << REQMHS1() >>
What for:    normalization of [serial 2062]

[serial 2078]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2069]

[serial 2080]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and REQMHS1() >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2070]
Done trying to apply axioms
step:  62
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2072]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << REQMHS1() >>
What for:    normalization of [serial 2062]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2086]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2072]

This Proof Obligation:

[serial 2078]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2069]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2087]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2078]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2080]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and REQMHS1() >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2070]

[serial 2086]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2072]

[serial 2087]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2078]
Done substituting Assertion labels in postconditions.
step:  63
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2086]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2072]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2090]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2086]

This Proof Obligation:

[serial 2087]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2078]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 2092]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2087]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2080]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and REQMHS1() >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2070]

[serial 2090]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2086]

[serial 2092]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2087]
Done Normalizing
step:  64
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2092]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2087]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2095]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2092]
. . . done spltting timed atoms  [8.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.4 seconds ]
After "dist^" remaining 
Obligations:

[serial 2080]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and REQMHS1() >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2070]

[serial 2090]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2086]

[serial 2095]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2092]
Done distributing ^ and @.
step:  65
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2095]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2092]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2099]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2095]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2080]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and REQMHS1() >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2070]

[serial 2090]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2086]

[serial 2099]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2095]
Done Normalizing
step:  66
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2080]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and REQMHS1() >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2070]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2101]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and ( REGULATOR_MODE(x : mmode'Init) ) >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:  Substituted assertions' predicates for labels  [serial 2080]

This Proof Obligation:

[serial 2090]: Regulate::manage_heat_source.impl
P [342] << INI()
  and INVMHS() >>
S [342]->
Q [359] << REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2086]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2102]: Regulate::manage_heat_source.impl
P [342] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( heat_previous_period = heat_control^-1 ) >>
S [342]->
Q [359] << ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2090]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute" remaining 
Obligations:

[serial 2099]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2095]

[serial 2101]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and ( REGULATOR_MODE(x : mmode'Init) ) >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:  Substituted assertions' predicates for labels  [serial 2080]

[serial 2102]: Regulate::manage_heat_source.impl
P [342] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( heat_previous_period = heat_control^-1 ) >>
S [342]->
Q [359] << ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2090]
Done substituting Assertion labels.
step:  67
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2099]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2095]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2103]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2099]

This Proof Obligation:

[serial 2101]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off^0 = heat_control^0
  and ( REGULATOR_MODE(x : mmode'Init) ) >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:  Substituted assertions' predicates for labels  [serial 2080]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2104]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off = heat_control
  and REGULATOR_MODE(x : mmode'Init) >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2101]
. . . done replacing P@now and P^0 with P  [8.4 seconds ]
After assuming present remaining 
Obligations:

[serial 2102]: Regulate::manage_heat_source.impl
P [342] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( heat_previous_period = heat_control^-1 ) >>
S [342]->
Q [359] << ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2090]

[serial 2103]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2099]

[serial 2104]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off = heat_control
  and REGULATOR_MODE(x : mmode'Init) >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2101]
Done assuming present.
step:  68
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2102]: Regulate::manage_heat_source.impl
P [342] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( heat_previous_period = heat_control^-1 ) >>
S [342]->
Q [359] << ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2090]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2106]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << INI() >>
What for:    normalization of [serial 2102]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2103]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2099]

[serial 2104]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off = heat_control
  and REGULATOR_MODE(x : mmode'Init) >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2101]

[serial 2106]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << INI() >>
What for:    normalization of [serial 2102]
Done Normalizing
step:  69
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2103]: Regulate::manage_heat_source.impl
P [363] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2099]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 2104]: Regulate::manage_heat_source.impl
P [360] << cntrl'Off = heat_control
  and REGULATOR_MODE(x : mmode'Init) >>
S [360]->
Q [361] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2101]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 2106]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << INI() >>
What for:    normalization of [serial 2102]
Done trying to apply axioms
step:  70
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2106]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << INI() >>
What for:    normalization of [serial 2102]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2110]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2106]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2110]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2106]
Done substituting Assertion labels in postconditions.
step:  71
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2110]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2106]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2112]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2110]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2112]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2110]
Done Normalizing
step:  72
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2112]: Regulate::manage_heat_source.impl
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342]->
Q [359] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2110]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1056]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [365]->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT() >>
What for:   <<M(check_mode) and x>> -> <<M(check_temp)>> for mhsNormal: check_mode-[x]->check_temp{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  73
#[serial 1056]  <<M(check_mode) and x>> -> <<M(check_temp)>> for mhsNormal: check_mode-[x]->check_temp{};
step:  74
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1056]: Regulate::manage_heat_source.impl
P [342] << ( INVMHS() )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [365]->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT() >>
What for:   <<M(check_mode) and x>> -> <<M(check_temp)>> for mhsNormal: check_mode-[x]->check_temp{};
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2115]: Regulate::manage_heat_source.impl
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365]->
Q [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:    normalization of [serial 1056]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2115]: Regulate::manage_heat_source.impl
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365]->
Q [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:    normalization of [serial 1056]
Done Normalizing
step:  75
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2115]: Regulate::manage_heat_source.impl
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365]->
Q [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:    normalization of [serial 1056]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2117]: Regulate::manage_heat_source.impl
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365]->
Q [343] << true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.4 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2117]: Regulate::manage_heat_source.impl
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365]->
Q [343] << true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  76
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2117]: Regulate::manage_heat_source.impl
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365]->
Q [343] << true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2118]: Regulate::manage_heat_source.impl
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365]->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:  Law of And-Simplification:  P and true is P [serial 2117]

This Proof Obligation:

[serial 2118]: Regulate::manage_heat_source.impl
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365]->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:  Law of And-Simplification:  P and true is P [serial 2117]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2119]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2118]
. . . done Applying Laws [8.4 seconds ]
After "laws" remaining 
Obligations:

[serial 2119]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2118]
Done applying laws
step:  77
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2119]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2118]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2120]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << INVMHS() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]

[serial 2121]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << REGULATOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]
. . . done splitting postcondition  [8.4 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2120]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << INVMHS() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]

[serial 2121]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << REGULATOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]
Done splitting postcondition
step:  78
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2120]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << INVMHS() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 2121]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << REGULATOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]
Done trying to apply axioms
step:  79
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2121]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << REGULATOR_MODE(x : mmode'Normal) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2122]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << ( REGULATOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2121]
. . . done substituting assertions' for Labels [8.4 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2122]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << ( REGULATOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2121]
Done substituting Assertion labels in postconditions.
step:  80
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2122]: Regulate::manage_heat_source.impl
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365]->
Q [343] << ( REGULATOR_OK()
  and RUN() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2121]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2124]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and REGULATOR_OK()
  and RUN() >>
S [365]->
Q [343] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2122]
. . . done Normalizing Unsolved Proof Obligations [8.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2124]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and REGULATOR_OK()
  and RUN() >>
S [365]->
Q [343] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2122]
Done Normalizing
step:  81
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2124]: Regulate::manage_heat_source.impl
P [342] << INVMHS()
  and REGULATOR_OK()
  and RUN() >>
S [365]->
Q [343] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2122]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1057]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [369]  << REQMHS2()
    and not REQMHS1() >>
  heat_control!(cntrl'O_n)
  ;
  << heat_control = cntrl'O_n >>
  heat_previous_period' := cntrl'O_n
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for mhsBelow: check_temp-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  82
#[serial 1057]  <<M(check_temp) and x>> A <<M(run)>> for mhsBelow: check_temp-[x]->run{A};
step:  83
****reduce****
This proof obligation:

[serial 1057]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [369]  << REQMHS2()
    and not REQMHS1() >>
  heat_control!(cntrl'O_n)
  ;
  << heat_control = cntrl'O_n >>
  heat_previous_period' := cntrl'O_n
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for mhsBelow: check_temp-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 2126]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [343]->
Q [369] << REQMHS2()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1057]

[serial 2127]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1057]

[serial 2128]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]heat_control!(cntrl'O_n)
Q [371] << heat_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1057]

[serial 2129]: Regulate::manage_heat_source.impl
P [371] << heat_control = cntrl'O_n >>
S [372]heat_previous_period' := cntrl'O_n
Q [373] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1057]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2126]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [343]->
Q [369] << REQMHS2()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1057]

[serial 2127]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1057]

[serial 2128]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]heat_control!(cntrl'O_n)
Q [371] << heat_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1057]

[serial 2129]: Regulate::manage_heat_source.impl
P [371] << heat_control = cntrl'O_n >>
S [372]heat_previous_period' := cntrl'O_n
Q [373] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1057]
done reducing composite actions
step:  84
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> HEAT_CONTROL(x : heat_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<HEAT_CONTROL: x ~ cntrl 
  +=> O_n -> REQMHS2()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMHS1()
     or REQMHS3()
     or REQMHS5()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'O_n" is:  
^{or 
 ^{INVOKE[REQMHS2] REQMHS2} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMHS4] REQMHS4} 
   ^{( 
    ^{= 
     ^{^ HEAT_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl O_n}} )}} )}}

This Proof Obligation:

[serial 2128]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]heat_control!(cntrl'O_n)
Q [371] << heat_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1057]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> heat_control!(') <<post>> to get:

[serial 2130]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]->
Q [96] << REQMHS2()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2128]

The Same Proof Obligation:
Has applied <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> for  <<pre>> heat_control!(') <<post>> to get:

[serial 2131]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and ( heat_control = cntrl'O_n )^0 >>
S [370]->
Q [371] << heat_control = cntrl'O_n >>
What for:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2128]

[serial 2131]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and ( heat_control = cntrl'O_n )^0 >>
S [370]->
Q [371] << heat_control = cntrl'O_n >>
What for:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2128]
solving assignment on line 372
replacing "heat_previous_period'" with "cntrl'O_n"
makes:  << ( cntrl'O_n ) = heat_control >>

This Proof Obligation:

[serial 2129]: Regulate::manage_heat_source.impl
P [371] << heat_control = cntrl'O_n >>
S [372]heat_previous_period' := cntrl'O_n
Q [373] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1057]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 2132]: Regulate::manage_heat_source.impl
P [371] << heat_control = cntrl'O_n >>
S [372]->
Q [373] << ( cntrl'O_n ) = heat_control >>
What for:  applied wp for assignment [serial 2129]
. . . done applying atomic actions [8.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 2126]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [343]->
Q [369] << REQMHS2()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1057]

[serial 2127]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1057]

[serial 2130]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]->
Q [96] << REQMHS2()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2128]

[serial 2131]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and ( heat_control = cntrl'O_n )^0 >>
S [370]->
Q [371] << heat_control = cntrl'O_n >>
What for:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2128]

[serial 2132]: Regulate::manage_heat_source.impl
P [371] << heat_control = cntrl'O_n >>
S [372]->
Q [373] << ( cntrl'O_n ) = heat_control >>
What for:  applied wp for assignment [serial 2129]
Done reducing atomic actions
step:  85
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2127]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1057]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2133]: Regulate::manage_heat_source.impl
P [373] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2127]

This Proof Obligation:

[serial 2131]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and ( heat_control = cntrl'O_n )^0 >>
S [370]->
Q [371] << heat_control = cntrl'O_n >>
What for:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2128]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2134]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'O_n )^0 ) >>
S [370]->
Q [371] << heat_control = cntrl'O_n >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2131]
. . . done spltting timed atoms  [8.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.5 seconds ]
After "dist^" remaining 
Obligations:

[serial 2126]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [343]->
Q [369] << REQMHS2()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1057]

[serial 2130]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]->
Q [96] << REQMHS2()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2128]

[serial 2132]: Regulate::manage_heat_source.impl
P [371] << heat_control = cntrl'O_n >>
S [372]->
Q [373] << ( cntrl'O_n ) = heat_control >>
What for:  applied wp for assignment [serial 2129]

[serial 2133]: Regulate::manage_heat_source.impl
P [373] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2127]

[serial 2134]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'O_n )^0 ) >>
S [370]->
Q [371] << heat_control = cntrl'O_n >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2131]
Done distributing ^ and @.
step:  86
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2126]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [343]->
Q [369] << REQMHS2()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1057]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2136]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << REQMHS2()
  and not REQMHS1() >>
What for:    normalization of [serial 2126]

This Proof Obligation:

[serial 2130]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]->
Q [96] << REQMHS2()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2128]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2138]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2130]

This Proof Obligation:

[serial 2132]: Regulate::manage_heat_source.impl
P [371] << heat_control = cntrl'O_n >>
S [372]->
Q [373] << ( cntrl'O_n ) = heat_control >>
What for:  applied wp for assignment [serial 2129]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2140]: Regulate::manage_heat_source.impl
P [371] << cntrl'O_n = heat_control >>
S [372]->
Q [373] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2132]

This Proof Obligation:

[serial 2133]: Regulate::manage_heat_source.impl
P [373] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2127]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2142]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2133]

This Proof Obligation:

[serial 2134]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'O_n )^0 ) >>
S [370]->
Q [371] << heat_control = cntrl'O_n >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2131]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2136]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << REQMHS2()
  and not REQMHS1() >>
What for:    normalization of [serial 2126]

[serial 2138]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2130]

[serial 2140]: Regulate::manage_heat_source.impl
P [371] << cntrl'O_n = heat_control >>
S [372]->
Q [373] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2132]

[serial 2142]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2133]

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]
Done Normalizing
step:  87
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 REQMHS2()


This Proof Obligation:

[serial 2138]: Regulate::manage_heat_source.impl
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2130]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 2140]: Regulate::manage_heat_source.impl
P [371] << cntrl'O_n = heat_control >>
S [372]->
Q [373] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2132]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 2136]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << REQMHS2()
  and not REQMHS1() >>
What for:    normalization of [serial 2126]

[serial 2142]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2133]

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]
Done trying to apply axioms
step:  88
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2136]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << REQMHS2()
  and not REQMHS1() >>
What for:    normalization of [serial 2126]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2150]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2136]

This Proof Obligation:

[serial 2142]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2133]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2151]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2142]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]

[serial 2150]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2136]

[serial 2151]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2142]
Done substituting Assertion labels in postconditions.
step:  89
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2150]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2136]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2154]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2150]

This Proof Obligation:

[serial 2151]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2142]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 2156]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2151]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]

[serial 2154]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2150]

[serial 2156]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2151]
Done Normalizing
step:  90
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2156]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2151]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2159]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2156]
. . . done spltting timed atoms  [8.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.5 seconds ]
After "dist^" remaining 
Obligations:

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]

[serial 2154]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2150]

[serial 2159]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2156]
Done distributing ^ and @.
step:  91
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2159]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2156]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]

[serial 2154]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2150]

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]
Done Normalizing
step:  92
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2154]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2150]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2165]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154]

[serial 2166]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154]
. . . done splitting postcondition  [8.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]

[serial 2165]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154]

[serial 2166]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154]
Done splitting postcondition
step:  93
****replace-port-value****
Replacing port names with BLESS::Value properties
Replacing port names with BLESS::Value properties.

This Proof Obligation:

[serial 2165]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154]
Reason solved:  Replacing port names with BLESS::Value properties
Has applied Replacing port names with BLESS::Value properties  to get:

[serial 2167]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Replacing port names with BLESS::Value properties  [serial 2165]

This Proof Obligation:

[serial 2166]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154]
Reason solved:  Replacing port names with BLESS::Value properties
Has applied Replacing port names with BLESS::Value properties  to get:

[serial 2168]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Replacing port names with BLESS::Value properties  [serial 2166]
done replacing port names with Assertions [8.5 seconds ]
After "Replacing port names with BLESS::Value properties" remaining 
Obligations:

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]

[serial 2167]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Replacing port names with BLESS::Value properties  [serial 2165]

[serial 2168]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Replacing port names with BLESS::Value properties  [serial 2166]
Done replacing port names with  BLESS::Value properties.
step:  94
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2144]: Regulate::manage_heat_source.impl
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2134]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2169]: Regulate::manage_heat_source.impl
P [370] << ( ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2144]

This Proof Obligation:

[serial 2167]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Replacing port names with BLESS::Value properties  [serial 2165]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2170]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2167]

This Proof Obligation:

[serial 2168]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Replacing port names with BLESS::Value properties  [serial 2166]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2171]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2168]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]

[serial 2169]: Regulate::manage_heat_source.impl
P [370] << ( ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2144]

[serial 2170]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2167]

[serial 2171]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2168]
Done substituting Assertion labels in preconditions
step:  95
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2169]: Regulate::manage_heat_source.impl
P [370] << ( ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2144]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2172]: Regulate::manage_heat_source.impl
P [370] << ( ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2169]

This Proof Obligation:

[serial 2170]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2167]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2173]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2170]

This Proof Obligation:

[serial 2171]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2168]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2174]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2171]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]

[serial 2172]: Regulate::manage_heat_source.impl
P [370] << ( ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2169]

[serial 2173]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2170]

[serial 2174]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2171]
Done substituting Assertion labels in preconditions
step:  96
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2172]: Regulate::manage_heat_source.impl
P [370] << ( ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2169]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2177]: Regulate::manage_heat_source.impl
P [370] << ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not INI() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2172]

This Proof Obligation:

[serial 2173]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2170]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2179]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2173]

This Proof Obligation:

[serial 2174]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2171]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2181]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2174]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]

[serial 2177]: Regulate::manage_heat_source.impl
P [370] << ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not INI() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2172]

[serial 2179]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2173]

[serial 2181]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2174]
Done Normalizing
step:  97
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2177]: Regulate::manage_heat_source.impl
P [370] << ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not INI() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2172]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2185]: Regulate::manage_heat_source.impl
P [370] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not INI()
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2177]

This Proof Obligation:

[serial 2179]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2173]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2186]: Regulate::manage_heat_source.impl
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2179]

This Proof Obligation:

[serial 2181]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2174]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2187]: Regulate::manage_heat_source.impl
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2181]

This Proof Obligation:

[serial 2186]: Regulate::manage_heat_source.impl
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2179]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2188]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2186]

This Proof Obligation:

[serial 2187]: Regulate::manage_heat_source.impl
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2181]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2189]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2187]
. . . done Applying Laws [8.5 seconds ]
After "laws" remaining 
Obligations:

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]

[serial 2185]: Regulate::manage_heat_source.impl
P [370] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not INI()
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2177]

[serial 2188]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2186]

[serial 2189]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2187]
Done applying laws
step:  98
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2185]: Regulate::manage_heat_source.impl
P [370] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not INI()
  and cntrl'O_n^0 = heat_control^0 >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2177]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2192]: Regulate::manage_heat_source.impl
P [370] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and cntrl'O_n^0 = heat_control^0
  and not INI() >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2185]

This Proof Obligation:

[serial 2188]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2186]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2194]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2188]

This Proof Obligation:

[serial 2189]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2187]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2196]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2189]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]

[serial 2192]: Regulate::manage_heat_source.impl
P [370] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and cntrl'O_n^0 = heat_control^0
  and not INI() >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2185]

[serial 2194]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2188]

[serial 2196]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2189]
Done Normalizing
step:  99
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 2192]: Regulate::manage_heat_source.impl
P [370] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and cntrl'O_n^0 = heat_control^0
  and not INI() >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2185]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2200]: Regulate::manage_heat_source.impl
P [370] << ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and cntrl'O_n^0 = heat_control^0
  and not INI() >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2192]

This Proof Obligation:

[serial 2194]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2188]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2201]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [108] << ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2194]

This Proof Obligation:

[serial 2196]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2189]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2202]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2196]
. . . Substituting <= with not < [8.5 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]

[serial 2200]: Regulate::manage_heat_source.impl
P [370] << ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and cntrl'O_n^0 = heat_control^0
  and not INI() >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2192]

[serial 2201]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [108] << ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2194]

[serial 2202]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2196]
Done replacing a<=b with (not b<a)
step:  100
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2163]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2159]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2203]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2163]

This Proof Obligation:

[serial 2200]: Regulate::manage_heat_source.impl
P [370] << ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and cntrl'O_n^0 = heat_control^0
  and not INI() >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2192]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2204]: Regulate::manage_heat_source.impl
P [370] << cntrl'O_n = heat_control
  and not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and not INI() >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2200]
. . . done replacing P@now and P^0 with P  [8.5 seconds ]
After assuming present remaining 
Obligations:

[serial 2201]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [108] << ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2194]

[serial 2202]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2196]

[serial 2203]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2163]

[serial 2204]: Regulate::manage_heat_source.impl
P [370] << cntrl'O_n = heat_control
  and not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and not INI() >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2200]
Done assuming present.
step:  101
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2201]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [108] << ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2194]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2203]: Regulate::manage_heat_source.impl
P [373] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2163]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 2204]: Regulate::manage_heat_source.impl
P [370] << cntrl'O_n = heat_control
  and not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and not INI() >>
S [370]->
Q [371] << cntrl'O_n = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2200]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 2202]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2196]
Done trying to apply axioms
step:  102
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2202]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2196]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2205]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2202]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2205]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2202]
Done substituting Assertion labels in postconditions.
step:  103
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2205]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2202]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2206]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2205]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2206]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2205]
Done substituting Assertion labels in postconditions.
step:  104
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2206]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2205]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2208]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 2206]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2208]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 2206]
Done Normalizing
step:  105
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2208]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [369] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 2206]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1058]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [377]  << REQMHS3()
    and not REQMHS1() >>
  heat_control!(cntrl'Off)
  ;
  << REQMHS3()
    and not REQMHS1()
    and ( heat_control = cntrl'Off ) >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for mhsAbove: check_temp-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  106
#[serial 1058]  <<M(check_temp) and x>> A <<M(run)>> for mhsAbove: check_temp-[x]->run{A};
step:  107
****reduce****
This proof obligation:

[serial 1058]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [377]  << REQMHS3()
    and not REQMHS1() >>
  heat_control!(cntrl'Off)
  ;
  << REQMHS3()
    and not REQMHS1()
    and ( heat_control = cntrl'Off ) >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_temp) and x>> A <<M(run)>> for mhsAbove: check_temp-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 2210]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [343]->
Q [377] << REQMHS3()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1058]

[serial 2211]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1058]

[serial 2212]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]heat_control!(cntrl'Off)
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1058]

[serial 2213]: Regulate::manage_heat_source.impl
P [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
S [380]heat_previous_period' := cntrl'Off
Q [381] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1058]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2210]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [343]->
Q [377] << REQMHS3()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1058]

[serial 2211]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1058]

[serial 2212]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]heat_control!(cntrl'Off)
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1058]

[serial 2213]: Regulate::manage_heat_source.impl
P [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
S [380]heat_previous_period' := cntrl'Off
Q [381] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1058]
done reducing composite actions
step:  108
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> HEAT_CONTROL(x : heat_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<HEAT_CONTROL: x ~ cntrl 
  +=> O_n -> REQMHS2()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMHS1()
     or REQMHS3()
     or REQMHS5()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'Off" is:  
^{or 
 ^{INVOKE[REQMHS1] REQMHS1} 
 ^{INVOKE[REQMHS3] REQMHS3} 
 ^{INVOKE[REQMHS5] REQMHS5} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMHS4] REQMHS4} 
   ^{( 
    ^{= 
     ^{^ HEAT_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl Off}} )}} )}}

This Proof Obligation:

[serial 2212]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]heat_control!(cntrl'Off)
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1058]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> heat_control!(') <<post>> to get:

[serial 2214]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2212]

The Same Proof Obligation:
Has applied <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> for  <<pre>> heat_control!(') <<post>> to get:

[serial 2215]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [378]->
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2212]

[serial 2215]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [378]->
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2212]
solving assignment on line 380
replacing "heat_previous_period'" with "cntrl'Off"
makes:  << ( cntrl'Off ) = heat_control >>

This Proof Obligation:

[serial 2213]: Regulate::manage_heat_source.impl
P [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
S [380]heat_previous_period' := cntrl'Off
Q [381] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1058]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 2216]: Regulate::manage_heat_source.impl
P [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
S [380]->
Q [381] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2213]
. . . done applying atomic actions [8.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 2210]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [343]->
Q [377] << REQMHS3()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1058]

[serial 2211]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1058]

[serial 2214]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2212]

[serial 2215]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [378]->
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2212]

[serial 2216]: Regulate::manage_heat_source.impl
P [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
S [380]->
Q [381] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2213]
Done reducing atomic actions
step:  109
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2211]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1058]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2217]: Regulate::manage_heat_source.impl
P [381] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2211]

This Proof Obligation:

[serial 2215]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [378]->
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2212]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2218]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [378]->
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2215]
. . . done spltting timed atoms  [8.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.5 seconds ]
After "dist^" remaining 
Obligations:

[serial 2210]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [343]->
Q [377] << REQMHS3()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1058]

[serial 2214]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2212]

[serial 2216]: Regulate::manage_heat_source.impl
P [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
S [380]->
Q [381] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2213]

[serial 2217]: Regulate::manage_heat_source.impl
P [381] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2211]

[serial 2218]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [378]->
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2215]
Done distributing ^ and @.
step:  110
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2210]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [343]->
Q [377] << REQMHS3()
  and not REQMHS1() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1058]
Reasons solved:  
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2220]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << REQMHS3()
  and not REQMHS1() >>
What for:    normalization of [serial 2210]

This Proof Obligation:

[serial 2214]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2212]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2222]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2214]

This Proof Obligation:

[serial 2216]: Regulate::manage_heat_source.impl
P [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
S [380]->
Q [381] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2213]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2224]: Regulate::manage_heat_source.impl
P [379] << cntrl'Off = heat_control
  and REQMHS3()
  and not REQMHS1() >>
S [380]->
Q [381] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2216]

This Proof Obligation:

[serial 2217]: Regulate::manage_heat_source.impl
P [381] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2211]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2226]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2217]

This Proof Obligation:

[serial 2218]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [378]->
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2215]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2228]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control
  and REQMHS3()
  and not REQMHS1() >>
What for:    normalization of [serial 2218]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2220]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << REQMHS3()
  and not REQMHS1() >>
What for:    normalization of [serial 2210]

[serial 2222]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2214]

[serial 2224]: Regulate::manage_heat_source.impl
P [379] << cntrl'Off = heat_control
  and REQMHS3()
  and not REQMHS1() >>
S [380]->
Q [381] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2216]

[serial 2226]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2217]

[serial 2228]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control
  and REQMHS3()
  and not REQMHS1() >>
What for:    normalization of [serial 2218]
Done Normalizing
step:  111
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 REQMHS3()


This Proof Obligation:

[serial 2222]: Regulate::manage_heat_source.impl
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2214]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 2224]: Regulate::manage_heat_source.impl
P [379] << cntrl'Off = heat_control
  and REQMHS3()
  and not REQMHS1() >>
S [380]->
Q [381] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2216]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 2220]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << REQMHS3()
  and not REQMHS1() >>
What for:    normalization of [serial 2210]

[serial 2226]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2217]

[serial 2228]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control
  and REQMHS3()
  and not REQMHS1() >>
What for:    normalization of [serial 2218]
Done trying to apply axioms
step:  112
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2220]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << REQMHS3()
  and not REQMHS1() >>
What for:    normalization of [serial 2210]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2234]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2220]

This Proof Obligation:

[serial 2226]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2217]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2235]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2226]

This Proof Obligation:

[serial 2228]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control
  and REQMHS3()
  and not REQMHS1() >>
What for:    normalization of [serial 2218]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2236]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control
  and ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2228]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2234]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2220]

[serial 2235]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2226]

[serial 2236]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control
  and ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2228]
Done substituting Assertion labels in postconditions.
step:  113
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2234]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2220]
Reasons solved:  
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2238]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2234]

This Proof Obligation:

[serial 2235]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2226]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 2240]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2235]

This Proof Obligation:

[serial 2236]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control
  and ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2228]
Reasons solved:  
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2242]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and cntrl'Off = heat_control
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2236]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2238]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2234]

[serial 2240]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2235]

[serial 2242]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and cntrl'Off = heat_control
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2236]
Done Normalizing
step:  114
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2240]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2235]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2246]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2240]
. . . done spltting timed atoms  [8.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.5 seconds ]
After "dist^" remaining 
Obligations:

[serial 2238]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2234]

[serial 2242]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and cntrl'Off = heat_control
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2236]

[serial 2246]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2240]
Done distributing ^ and @.
step:  115
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2246]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2240]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2238]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2234]

[serial 2242]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and cntrl'Off = heat_control
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2236]

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]
Done Normalizing
step:  116
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2238]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2234]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2252]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238]

[serial 2253]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238]

This Proof Obligation:

[serial 2242]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and cntrl'Off = heat_control
  and not REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2236]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2254]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]

[serial 2255]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]

[serial 2256]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]
. . . done splitting postcondition  [8.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]

[serial 2252]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238]

[serial 2253]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238]

[serial 2254]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]

[serial 2255]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]

[serial 2256]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]
Done splitting postcondition
step:  117
****replace-port-value****
Replacing port names with BLESS::Value properties
Replacing port names with BLESS::Value properties.

This Proof Obligation:

[serial 2252]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238]
Reason solved:  Replacing port names with BLESS::Value properties
Has applied Replacing port names with BLESS::Value properties  to get:

[serial 2257]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Replacing port names with BLESS::Value properties  [serial 2252]

This Proof Obligation:

[serial 2253]: Regulate::manage_heat_source.impl
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238]
Reason solved:  Replacing port names with BLESS::Value properties
Has applied Replacing port names with BLESS::Value properties  to get:

[serial 2258]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Replacing port names with BLESS::Value properties  [serial 2253]
done replacing port names with Assertions [8.5 seconds ]
After "Replacing port names with BLESS::Value properties" remaining 
Obligations:

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]

[serial 2254]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]

[serial 2255]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]

[serial 2256]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]

[serial 2257]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Replacing port names with BLESS::Value properties  [serial 2252]

[serial 2258]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Replacing port names with BLESS::Value properties  [serial 2253]
Done replacing port names with  BLESS::Value properties.
step:  118
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2254]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2259]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels  [serial 2254]

This Proof Obligation:

[serial 2255]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2260]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Substituted assertions' predicates for labels  [serial 2255]

This Proof Obligation:

[serial 2256]: Regulate::manage_heat_source.impl
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2261]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2256]

This Proof Obligation:

[serial 2257]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Replacing port names with BLESS::Value properties  [serial 2252]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2262]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels  [serial 2257]

This Proof Obligation:

[serial 2258]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343]->
Q [377] << not REGULATOR_MODE(x : mmode'Init) >>
What for:  Replacing port names with BLESS::Value properties  [serial 2253]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2263]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [377] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2258]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute" remaining 
Obligations:

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]

[serial 2259]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels  [serial 2254]

[serial 2260]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Substituted assertions' predicates for labels  [serial 2255]

[serial 2261]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2256]

[serial 2262]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels  [serial 2257]

[serial 2263]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [377] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2258]
Done substituting Assertion labels.
step:  119
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2259]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels  [serial 2254]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2264]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2259]

This Proof Obligation:

[serial 2260]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Substituted assertions' predicates for labels  [serial 2255]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2265]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2260]

This Proof Obligation:

[serial 2261]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2256]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2266]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2261]

This Proof Obligation:

[serial 2262]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels  [serial 2257]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2267]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2262]

This Proof Obligation:

[serial 2263]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343]->
Q [377] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2258]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2268]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [377] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2263]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]

[serial 2264]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2259]

[serial 2265]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2260]

[serial 2266]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2261]

[serial 2267]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2262]

[serial 2268]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [377] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2263]
Done substituting Assertion labels in preconditions
step:  120
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2264]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2259]
Reasons solved:  
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2271]: Regulate::manage_heat_source.impl
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:    normalization of [serial 2264]

This Proof Obligation:

[serial 2265]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2260]
Reasons solved:  
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2273]: Regulate::manage_heat_source.impl
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2265]

This Proof Obligation:

[serial 2266]: Regulate::manage_heat_source.impl
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2261]
Reasons solved:  
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2275]: Regulate::manage_heat_source.impl
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not INI() >>
What for:    normalization of [serial 2266]

This Proof Obligation:

[serial 2267]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2262]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2277]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:    normalization of [serial 2267]

This Proof Obligation:

[serial 2268]: Regulate::manage_heat_source.impl
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343]->
Q [377] << not ( INI() ) >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2263]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2279]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:    normalization of [serial 2268]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]

[serial 2271]: Regulate::manage_heat_source.impl
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:    normalization of [serial 2264]

[serial 2273]: Regulate::manage_heat_source.impl
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2265]

[serial 2275]: Regulate::manage_heat_source.impl
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not INI() >>
What for:    normalization of [serial 2266]

[serial 2277]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:    normalization of [serial 2267]

[serial 2279]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:    normalization of [serial 2268]
Done Normalizing
step:  121
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 2271]: Regulate::manage_heat_source.impl
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:    normalization of [serial 2264]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2285]: Regulate::manage_heat_source.impl
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2271]

This Proof Obligation:

[serial 2273]: Regulate::manage_heat_source.impl
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2265]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2286]: Regulate::manage_heat_source.impl
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2273]

This Proof Obligation:

[serial 2275]: Regulate::manage_heat_source.impl
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not INI() >>
What for:    normalization of [serial 2266]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2287]: Regulate::manage_heat_source.impl
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not INI() >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2275]

This Proof Obligation:

[serial 2277]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
What for:    normalization of [serial 2267]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2288]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2277]

This Proof Obligation:

[serial 2279]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:    normalization of [serial 2268]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2289]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2279]
. . . Substituting <= with not < [8.5 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]

[serial 2285]: Regulate::manage_heat_source.impl
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2271]

[serial 2286]: Regulate::manage_heat_source.impl
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2273]

[serial 2287]: Regulate::manage_heat_source.impl
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not INI() >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2275]

[serial 2288]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2277]

[serial 2289]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2279]
Done replacing a<=b with (not b<a)
step:  122
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2285]: Regulate::manage_heat_source.impl
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2271]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2290]: Regulate::manage_heat_source.impl
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2285]

This Proof Obligation:

[serial 2286]: Regulate::manage_heat_source.impl
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2273]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2291]: Regulate::manage_heat_source.impl
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2286]

This Proof Obligation:

[serial 2287]: Regulate::manage_heat_source.impl
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not INI() >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2275]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2292]: Regulate::manage_heat_source.impl
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2287]

This Proof Obligation:

[serial 2288]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2277]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2293]: Regulate::manage_heat_source.impl
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2288]

This Proof Obligation:

[serial 2289]: Regulate::manage_heat_source.impl
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2279]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2294]: Regulate::manage_heat_source.impl
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2289]

This Proof Obligation:

[serial 2293]: Regulate::manage_heat_source.impl
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2288]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2295]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2293]

This Proof Obligation:

[serial 2294]: Regulate::manage_heat_source.impl
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2289]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2296]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2294]
. . . done Applying Laws [8.5 seconds ]
After "laws" remaining 
Obligations:

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]

[serial 2290]: Regulate::manage_heat_source.impl
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2285]

[serial 2291]: Regulate::manage_heat_source.impl
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2286]

[serial 2292]: Regulate::manage_heat_source.impl
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2287]

[serial 2295]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2293]

[serial 2296]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2294]
Done applying laws
step:  123
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2250]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2246]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2297]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2250]

This Proof Obligation:

[serial 2290]: Regulate::manage_heat_source.impl
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2285]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2298]: Regulate::manage_heat_source.impl
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378]->
Q [164] << not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2290]

This Proof Obligation:

[serial 2291]: Regulate::manage_heat_source.impl
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2286]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2299]: Regulate::manage_heat_source.impl
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2291]

This Proof Obligation:

[serial 2292]: Regulate::manage_heat_source.impl
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378]->
Q [379] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2287]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2300]: Regulate::manage_heat_source.impl
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378]->
Q [379] << not INI() >>
What for:  Assume Present:  P = P@now = P^0   [serial 2292]
. . . done replacing P@now and P^0 with P  [8.5 seconds ]
After assuming present remaining 
Obligations:

[serial 2295]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2293]

[serial 2296]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2294]

[serial 2297]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2250]

[serial 2298]: Regulate::manage_heat_source.impl
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378]->
Q [164] << not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2290]

[serial 2299]: Regulate::manage_heat_source.impl
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2291]

[serial 2300]: Regulate::manage_heat_source.impl
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378]->
Q [379] << not INI() >>
What for:  Assume Present:  P = P@now = P^0   [serial 2292]
Done assuming present.
step:  124
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2295]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2293]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2297]: Regulate::manage_heat_source.impl
P [381] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2250]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 2298]: Regulate::manage_heat_source.impl
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378]->
Q [164] << not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2290]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2299]: Regulate::manage_heat_source.impl
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378]->
Q [379] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2291]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2300]: Regulate::manage_heat_source.impl
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378]->
Q [379] << not INI() >>
What for:  Assume Present:  P = P@now = P^0   [serial 2292]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 2296]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2294]
Done trying to apply axioms
step:  125
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2296]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2294]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2301]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2296]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2301]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2296]
Done substituting Assertion labels in postconditions.
step:  126
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2301]: Regulate::manage_heat_source.impl
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343]->
Q [377] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2296]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2303]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [377] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 2301]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2303]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [377] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 2301]
Done Normalizing
step:  127
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2303]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343]->
Q [377] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 2301]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1059]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383]->
Q [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT() >>
What for:   <<M(check_temp) and x>> -> <<M(check_hyst)>> for mhsHys: check_temp-[x]->check_hyst{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  128
#[serial 1059]  <<M(check_temp) and x>> -> <<M(check_hyst)>> for mhsHys: check_temp-[x]->check_hyst{};
step:  129
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1059]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383]->
Q [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT() >>
What for:   <<M(check_temp) and x>> -> <<M(check_hyst)>> for mhsHys: check_temp-[x]->check_hyst{};
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2305]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383]->
Q [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.5 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2305]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383]->
Q [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  130
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2305]: Regulate::manage_heat_source.impl
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383]->
Q [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2306]: Regulate::manage_heat_source.impl
P [343] << ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383]->
Q [344] << ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = heat_control^-1 )
  and true >>
What for:  Substituted assertions' predicates for labels  [serial 2305]
. . . done substituting assertions' for Labels [8.5 seconds ]
After "substitute" remaining 
Obligations:

[serial 2306]: Regulate::manage_heat_source.impl
P [343] << ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383]->
Q [344] << ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = heat_control^-1 )
  and true >>
What for:  Substituted assertions' predicates for labels  [serial 2305]
Done substituting Assertion labels.
step:  131
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2306]: Regulate::manage_heat_source.impl
P [343] << ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383]->
Q [344] << ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = heat_control^-1 )
  and true >>
What for:  Substituted assertions' predicates for labels  [serial 2305]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2308]: Regulate::manage_heat_source.impl
P [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and heat_control^-1 = heat_previous_period
  and true >>
What for:    normalization of [serial 2306]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2308]: Regulate::manage_heat_source.impl
P [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and heat_control^-1 = heat_previous_period
  and true >>
What for:    normalization of [serial 2306]
Done Normalizing
step:  132
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2308]: Regulate::manage_heat_source.impl
P [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and heat_control^-1 = heat_previous_period
  and true >>
What for:    normalization of [serial 2306]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2310]: Regulate::manage_heat_source.impl
P [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and heat_control^-1 = heat_previous_period >>
What for:  Law of And-Simplification:  P and true is P [serial 2308]

This Proof Obligation:

[serial 2310]: Regulate::manage_heat_source.impl
P [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and heat_control^-1 = heat_previous_period >>
What for:  Law of And-Simplification:  P and true is P [serial 2308]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2311]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
What for:  Associativity: (b.c).a = a.b.c [serial 2310]
. . . done Applying Laws [8.5 seconds ]
After "laws" remaining 
Obligations:

[serial 2311]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
What for:  Associativity: (b.c).a = a.b.c [serial 2310]
Done applying laws
step:  133
****replace-port-value****
Replacing port names with BLESS::Value properties
Replacing port names with BLESS::Value properties.

This Proof Obligation:

[serial 2311]: Regulate::manage_heat_source.impl
P [343] << current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
What for:  Associativity: (b.c).a = a.b.c [serial 2310]
Reason solved:  Replacing port names with BLESS::Value properties
Has applied Replacing port names with BLESS::Value properties  to get:

[serial 2312]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
What for:  Replacing port names with BLESS::Value properties  [serial 2311]
done replacing port names with Assertions [8.5 seconds ]
After "Replacing port names with BLESS::Value properties" remaining 
Obligations:

[serial 2312]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
What for:  Replacing port names with BLESS::Value properties  [serial 2311]
Done replacing port names with  BLESS::Value properties.
step:  134
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2312]: Regulate::manage_heat_source.impl
P [343] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383]->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
What for:  Replacing port names with BLESS::Value properties  [serial 2311]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2314]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [383]->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2312]
. . . done Normalizing Unsolved Proof Obligations [8.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2314]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [383]->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2312]
Done Normalizing
step:  135
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2314]: Regulate::manage_heat_source.impl
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [383]->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2312]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1060]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( ( heat_previous_period = cntrl'O_n ) ) >>
S [388]  << TEMP_IN_DESIRED_RANGE()
    and REGULATOR_MODE(x : mmode'Normal)
    and AXIOM_HC()
    and ( heat_previous_period = cntrl'O_n )
    and INVMHS() >>
  heat_control!(cntrl'O_n)
  ;
  << heat_control = cntrl'O_n >>
  heat_previous_period' := cntrl'O_n
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOn: check_hyst-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  136
#[serial 1060]  <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOn: check_hyst-[x]->run{A};
step:  137
****reduce****
This proof obligation:

[serial 1060]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( ( heat_previous_period = cntrl'O_n ) ) >>
S [388]  << TEMP_IN_DESIRED_RANGE()
    and REGULATOR_MODE(x : mmode'Normal)
    and AXIOM_HC()
    and ( heat_previous_period = cntrl'O_n )
    and INVMHS() >>
  heat_control!(cntrl'O_n)
  ;
  << heat_control = cntrl'O_n >>
  heat_previous_period' := cntrl'O_n
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOn: check_hyst-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 2316]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( ( heat_previous_period = cntrl'O_n ) ) >>
S [344]->
Q [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1060]

[serial 2317]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1060]

[serial 2318]: Regulate::manage_heat_source.impl
P [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
S [390]heat_control!(cntrl'O_n)
Q [391] << heat_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1060]

[serial 2319]: Regulate::manage_heat_source.impl
P [391] << heat_control = cntrl'O_n >>
S [392]heat_previous_period' := cntrl'O_n
Q [393] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1060]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2316]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( ( heat_previous_period = cntrl'O_n ) ) >>
S [344]->
Q [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1060]

[serial 2317]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1060]

[serial 2318]: Regulate::manage_heat_source.impl
P [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
S [390]heat_control!(cntrl'O_n)
Q [391] << heat_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1060]

[serial 2319]: Regulate::manage_heat_source.impl
P [391] << heat_control = cntrl'O_n >>
S [392]heat_previous_period' := cntrl'O_n
Q [393] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1060]
done reducing composite actions
step:  138
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> HEAT_CONTROL(x : heat_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<HEAT_CONTROL: x ~ cntrl 
  +=> O_n -> REQMHS2()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMHS1()
     or REQMHS3()
     or REQMHS5()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'O_n" is:  
^{or 
 ^{INVOKE[REQMHS2] REQMHS2} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMHS4] REQMHS4} 
   ^{( 
    ^{= 
     ^{^ HEAT_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl O_n}} )}} )}}

This Proof Obligation:

[serial 2318]: Regulate::manage_heat_source.impl
P [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
S [390]heat_control!(cntrl'O_n)
Q [391] << heat_control = cntrl'O_n >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1060]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> heat_control!(') <<post>> to get:

[serial 2320]: Regulate::manage_heat_source.impl
P [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
S [390]->
Q [96] << REQMHS2()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2318]

The Same Proof Obligation:
Has applied <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> for  <<pre>> heat_control!(') <<post>> to get:

[serial 2321]: Regulate::manage_heat_source.impl
P [390] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() )
  and ( heat_control = cntrl'O_n )^0 >>
S [390]->
Q [391] << heat_control = cntrl'O_n >>
What for:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2318]

[serial 2321]: Regulate::manage_heat_source.impl
P [390] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() )
  and ( heat_control = cntrl'O_n )^0 >>
S [390]->
Q [391] << heat_control = cntrl'O_n >>
What for:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2318]
solving assignment on line 392
replacing "heat_previous_period'" with "cntrl'O_n"
makes:  << ( cntrl'O_n ) = heat_control >>

This Proof Obligation:

[serial 2319]: Regulate::manage_heat_source.impl
P [391] << heat_control = cntrl'O_n >>
S [392]heat_previous_period' := cntrl'O_n
Q [393] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1060]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 2322]: Regulate::manage_heat_source.impl
P [391] << heat_control = cntrl'O_n >>
S [392]->
Q [393] << ( cntrl'O_n ) = heat_control >>
What for:  applied wp for assignment [serial 2319]
. . . done applying atomic actions [8.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 2316]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( ( heat_previous_period = cntrl'O_n ) ) >>
S [344]->
Q [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1060]

[serial 2317]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1060]

[serial 2320]: Regulate::manage_heat_source.impl
P [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
S [390]->
Q [96] << REQMHS2()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2318]

[serial 2321]: Regulate::manage_heat_source.impl
P [390] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() )
  and ( heat_control = cntrl'O_n )^0 >>
S [390]->
Q [391] << heat_control = cntrl'O_n >>
What for:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2318]

[serial 2322]: Regulate::manage_heat_source.impl
P [391] << heat_control = cntrl'O_n >>
S [392]->
Q [393] << ( cntrl'O_n ) = heat_control >>
What for:  applied wp for assignment [serial 2319]
Done reducing atomic actions
step:  139
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2316]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( ( heat_previous_period = cntrl'O_n ) ) >>
S [344]->
Q [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1060]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2324]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:    normalization of [serial 2316]

This Proof Obligation:

[serial 2317]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1060]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2326]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2317]

This Proof Obligation:

[serial 2320]: Regulate::manage_heat_source.impl
P [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
S [390]->
Q [96] << REQMHS2()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'O_n ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2318]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2328]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2320]

This Proof Obligation:

[serial 2321]: Regulate::manage_heat_source.impl
P [390] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() )
  and ( heat_control = cntrl'O_n )^0 >>
S [390]->
Q [391] << heat_control = cntrl'O_n >>
What for:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2318]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2330]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( cntrl'O_n = heat_control )^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2321]

This Proof Obligation:

[serial 2322]: Regulate::manage_heat_source.impl
P [391] << heat_control = cntrl'O_n >>
S [392]->
Q [393] << ( cntrl'O_n ) = heat_control >>
What for:  applied wp for assignment [serial 2319]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2332]: Regulate::manage_heat_source.impl
P [391] << cntrl'O_n = heat_control >>
S [392]->
Q [393] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2322]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2324]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:    normalization of [serial 2316]

[serial 2326]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2317]

[serial 2328]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2320]

[serial 2330]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( cntrl'O_n = heat_control )^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2321]

[serial 2332]: Regulate::manage_heat_source.impl
P [391] << cntrl'O_n = heat_control >>
S [392]->
Q [393] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2322]
Done Normalizing
step:  140
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2324]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:    normalization of [serial 2316]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2338]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.6 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2326]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2317]

[serial 2328]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2320]

[serial 2330]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( cntrl'O_n = heat_control )^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2321]

[serial 2332]: Regulate::manage_heat_source.impl
P [391] << cntrl'O_n = heat_control >>
S [392]->
Q [393] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2322]

[serial 2338]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  141
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2332]: Regulate::manage_heat_source.impl
P [391] << cntrl'O_n = heat_control >>
S [392]->
Q [393] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2322]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 2326]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2317]

[serial 2328]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2320]

[serial 2330]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( cntrl'O_n = heat_control )^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2321]

[serial 2338]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:   add user-defined axioms to postcondition
Done trying to apply axioms
step:  142
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2326]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2317]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2339]: Regulate::manage_heat_source.impl
P [393] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2326]

This Proof Obligation:

[serial 2330]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( cntrl'O_n = heat_control )^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2321]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2340]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( ( cntrl'O_n )^0 = ( heat_control )^0 ) >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2330]
. . . done spltting timed atoms  [8.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.6 seconds ]
After "dist^" remaining 
Obligations:

[serial 2328]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2320]

[serial 2338]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:   add user-defined axioms to postcondition

[serial 2339]: Regulate::manage_heat_source.impl
P [393] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2326]

[serial 2340]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( ( cntrl'O_n )^0 = ( heat_control )^0 ) >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2330]
Done distributing ^ and @.
step:  143
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2338]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:   add user-defined axioms to postcondition
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2343]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and true >>
What for:    normalization of [serial 2338]

This Proof Obligation:

[serial 2339]: Regulate::manage_heat_source.impl
P [393] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2326]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2345]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2339]

This Proof Obligation:

[serial 2340]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( ( cntrl'O_n )^0 = ( heat_control )^0 ) >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2330]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2347]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and cntrl'O_n^0 = heat_control^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2340]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2328]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2320]

[serial 2343]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and true >>
What for:    normalization of [serial 2338]

[serial 2345]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2339]

[serial 2347]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and cntrl'O_n^0 = heat_control^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2340]
Done Normalizing
step:  144
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2343]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and true >>
What for:    normalization of [serial 2338]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2351]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:  Law of And-Simplification:  P and true is P [serial 2343]

This Proof Obligation:

[serial 2347]: Regulate::manage_heat_source.impl
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and cntrl'O_n^0 = heat_control^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2340]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2352]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and cntrl'O_n^0 = heat_control^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2347]
. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2328]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2320]

[serial 2345]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2339]

[serial 2351]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:  Law of And-Simplification:  P and true is P [serial 2343]

[serial 2352]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and cntrl'O_n^0 = heat_control^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2347]
Done applying laws
step:  145
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2328]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
What for:    normalization of [serial 2320]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2353]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and ( CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t ) )
   or ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2328]

This Proof Obligation:

[serial 2345]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2339]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2354]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2345]

This Proof Obligation:

[serial 2351]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:  Law of And-Simplification:  P and true is P [serial 2343]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2355]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2351]
. . . done substituting assertions' for Labels [8.6 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2352]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and cntrl'O_n^0 = heat_control^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2347]

[serial 2353]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and ( CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t ) )
   or ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2328]

[serial 2354]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2345]

[serial 2355]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2351]
Done substituting Assertion labels in postconditions.
step:  146
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2352]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and cntrl'O_n^0 = heat_control^0 >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Associativity: (b.c).a = a.b.c [serial 2347]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2357]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_previous_period
  and cntrl'O_n^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2352]

This Proof Obligation:

[serial 2353]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and ( CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t ) )
   or ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2328]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2359]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2353]

This Proof Obligation:

[serial 2354]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2345]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 2361]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2354]

This Proof Obligation:

[serial 2355]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2351]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2363]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2355]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2357]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_previous_period
  and cntrl'O_n^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2352]

[serial 2359]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2353]

[serial 2361]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2354]

[serial 2363]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2355]
Done Normalizing
step:  147
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2361]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2354]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2368]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2361]
. . . done spltting timed atoms  [8.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.6 seconds ]
After "dist^" remaining 
Obligations:

[serial 2357]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_previous_period
  and cntrl'O_n^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2352]

[serial 2359]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2353]

[serial 2363]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2355]

[serial 2368]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2361]
Done distributing ^ and @.
step:  148
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2368]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2361]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2373]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2368]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2357]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_previous_period
  and cntrl'O_n^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2352]

[serial 2359]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2353]

[serial 2363]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2355]

[serial 2373]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2368]
Done Normalizing
step:  149
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2357]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_previous_period
  and cntrl'O_n^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:    normalization of [serial 2352]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2375]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_control
  and cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2357]

This Proof Obligation:

[serial 2373]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2368]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2376]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2373]
. . . done replacing P@now and P^0 with P  [8.6 seconds ]
After assuming present remaining 
Obligations:

[serial 2359]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2353]

[serial 2363]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2355]

[serial 2375]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_control
  and cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2357]

[serial 2376]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2373]
Done assuming present.
step:  150
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2375]: Regulate::manage_heat_source.impl
P [390] << cntrl'O_n = heat_control
  and cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [391] << cntrl'O_n = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2357]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2376]: Regulate::manage_heat_source.impl
P [393] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2373]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 2359]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2353]

[serial 2363]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2355]
Done trying to apply axioms
step:  151
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2363]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2355]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2377]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:  Associativity: (b.c).a = a.b.c [serial 2363]
. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2359]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2353]

[serial 2377]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:  Associativity: (b.c).a = a.b.c [serial 2363]
Done applying laws
step:  152
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2377]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:  Associativity: (b.c).a = a.b.c [serial 2363]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2380]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2377]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2359]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2353]

[serial 2380]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2377]
Done Normalizing
step:  153
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2359]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2353]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2382]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and ( HEAT_CONTROL^-1 = heat_control^-1 )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels  [serial 2359]

This Proof Obligation:

[serial 2380]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2377]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2383]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2380]
. . . done substituting assertions' for Labels [8.6 seconds ]
After "substitute" remaining 
Obligations:

[serial 2382]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and ( HEAT_CONTROL^-1 = heat_control^-1 )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels  [serial 2359]

[serial 2383]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2380]
Done substituting Assertion labels.
step:  154
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2382]: Regulate::manage_heat_source.impl
P [388] << cntrl'O_n = heat_previous_period
  and ( HEAT_CONTROL^-1 = heat_control^-1 )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels  [serial 2359]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2385]: Regulate::manage_heat_source.impl
P [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2382]

This Proof Obligation:

[serial 2383]: Regulate::manage_heat_source.impl
P [344] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2380]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2387]: Regulate::manage_heat_source.impl
P [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2383]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2385]: Regulate::manage_heat_source.impl
P [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2382]

[serial 2387]: Regulate::manage_heat_source.impl
P [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2383]
Done Normalizing
step:  155
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2385]: Regulate::manage_heat_source.impl
P [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2382]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2390]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2385]

This Proof Obligation:

[serial 2387]: Regulate::manage_heat_source.impl
P [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:    normalization of [serial 2383]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2391]: Regulate::manage_heat_source.impl
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:  Associativity: (b.c).a = a.b.c [serial 2387]
. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2390]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2385]

[serial 2391]: Regulate::manage_heat_source.impl
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:  Associativity: (b.c).a = a.b.c [serial 2387]
Done applying laws
step:  156
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2390]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2385]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2392]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2390]

This Proof Obligation:

[serial 2391]: Regulate::manage_heat_source.impl
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:  Associativity: (b.c).a = a.b.c [serial 2387]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2393]: Regulate::manage_heat_source.impl
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2391]
. . . done substituting assertions' for Labels [8.6 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2392]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2390]

[serial 2393]: Regulate::manage_heat_source.impl
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2391]
Done substituting Assertion labels in preconditions
step:  157
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2392]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2390]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2395]: Regulate::manage_heat_source.impl
P [388] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2392]

This Proof Obligation:

[serial 2393]: Regulate::manage_heat_source.impl
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 2391]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2397]: Regulate::manage_heat_source.impl
P [344] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2393]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2395]: Regulate::manage_heat_source.impl
P [388] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2392]

[serial 2397]: Regulate::manage_heat_source.impl
P [344] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2393]
Done Normalizing
step:  158
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2395]: Regulate::manage_heat_source.impl
P [388] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2392]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2400]: Regulate::manage_heat_source.impl
P [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2395]

This Proof Obligation:

[serial 2397]: Regulate::manage_heat_source.impl
P [344] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2393]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2401]: Regulate::manage_heat_source.impl
P [344] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2397]
. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2400]: Regulate::manage_heat_source.impl
P [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2395]

[serial 2401]: Regulate::manage_heat_source.impl
P [344] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2397]
Done applying laws
step:  159
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2400]: Regulate::manage_heat_source.impl
P [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Associativity: (b.c).a = a.b.c [serial 2395]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2403]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2400]

This Proof Obligation:

[serial 2401]: Regulate::manage_heat_source.impl
P [344] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2397]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2405]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2401]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2403]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2400]

[serial 2405]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2401]
Done Normalizing
step:  160
****sub-equals****
substituting an equals . . .

This Proof Obligation:

[serial 2403]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:    normalization of [serial 2400]
Reason solved:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
Has substituted 
"cntrl'O_n"
 with its =
 "( heat_previous_period )"
 to get:

[serial 2408]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "cntrl'O_n"
 with its ="
 ( heat_previous_period )" [serial 2403]
with score 1.

This Proof Obligation:

[serial 2405]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2401]
Reason solved:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
Has substituted 
"heat_previous_period"
 with its =
 "( heat_control^-1 )"
 to get:

[serial 2409]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "heat_previous_period"
 with its ="
 ( heat_control^-1 )" [serial 2405]
with score 3.
. . . done substituting an equals  [8.6 seconds ]
After substituting an equals remaining 
Obligations:

[serial 2408]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "cntrl'O_n"
 with its ="
 ( heat_previous_period )" [serial 2403]

[serial 2409]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "heat_previous_period"
 with its ="
 ( heat_control^-1 )" [serial 2405]
Done substituting an equals
step:  161
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 2408]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
What for:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "cntrl'O_n"
 with its ="
 ( heat_previous_period )" [serial 2403]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2410]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2408]

This Proof Obligation:

[serial 2409]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "heat_previous_period"
 with its ="
 ( heat_control^-1 )" [serial 2405]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2411]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2409]
. . . Substituting <= with not < [8.6 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 2410]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2408]

[serial 2411]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2409]
Done replacing a<=b with (not b<a)
step:  162
****range-exp****
Replacing Ranges with Boolean Expressions
replacing ranges with boolean expressions . . .

This Proof Obligation:

[serial 2410]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2408]
Reason solved:  Replace expression with range:   a<=x and x<=b  iff  x in a..b
Has applied Replace expression with range:   a<=x and x<=b  iff  x in a..b  to get:

[serial 2412]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2410]
. . . done replacing ranges with boolean expressions  [8.6 seconds ]
After changing ranges to boolean expressions: 
Obligations:

[serial 2411]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2409]

[serial 2412]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2410]
Done changing ranges to boolean expressions
step:  163
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2411]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2409]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2414]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2411]

This Proof Obligation:

[serial 2412]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2410]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2416]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and HEAT_CONTROL^-1 = heat_previous_period )
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2412]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2414]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2411]

[serial 2416]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and HEAT_CONTROL^-1 = heat_previous_period )
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2412]
Done Normalizing
step:  164
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2414]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2411]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 2419]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and true
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2414]

This Proof Obligation:

[serial 2416]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and HEAT_CONTROL^-1 = heat_previous_period )
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2412]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2420]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and HEAT_CONTROL^-1 = heat_previous_period )
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2416]

This Proof Obligation:

[serial 2419]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and true
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2414]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2421]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2419]
. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2420]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and HEAT_CONTROL^-1 = heat_previous_period )
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2416]

[serial 2421]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2419]
Done applying laws
step:  165
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 2420]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and HEAT_CONTROL^-1 = heat_previous_period )
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2416]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 2422]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2420]
. . . done putting into conjunctive normal form [8.6 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 2421]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2419]

[serial 2422]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2420]
Done making conjunctive normal forms.
step:  166
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2422]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2420]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 2423]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( true )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2422]
. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2421]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2419]

[serial 2423]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( true )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2422]
Done applying laws
step:  167
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2423]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( true )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2422]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2426]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and true >>
What for:    normalization of [serial 2423]
. . . done Normalizing Unsolved Proof Obligations [8.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2421]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2419]

[serial 2426]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and true >>
What for:    normalization of [serial 2423]
Done Normalizing
step:  168
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2426]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and true >>
What for:    normalization of [serial 2423]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2428]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2426]
. . . done Applying Laws [8.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2421]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2419]

[serial 2428]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2426]
Done applying laws
step:  169
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2421]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2419]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2429]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [333] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2430]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [164] << LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2431]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [389] << cntrl'O_n = heat_control^-1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2432]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [129] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2433]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [164] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2434]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [128] << not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

This Proof Obligation:

[serial 2428]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2426]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2435]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428]

[serial 2436]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428]
. . . done splitting postcondition  [8.6 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2429]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [333] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2430]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [164] << LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2431]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [389] << cntrl'O_n = heat_control^-1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2432]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [129] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2433]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [164] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2434]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [128] << not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2435]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428]

[serial 2436]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428]
Done splitting postcondition
step:  170
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2435]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2444]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2435]

This Proof Obligation:

[serial 2436]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2446]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2436]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2429]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [333] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2430]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [164] << LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2431]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [389] << cntrl'O_n = heat_control^-1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2432]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [129] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2433]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [164] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2434]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [128] << not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2444]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2435]

[serial 2446]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2436]
Done Normalizing
step:  171
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2429]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [333] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2430]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [164] << LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2432]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [129] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2433]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [164] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2434]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [128] << not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t


This Proof Obligation:

[serial 2444]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2435]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [8.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 2431]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [389] << cntrl'O_n = heat_control^-1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]

[serial 2446]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2436]
Done trying to apply axioms
step:  172
****guided-sub-equals****
guided substitution of equals "heat_control^-1" . . .
equality selected for substitution:  heat_control^-1 = heat_previous_period

This Proof Obligation:

[serial 2431]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [389] << cntrl'O_n = heat_control^-1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Reason solved:  Guided Substitution of Equals
Has substituted 
"heat_control^-1" with its = "heat_previous_period"
 to get:

[serial 2449]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [389] << cntrl'O_n = heat_previous_period >>
What for:  Guided Substitution of Equals 
 replacing "heat_control^-1" with its = "heat_previous_period" in its postcondition [serial 2431]
equality selected for substitution:  heat_control^-1 = heat_previous_period
. . . done guided substitution of equals  [8.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2446]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2436]
Reason solved:  Guided Substitution of Equals

[serial 2449]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [389] << cntrl'O_n = heat_previous_period >>
What for:  Guided Substitution of Equals 
 replacing "heat_control^-1" with its = "heat_previous_period" in its postcondition [serial 2431]
Done guided substituting an equals
step:  173
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2449]: Regulate::manage_heat_source.impl
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344]->
Q [389] << cntrl'O_n = heat_previous_period >>
What for:  Guided Substitution of Equals 
 replacing "heat_control^-1" with its = "heat_previous_period" in its postcondition [serial 2431]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 2446]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2436]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  174
****guided-sub-equals****
guided substitution of equals "HEAT_CONTROL^-1" . . .
equality selected for substitution:  HEAT_CONTROL^-1 = heat_control^-1

This Proof Obligation:

[serial 2446]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:    normalization of [serial 2436]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
Has substituted 
"HEAT_CONTROL^-1" with its = "heat_control^-1"
 to get:

[serial 2450]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << heat_control^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "HEAT_CONTROL^-1" with its = "heat_control^-1" in its postcondition [serial 2446]
. . . done guided substitution of equals  [8.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2450]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << heat_control^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "HEAT_CONTROL^-1" with its = "heat_control^-1" in its postcondition [serial 2446]
Done guided substituting an equals
step:  175
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 heat_control^-1 = heat_previous_period


This Proof Obligation:

[serial 2450]: Regulate::manage_heat_source.impl
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390]->
Q [96] << heat_control^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "HEAT_CONTROL^-1" with its = "heat_control^-1" in its postcondition [serial 2446]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [8.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1061]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [397]  << TEMP_IN_DESIRED_RANGE()
    and REGULATOR_MODE(x : mmode'Normal)
    and AXIOM_HC()
    and ( heat_previous_period = cntrl'Off )
    and INVMHS() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOff: check_hyst-[x]->run{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  176
#[serial 1061]  <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOff: check_hyst-[x]->run{A};
step:  177
****reduce****
This proof obligation:

[serial 1061]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [397]  << TEMP_IN_DESIRED_RANGE()
    and REGULATOR_MODE(x : mmode'Normal)
    and AXIOM_HC()
    and ( heat_previous_period = cntrl'Off )
    and INVMHS() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
What for:   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOff: check_hyst-[x]->run{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 2451]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1061]

[serial 2452]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1061]

[serial 2453]: Regulate::manage_heat_source.impl
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399]heat_control!(cntrl'Off)
Q [400] << heat_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1061]

[serial 2454]: Regulate::manage_heat_source.impl
P [400] << heat_control = cntrl'Off >>
S [401]heat_previous_period' := cntrl'Off
Q [402] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1061]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2451]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1061]

[serial 2452]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1061]

[serial 2453]: Regulate::manage_heat_source.impl
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399]heat_control!(cntrl'Off)
Q [400] << heat_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1061]

[serial 2454]: Regulate::manage_heat_source.impl
P [400] << heat_control = cntrl'Off >>
S [401]heat_previous_period' := cntrl'Off
Q [402] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1061]
done reducing composite actions
step:  178
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> HEAT_CONTROL(x : heat_control) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<HEAT_CONTROL: x ~ cntrl 
  +=> O_n -> REQMHS2()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'O_n ) ),
    Off -> REQMHS1()
     or REQMHS3()
     or REQMHS5()
     or ( REQMHS4()
    and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x cntrl}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =cntrl
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "cntrl'Off" is:  
^{or 
 ^{INVOKE[REQMHS1] REQMHS1} 
 ^{INVOKE[REQMHS3] REQMHS3} 
 ^{INVOKE[REQMHS5] REQMHS5} 
 ^{( 
  ^{and 
   ^{INVOKE[REQMHS4] REQMHS4} 
   ^{( 
    ^{= 
     ^{^ HEAT_CONTROL 
      ^{QUANTITY -1}} 
     ^{' cntrl Off}} )}} )}}

This Proof Obligation:

[serial 2453]: Regulate::manage_heat_source.impl
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399]heat_control!(cntrl'Off)
Q [400] << heat_control = cntrl'Off >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1061]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> heat_control!(') <<post>> to get:

[serial 2455]: Regulate::manage_heat_source.impl
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2453]

The Same Proof Obligation:
Has applied <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> for  <<pre>> heat_control!(') <<post>> to get:

[serial 2456]: Regulate::manage_heat_source.impl
P [399] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() )
  and ( heat_control = cntrl'Off )^0 >>
S [399]->
Q [400] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2453]

[serial 2456]: Regulate::manage_heat_source.impl
P [399] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() )
  and ( heat_control = cntrl'Off )^0 >>
S [399]->
Q [400] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2453]
solving assignment on line 401
replacing "heat_previous_period'" with "cntrl'Off"
makes:  << ( cntrl'Off ) = heat_control >>

This Proof Obligation:

[serial 2454]: Regulate::manage_heat_source.impl
P [400] << heat_control = cntrl'Off >>
S [401]heat_previous_period' := cntrl'Off
Q [402] << heat_previous_period' = heat_control >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1061]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 2457]: Regulate::manage_heat_source.impl
P [400] << heat_control = cntrl'Off >>
S [401]->
Q [402] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2454]
. . . done applying atomic actions [8.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 2451]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1061]

[serial 2452]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1061]

[serial 2455]: Regulate::manage_heat_source.impl
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2453]

[serial 2456]: Regulate::manage_heat_source.impl
P [399] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() )
  and ( heat_control = cntrl'Off )^0 >>
S [399]->
Q [400] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2453]

[serial 2457]: Regulate::manage_heat_source.impl
P [400] << heat_control = cntrl'Off >>
S [401]->
Q [402] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2454]
Done reducing atomic actions
step:  179
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2451]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1061]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2458]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and true
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.7 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2452]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1061]

[serial 2455]: Regulate::manage_heat_source.impl
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2453]

[serial 2456]: Regulate::manage_heat_source.impl
P [399] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() )
  and ( heat_control = cntrl'Off )^0 >>
S [399]->
Q [400] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2453]

[serial 2457]: Regulate::manage_heat_source.impl
P [400] << heat_control = cntrl'Off >>
S [401]->
Q [402] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2454]

[serial 2458]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and true
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  180
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2456]: Regulate::manage_heat_source.impl
P [399] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() )
  and ( heat_control = cntrl'Off )^0 >>
S [399]->
Q [400] << heat_control = cntrl'Off >>
What for:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2453]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2459]: Regulate::manage_heat_source.impl
P [399] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS()
  and ( heat_control = cntrl'Off )^0 >>
S [399]->
Q [400] << heat_control = cntrl'Off >>
What for:  Associativity: (b.c).a = a.b.c [serial 2456]

This Proof Obligation:

[serial 2458]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and true
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2460]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:  Law of And-Simplification:  P and true is P [serial 2458]
. . . done Applying Laws [8.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2452]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1061]

[serial 2455]: Regulate::manage_heat_source.impl
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2453]

[serial 2457]: Regulate::manage_heat_source.impl
P [400] << heat_control = cntrl'Off >>
S [401]->
Q [402] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2454]

[serial 2459]: Regulate::manage_heat_source.impl
P [399] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS()
  and ( heat_control = cntrl'Off )^0 >>
S [399]->
Q [400] << heat_control = cntrl'Off >>
What for:  Associativity: (b.c).a = a.b.c [serial 2456]

[serial 2460]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:  Law of And-Simplification:  P and true is P [serial 2458]
Done applying laws
step:  181
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2452]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << ( INVMHS() )^1 >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1061]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2462]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2452]

This Proof Obligation:

[serial 2455]: Regulate::manage_heat_source.impl
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399]->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
What for:  applied port output of enumeration type  heat_control!(') [serial 2453]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2464]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2455]

This Proof Obligation:

[serial 2457]: Regulate::manage_heat_source.impl
P [400] << heat_control = cntrl'Off >>
S [401]->
Q [402] << ( cntrl'Off ) = heat_control >>
What for:  applied wp for assignment [serial 2454]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2466]: Regulate::manage_heat_source.impl
P [400] << cntrl'Off = heat_control >>
S [401]->
Q [402] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2457]

This Proof Obligation:

[serial 2459]: Regulate::manage_heat_source.impl
P [399] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS()
  and ( heat_control = cntrl'Off )^0 >>
S [399]->
Q [400] << heat_control = cntrl'Off >>
What for:  Associativity: (b.c).a = a.b.c [serial 2456]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2468]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and ( cntrl'Off = heat_control )^0 >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2459]

This Proof Obligation:

[serial 2460]: Regulate::manage_heat_source.impl
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344]->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
What for:  Law of And-Simplification:  P and true is P [serial 2458]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2470]: Regulate::manage_heat_source.impl
P [344] << cntrl'Off = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [397] << cntrl'Off = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:    normalization of [serial 2460]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2462]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2452]

[serial 2464]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2455]

[serial 2466]: Regulate::manage_heat_source.impl
P [400] << cntrl'Off = heat_control >>
S [401]->
Q [402] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2457]

[serial 2468]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and ( cntrl'Off = heat_control )^0 >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2459]

[serial 2470]: Regulate::manage_heat_source.impl
P [344] << cntrl'Off = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [397] << cntrl'Off = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:    normalization of [serial 2460]
Done Normalizing
step:  182
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2466]: Regulate::manage_heat_source.impl
P [400] << cntrl'Off = heat_control >>
S [401]->
Q [402] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2457]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 2470]: Regulate::manage_heat_source.impl
P [344] << cntrl'Off = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344]->
Q [397] << cntrl'Off = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
What for:    normalization of [serial 2460]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 2462]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2452]

[serial 2464]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2455]

[serial 2468]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and ( cntrl'Off = heat_control )^0 >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2459]
Done trying to apply axioms
step:  183
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2462]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period' = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2452]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2476]: Regulate::manage_heat_source.impl
P [402] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2462]

This Proof Obligation:

[serial 2468]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and ( cntrl'Off = heat_control )^0 >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2459]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2477]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and ( ( cntrl'Off )^0 = ( heat_control )^0 ) >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2468]
. . . done spltting timed atoms  [8.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.7 seconds ]
After "dist^" remaining 
Obligations:

[serial 2464]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2455]

[serial 2476]: Regulate::manage_heat_source.impl
P [402] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2462]

[serial 2477]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and ( ( cntrl'Off )^0 = ( heat_control )^0 ) >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2468]
Done distributing ^ and @.
step:  184
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2476]: Regulate::manage_heat_source.impl
P [402] << ( heat_previous_period )^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2462]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2480]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2476]

This Proof Obligation:

[serial 2477]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and ( ( cntrl'Off )^0 = ( heat_control )^0 ) >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2468]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2482]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and cntrl'Off^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2477]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2464]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2455]

[serial 2480]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2476]

[serial 2482]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and cntrl'Off^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2477]
Done Normalizing
step:  185
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2482]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_previous_period
  and cntrl'Off^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:    normalization of [serial 2477]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2485]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_control
  and cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2482]
. . . done replacing P@now and P^0 with P  [8.7 seconds ]
After assuming present remaining 
Obligations:

[serial 2464]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2455]

[serial 2480]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2476]

[serial 2485]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_control
  and cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2482]
Done assuming present.
step:  186
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2485]: Regulate::manage_heat_source.impl
P [399] << cntrl'Off = heat_control
  and cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [400] << cntrl'Off = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2482]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 2464]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2455]

[serial 2480]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2476]
Done trying to apply axioms
step:  187
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2464]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
What for:    normalization of [serial 2455]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2486]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t ) )
   or ( REGULATOR_MODE(x : mmode'Init) )
   or ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
   or ( REGULATOR_MODE(x : mmode'Failed) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2464]

This Proof Obligation:

[serial 2480]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << INVMHS()^1 >>
What for:    normalization of [serial 2476]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2487]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2480]
. . . done substituting assertions' for Labels [8.7 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2486]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t ) )
   or ( REGULATOR_MODE(x : mmode'Init) )
   or ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
   or ( REGULATOR_MODE(x : mmode'Failed) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2464]

[serial 2487]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2480]
Done substituting Assertion labels in postconditions.
step:  188
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2486]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t ) )
   or ( REGULATOR_MODE(x : mmode'Init) )
   or ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
   or ( REGULATOR_MODE(x : mmode'Failed) ) >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2464]
Reasons solved:  
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2489]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or REGULATOR_MODE(x : mmode'Failed)
   or REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2486]

This Proof Obligation:

[serial 2487]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 2480]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 2491]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2487]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2489]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or REGULATOR_MODE(x : mmode'Failed)
   or REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2486]

[serial 2491]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2487]
Done Normalizing
step:  189
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2491]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
What for:    normalization of [serial 2487]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2494]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2491]
. . . done spltting timed atoms  [8.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.7 seconds ]
After "dist^" remaining 
Obligations:

[serial 2489]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or REGULATOR_MODE(x : mmode'Failed)
   or REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2486]

[serial 2494]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2491]
Done distributing ^ and @.
step:  190
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2494]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2491]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2497]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2494]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2489]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or REGULATOR_MODE(x : mmode'Failed)
   or REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2486]

[serial 2497]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2494]
Done Normalizing
step:  191
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2497]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_control^0 = heat_previous_period^1 >>
What for:    normalization of [serial 2494]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2499]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2497]
. . . done replacing P@now and P^0 with P  [8.7 seconds ]
After assuming present remaining 
Obligations:

[serial 2489]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or REGULATOR_MODE(x : mmode'Failed)
   or REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2486]

[serial 2499]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2497]
Done assuming present.
step:  192
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2499]: Regulate::manage_heat_source.impl
P [402] << heat_previous_period^1 = heat_control >>
S [341]->
Q [302] << heat_previous_period^1 = heat_control >>
What for:  Assume Present:  P = P@now = P^0   [serial 2497]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 2489]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or REGULATOR_MODE(x : mmode'Failed)
   or REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2486]
Done trying to apply axioms
step:  193
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2489]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or REGULATOR_MODE(x : mmode'Failed)
   or REGULATOR_MODE(x : mmode'Init) >>
What for:    normalization of [serial 2486]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2500]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and ( HEAT_CONTROL^-1 = heat_control^-1 )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or ( not REGULATOR_OK()
  and RUN() )
   or ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2489]
. . . done substituting assertions' for Labels [8.7 seconds ]
After "substitute" remaining 
Obligations:

[serial 2500]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and ( HEAT_CONTROL^-1 = heat_control^-1 )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or ( not REGULATOR_OK()
  and RUN() )
   or ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2489]
Done substituting Assertion labels.
step:  194
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2500]: Regulate::manage_heat_source.impl
P [397] << cntrl'Off = heat_previous_period
  and ( HEAT_CONTROL^-1 = heat_control^-1 )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or ( not REGULATOR_OK()
  and RUN() )
   or ( INI() ) >>
What for:  Substituted assertions' predicates for labels  [serial 2489]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2502]: Regulate::manage_heat_source.impl
P [397] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:    normalization of [serial 2500]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2502]: Regulate::manage_heat_source.impl
P [397] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:    normalization of [serial 2500]
Done Normalizing
step:  195
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2502]: Regulate::manage_heat_source.impl
P [397] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:    normalization of [serial 2500]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2504]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2502]
. . . done Applying Laws [8.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2504]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2502]
Done applying laws
step:  196
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2504]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2502]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2506]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:    normalization of [serial 2504]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2506]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:    normalization of [serial 2504]
Done Normalizing
step:  197
****range-exp****
Replacing Ranges with Boolean Expressions
replacing ranges with boolean expressions . . .

This Proof Obligation:

[serial 2506]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:    normalization of [serial 2504]
Reason solved:  Replace expression with range:   a<=x and x<=b  iff  x in a..b
Has applied Replace expression with range:   a<=x and x<=b  iff  x in a..b  to get:

[serial 2508]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2506]
. . . done replacing ranges with boolean expressions  [8.7 seconds ]
After changing ranges to boolean expressions: 
Obligations:

[serial 2508]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2506]
Done changing ranges to boolean expressions
step:  198
****equivalent****
Adding equivalent terms to conjunctions having an equality term . . .
Adding equivalent terms to conjunction . . .
Add Equivalent Term:  heat_control^-1 = heat_previous_period and cntrl'Off = heat_previous_period -> heat_control^-1 = cntrl'Off
Add Equivalent Term:  heat_control^-1 = heat_previous_period and HEAT_CONTROL^-1 = heat_control^-1 -> HEAT_CONTROL^-1 = heat_previous_period
Add Equivalent Term:  cntrl'Off = heat_previous_period and heat_control^-1 = heat_previous_period -> cntrl'Off = heat_control^-1
Add Equivalent Term:  HEAT_CONTROL^-1 = heat_control^-1 and heat_control^-1 = heat_previous_period -> HEAT_CONTROL^-1 = heat_previous_period

This Proof Obligation:

[serial 2508]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2506]
Reason solved:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b
Has applied Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  to get:

[serial 2509]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2508]
. . . done adding equivalent terms [8.7 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2509]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2508]
Done adding equivalent terms
step:  199
****equivalent****
Adding equivalent terms to conjunctions having an equality term . . .
Adding equivalent terms to conjunction . . .
Add Equivalent Term:  cntrl'Off = heat_previous_period and cntrl'Off = heat_control^-1 -> heat_control^-1 = heat_previous_period
Add Equivalent Term:  HEAT_CONTROL^-1 = heat_control^-1 and cntrl'Off = heat_control^-1 -> HEAT_CONTROL^-1 = cntrl'Off
Add Equivalent Term:  heat_control^-1 = heat_previous_period and cntrl'Off = heat_control^-1 -> cntrl'Off = heat_previous_period
Add Equivalent Term:  cntrl'Off = heat_control^-1 and cntrl'Off = heat_previous_period -> heat_previous_period = heat_control^-1
Add Equivalent Term:  HEAT_CONTROL^-1 = heat_previous_period and cntrl'Off = heat_previous_period -> HEAT_CONTROL^-1 = cntrl'Off
Add Equivalent Term:  heat_control^-1 = heat_previous_period and cntrl'Off = heat_previous_period -> heat_control^-1 = cntrl'Off
Add Equivalent Term:  cntrl'Off = heat_control^-1 and HEAT_CONTROL^-1 = heat_control^-1 -> cntrl'Off = HEAT_CONTROL^-1
Add Equivalent Term:  HEAT_CONTROL^-1 = heat_previous_period and HEAT_CONTROL^-1 = heat_control^-1 -> heat_control^-1 = heat_previous_period
Add Equivalent Term:  heat_control^-1 = heat_previous_period and HEAT_CONTROL^-1 = heat_control^-1 -> HEAT_CONTROL^-1 = heat_previous_period
Add Equivalent Term:  cntrl'Off = heat_previous_period and HEAT_CONTROL^-1 = heat_previous_period -> cntrl'Off = HEAT_CONTROL^-1
Add Equivalent Term:  HEAT_CONTROL^-1 = heat_control^-1 and HEAT_CONTROL^-1 = heat_previous_period -> heat_previous_period = heat_control^-1
Add Equivalent Term:  heat_control^-1 = heat_previous_period and HEAT_CONTROL^-1 = heat_previous_period -> heat_control^-1 = HEAT_CONTROL^-1
Add Equivalent Term:  cntrl'Off = heat_control^-1 and heat_control^-1 = heat_previous_period -> cntrl'Off = heat_previous_period
Add Equivalent Term:  cntrl'Off = heat_previous_period and heat_control^-1 = heat_previous_period -> cntrl'Off = heat_control^-1
Add Equivalent Term:  HEAT_CONTROL^-1 = heat_control^-1 and heat_control^-1 = heat_previous_period -> HEAT_CONTROL^-1 = heat_previous_period
Add Equivalent Term:  HEAT_CONTROL^-1 = heat_previous_period and heat_control^-1 = heat_previous_period -> HEAT_CONTROL^-1 = heat_control^-1

This Proof Obligation:

[serial 2509]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2508]
Reason solved:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b
Has applied Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  to get:

[serial 2510]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2509]
. . . done adding equivalent terms [8.7 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2510]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2509]
Done adding equivalent terms
step:  200
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2510]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2509]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2512]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:    normalization of [serial 2510]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2512]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:    normalization of [serial 2510]
Done Normalizing
step:  201
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2512]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:    normalization of [serial 2510]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 2514]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Law of And-Simplification:  P and P is P [serial 2512]

This Proof Obligation:

[serial 2514]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Law of And-Simplification:  P and P is P [serial 2512]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 2515]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Law of And-Simplification:  P and P is P [serial 2514]

This Proof Obligation:

[serial 2515]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Law of And-Simplification:  P and P is P [serial 2514]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2516]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2515]
. . . done Applying Laws [8.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2516]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2515]
Done applying laws
step:  202
****axioms****
Applying Axioms . . .
AXIOM.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1


This Proof Obligation:

[serial 2516]: Regulate::manage_heat_source.impl
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399]->
Q [98] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2515]
Reason solved:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
Has been solved by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
. . . done Applying Axioms [8.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1033]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [204]->
Q [204] << true >>
What for:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
Main proof script resumed.
step:  8
# manage_regulator_mode_mrm.impl
step:  9
****subscript****
You chose proof subscript: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/subscripts/mrm.ps
step:  1
#  You chose proof script: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/subscripts/mrm.ps
step:  2
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  3
****sort-by-component****
sorting proof obligations for Regulate::manage_regulator_mode.impl
Regulate::manage_regulator_mode.impl  [serial 1033]  
Regulate::manage_regulator_mode.impl  [serial 1034]  
Regulate::manage_regulator_mode.impl  [serial 1035]  
Regulate::manage_regulator_mode.impl  [serial 1036]  
Regulate::manage_regulator_mode.impl  [serial 1037]  
Regulate::manage_regulator_mode.impl  [serial 1038]  
Regulate::manage_regulator_mode.impl  [serial 1039]  
Regulate::manage_regulator_mode.impl  [serial 1040]  
Regulate::manage_regulator_mode.impl  [serial 1041]  
Regulate::manage_regulator_mode.impl  [serial 1042]  
Regulate::manage_regulator_mode.impl  [serial 1043]  
Regulate::manage_regulator_mode.impl  [serial 1044]  
Regulate::manage_regulator_mode.impl  [serial 1045]  
manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure  [serial 1062]  
manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode  [serial 1063]  
manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode  [serial 1064]  
manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure  [serial 1065]  
manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode  [serial 1066]  
manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode  [serial 1067]  
detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure  [serial 1068]  
air_temperature -> temperature_sensor.air  [serial 1069]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature  [serial 1070]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature  [serial 1071]  
temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature  [serial 1072]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature  [serial 1073]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature  [serial 1074]  
temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature  [serial 1075]  
thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status  [serial 1076]  
thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature  [serial 1077]  
thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control  [serial 1078]  
thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm  [serial 1079]  
thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status  [serial 1080]  
operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp  [serial 1081]  
operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature  [serial 1082]  
operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp  [serial 1083]  
operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature  [serial 1084]  
operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature  [serial 1085]  
operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature  [serial 1086]  
operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature  [serial 1087]  
operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature  [serial 1088]  
Monitor::monitor_temperature.impl.mcti  [serial 1089]  
Monitor::monitor_temperature.impl.mcta  [serial 1090]  
Monitor::monitor_temperature.impl.mctm  [serial 1091]  
Monitor::monitor_temperature.impl.muat  [serial 1092]  
Monitor::monitor_temperature.impl.mlat  [serial 1093]  
Monitor::monitor_temperature.impl.maul  [serial 1094]  
Monitor::monitor_temperature.impl.mall  [serial 1095]  
Monitor::monitor_temperature.impl.malrm  [serial 1096]  
Monitor::monitor_temperature.impl.mms  [serial 1097]  
Monitor::monitor_temperature.impl.intff  [serial 1098]  
Monitor::monitor_temperature.impl.mf  [serial 1099]  
Monitor::monitor_temperature.impl.mmmi  [serial 1100]  
Monitor::monitor_temperature.impl.mmma  [serial 1101]  
KSU_Isolette::isolette.single_sensor.a2ts  [serial 1102]  
KSU_Isolette::isolette.single_sensor.ct  [serial 1103]  
KSU_Isolette::isolette.single_sensor.hc  [serial 1104]  
KSU_Isolette::isolette.single_sensor.ldt  [serial 1105]  
KSU_Isolette::isolette.single_sensor.udt  [serial 1106]  
KSU_Isolette::isolette.single_sensor.lat  [serial 1107]  
KSU_Isolette::isolette.single_sensor.uat  [serial 1108]  
KSU_Isolette::isolette.single_sensor.rs  [serial 1109]  
KSU_Isolette::isolette.single_sensor.ms  [serial 1110]  
KSU_Isolette::isolette.single_sensor.dt  [serial 1111]  
KSU_Isolette::isolette.single_sensor.al  [serial 1112]  
KSU_Isolette::isolette.dual_sensor.a2cs  [serial 1113]  
KSU_Isolette::isolette.dual_sensor.a2ms  [serial 1114]  
KSU_Isolette::isolette.dual_sensor.cont  [serial 1115]  
KSU_Isolette::isolette.dual_sensor.ct  [serial 1116]  
KSU_Isolette::isolette.dual_sensor.hc  [serial 1117]  
KSU_Isolette::isolette.dual_sensor.ldt  [serial 1118]  
KSU_Isolette::isolette.dual_sensor.udt  [serial 1119]  
KSU_Isolette::isolette.dual_sensor.lat  [serial 1120]  
KSU_Isolette::isolette.dual_sensor.uat  [serial 1121]  
KSU_Isolette::isolette.dual_sensor.rs  [serial 1122]  
KSU_Isolette::isolette.dual_sensor.ms  [serial 1123]  
KSU_Isolette::isolette.dual_sensor.dt  [serial 1124]  
KSU_Isolette::isolette.dual_sensor.al  [serial 1125]  
KSU_Isolette::thermostat_single_sensor.impl.tctm  [serial 1126]  
KSU_Isolette::thermostat_single_sensor.impl.tctr  [serial 1127]  
KSU_Isolette::thermostat_single_sensor.impl.thc  [serial 1128]  
KSU_Isolette::thermostat_single_sensor.impl.tudt  [serial 1129]  
KSU_Isolette::thermostat_single_sensor.impl.tldt  [serial 1130]  
KSU_Isolette::thermostat_single_sensor.impl.tuat  [serial 1131]  
KSU_Isolette::thermostat_single_sensor.impl.tlat  [serial 1132]  
KSU_Isolette::thermostat_single_sensor.impl.trs  [serial 1133]  
KSU_Isolette::thermostat_single_sensor.impl.tdt  [serial 1134]  
KSU_Isolette::thermostat_single_sensor.impl.tms  [serial 1135]  
KSU_Isolette::thermostat_single_sensor.impl.ta  [serial 1136]  
KSU_Isolette::thermostat_single_sensor.impl.tf  [serial 1137]  
KSU_Isolette::thermostat_dual_sensor.impl.tctm  [serial 1138]  
KSU_Isolette::thermostat_dual_sensor.impl.tctr  [serial 1139]  
KSU_Isolette::thermostat_dual_sensor.impl.thc  [serial 1140]  
KSU_Isolette::thermostat_dual_sensor.impl.tudt  [serial 1141]  
KSU_Isolette::thermostat_dual_sensor.impl.tldt  [serial 1142]  
KSU_Isolette::thermostat_dual_sensor.impl.tuat  [serial 1143]  
KSU_Isolette::thermostat_dual_sensor.impl.tlat  [serial 1144]  
KSU_Isolette::thermostat_dual_sensor.impl.trs  [serial 1145]  
KSU_Isolette::thermostat_dual_sensor.impl.tdt  [serial 1146]  
KSU_Isolette::thermostat_dual_sensor.impl.tms  [serial 1147]  
KSU_Isolette::thermostat_dual_sensor.impl.ta  [serial 1148]  
KSU_Isolette::thermostat_dual_sensor.impl.tf  [serial 1149]  
Nursery::Room.Normal_Operation.tmp  [serial 1150]  
Regulate::regulate_temperature.impl.rudt  [serial 1151]  
Regulate::regulate_temperature.impl.rldt  [serial 1152]  
Regulate::regulate_temperature.impl.mudt  [serial 1153]  
Regulate::regulate_temperature.impl.mldt  [serial 1154]  
Regulate::regulate_temperature.impl.rrs  [serial 1155]  
Regulate::regulate_temperature.impl.rdt  [serial 1156]  
Regulate::regulate_temperature.impl.rcti  [serial 1157]  
Regulate::regulate_temperature.impl.rcth  [serial 1158]  
Regulate::regulate_temperature.impl.rhc  [serial 1159]  
Regulate::regulate_temperature.impl.rrmh  [serial 1160]  
Regulate::regulate_temperature.impl.rrmi  [serial 1161]  
Regulate::regulate_temperature.impl.rctm  [serial 1162]  
Regulate::regulate_temperature.impl.rif  [serial 1163]  
After sort-by-component[Regulate::manage_regulator_mode.impl], no change. 
step:  4
#Regulate::manage_regulator_mode.impl
step:  5
#[serial 1033] <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definitio
step:  6
****make-an****
Making obligation 62
Obligations:

[serial 1033]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [204]->
Q [204] << true >>
What for:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.
Done making obligation 62
step:  7
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1033]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [204]->
Q [204] << true >>
What for:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1034]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [204]->
Q [204] << true >>
What for:  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  8
#[serial 1034] <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
step:  9
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1034]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [204]->
Q [204] << true >>
What for:  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1035]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  10
#[serial 1035] Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>
step:  11
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1035]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2518]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
   or ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1035]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2518]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
   or ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1035]
Done Normalizing
step:  12
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 2518]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
   or ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 1035]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2520]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2518]
. . . Substituting <= with not < [8.7 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 2520]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2518]
Done replacing a<=b with (not b<a)
step:  13
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2520]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2518]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2522]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( status'Valid = current_temperature_status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2520]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2522]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( status'Valid = current_temperature_status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2520]
Done Normalizing
step:  14
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 2522]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( status'Valid = current_temperature_status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2520]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 2524]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2522]
. . . done putting into conjunctive normal form [8.7 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 2524]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2522]
Done making conjunctive normal forms.
step:  15
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2524]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2522]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 2525]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2524]

This Proof Obligation:

[serial 2525]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2524]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 2526]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( true )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2525]

This Proof Obligation:

[serial 2526]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( true )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2525]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 2527]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2526]

This Proof Obligation:

[serial 2527]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2526]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2528]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2527]
. . . done Applying Laws [8.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2528]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2527]
Done applying laws
step:  16
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2528]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2527]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2530]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
  and true
  and true >>
What for:    normalization of [serial 2528]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2530]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
  and true
  and true >>
What for:    normalization of [serial 2528]
Done Normalizing
step:  17
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2530]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
  and true
  and true >>
What for:    normalization of [serial 2528]
Reason solved:  Law of Or-Simplification: P or P is P
Has applied law "Law of Or-Simplification: P or P is P " to get:

[serial 2532]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2530]

This Proof Obligation:

[serial 2532]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2530]
Reason solved:  Law of Or-Simplification: P or P is P
Has applied law "Law of Or-Simplification: P or P is P " to get:

[serial 2533]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2532]
. . . done Applying Laws [8.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2533]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2532]
Done applying laws
step:  18
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2533]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2532]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2535]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
What for:    normalization of [serial 2533]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2535]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
What for:    normalization of [serial 2533]
Done Normalizing
step:  19
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 2535]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
What for:    normalization of [serial 2533]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 2537]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not ( INTERNAL_FAILURE^0 )
  and not ( REGULATOR_INTERFACE_FAILURE^0 ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2535]
. . . done applying DeMorgan's Law  [8.7 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 2537]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not ( INTERNAL_FAILURE^0 )
  and not ( REGULATOR_INTERFACE_FAILURE^0 ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2535]
step:  20
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2537]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not ( INTERNAL_FAILURE^0 )
  and not ( REGULATOR_INTERFACE_FAILURE^0 ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2535]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2539]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2537]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2539]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2537]
Done Normalizing
step:  21
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 2539]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2537]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 2541]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( not INTERNAL_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2539]
. . . done putting into conjunctive normal form [8.7 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 2541]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( not INTERNAL_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2539]
Done making conjunctive normal forms.
step:  22
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2541]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( not INTERNAL_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2539]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2543]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not INTERNAL_FAILURE^0 )
  and ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not REGULATOR_INTERFACE_FAILURE^0 ) >>
What for:    normalization of [serial 2541]
. . . done Normalizing Unsolved Proof Obligations [8.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2543]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not INTERNAL_FAILURE^0 )
  and ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not REGULATOR_INTERFACE_FAILURE^0 ) >>
What for:    normalization of [serial 2541]
Done Normalizing
step:  23
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2543]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not INTERNAL_FAILURE^0 )
  and ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not REGULATOR_INTERFACE_FAILURE^0 ) >>
What for:    normalization of [serial 2541]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 2545]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2543]

This Proof Obligation:

[serial 2545]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2543]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 2546]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2545]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2546]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2545]
Done applying laws
step:  24
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2546]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2545]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2548]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << true >>
What for:    normalization of [serial 2546]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2548]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << true >>
What for:    normalization of [serial 2546]
Done Normalizing
step:  25
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2548]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [215] << true >>
What for:    normalization of [serial 2546]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1036]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [212]->
Q [212] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  26
#[serial 1036] Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
step:  27
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1036]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [212]->
Q [212] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1037]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [219]->
Q [219] << ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  28
#[serial 1037] Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
step:  29
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1037]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [219]->
Q [219] << ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 2550]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [219]->
Q [219] << ( ( not ( REGULATOR_INTERFACE_FAILURE^0 )
  and not ( INTERNAL_FAILURE^0 ) )
  and ( current_temperature_status = status'Valid ) )
   or ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1037]
. . . done applying DeMorgan's Law  [8.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 2550]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [219]->
Q [219] << ( ( not ( REGULATOR_INTERFACE_FAILURE^0 )
  and not ( INTERNAL_FAILURE^0 ) )
  and ( current_temperature_status = status'Valid ) )
   or ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1037]
step:  30
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2550]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [219]->
Q [219] << ( ( not ( REGULATOR_INTERFACE_FAILURE^0 )
  and not ( INTERNAL_FAILURE^0 ) )
  and ( current_temperature_status = status'Valid ) )
   or ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1037]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2552]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
  and status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:    normalization of [serial 2550]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2552]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
  and status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:    normalization of [serial 2550]
Done Normalizing
step:  31
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 2552]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
  and status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:    normalization of [serial 2550]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 2554]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
  and ( status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2552]
. . . done putting into conjunctive normal form [8.8 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 2554]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
  and ( status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2552]
Done making conjunctive normal forms.
step:  32
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2554]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
  and ( status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2552]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 2555]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2554]

This Proof Obligation:

[serial 2555]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2554]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2556]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( true ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2555]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2556]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( true ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2555]
Done applying laws
step:  33
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2556]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( true ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2555]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2558]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and true >>
What for:    normalization of [serial 2556]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2558]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and true >>
What for:    normalization of [serial 2556]
Done Normalizing
step:  34
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2558]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and true >>
What for:    normalization of [serial 2556]
Reason solved:  Law of Or-Simplification: P or P is P
Has applied law "Law of Or-Simplification: P or P is P " to get:

[serial 2560]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2558]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2560]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2558]
Done applying laws
step:  35
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2560]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2558]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2562]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2560]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2562]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2560]
Done Normalizing
step:  36
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 2562]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2560]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 2564]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( not INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2562]
. . . done putting into conjunctive normal form [8.8 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 2564]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( not INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2562]
Done making conjunctive normal forms.
step:  37
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2564]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( not INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2562]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 2565]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2564]

This Proof Obligation:

[serial 2565]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 2564]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 2566]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2565]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2566]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2565]
Done applying laws
step:  38
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2566]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 2565]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2568]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << true >>
What for:    normalization of [serial 2566]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2568]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << true >>
What for:    normalization of [serial 2566]
Done Normalizing
step:  39
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2568]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [219] << true >>
What for:    normalization of [serial 2566]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1038]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]  start_time := now
  << ( start_time = now )
    and AXIOM_TOGT0()
    and AXIOM_STR() >>
  ;
  regulator_mode!(mmode'Init) 
Q [213] << ( true )^1 >>
What for:   <<M(start)>> A <<M(init)>> for mrm1: start-[ ]->init{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  40
#[serial 1038]  <<M(start)>> A <<M(init)>> for mrm1: start-[ ]->init{A};
step:  41
****reduce****
This proof obligation:

[serial 1038]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]  start_time := now
  << ( start_time = now )
    and AXIOM_TOGT0()
    and AXIOM_STR() >>
  ;
  regulator_mode!(mmode'Init) 
Q [213] << ( true )^1 >>
What for:   <<M(start)>> A <<M(init)>> for mrm1: start-[ ]->init{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 2570]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]start_time := now
Q [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1038]

[serial 2571]: Regulate::manage_regulator_mode.impl
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230]regulator_mode!(mmode'Init)
Q [302] << ( true )^1 >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1038]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2570]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]start_time := now
Q [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1038]

[serial 2571]: Regulate::manage_regulator_mode.impl
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230]regulator_mode!(mmode'Init)
Q [302] << ( true )^1 >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1038]
done reducing composite actions
step:  42
****atomic****
applying atomic actions . . .
solving assignment on line 226
replacing "start_time" with "now"
makes:  << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>

This Proof Obligation:

[serial 2570]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]start_time := now
Q [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1038]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 2572]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
What for:  applied wp for assignment [serial 2570]
Proof.reducePortOutput portValue=<< +=> REGULATOR_MODE(x : regulator_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<REGULATOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> REGULATOR_OK()
    and RUN(),
    Failed -> not REGULATOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Init" is:  
^{INVOKE[INI] INI}

This Proof Obligation:

[serial 2571]: Regulate::manage_regulator_mode.impl
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230]regulator_mode!(mmode'Init)
Q [302] << ( true )^1 >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1038]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> regulator_mode!(') <<post>> to get:

[serial 2573]: Regulate::manage_regulator_mode.impl
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230]->
Q [133] << INI() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2571]

The Same Proof Obligation:
Has applied <<pre and (regulator_mode=mmode'Init)^0>> -> <<post>> for  <<pre>> regulator_mode!(') <<post>> to get:

[serial 2574]: Regulate::manage_regulator_mode.impl
P [230] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() )
  and ( regulator_mode = mmode'Init )^0 >>
S [230]->
Q [302] << ( true )^1 >>
What for:  applied port output <<pre and (regulator_mode=mmode'Init)^0>> -> <<post>> [serial 2571]

[serial 2574]: Regulate::manage_regulator_mode.impl
P [230] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() )
  and ( regulator_mode = mmode'Init )^0 >>
S [230]->
Q [302] << ( true )^1 >>
What for:  applied port output <<pre and (regulator_mode=mmode'Init)^0>> -> <<post>> [serial 2571]
. . . done applying atomic actions [8.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 2572]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
What for:  applied wp for assignment [serial 2570]

[serial 2573]: Regulate::manage_regulator_mode.impl
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230]->
Q [133] << INI() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2571]

[serial 2574]: Regulate::manage_regulator_mode.impl
P [230] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() )
  and ( regulator_mode = mmode'Init )^0 >>
S [230]->
Q [302] << ( true )^1 >>
What for:  applied port output <<pre and (regulator_mode=mmode'Init)^0>> -> <<post>> [serial 2571]
Done reducing atomic actions
step:  43
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2572]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
What for:  applied wp for assignment [serial 2570]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2575]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( now = now )
  and true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.8 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2573]: Regulate::manage_regulator_mode.impl
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230]->
Q [133] << INI() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2571]

[serial 2574]: Regulate::manage_regulator_mode.impl
P [230] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() )
  and ( regulator_mode = mmode'Init )^0 >>
S [230]->
Q [302] << ( true )^1 >>
What for:  applied port output <<pre and (regulator_mode=mmode'Init)^0>> -> <<post>> [serial 2571]

[serial 2575]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( now = now )
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  44
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2574]: Regulate::manage_regulator_mode.impl
P [230] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() )
  and ( regulator_mode = mmode'Init )^0 >>
S [230]->
Q [302] << ( true )^1 >>
What for:  applied port output <<pre and (regulator_mode=mmode'Init)^0>> -> <<post>> [serial 2571]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2576]: Regulate::manage_regulator_mode.impl
P [230] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR()
  and ( regulator_mode = mmode'Init )^0 >>
S [230]->
Q [302] << ( true )^1 >>
What for:  Associativity: (b.c).a = a.b.c [serial 2574]

This Proof Obligation:

[serial 2575]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( now = now )
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 2577]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( true )
  and true
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2575]

This Proof Obligation:

[serial 2577]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( true )
  and true
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2575]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2578]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( ( true ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2577]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2573]: Regulate::manage_regulator_mode.impl
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230]->
Q [133] << INI() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2571]

[serial 2576]: Regulate::manage_regulator_mode.impl
P [230] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR()
  and ( regulator_mode = mmode'Init )^0 >>
S [230]->
Q [302] << ( true )^1 >>
What for:  Associativity: (b.c).a = a.b.c [serial 2574]

[serial 2578]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( ( true ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2577]
Done applying laws
step:  45
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2573]: Regulate::manage_regulator_mode.impl
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230]->
Q [133] << INI() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2571]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2580]: Regulate::manage_regulator_mode.impl
P [227] << now = start_time
  and AXIOM_STR()
  and AXIOM_TOGT0() >>
S [230]->
Q [133] << INI() >>
What for:    normalization of [serial 2573]

This Proof Obligation:

[serial 2576]: Regulate::manage_regulator_mode.impl
P [230] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR()
  and ( regulator_mode = mmode'Init )^0 >>
S [230]->
Q [302] << ( true )^1 >>
What for:  Associativity: (b.c).a = a.b.c [serial 2574]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Constants are always the same
Has been normalized to get:

[serial 2582]: Regulate::manage_regulator_mode.impl
P [230] << now = start_time
  and AXIOM_STR()
  and AXIOM_TOGT0()
  and ( mmode'Init = regulator_mode )^0 >>
S [230]->
Q [302] << true >>
What for:    normalization of [serial 2576]

This Proof Obligation:

[serial 2578]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << ( ( true ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2577]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2584]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << true >>
What for:    normalization of [serial 2578]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2580]: Regulate::manage_regulator_mode.impl
P [227] << now = start_time
  and AXIOM_STR()
  and AXIOM_TOGT0() >>
S [230]->
Q [133] << INI() >>
What for:    normalization of [serial 2573]

[serial 2582]: Regulate::manage_regulator_mode.impl
P [230] << now = start_time
  and AXIOM_STR()
  and AXIOM_TOGT0()
  and ( mmode'Init = regulator_mode )^0 >>
S [230]->
Q [302] << true >>
What for:    normalization of [serial 2576]

[serial 2584]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << true >>
What for:    normalization of [serial 2578]
Done Normalizing
step:  46
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2582]: Regulate::manage_regulator_mode.impl
P [230] << now = start_time
  and AXIOM_STR()
  and AXIOM_TOGT0()
  and ( mmode'Init = regulator_mode )^0 >>
S [230]->
Q [302] << true >>
What for:    normalization of [serial 2576]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 2584]: Regulate::manage_regulator_mode.impl
P [212] << true >>
S [226]->
Q [227] << true >>
What for:    normalization of [serial 2578]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 2580]: Regulate::manage_regulator_mode.impl
P [227] << now = start_time
  and AXIOM_STR()
  and AXIOM_TOGT0() >>
S [230]->
Q [133] << INI() >>
What for:    normalization of [serial 2573]
Done trying to apply axioms
step:  47
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2580]: Regulate::manage_regulator_mode.impl
P [227] << now = start_time
  and AXIOM_STR()
  and AXIOM_TOGT0() >>
S [230]->
Q [133] << INI() >>
What for:    normalization of [serial 2573]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2588]: Regulate::manage_regulator_mode.impl
P [227] << now = start_time
  and ( start_time = START_TIME )
  and ( 0 < #Iso_Properties::Initialization_Timeout ) >>
S [230]->
Q [133] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2580]
. . . done substituting assertions' for Labels [8.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 2588]: Regulate::manage_regulator_mode.impl
P [227] << now = start_time
  and ( start_time = START_TIME )
  and ( 0 < #Iso_Properties::Initialization_Timeout ) >>
S [230]->
Q [133] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2580]
Done substituting Assertion labels.
step:  48
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2588]: Regulate::manage_regulator_mode.impl
P [227] << now = start_time
  and ( start_time = START_TIME )
  and ( 0 < #Iso_Properties::Initialization_Timeout ) >>
S [230]->
Q [133] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2580]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2590]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2588]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2590]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2588]
Done Normalizing
step:  49
****guided-sub-equals****
guided substitution of equals "START_TIME" . . .
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 2590]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2588]
Reason solved:  Guided Substitution of Equals
Has substituted 
"START_TIME" with its = "start_time"
 to get:

[serial 2592]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2590]
. . . done guided substitution of equals  [8.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2592]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2590]
Done guided substituting an equals
step:  50
****guided-sub-equals****
guided substitution of equals "now" . . .
equality selected for substitution:  now = start_time

This Proof Obligation:

[serial 2592]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << now - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2590]
Reason solved:  Guided Substitution of Equals
Has substituted 
"now" with its = "start_time"
 to get:

[serial 2593]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << start_time - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "now" with its = "start_time" in its postcondition [serial 2592]
. . . done guided substitution of equals  [8.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2593]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << start_time - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "now" with its = "start_time" in its postcondition [serial 2592]
Done guided substituting an equals
step:  51
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2593]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << start_time - start_time < #Iso_Properties::Initialization_Timeout s >>
What for:  Guided Substitution of Equals 
 replacing "now" with its = "start_time" in its postcondition [serial 2592]
Has been normalized to get:

[serial 2595]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << 0 < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2593]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2595]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << 0 < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2593]
Done Normalizing
step:  52
Removing units . . .
removing units . . .

This Proof Obligation:

[serial 2595]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << 0 < #Iso_Properties::Initialization_Timeout s >>
What for:    normalization of [serial 2593]
Reason solved:  Remove units from quantities
Has applied Remove units from quantities  to get:

[serial 2597]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << 0 < #Iso_Properties::Initialization_Timeout >>
What for:  Remove units from quantities  [serial 2595]
. . . done removing units  [8.8 seconds ]
After removing units remaining 
Obligations:

[serial 2597]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << 0 < #Iso_Properties::Initialization_Timeout >>
What for:  Remove units from quantities  [serial 2595]
Done extending tops to now.
step:  53
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2597]: Regulate::manage_regulator_mode.impl
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230]->
Q [133] << 0 < #Iso_Properties::Initialization_Timeout >>
What for:  Remove units from quantities  [serial 2595]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1039]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [235]  current_temperature?(temperature)
  ;
  current_temperature_status := temperature.status 
Q [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  54
#[serial 1039]  <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};
step:  55
****reduce****
This proof obligation:

[serial 1039]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [235]  current_temperature?(temperature)
  ;
  current_temperature_status := temperature.status 
Q [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 2598]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [235]current_temperature?(temperature)
Q [235] << true >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1039]

[serial 2599]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]current_temperature_status := temperature.status
Q [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1039]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2598]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [235]current_temperature?(temperature)
Q [235] << true >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1039]

[serial 2599]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]current_temperature_status := temperature.status
Q [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1039]
done reducing composite actions
step:  56
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 2598]: Regulate::manage_regulator_mode.impl
P [213] << true >>
S [235]current_temperature?(temperature)
Q [235] << true >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1039]
Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(current_temperature)>> -> <<post>> for <<pre>> current_temperature?(temperature) <<post>> to get:

[serial 2600]: Regulate::manage_regulator_mode.impl
P [235] << ( true )
  and temperature = CURRENT_TEMP >>
S [235]->
Q [235] << true >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2598]
solving assignment on line 237
replacing "current_temperature_status" with "temperature.status"
makes:  << temperature.status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>

This Proof Obligation:

[serial 2599]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]current_temperature_status := temperature.status
Q [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1039]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 2601]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << temperature.status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  applied wp for assignment [serial 2599]
. . . done applying atomic actions [8.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 2600]: Regulate::manage_regulator_mode.impl
P [235] << ( true )
  and temperature = CURRENT_TEMP >>
S [235]->
Q [235] << true >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2598]

[serial 2601]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << temperature.status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  applied wp for assignment [serial 2599]
Done reducing atomic actions
step:  57
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2601]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << temperature.status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  applied wp for assignment [serial 2599]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 2602]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << true
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2601]

This Proof Obligation:

[serial 2602]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << true
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2601]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2603]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  Law of And-Simplification:  P and true is P [serial 2602]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2600]: Regulate::manage_regulator_mode.impl
P [235] << ( true )
  and temperature = CURRENT_TEMP >>
S [235]->
Q [235] << true >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2598]

[serial 2603]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  Law of And-Simplification:  P and true is P [serial 2602]
Done applying laws
step:  58
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2600]: Regulate::manage_regulator_mode.impl
P [235] << ( true )
  and temperature = CURRENT_TEMP >>
S [235]->
Q [235] << true >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2598]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2605]: Regulate::manage_regulator_mode.impl
P [235] << CURRENT_TEMP = temperature
  and true >>
S [235]->
Q [235] << true >>
What for:    normalization of [serial 2600]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2603]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  Law of And-Simplification:  P and true is P [serial 2602]

[serial 2605]: Regulate::manage_regulator_mode.impl
P [235] << CURRENT_TEMP = temperature
  and true >>
S [235]->
Q [235] << true >>
What for:    normalization of [serial 2600]
Done Normalizing
step:  59
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2605]: Regulate::manage_regulator_mode.impl
P [235] << CURRENT_TEMP = temperature
  and true >>
S [235]->
Q [235] << true >>
What for:    normalization of [serial 2600]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 2603]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  Law of And-Simplification:  P and true is P [serial 2602]
Done trying to apply axioms
step:  60
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2603]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  Law of And-Simplification:  P and true is P [serial 2602]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2608]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.8 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2608]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  61
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2608]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << true
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2609]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 2608]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2609]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 2608]
Done applying laws
step:  62
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2609]: Regulate::manage_regulator_mode.impl
P [235] << true >>
S [237]->
Q [215] << true >>
What for:  Law of And-Simplification:  P and true is P [serial 2608]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1040]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [244]<< not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:   <<M(check_init) and x>> A <<M(failed)>> for mrm: check_init-[x]->failed{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  63
#[serial 1040]  <<M(check_init) and x>> A <<M(failed)>> for mrm: check_init-[x]->failed{A};
step:  64
****reduce****

[serial 2610]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215]->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1040]

[serial 2611]: Regulate::manage_regulator_mode.impl
P [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [246]regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1040]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2610]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215]->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1040]

[serial 2611]: Regulate::manage_regulator_mode.impl
P [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [246]regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1040]
done reducing composite actions
step:  65
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> REGULATOR_MODE(x : regulator_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<REGULATOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> REGULATOR_OK()
    and RUN(),
    Failed -> not REGULATOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Failed" is:  
^{and 
 ^{not 
  ^{INVOKE[REGULATOR_OK] REGULATOR_OK}} 
 ^{INVOKE[RUN] RUN}}

This Proof Obligation:

[serial 2611]: Regulate::manage_regulator_mode.impl
P [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [246]regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1040]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> regulator_mode!(') <<post>> to get:

[serial 2612]: Regulate::manage_regulator_mode.impl
P [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [246]->
Q [135] << not REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2611]

The Same Proof Obligation:
Has applied <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> for  <<pre>> regulator_mode!(') <<post>> to get:

[serial 2613]: Regulate::manage_regulator_mode.impl
P [246] << ( not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [246]->
Q [220] << true >>
What for:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2611]

[serial 2613]: Regulate::manage_regulator_mode.impl
P [246] << ( not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [246]->
Q [220] << true >>
What for:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2611]
. . . done applying atomic actions [8.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 2610]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215]->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1040]

[serial 2612]: Regulate::manage_regulator_mode.impl
P [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [246]->
Q [135] << not REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2611]

[serial 2613]: Regulate::manage_regulator_mode.impl
P [246] << ( not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [246]->
Q [220] << true >>
What for:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2611]
Done reducing atomic actions
step:  66
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2610]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215]->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1040]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2614]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215]->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.8 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2612]: Regulate::manage_regulator_mode.impl
P [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [246]->
Q [135] << not REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2611]

[serial 2613]: Regulate::manage_regulator_mode.impl
P [246] << ( not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [246]->
Q [220] << true >>
What for:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2611]

[serial 2614]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215]->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  67
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2612]: Regulate::manage_regulator_mode.impl
P [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [246]->
Q [135] << not REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2611]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2616]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2612]

This Proof Obligation:

[serial 2613]: Regulate::manage_regulator_mode.impl
P [246] << ( not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [246]->
Q [220] << true >>
What for:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2611]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2618]: Regulate::manage_regulator_mode.impl
P [246] << ( AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) )
  and ( mmode'Failed = regulator_mode )^0 >>
S [246]->
Q [220] << true >>
What for:    normalization of [serial 2613]

This Proof Obligation:

[serial 2614]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215]->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2620]: Regulate::manage_regulator_mode.impl
P [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() )
  and true
  and true >>
What for:    normalization of [serial 2614]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2616]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2612]

[serial 2618]: Regulate::manage_regulator_mode.impl
P [246] << ( AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) )
  and ( mmode'Failed = regulator_mode )^0 >>
S [246]->
Q [220] << true >>
What for:    normalization of [serial 2613]

[serial 2620]: Regulate::manage_regulator_mode.impl
P [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() )
  and true
  and true >>
What for:    normalization of [serial 2614]
Done Normalizing
step:  68
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2618]: Regulate::manage_regulator_mode.impl
P [246] << ( AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) )
  and ( mmode'Failed = regulator_mode )^0 >>
S [246]->
Q [220] << true >>
What for:    normalization of [serial 2613]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2624]: Regulate::manage_regulator_mode.impl
P [246] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() )
  and ( mmode'Failed = regulator_mode )^0 >>
S [246]->
Q [220] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 2618]

This Proof Obligation:

[serial 2620]: Regulate::manage_regulator_mode.impl
P [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() )
  and true
  and true >>
What for:    normalization of [serial 2614]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2625]: Regulate::manage_regulator_mode.impl
P [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2620]

This Proof Obligation:

[serial 2625]: Regulate::manage_regulator_mode.impl
P [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2620]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2626]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2625]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2616]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2612]

[serial 2624]: Regulate::manage_regulator_mode.impl
P [246] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() )
  and ( mmode'Failed = regulator_mode )^0 >>
S [246]->
Q [220] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 2618]

[serial 2626]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2625]
Done applying laws
step:  69
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2624]: Regulate::manage_regulator_mode.impl
P [246] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() )
  and ( mmode'Failed = regulator_mode )^0 >>
S [246]->
Q [220] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 2618]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2629]: Regulate::manage_regulator_mode.impl
P [246] << AXIOM_CTSR()
  and AXIOM_STR()
  and ( mmode'Failed = regulator_mode )^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246]->
Q [220] << true >>
What for:    normalization of [serial 2624]

This Proof Obligation:

[serial 2626]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2625]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2631]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
What for:    normalization of [serial 2626]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2616]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2612]

[serial 2629]: Regulate::manage_regulator_mode.impl
P [246] << AXIOM_CTSR()
  and AXIOM_STR()
  and ( mmode'Failed = regulator_mode )^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246]->
Q [220] << true >>
What for:    normalization of [serial 2624]

[serial 2631]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
What for:    normalization of [serial 2626]
Done Normalizing
step:  70
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2629]: Regulate::manage_regulator_mode.impl
P [246] << AXIOM_CTSR()
  and AXIOM_STR()
  and ( mmode'Failed = regulator_mode )^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246]->
Q [220] << true >>
What for:    normalization of [serial 2624]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 2616]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2612]

[serial 2631]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
What for:    normalization of [serial 2626]
Done trying to apply axioms
step:  71
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 2616]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2612]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 2634]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2616]

This Proof Obligation:

[serial 2631]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
What for:    normalization of [serial 2626]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 2635]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2631]
. . . done applying DeMorgan's Law  [8.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 2634]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2616]

[serial 2635]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2631]
step:  72
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 2635]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2631]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2636]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2635]
. . . Substituting <= with not < [8.8 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 2634]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2616]

[serial 2636]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2635]
Done replacing a<=b with (not b<a)
step:  73
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2634]: Regulate::manage_regulator_mode.impl
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2616]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2638]: Regulate::manage_regulator_mode.impl
P [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() )
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2634]

This Proof Obligation:

[serial 2636]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2635]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2640]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2636]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2638]: Regulate::manage_regulator_mode.impl
P [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() )
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2634]

[serial 2640]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2636]
Done Normalizing
step:  74
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2638]: Regulate::manage_regulator_mode.impl
P [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() )
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2634]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2643]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2638]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2640]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2636]

[serial 2643]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2638]
Done applying laws
step:  75
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2640]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2636]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2644]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]

[serial 2645]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]

This Proof Obligation:

[serial 2643]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2638]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2646]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643]

[serial 2647]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643]
. . . done splitting postcondition  [8.8 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2644]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]

[serial 2645]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]

[serial 2646]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643]

[serial 2647]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643]
Done splitting postcondition
step:  76
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2644]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2647]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 2645]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]

[serial 2646]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643]
Done trying to apply axioms
step:  77
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2645]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2648]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2645]

This Proof Obligation:

[serial 2646]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246]->
Q [135] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2649]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [246]->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2646]
. . . done substituting assertions' for Labels [8.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 2648]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2645]

[serial 2649]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [246]->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2646]
Done substituting Assertion labels.
step:  78
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 2648]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2645]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 2650]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << ( not ( ( not ( REGULATOR_INTERFACE_FAILURE )
  and not ( INTERNAL_FAILURE ) ) )
   or not ( ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2648]

This Proof Obligation:

[serial 2649]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [246]->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2646]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 2651]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( ( not ( REGULATOR_INTERFACE_FAILURE )
  and not ( INTERNAL_FAILURE ) ) )
   or not ( ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [246]->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2649]
. . . done applying DeMorgan's Law  [8.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 2650]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << ( not ( ( not ( REGULATOR_INTERFACE_FAILURE )
  and not ( INTERNAL_FAILURE ) ) )
   or not ( ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2648]

[serial 2651]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( ( not ( REGULATOR_INTERFACE_FAILURE )
  and not ( INTERNAL_FAILURE ) ) )
   or not ( ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [246]->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2649]
step:  79
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2650]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << ( not ( ( not ( REGULATOR_INTERFACE_FAILURE )
  and not ( INTERNAL_FAILURE ) ) )
   or not ( ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2648]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2653]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2650]

This Proof Obligation:

[serial 2651]: Regulate::manage_regulator_mode.impl
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( ( not ( REGULATOR_INTERFACE_FAILURE )
  and not ( INTERNAL_FAILURE ) ) )
   or not ( ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [246]->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2649]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2655]: Regulate::manage_regulator_mode.impl
P [244] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2651]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2653]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2650]

[serial 2655]: Regulate::manage_regulator_mode.impl
P [244] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2651]
Done Normalizing
step:  80
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 2653]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2650]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 2658]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2653]

This Proof Obligation:

[serial 2655]: Regulate::manage_regulator_mode.impl
P [244] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2651]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 2659]: Regulate::manage_regulator_mode.impl
P [244] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2655]
. . . done applying DeMorgan's Law  [8.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 2658]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2653]

[serial 2659]: Regulate::manage_regulator_mode.impl
P [244] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2655]
step:  81
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2658]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2653]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2661]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 2658]

This Proof Obligation:

[serial 2659]: Regulate::manage_regulator_mode.impl
P [244] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2655]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2663]: Regulate::manage_regulator_mode.impl
P [244] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2659]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2661]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 2658]

[serial 2663]: Regulate::manage_regulator_mode.impl
P [244] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2659]
Done Normalizing
step:  82
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2661]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 2658]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2666]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2661]

This Proof Obligation:

[serial 2663]: Regulate::manage_regulator_mode.impl
P [244] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2659]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2667]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2663]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2666]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2661]

[serial 2667]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2663]
Done applying laws
step:  83
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2666]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2661]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2668]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2666]
. . . done replacing P@now and P^0 with P  [8.8 seconds ]
After assuming present remaining 
Obligations:

[serial 2667]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2663]

[serial 2668]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2666]
Done assuming present.
step:  84
****guided-sub-equals****
guided substitution of equals "CURRENT_TEMPERATURE_STATUS" . . .
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 2668]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2666]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 2669]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2668]
. . . done guided substitution of equals  [8.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2667]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2663]
Reason solved:  Guided Substitution of Equals

[serial 2669]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2668]
Done guided substituting an equals
step:  85
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2669]: Regulate::manage_regulator_mode.impl
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215]->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2668]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 2667]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2663]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  86
****guided-sub-equals****
guided substitution of equals "START_TIME" . . .
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 2667]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2663]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
Has substituted 
"START_TIME" with its = "start_time"
 to get:

[serial 2670]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2667]
. . . done guided substitution of equals  [8.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2670]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2667]
Done guided substituting an equals
step:  87
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 2670]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2667]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 2671]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2670]
. . . Substituting <= with not < [8.8 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 2671]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2670]
Done replacing a<=b with (not b<a)
step:  88
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2671]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2670]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2673]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 2671]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2673]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 2671]
Done Normalizing
step:  89
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2673]: Regulate::manage_regulator_mode.impl
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246]->
Q [135] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
What for:    normalization of [serial 2671]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1041]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [253]<< REGULATOR_OK()
  and RUN() >>
regulator_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [217] << ( RUN() )^1 >>
What for:   <<M(check_init) and x>> A <<M(normal)>> for mrm2: check_init-[x]->normal{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  90
#[serial 1041]  <<M(check_init) and x>> A <<M(normal)>> for mrm2: check_init-[x]->normal{A};
step:  91
****reduce****

[serial 2675]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1041]

[serial 2676]: Regulate::manage_regulator_mode.impl
P [255] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]

[serial 2677]: Regulate::manage_regulator_mode.impl
P [253] << REGULATOR_OK()
  and RUN() >>
S [254]regulator_mode!(mmode'Normal)
Q [255] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2675]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1041]

[serial 2676]: Regulate::manage_regulator_mode.impl
P [255] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]

[serial 2677]: Regulate::manage_regulator_mode.impl
P [253] << REGULATOR_OK()
  and RUN() >>
S [254]regulator_mode!(mmode'Normal)
Q [255] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]
done reducing composite actions
step:  92
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> REGULATOR_MODE(x : regulator_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<REGULATOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> REGULATOR_OK()
    and RUN(),
    Failed -> not REGULATOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Normal" is:  
^{and 
 ^{INVOKE[REGULATOR_OK] REGULATOR_OK} 
 ^{INVOKE[RUN] RUN}}

This Proof Obligation:

[serial 2677]: Regulate::manage_regulator_mode.impl
P [253] << REGULATOR_OK()
  and RUN() >>
S [254]regulator_mode!(mmode'Normal)
Q [255] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> regulator_mode!(') <<post>> to get:

[serial 2678]: Regulate::manage_regulator_mode.impl
P [253] << REGULATOR_OK()
  and RUN() >>
S [254]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2677]

The Same Proof Obligation:
Has applied <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> for  <<pre>> regulator_mode!(') <<post>> to get:

[serial 2679]: Regulate::manage_regulator_mode.impl
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2677]

[serial 2679]: Regulate::manage_regulator_mode.impl
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2677]
. . . done applying atomic actions [8.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 2675]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1041]

[serial 2676]: Regulate::manage_regulator_mode.impl
P [255] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]

[serial 2678]: Regulate::manage_regulator_mode.impl
P [253] << REGULATOR_OK()
  and RUN() >>
S [254]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2677]

[serial 2679]: Regulate::manage_regulator_mode.impl
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2677]
Done reducing atomic actions
step:  93
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2679]: Regulate::manage_regulator_mode.impl
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2677]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2680]: Regulate::manage_regulator_mode.impl
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.8 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2675]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1041]

[serial 2676]: Regulate::manage_regulator_mode.impl
P [255] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]

[serial 2678]: Regulate::manage_regulator_mode.impl
P [253] << REGULATOR_OK()
  and RUN() >>
S [254]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2677]

[serial 2680]: Regulate::manage_regulator_mode.impl
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  94
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2675]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1041]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2681]: Regulate::manage_regulator_mode.impl
P [215] << ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2675]

This Proof Obligation:

[serial 2680]: Regulate::manage_regulator_mode.impl
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2682]: Regulate::manage_regulator_mode.impl
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2680]

This Proof Obligation:

[serial 2682]: Regulate::manage_regulator_mode.impl
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2680]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2683]: Regulate::manage_regulator_mode.impl
P [254] << REGULATOR_OK()
  and RUN()
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2682]
. . . done Applying Laws [8.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2676]: Regulate::manage_regulator_mode.impl
P [255] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]

[serial 2678]: Regulate::manage_regulator_mode.impl
P [253] << REGULATOR_OK()
  and RUN() >>
S [254]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2677]

[serial 2681]: Regulate::manage_regulator_mode.impl
P [215] << ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2675]

[serial 2683]: Regulate::manage_regulator_mode.impl
P [254] << REGULATOR_OK()
  and RUN()
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2682]
Done applying laws
step:  95
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2676]: Regulate::manage_regulator_mode.impl
P [255] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2685]: Regulate::manage_regulator_mode.impl
P [255] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2676]

This Proof Obligation:

[serial 2681]: Regulate::manage_regulator_mode.impl
P [215] << ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2675]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2688]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2681]

This Proof Obligation:

[serial 2683]: Regulate::manage_regulator_mode.impl
P [254] << REGULATOR_OK()
  and RUN()
  and ( regulator_mode = mmode'Normal )^0 >>
S [254]->
Q [255] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2682]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2690]: Regulate::manage_regulator_mode.impl
P [254] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [254]->
Q [255] << RUN() >>
What for:    normalization of [serial 2683]
. . . done Normalizing Unsolved Proof Obligations [8.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2678]: Regulate::manage_regulator_mode.impl
P [253] << REGULATOR_OK()
  and RUN() >>
S [254]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2677]

[serial 2685]: Regulate::manage_regulator_mode.impl
P [255] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2676]

[serial 2688]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2681]

[serial 2690]: Regulate::manage_regulator_mode.impl
P [254] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [254]->
Q [255] << RUN() >>
What for:    normalization of [serial 2683]
Done Normalizing
step:  96
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2678]: Regulate::manage_regulator_mode.impl
P [253] << REGULATOR_OK()
  and RUN() >>
S [254]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2677]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 2690]: Regulate::manage_regulator_mode.impl
P [254] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [254]->
Q [255] << RUN() >>
What for:    normalization of [serial 2683]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 2685]: Regulate::manage_regulator_mode.impl
P [255] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2676]

[serial 2688]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2681]
Done trying to apply axioms
step:  97
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2685]: Regulate::manage_regulator_mode.impl
P [255] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2676]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2694]: Regulate::manage_regulator_mode.impl
P [255] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [217]->
Q [217] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels  [serial 2685]

This Proof Obligation:

[serial 2688]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2681]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2695]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2688]
. . . done substituting assertions' for Labels [8.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 2694]: Regulate::manage_regulator_mode.impl
P [255] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [217]->
Q [217] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels  [serial 2685]

[serial 2695]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2688]
Done substituting Assertion labels.
step:  98
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2694]: Regulate::manage_regulator_mode.impl
P [255] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [217]->
Q [217] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels  [serial 2685]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2697]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2694]

This Proof Obligation:

[serial 2695]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2688]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2699]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2695]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2697]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2694]

[serial 2699]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2695]
Done Normalizing
step:  99
****guided-sub-equals****
guided substitution of equals "CURRENT_TEMPERATURE_STATUS" . . .
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 2699]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2695]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 2702]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2699]
. . . done guided substitution of equals  [8.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2697]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2694]

[serial 2702]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2699]
Done guided substituting an equals
step:  100
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2702]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2699]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2703]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2702]
. . . done Applying Laws [8.9 seconds ]
After "laws" remaining 
Obligations:

[serial 2697]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2694]

[serial 2703]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2702]
Done applying laws
step:  101
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2703]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2702]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2706]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2703]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2697]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2694]

[serial 2706]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2703]
Done Normalizing
step:  102
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2706]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215]->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2703]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2708]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [215]->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2706]
. . . done replacing P@now and P^0 with P  [8.9 seconds ]
After assuming present remaining 
Obligations:

[serial 2697]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2694]

[serial 2708]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [215]->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2706]
Done assuming present.
step:  103
****guided-sub-equals****
guided substitution of equals "START_TIME" . . .
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 2708]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [215]->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2706]
Reason solved:  Guided Substitution of Equals
Has substituted 
"START_TIME" with its = "start_time"
 to get:

[serial 2709]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [215]->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2708]
. . . done guided substitution of equals  [8.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2697]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2694]

[serial 2709]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [215]->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2708]
Done guided substituting an equals
step:  104
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2709]: Regulate::manage_regulator_mode.impl
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [215]->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2708]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 2697]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2694]
Done trying to apply axioms
step:  105
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  #Iso_Properties::Initialization_Timeout s <= now - START_TIME and now - START_TIME <= ( now - START_TIME )^1 -> #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1

This Proof Obligation:

[serial 2697]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2694]
Reason solved:  Transitivity: x<y and y<z -> x<z
Has applied Transitivity: x<y and y<z -> x<z  to get:

[serial 2710]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 2697]
. . . done adding transitive terms [8.9 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2710]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 2697]
Done adding transitive relations
step:  106
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2710]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 2697]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2711]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [217]->
Q [217] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2710]
. . . done spltting timed atoms  [8.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2711]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [217]->
Q [217] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2710]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Constants are always the same
Has been normalized to get:

[serial 2713]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 2711]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 2713]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 2711]
Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 2713]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 2711]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2715]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2713]
. . . done spltting timed atoms  [8.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2715]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2713]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2717]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 2715]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 2717]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 2715]
Done completely distributing ^ and @, round 1.
Distributing carets . .
. . . done spltting timed atoms  [8.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.9 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
step:  107
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2717]: Regulate::manage_regulator_mode.impl
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 2715]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1042]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
S [257]->
Q [213] << ( true )^1 >>
What for:   <<M(check_init) and x>> -> <<M(init)>> for mrm2x: check_init-[x]->init{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  108
#[serial 1042]  <<M(check_init) and x>> -> <<M(init)>> for mrm2x: check_init-[x]->init{};
step:  109
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1042]: Regulate::manage_regulator_mode.impl
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
S [257]->
Q [213] << ( true )^1 >>
What for:   <<M(check_init) and x>> -> <<M(init)>> for mrm2x: check_init-[x]->init{};
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Constants are always the same
Has been normalized to get:

[serial 2721]: Regulate::manage_regulator_mode.impl
P [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [257]->
Q [213] << true >>
What for:    normalization of [serial 1042]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2721]: Regulate::manage_regulator_mode.impl
P [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [257]->
Q [213] << true >>
What for:    normalization of [serial 1042]
Done Normalizing
step:  110
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2721]: Regulate::manage_regulator_mode.impl
P [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [257]->
Q [213] << true >>
What for:    normalization of [serial 1042]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1043]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [262]  << RUN() >>
  current_temperature?(temperature)
  ;
  << temperature = CURRENT_TEMP
    and RUN() >>
  current_temperature_status := temperature.status
  << ( current_temperature_status = temperature.status )
    and ( temperature = CURRENT_TEMP )
    and RUN() >> 
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  111
#[serial 1043]  <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};
step:  112
****reduce****
This proof obligation:

[serial 1043]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [262]  << RUN() >>
  current_temperature?(temperature)
  ;
  << temperature = CURRENT_TEMP
    and RUN() >>
  current_temperature_status := temperature.status
  << ( current_temperature_status = temperature.status )
    and ( temperature = CURRENT_TEMP )
    and RUN() >> 
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 2723]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [217]->
Q [262] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1043]

[serial 2724]: Regulate::manage_regulator_mode.impl
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1043]

[serial 2725]: Regulate::manage_regulator_mode.impl
P [262] << RUN() >>
S [263]current_temperature?(temperature)
Q [264] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1043]

[serial 2726]: Regulate::manage_regulator_mode.impl
P [264] << temperature = CURRENT_TEMP
  and RUN() >>
S [265]current_temperature_status := temperature.status
Q [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1043]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2723]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [217]->
Q [262] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1043]

[serial 2724]: Regulate::manage_regulator_mode.impl
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1043]

[serial 2725]: Regulate::manage_regulator_mode.impl
P [262] << RUN() >>
S [263]current_temperature?(temperature)
Q [264] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1043]

[serial 2726]: Regulate::manage_regulator_mode.impl
P [264] << temperature = CURRENT_TEMP
  and RUN() >>
S [265]current_temperature_status := temperature.status
Q [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1043]
done reducing composite actions
step:  113
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 2725]: Regulate::manage_regulator_mode.impl
P [262] << RUN() >>
S [263]current_temperature?(temperature)
Q [264] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1043]
Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(current_temperature)>> -> <<post>> for <<pre>> current_temperature?(temperature) <<post>> to get:

[serial 2727]: Regulate::manage_regulator_mode.impl
P [263] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [263]->
Q [264] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2725]
solving assignment on line 265
replacing "current_temperature_status" with "temperature.status"
makes:  << ( temperature.status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>

This Proof Obligation:

[serial 2726]: Regulate::manage_regulator_mode.impl
P [264] << temperature = CURRENT_TEMP
  and RUN() >>
S [265]current_temperature_status := temperature.status
Q [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1043]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 2728]: Regulate::manage_regulator_mode.impl
P [264] << temperature = CURRENT_TEMP
  and RUN() >>
S [265]->
Q [266] << ( temperature.status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
What for:  applied wp for assignment [serial 2726]
. . . done applying atomic actions [8.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 2723]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [217]->
Q [262] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1043]

[serial 2724]: Regulate::manage_regulator_mode.impl
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1043]

[serial 2727]: Regulate::manage_regulator_mode.impl
P [263] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [263]->
Q [264] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2725]

[serial 2728]: Regulate::manage_regulator_mode.impl
P [264] << temperature = CURRENT_TEMP
  and RUN() >>
S [265]->
Q [266] << ( temperature.status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
What for:  applied wp for assignment [serial 2726]
Done reducing atomic actions
step:  114
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2724]: Regulate::manage_regulator_mode.impl
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1043]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2729]: Regulate::manage_regulator_mode.impl
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.9 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2723]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [217]->
Q [262] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1043]

[serial 2727]: Regulate::manage_regulator_mode.impl
P [263] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [263]->
Q [264] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2725]

[serial 2728]: Regulate::manage_regulator_mode.impl
P [264] << temperature = CURRENT_TEMP
  and RUN() >>
S [265]->
Q [266] << ( temperature.status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
What for:  applied wp for assignment [serial 2726]

[serial 2729]: Regulate::manage_regulator_mode.impl
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  115
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2727]: Regulate::manage_regulator_mode.impl
P [263] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [263]->
Q [264] << temperature = CURRENT_TEMP
  and RUN() >>
What for:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2725]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2732]: Regulate::manage_regulator_mode.impl
P [263] << CURRENT_TEMP = temperature
  and RUN() >>
S [263]->
Q [264] << CURRENT_TEMP = temperature
  and RUN() >>
What for:    normalization of [serial 2727]

This Proof Obligation:

[serial 2728]: Regulate::manage_regulator_mode.impl
P [264] << temperature = CURRENT_TEMP
  and RUN() >>
S [265]->
Q [266] << ( temperature.status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
What for:  applied wp for assignment [serial 2726]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2734]: Regulate::manage_regulator_mode.impl
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265]->
Q [266] << CURRENT_TEMP = temperature
  and temperature.status = temperature.status
  and RUN() >>
What for:    normalization of [serial 2728]

This Proof Obligation:

[serial 2729]: Regulate::manage_regulator_mode.impl
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2736]: Regulate::manage_regulator_mode.impl
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
What for:    normalization of [serial 2729]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2723]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [217]->
Q [262] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1043]

[serial 2732]: Regulate::manage_regulator_mode.impl
P [263] << CURRENT_TEMP = temperature
  and RUN() >>
S [263]->
Q [264] << CURRENT_TEMP = temperature
  and RUN() >>
What for:    normalization of [serial 2727]

[serial 2734]: Regulate::manage_regulator_mode.impl
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265]->
Q [266] << CURRENT_TEMP = temperature
  and temperature.status = temperature.status
  and RUN() >>
What for:    normalization of [serial 2728]

[serial 2736]: Regulate::manage_regulator_mode.impl
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
What for:    normalization of [serial 2729]
Done Normalizing
step:  116
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2734]: Regulate::manage_regulator_mode.impl
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265]->
Q [266] << CURRENT_TEMP = temperature
  and temperature.status = temperature.status
  and RUN() >>
What for:    normalization of [serial 2728]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 2740]: Regulate::manage_regulator_mode.impl
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265]->
Q [266] << CURRENT_TEMP = temperature
  and true
  and RUN() >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2734]

This Proof Obligation:

[serial 2736]: Regulate::manage_regulator_mode.impl
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
What for:    normalization of [serial 2729]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2741]: Regulate::manage_regulator_mode.impl
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 2736]

This Proof Obligation:

[serial 2740]: Regulate::manage_regulator_mode.impl
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265]->
Q [266] << CURRENT_TEMP = temperature
  and true
  and RUN() >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2734]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2742]: Regulate::manage_regulator_mode.impl
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265]->
Q [266] << CURRENT_TEMP = temperature
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 2740]
. . . done Applying Laws [8.9 seconds ]
After "laws" remaining 
Obligations:

[serial 2723]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [217]->
Q [262] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1043]

[serial 2732]: Regulate::manage_regulator_mode.impl
P [263] << CURRENT_TEMP = temperature
  and RUN() >>
S [263]->
Q [264] << CURRENT_TEMP = temperature
  and RUN() >>
What for:    normalization of [serial 2727]

[serial 2741]: Regulate::manage_regulator_mode.impl
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 2736]

[serial 2742]: Regulate::manage_regulator_mode.impl
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265]->
Q [266] << CURRENT_TEMP = temperature
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 2740]
Done applying laws
step:  117
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2723]: Regulate::manage_regulator_mode.impl
P [217] << RUN() >>
S [217]->
Q [262] << RUN() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1043]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 2732]: Regulate::manage_regulator_mode.impl
P [263] << CURRENT_TEMP = temperature
  and RUN() >>
S [263]->
Q [264] << CURRENT_TEMP = temperature
  and RUN() >>
What for:    normalization of [serial 2727]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 2741]: Regulate::manage_regulator_mode.impl
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219]->
Q [219] << current_temperature_status = temperature.status
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 2736]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 2742]: Regulate::manage_regulator_mode.impl
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265]->
Q [266] << CURRENT_TEMP = temperature
  and RUN() >>
What for:  Law of And-Simplification:  P and true is P [serial 2740]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [8.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1044]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [273]<< REGULATOR_OK()
  and RUN() >>
regulator_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [217] << ( RUN() )^1 >>
What for:   <<M(check_normal) and x>> A <<M(normal)>> for mrm3: check_normal-[x]->normal{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  118
#[serial 1044]  <<M(check_normal) and x>> A <<M(normal)>> for mrm3: check_normal-[x]->normal{A};
step:  119
****reduce****

[serial 2743]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1044]

[serial 2744]: Regulate::manage_regulator_mode.impl
P [275] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]

[serial 2745]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]regulator_mode!(mmode'Normal)
Q [275] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2743]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1044]

[serial 2744]: Regulate::manage_regulator_mode.impl
P [275] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]

[serial 2745]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]regulator_mode!(mmode'Normal)
Q [275] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]
done reducing composite actions
step:  120
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> REGULATOR_MODE(x : regulator_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<REGULATOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> REGULATOR_OK()
    and RUN(),
    Failed -> not REGULATOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Normal" is:  
^{and 
 ^{INVOKE[REGULATOR_OK] REGULATOR_OK} 
 ^{INVOKE[RUN] RUN}}

This Proof Obligation:

[serial 2745]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]regulator_mode!(mmode'Normal)
Q [275] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> regulator_mode!(') <<post>> to get:

[serial 2746]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2745]

The Same Proof Obligation:
Has applied <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> for  <<pre>> regulator_mode!(') <<post>> to get:

[serial 2747]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274]->
Q [275] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2745]

[serial 2747]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274]->
Q [275] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2745]
. . . done applying atomic actions [8.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 2743]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1044]

[serial 2744]: Regulate::manage_regulator_mode.impl
P [275] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]

[serial 2746]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2745]

[serial 2747]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274]->
Q [275] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2745]
Done reducing atomic actions
step:  121
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2747]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274]->
Q [275] << RUN()
  and AXIOM_PAST_INIT() >>
What for:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2745]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 2748]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274]->
Q [275] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [8.9 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2743]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1044]

[serial 2744]: Regulate::manage_regulator_mode.impl
P [275] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]

[serial 2746]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2745]

[serial 2748]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274]->
Q [275] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  122
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2743]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1044]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2750]: Regulate::manage_regulator_mode.impl
P [219] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2743]

This Proof Obligation:

[serial 2744]: Regulate::manage_regulator_mode.impl
P [275] << RUN()
  and AXIOM_PAST_INIT() >>
S [217]->
Q [217] << ( RUN() )^1 >>
What for:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2752]: Regulate::manage_regulator_mode.impl
P [275] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2744]

This Proof Obligation:

[serial 2748]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274]->
Q [275] << RUN()
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 2755]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << RUN()
  and true >>
What for:    normalization of [serial 2748]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2746]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2745]

[serial 2750]: Regulate::manage_regulator_mode.impl
P [219] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2743]

[serial 2752]: Regulate::manage_regulator_mode.impl
P [275] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2744]

[serial 2755]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << RUN()
  and true >>
What for:    normalization of [serial 2748]
Done Normalizing
step:  123
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2750]: Regulate::manage_regulator_mode.impl
P [219] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2743]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2759]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2750]

This Proof Obligation:

[serial 2755]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << RUN()
  and true >>
What for:    normalization of [serial 2748]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 2760]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2755]

This Proof Obligation:

[serial 2760]: Regulate::manage_regulator_mode.impl
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << ( RUN() ) >>
What for:  Law of And-Simplification:  P and true is P [serial 2755]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2761]: Regulate::manage_regulator_mode.impl
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2760]
. . . done Applying Laws [8.9 seconds ]
After "laws" remaining 
Obligations:

[serial 2746]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2745]

[serial 2752]: Regulate::manage_regulator_mode.impl
P [275] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2744]

[serial 2759]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2750]

[serial 2761]: Regulate::manage_regulator_mode.impl
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2760]
Done applying laws
step:  124
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2759]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:  Associativity: (b.c).a = a.b.c [serial 2750]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2765]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2759]

This Proof Obligation:

[serial 2761]: Regulate::manage_regulator_mode.impl
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << ( RUN() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2760]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2767]: Regulate::manage_regulator_mode.impl
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << RUN() >>
What for:    normalization of [serial 2761]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2746]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2745]

[serial 2752]: Regulate::manage_regulator_mode.impl
P [275] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2744]

[serial 2765]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2759]

[serial 2767]: Regulate::manage_regulator_mode.impl
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << RUN() >>
What for:    normalization of [serial 2761]
Done Normalizing
step:  125
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2746]: Regulate::manage_regulator_mode.impl
P [273] << REGULATOR_OK()
  and RUN() >>
S [274]->
Q [134] << REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2745]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 2767]: Regulate::manage_regulator_mode.impl
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274]->
Q [275] << RUN() >>
What for:    normalization of [serial 2761]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 2752]: Regulate::manage_regulator_mode.impl
P [275] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2744]

[serial 2765]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2759]
Done trying to apply axioms
step:  126
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2765]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << REGULATOR_OK()
  and RUN() >>
What for:    normalization of [serial 2759]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2770]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765]

[serial 2771]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765]
. . . done splitting postcondition  [8.9 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2752]: Regulate::manage_regulator_mode.impl
P [275] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2744]

[serial 2770]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765]

[serial 2771]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765]
Done splitting postcondition
step:  127
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2771]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 2752]: Regulate::manage_regulator_mode.impl
P [275] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2744]

[serial 2770]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765]
Done trying to apply axioms
step:  128
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2752]: Regulate::manage_regulator_mode.impl
P [275] << AXIOM_PAST_INIT()
  and RUN() >>
S [217]->
Q [217] << RUN()^1 >>
What for:    normalization of [serial 2744]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2772]: Regulate::manage_regulator_mode.impl
P [275] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [217]->
Q [217] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels  [serial 2752]

This Proof Obligation:

[serial 2770]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2773]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2770]
. . . done substituting assertions' for Labels [8.9 seconds ]
After "substitute" remaining 
Obligations:

[serial 2772]: Regulate::manage_regulator_mode.impl
P [275] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [217]->
Q [217] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels  [serial 2752]

[serial 2773]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2770]
Done substituting Assertion labels.
step:  129
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2772]: Regulate::manage_regulator_mode.impl
P [275] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [217]->
Q [217] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
What for:  Substituted assertions' predicates for labels  [serial 2752]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2775]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2772]

This Proof Obligation:

[serial 2773]: Regulate::manage_regulator_mode.impl
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2770]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2777]: Regulate::manage_regulator_mode.impl
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2773]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2775]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2772]

[serial 2777]: Regulate::manage_regulator_mode.impl
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2773]
Done Normalizing
step:  130
****guided-sub-equals****
guided substitution of equals "CURRENT_TEMPERATURE_STATUS" . . .
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 2777]: Regulate::manage_regulator_mode.impl
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2773]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 2780]: Regulate::manage_regulator_mode.impl
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2777]
. . . done guided substitution of equals  [8.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2775]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2772]

[serial 2780]: Regulate::manage_regulator_mode.impl
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2777]
Done guided substituting an equals
step:  131
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2780]: Regulate::manage_regulator_mode.impl
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219]->
Q [273] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2777]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2781]: Regulate::manage_regulator_mode.impl
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [219]->
Q [273] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2780]
. . . done replacing P@now and P^0 with P  [8.9 seconds ]
After assuming present remaining 
Obligations:

[serial 2775]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2772]

[serial 2781]: Regulate::manage_regulator_mode.impl
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [219]->
Q [273] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2780]
Done assuming present.
step:  132
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2781]: Regulate::manage_regulator_mode.impl
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [219]->
Q [273] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2780]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [8.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 2775]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2772]
Done trying to apply axioms
step:  133
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  #Iso_Properties::Initialization_Timeout s <= now - START_TIME and now - START_TIME <= ( now - START_TIME )^1 -> #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1

This Proof Obligation:

[serial 2775]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:    normalization of [serial 2772]
Reason solved:  Transitivity: x<y and y<z -> x<z
Has applied Transitivity: x<y and y<z -> x<z  to get:

[serial 2782]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 2775]
. . . done adding transitive terms [8.9 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2782]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 2775]
Done adding transitive relations
step:  134
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2782]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [217]->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 2775]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2783]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [217]->
Q [217] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2782]
. . . done spltting timed atoms  [8.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2783]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [217]->
Q [217] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2782]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Constants are always the same
Has been normalized to get:

[serial 2785]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 2783]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 2785]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 2783]
Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 2785]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
What for:    normalization of [serial 2783]
Reason solved:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  to get:

[serial 2787]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2785]
. . . done spltting timed atoms  [8.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2787]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
What for:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2785]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2789]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 2787]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 2789]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 2787]
Done completely distributing ^ and @, round 1.
Distributing carets . .
. . . done spltting timed atoms  [8.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [8.9 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
step:  135
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2789]: Regulate::manage_regulator_mode.impl
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217]->
Q [217] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
What for:    normalization of [serial 2787]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [8.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1045]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [281]<< ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:   <<M(check_normal) and x>> A <<M(failed)>> for mrm3x: check_normal-[x]->failed{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  136
#[serial 1045]  <<M(check_normal) and x>> A <<M(failed)>> for mrm3x: check_normal-[x]->failed{A};
step:  137
****reduce****

[serial 2792]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [219]->
Q [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1045]

[serial 2793]: Regulate::manage_regulator_mode.impl
P [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [284]regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1045]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2792]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [219]->
Q [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1045]

[serial 2793]: Regulate::manage_regulator_mode.impl
P [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [284]regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1045]
done reducing composite actions
step:  138
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< +=> REGULATOR_MODE(x : regulator_mode) >>
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE referencedPred=<<REGULATOR_MODE: x ~ mmode 
  +=> Init -> INI(),
    Normal -> REGULATOR_OK()
    and RUN(),
    Failed -> not REGULATOR_OK()
    and RUN() >> 
Proof.reducePortOutput ASSERTION_ENUMERATION INVOKE portValue=
^{~ x mmode}
Proof.reducePortOutput ASSERTION_ENUMERATION LABEL =mmode
Proof.reducePortOutput ASSERTION_ENUMERATION meaning of label "mmode'Failed" is:  
^{and 
 ^{not 
  ^{INVOKE[REGULATOR_OK] REGULATOR_OK}} 
 ^{INVOKE[RUN] RUN}}

This Proof Obligation:

[serial 2793]: Regulate::manage_regulator_mode.impl
P [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [284]regulator_mode!(mmode'Failed)
Q [220] << true >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1045]
Reason solved:  Enumeration Type Port Output 
Has applied port output of enumeration type <<pre>> regulator_mode!(') <<post>> to get:

[serial 2794]: Regulate::manage_regulator_mode.impl
P [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [284]->
Q [135] << not REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2793]

The Same Proof Obligation:
Has applied <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> for  <<pre>> regulator_mode!(') <<post>> to get:

[serial 2795]: Regulate::manage_regulator_mode.impl
P [284] << ( ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [284]->
Q [220] << true >>
What for:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2793]

[serial 2795]: Regulate::manage_regulator_mode.impl
P [284] << ( ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [284]->
Q [220] << true >>
What for:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2793]
. . . done applying atomic actions [8.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 2792]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [219]->
Q [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1045]

[serial 2794]: Regulate::manage_regulator_mode.impl
P [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [284]->
Q [135] << not REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2793]

[serial 2795]: Regulate::manage_regulator_mode.impl
P [284] << ( ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [284]->
Q [220] << true >>
What for:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2793]
Done reducing atomic actions
step:  139
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2792]: Regulate::manage_regulator_mode.impl
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [219]->
Q [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1045]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2797]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:    normalization of [serial 2792]

This Proof Obligation:

[serial 2794]: Regulate::manage_regulator_mode.impl
P [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [284]->
Q [135] << not REGULATOR_OK()
  and RUN() >>
What for:  applied port output of enumeration type  regulator_mode!(') [serial 2793]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2799]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2794]

This Proof Obligation:

[serial 2795]: Regulate::manage_regulator_mode.impl
P [284] << ( ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [284]->
Q [220] << true >>
What for:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2793]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2801]: Regulate::manage_regulator_mode.impl
P [284] << ( ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() )
  and ( mmode'Failed = regulator_mode )^0 >>
S [284]->
Q [220] << true >>
What for:    normalization of [serial 2795]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2797]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:    normalization of [serial 2792]

[serial 2799]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2794]

[serial 2801]: Regulate::manage_regulator_mode.impl
P [284] << ( ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() )
  and ( mmode'Failed = regulator_mode )^0 >>
S [284]->
Q [220] << true >>
What for:    normalization of [serial 2795]
Done Normalizing
step:  140
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2801]: Regulate::manage_regulator_mode.impl
P [284] << ( ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() )
  and ( mmode'Failed = regulator_mode )^0 >>
S [284]->
Q [220] << true >>
What for:    normalization of [serial 2795]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2805]: Regulate::manage_regulator_mode.impl
P [284] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( mmode'Failed = regulator_mode )^0 >>
S [284]->
Q [220] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 2801]
. . . done Applying Laws [8.9 seconds ]
After "laws" remaining 
Obligations:

[serial 2797]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:    normalization of [serial 2792]

[serial 2799]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2794]

[serial 2805]: Regulate::manage_regulator_mode.impl
P [284] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( mmode'Failed = regulator_mode )^0 >>
S [284]->
Q [220] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 2801]
Done applying laws
step:  141
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2805]: Regulate::manage_regulator_mode.impl
P [284] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( mmode'Failed = regulator_mode )^0 >>
S [284]->
Q [220] << true >>
What for:  Associativity: (b.c).a = a.b.c [serial 2801]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [8.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 2797]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:    normalization of [serial 2792]

[serial 2799]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2794]
Done trying to apply axioms
step:  142
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2797]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
What for:    normalization of [serial 2792]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2806]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2807]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2808]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [283] << AXIOM_CTSR() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2809]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [283] << AXIOM_STR() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

This Proof Obligation:

[serial 2799]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << RUN()
  and not REGULATOR_OK() >>
What for:    normalization of [serial 2794]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 2810]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]

[serial 2811]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]
. . . done splitting postcondition  [8.9 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2806]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2807]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2808]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [283] << AXIOM_CTSR() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2809]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [283] << AXIOM_STR() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2810]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]

[serial 2811]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]
Done splitting postcondition
step:  143
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2806]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2813]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() >>
What for:    normalization of [serial 2806]
. . . done Normalizing Unsolved Proof Obligations [8.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2807]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2808]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [283] << AXIOM_CTSR() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2809]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [283] << AXIOM_STR() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]

[serial 2810]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]

[serial 2811]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]

[serial 2813]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() >>
What for:    normalization of [serial 2806]
Done Normalizing
step:  144
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2807]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2820]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Substituted assertions' predicates for labels  [serial 2807]

This Proof Obligation:

[serial 2808]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [283] << AXIOM_CTSR() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2821]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [283] << ( current_temperature_status = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Substituted assertions' predicates for labels  [serial 2808]

This Proof Obligation:

[serial 2809]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [283] << AXIOM_STR() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2822]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [283] << ( start_time = START_TIME ) >>
What for:  Substituted assertions' predicates for labels  [serial 2809]

This Proof Obligation:

[serial 2810]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << RUN() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2823]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [284]->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2810]

This Proof Obligation:

[serial 2811]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284]->
Q [135] << not REGULATOR_OK() >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2824]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [284]->
Q [135] << not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2811]

This Proof Obligation:

[serial 2813]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() >>
What for:    normalization of [serial 2806]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 2825]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2813]
. . . done substituting assertions' for Labels [8.9 seconds ]
After "substitute" remaining 
Obligations:

[serial 2820]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Substituted assertions' predicates for labels  [serial 2807]

[serial 2821]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [283] << ( current_temperature_status = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Substituted assertions' predicates for labels  [serial 2808]

[serial 2822]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [283] << ( start_time = START_TIME ) >>
What for:  Substituted assertions' predicates for labels  [serial 2809]

[serial 2823]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [284]->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2810]

[serial 2824]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [284]->
Q [135] << not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2811]

[serial 2825]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2813]
Done substituting Assertion labels.
step:  145
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2820]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Substituted assertions' predicates for labels  [serial 2807]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]

This Proof Obligation:

[serial 2821]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [283] << ( current_temperature_status = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Substituted assertions' predicates for labels  [serial 2808]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2829]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << CURRENT_TEMPERATURE_STATUS = current_temperature_status >>
What for:    normalization of [serial 2821]

This Proof Obligation:

[serial 2822]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [283] << ( start_time = START_TIME ) >>
What for:  Substituted assertions' predicates for labels  [serial 2809]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]

This Proof Obligation:

[serial 2823]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [284]->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
What for:  Substituted assertions' predicates for labels  [serial 2810]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2833]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2823]

This Proof Obligation:

[serial 2824]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [284]->
Q [135] << not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2811]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2835]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 2824]

This Proof Obligation:

[serial 2825]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 2813]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2837]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 2825]
. . . done Normalizing Unsolved Proof Obligations [9.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]

[serial 2829]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << CURRENT_TEMPERATURE_STATUS = current_temperature_status >>
What for:    normalization of [serial 2821]

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]

[serial 2833]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2823]

[serial 2835]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 2824]

[serial 2837]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 2825]
Done Normalizing
step:  146
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 2833]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2823]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 2844]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2833]

This Proof Obligation:

[serial 2835]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 2824]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 2845]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2835]

This Proof Obligation:

[serial 2837]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) >>
What for:    normalization of [serial 2825]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 2846]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2837]
. . . done applying DeMorgan's Law  [9.0 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]

[serial 2829]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << CURRENT_TEMPERATURE_STATUS = current_temperature_status >>
What for:    normalization of [serial 2821]

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]

[serial 2844]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2833]

[serial 2845]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2835]

[serial 2846]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2837]
step:  147
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2844]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2833]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2851]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2844]

This Proof Obligation:

[serial 2845]: Regulate::manage_regulator_mode.impl
P [281] << ( not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2835]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2853]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2845]

This Proof Obligation:

[serial 2846]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2837]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2855]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2846]
. . . done Normalizing Unsolved Proof Obligations [9.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]

[serial 2829]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << CURRENT_TEMPERATURE_STATUS = current_temperature_status >>
What for:    normalization of [serial 2821]

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]

[serial 2851]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2844]

[serial 2853]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2845]

[serial 2855]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2846]
Done Normalizing
step:  148
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 2851]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2844]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 2859]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2851]

This Proof Obligation:

[serial 2853]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) >>
What for:    normalization of [serial 2845]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 2860]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2853]

This Proof Obligation:

[serial 2855]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2846]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 2861]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2855]
. . . done applying DeMorgan's Law  [9.0 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]

[serial 2829]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << CURRENT_TEMPERATURE_STATUS = current_temperature_status >>
What for:    normalization of [serial 2821]

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]

[serial 2859]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2851]

[serial 2860]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2853]

[serial 2861]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2855]
step:  149
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2859]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2851]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2866]: Regulate::manage_regulator_mode.impl
P [281] << ( ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2859]

This Proof Obligation:

[serial 2860]: Regulate::manage_regulator_mode.impl
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2853]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2868]: Regulate::manage_regulator_mode.impl
P [281] << ( ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 2860]

This Proof Obligation:

[serial 2861]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2855]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Complement
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2870]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2861]
. . . done Normalizing Unsolved Proof Obligations [9.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]

[serial 2829]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << CURRENT_TEMPERATURE_STATUS = current_temperature_status >>
What for:    normalization of [serial 2821]

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]

[serial 2866]: Regulate::manage_regulator_mode.impl
P [281] << ( ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2859]

[serial 2868]: Regulate::manage_regulator_mode.impl
P [281] << ( ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 2860]

[serial 2870]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2861]
Done Normalizing
step:  150
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2866]: Regulate::manage_regulator_mode.impl
P [281] << ( ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:    normalization of [serial 2859]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2874]: Regulate::manage_regulator_mode.impl
P [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2866]

This Proof Obligation:

[serial 2868]: Regulate::manage_regulator_mode.impl
P [281] << ( ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:    normalization of [serial 2860]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2875]: Regulate::manage_regulator_mode.impl
P [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2868]

This Proof Obligation:

[serial 2870]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2861]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2876]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2870]

This Proof Obligation:

[serial 2874]: Regulate::manage_regulator_mode.impl
P [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2866]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2877]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2874]

This Proof Obligation:

[serial 2875]: Regulate::manage_regulator_mode.impl
P [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2868]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2878]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2875]

This Proof Obligation:

[serial 2876]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2870]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 2879]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2876]
. . . done Applying Laws [9.0 seconds ]
After "laws" remaining 
Obligations:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]

[serial 2829]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << CURRENT_TEMPERATURE_STATUS = current_temperature_status >>
What for:    normalization of [serial 2821]

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]

[serial 2877]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2874]

[serial 2878]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2875]

[serial 2879]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2876]
Done applying laws
step:  151
****guided-sub-equals****
guided substitution of equals "CURRENT_TEMPERATURE_STATUS" . . .
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 2829]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << CURRENT_TEMPERATURE_STATUS = current_temperature_status >>
What for:    normalization of [serial 2821]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 2880]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << current_temperature_status = current_temperature_status >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2829]
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 2878]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2875]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]
equality selected for substitution:  CURRENT_TEMPERATURE_STATUS = current_temperature_status

This Proof Obligation:

[serial 2879]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 2876]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status"
 to get:

[serial 2882]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2879]
. . . done guided substitution of equals  [9.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]
Reason solved:  Guided Substitution of Equals

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]
Reason solved:  Guided Substitution of Equals

[serial 2877]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2874]
Reason solved:  Guided Substitution of Equals

[serial 2880]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << current_temperature_status = current_temperature_status >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2829]

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]

[serial 2882]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2879]
Done guided substituting an equals
step:  152
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2880]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << current_temperature_status = current_temperature_status >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2829]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 2883]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2880]

This Proof Obligation:

[serial 2882]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2879]
Reason solved:  Law of Or-Simplification: P or P is P
Has applied law "Law of Or-Simplification: P or P is P " to get:

[serial 2884]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2882]
. . . done Applying Laws [9.0 seconds ]
After "laws" remaining 
Obligations:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]
Reason solved:  Guided Substitution of Equals

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]
Reason solved:  Guided Substitution of Equals

[serial 2877]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2874]
Reason solved:  Guided Substitution of Equals

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]

[serial 2883]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2880]

[serial 2884]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2882]
Done applying laws
step:  153
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2827]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:    normalization of [serial 2820]
Reasons solved:  
   Guided Substitution of Equals
   Assume Present:  P = P@now = P^0 
Has applied Guided Substitution of Equals Assume Present:  P = P@now = P^0   to get:

[serial 2885]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2827]

This Proof Obligation:

[serial 2831]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:    normalization of [serial 2822]
Reasons solved:  
   Guided Substitution of Equals
   Assume Present:  P = P@now = P^0 
Has applied Guided Substitution of Equals Assume Present:  P = P@now = P^0   to get:

[serial 2886]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2831]

This Proof Obligation:

[serial 2883]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 2880]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2887]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << true >>
What for:  Assume Present:  P = P@now = P^0   [serial 2883]

This Proof Obligation:

[serial 2884]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2882]
Reason solved:  Assume Present:  P = P@now = P^0 
Has applied Assume Present:  P = P@now = P^0   to get:

[serial 2888]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2884]
. . . done replacing P@now and P^0 with P  [9.0 seconds ]
After assuming present remaining 
Obligations:

[serial 2877]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2874]
Reason solved:  Guided Substitution of Equals

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]

[serial 2885]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2827]

[serial 2886]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2831]

[serial 2887]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << true >>
What for:  Assume Present:  P = P@now = P^0   [serial 2883]

[serial 2888]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2884]
Done assuming present.
step:  154
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2886]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << START_TIME = start_time >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2831]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2887]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [283] << true >>
What for:  Assume Present:  P = P@now = P^0   [serial 2883]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 2888]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Assume Present:  P = P@now = P^0   [serial 2884]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 2877]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2874]
Reason solved:  Guided Substitution of Equals

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]

[serial 2885]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2827]
Done trying to apply axioms
step:  155
****guided-sub-equals****
guided substitution of equals "start_time" . . .
equality selected for substitution:  START_TIME = start_time
equality selected for substitution:  START_TIME = start_time
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 2885]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2827]
Reason solved:  Guided Substitution of Equals
Has substituted 
"start_time" with its = "START_TIME"
 to get:

[serial 2889]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 2885]
. . . done guided substitution of equals  [9.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2877]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2874]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]
Reason solved:  Guided Substitution of Equals

[serial 2889]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 2885]
Done guided substituting an equals
step:  156
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2889]: Regulate::manage_regulator_mode.impl
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219]->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 2885]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 2877]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2874]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  157
****guided-sub-equals****
guided substitution of equals "START_TIME" . . .
equality selected for substitution:  START_TIME = start_time

This Proof Obligation:

[serial 2877]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
What for:  Associativity: (b.c).a = a.b.c [serial 2874]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
   Guided Substitution of Equals
Has substituted 
"START_TIME" with its = "start_time"
 to get:

[serial 2890]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2877]
equality selected for substitution:  START_TIME = start_time
. . . done guided substitution of equals  [9.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals

[serial 2890]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2877]
Done guided substituting an equals
step:  158
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2890]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
What for:  Guided Substitution of Equals Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2877]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
Done trying to apply axioms
step:  159
****sub-equals-and****
substituting equals within conjunctions. . .
Replacing CURRENT_TEMPERATURE_STATUS with current_temperature_status

This Proof Obligation:

[serial 2881]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
   Substituting Equals Within Conjunction
Has substituted equals within conjunction to get:

[serial 2891]: Regulate::manage_regulator_mode.impl
P [281] << ( CURRENT_TEMPERATURE_STATUS = current_temperature_status )
  and ( START_TIME = start_time )
  and ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and ( #Iso_Properties::Initialization_Timeout s <= now - start_time ) >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Substituting Equals Within Conjunction [serial 2881]
. . . done substituting equals within conjunction  [9.0 seconds ]
After substituting equals within conjunction remaining 
Obligations:

[serial 2891]: Regulate::manage_regulator_mode.impl
P [281] << ( CURRENT_TEMPERATURE_STATUS = current_temperature_status )
  and ( START_TIME = start_time )
  and ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and ( #Iso_Properties::Initialization_Timeout s <= now - start_time ) >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Substituting Equals Within Conjunction [serial 2881]
Done substituting equals within conjunction
step:  160
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2891]: Regulate::manage_regulator_mode.impl
P [281] << ( CURRENT_TEMPERATURE_STATUS = current_temperature_status )
  and ( START_TIME = start_time )
  and ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and ( #Iso_Properties::Initialization_Timeout s <= now - start_time ) >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Substituting Equals Within Conjunction [serial 2881]
Reasons solved:  
   By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2893]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2891]
. . . done Normalizing Unsolved Proof Obligations [9.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2893]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2891]
Done Normalizing
step:  161
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2893]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:    normalization of [serial 2891]
Reason solved:  Law of Or-Simplification: P or P is P
Has applied law "Law of Or-Simplification: P or P is P " to get:

[serial 2895]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2893]
. . . done Applying Laws [9.0 seconds ]
After "laws" remaining 
Obligations:

[serial 2895]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2893]
Done applying laws
step:  162
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2895]: Regulate::manage_regulator_mode.impl
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284]->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
What for:  Law of Or-Simplification: P or P is P [serial 2893]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1062]: manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure
P [1] << REGULATOR_INTERFACE_FAILURE >>
S [2]->
Q [1] << REGULATOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure:
 interface_failure -> interface_failure
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
Main proof script resumed.
step:  10
#isolette connections
step:  11
****subscript****
You chose proof subscript: /Users/brianlarson/git/BLESS-models/Isolette-classic/proof scripts/subscripts/isocon.ps
step:  1
#isolette connections
step:  2
#[serial 1062] Composition of Subcomponents via Directional Connection manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure:
step:  3
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1062]: manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure
P [1] << REGULATOR_INTERFACE_FAILURE >>
S [2]->
Q [1] << REGULATOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure:
 interface_failure -> interface_failure
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1063]: manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode
P [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [2]->
Q [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode:
 regulator_mode -> regulator_mode
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  4
#[serial 1063] Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode:
step:  5
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1063]: manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode
P [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [2]->
Q [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode:
 regulator_mode -> regulator_mode
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1064]: manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode
P [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [2]->
Q [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode:
 regulator_mode -> regulator_mode
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  6
#[serial 1064] Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode:
step:  7
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1064]: manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode
P [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [2]->
Q [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode:
 regulator_mode -> regulator_mode
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1065]: manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure
P [1] << MONITOR_INTERFACE_FAILURE >>
S [2]->
Q [1] << MONITOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure:
 interface_failure -> interface_failure
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  8
#[serial 1065] Composition of Subcomponents via Directional Connection manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure:
step:  9
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1065]: manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure
P [1] << MONITOR_INTERFACE_FAILURE >>
S [2]->
Q [1] << MONITOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure:
 interface_failure -> interface_failure
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1066]: manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode
P [1] << +=> MONITOR_MODE(x : monitor_mode) >>
S [2]->
Q [1] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode:
 monitor_mode -> monitor_mode
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  10
#[serial 1066] Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode:
step:  11
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1066]: manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode
P [1] << +=> MONITOR_MODE(x : monitor_mode) >>
S [2]->
Q [1] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode:
 monitor_mode -> monitor_mode
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1067]: manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode
P [1] << +=> MONITOR_MODE(x : monitor_mode) >>
S [2]->
Q [1] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode:
 monitor_mode -> monitor_mode
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  12
#[serial 1067] Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode:
step:  13
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1067]: manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode
P [1] << +=> MONITOR_MODE(x : monitor_mode) >>
S [2]->
Q [1] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode:
 monitor_mode -> monitor_mode
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1068]: detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure
P [1] << INTERNAL_FAILURE >>
S [2]->
Q [1] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure:
 internal_failure -> internal_failure
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  14
#[serial 1068] Composition of Subcomponents via Directional Connection detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure:
step:  15
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1068]: detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure
P [1] << INTERNAL_FAILURE >>
S [2]->
Q [1] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure:
 internal_failure -> internal_failure
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1069]: air_temperature -> temperature_sensor.air
P [1] << air_temperature_air = CURRENT_TEMP >>
S [2]->
Q [1] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection air_temperature -> temperature_sensor.air:
 air_temperature -> air
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  16
#[serial 1069] Composition of Subcomponents via Directional Connection air_temperature -> temperature_sensor.air:
step:  17
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1069]: air_temperature -> temperature_sensor.air
P [1] << air_temperature_air = CURRENT_TEMP >>
S [2]->
Q [1] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection air_temperature -> temperature_sensor.air:
 air_temperature -> air
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1070]: temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  18
#[serial 1070] Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature:
step:  19
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1070]: temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1071]: temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  20
#[serial 1071] Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature:
step:  21
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1071]: temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1072]: temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  22
#[serial 1072] Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature:
step:  23
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1072]: temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1073]: temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  24
#[serial 1073] Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature:
step:  25
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1073]: temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1074]: temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  26
#[serial 1074] Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature:
step:  27
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1074]: temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1075]: temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  28
#[serial 1075] Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature:
step:  29
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1075]: temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature
P [1] << current_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1076]: thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status
P [1] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [2]->
Q [1] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status:
 regulator_status -> regulator_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  30
#[serial 1076] Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status:
step:  31
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1076]: thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status
P [1] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [2]->
Q [1] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status:
 regulator_status -> regulator_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1077]: thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature
P [1] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << displayed_temp_display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature:
 displayed_temp -> display_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  32
#[serial 1077] Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature:
step:  33
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1077]: thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature
P [1] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [2]->
Q [1] << displayed_temp_display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature:
 displayed_temp -> display_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1078]: thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control
P [1] << +=> HEAT_CONTROL(x : heat_control) >>
S [2]->
Q [1] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control:
 heat_control -> heat_control
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  34
#[serial 1078] Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control:
step:  35
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1078]: thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control
P [1] << +=> HEAT_CONTROL(x : heat_control) >>
S [2]->
Q [1] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control:
 heat_control -> heat_control
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1079]: thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm
P [1] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [2]->
Q [1] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm:
 alarm_control -> alarm
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  36
#[serial 1079] Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm:
step:  37
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1079]: thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm
P [1] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [2]->
Q [1] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm:
 alarm_control -> alarm
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1080]: thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status
P [1] << monitor_status = MONITOR_STATUS() >>
S [2]->
Q [1] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status:
 monitor_status -> monitor_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  38
#[serial 1080] Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status:
step:  39
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1080]: thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status
P [1] << monitor_status = MONITOR_STATUS() >>
S [2]->
Q [1] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status:
 monitor_status -> monitor_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1081]: operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp
P [1] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
S [2]->
Q [1] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp:
 lower_desired_temperature -> lower_desired_temp
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  40
#[serial 1081] Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp:
step:  41
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1081]: operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp
P [1] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
S [2]->
Q [1] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp:
 lower_desired_temperature -> lower_desired_temp
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1082]: operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature
P [1] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [2]->
Q [1] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature:
 lower_desired_temperature -> lower_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  42
#[serial 1082] Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature:
step:  43
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1082]: operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature
P [1] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [2]->
Q [1] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature:
 lower_desired_temperature -> lower_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1083]: operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp
P [1] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
S [2]->
Q [1] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp:
 upper_desired_temperature -> upper_desired_temp
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  44
#[serial 1083] Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp:
step:  45
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1083]: operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp
P [1] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
S [2]->
Q [1] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp:
 upper_desired_temperature -> upper_desired_temp
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1084]: operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature
P [1] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [2]->
Q [1] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature:
 upper_desired_temperature -> upper_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  46
#[serial 1084] Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature:
step:  47
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1084]: operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature
P [1] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [2]->
Q [1] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature:
 upper_desired_temperature -> upper_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1085]: operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature
P [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [2]->
Q [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  48
#[serial 1085] Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature:
step:  49
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1085]: operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature
P [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [2]->
Q [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1086]: operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature
P [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [2]->
Q [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  50
#[serial 1086] Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature:
step:  51
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1086]: operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature
P [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [2]->
Q [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1087]: operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature
P [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [2]->
Q [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  52
#[serial 1087] Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature:
step:  53
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1087]: operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature
P [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [2]->
Q [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1088]: operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature
P [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [2]->
Q [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  54
#[serial 1088] Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature:
step:  55
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1088]: operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature
P [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [2]->
Q [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1089]: Monitor::monitor_temperature.impl.mcti
P [9] << current_temperature = CURRENT_TEMP >>
S [42]->
Q [77] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcti:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  56
#[serial 1089] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcti:
step:  57
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1089]: Monitor::monitor_temperature.impl.mcti
P [9] << current_temperature = CURRENT_TEMP >>
S [42]->
Q [77] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcti:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1090]: Monitor::monitor_temperature.impl.mcta
P [9] << current_temperature = CURRENT_TEMP >>
S [43]->
Q [259] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcta:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  58
#[serial 1090] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcta:
step:  59
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1090]: Monitor::monitor_temperature.impl.mcta
P [9] << current_temperature = CURRENT_TEMP >>
S [43]->
Q [259] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcta:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1091]: Monitor::monitor_temperature.impl.mctm
P [9] << current_temperature = CURRENT_TEMP >>
S [44]->
Q [126] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mctm:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  60
#[serial 1091] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mctm:
step:  61
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1091]: Monitor::monitor_temperature.impl.mctm
P [9] << current_temperature = CURRENT_TEMP >>
S [44]->
Q [126] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mctm:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1092]: Monitor::monitor_temperature.impl.muat
P [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [46]->
Q [81] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.muat:
 upper_alarm_temperature -> upper_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  62
#[serial 1092] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.muat:
step:  63
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1092]: Monitor::monitor_temperature.impl.muat
P [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [46]->
Q [81] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.muat:
 upper_alarm_temperature -> upper_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1093]: Monitor::monitor_temperature.impl.mlat
P [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [47]->
Q [83] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mlat:
 lower_alarm_temperature -> lower_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  64
#[serial 1093] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mlat:
step:  65
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1093]: Monitor::monitor_temperature.impl.mlat
P [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [47]->
Q [83] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mlat:
 lower_alarm_temperature -> lower_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1094]: Monitor::monitor_temperature.impl.maul
P [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [48]->
Q [257] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.maul:
 upper_alarm_temperature -> upper_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  66
#[serial 1094] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.maul:
step:  67
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1094]: Monitor::monitor_temperature.impl.maul
P [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [48]->
Q [257] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.maul:
 upper_alarm_temperature -> upper_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1095]: Monitor::monitor_temperature.impl.mall
P [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [49]->
Q [255] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mall:
 lower_alarm_temperature -> lower_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  68
#[serial 1095] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mall:
step:  69
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1095]: Monitor::monitor_temperature.impl.mall
P [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [49]->
Q [255] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mall:
 lower_alarm_temperature -> lower_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1096]: Monitor::monitor_temperature.impl.malrm
P [251] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [51]->
Q [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.malrm:
 alarm_control -> alarm_control
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  70
#[serial 1096] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.malrm:
step:  71
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1096]: Monitor::monitor_temperature.impl.malrm
P [251] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [51]->
Q [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.malrm:
 alarm_control -> alarm_control
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1097]: Monitor::monitor_temperature.impl.mms
P [85] << monitor_status = MONITOR_STATUS() >>
S [53]->
Q [17] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mms:
 monitor_status -> monitor_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  72
#[serial 1097] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mms:
step:  73
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1097]: Monitor::monitor_temperature.impl.mms
P [85] << monitor_status = MONITOR_STATUS() >>
S [53]->
Q [17] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mms:
 monitor_status -> monitor_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1098]: Monitor::monitor_temperature.impl.intff
P [87] << MONITOR_INTERFACE_FAILURE >>
S [54]->
Q [122] << MONITOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.intff:
 interface_failure -> interface_failure
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  74
#[serial 1098] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.intff:
step:  75
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1098]: Monitor::monitor_temperature.impl.intff
P [87] << MONITOR_INTERFACE_FAILURE >>
S [54]->
Q [122] << MONITOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.intff:
 interface_failure -> interface_failure
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1099]: Monitor::monitor_temperature.impl.mf
P [19] << INTERNAL_FAILURE >>
S [56]->
Q [124] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mf:
 regulator_failure -> internal_failure
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  76
#[serial 1099] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mf:
step:  77
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1099]: Monitor::monitor_temperature.impl.mf
P [19] << INTERNAL_FAILURE >>
S [56]->
Q [124] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mf:
 regulator_failure -> internal_failure
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1100]: Monitor::monitor_temperature.impl.mmmi
P [120] << +=> MONITOR_MODE(x : monitor_mode) >>
S [57]->
Q [79] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmmi:
 monitor_mode -> monitor_mode
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  78
#[serial 1100] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmmi:
step:  79
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1100]: Monitor::monitor_temperature.impl.mmmi
P [120] << +=> MONITOR_MODE(x : monitor_mode) >>
S [57]->
Q [79] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmmi:
 monitor_mode -> monitor_mode
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1101]: Monitor::monitor_temperature.impl.mmma
P [120] << +=> MONITOR_MODE(x : monitor_mode) >>
S [58]->
Q [253] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmma:
 monitor_mode -> monitor_mode
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  80
#[serial 1101] Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmma:
step:  81
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1101]: Monitor::monitor_temperature.impl.mmma
P [120] << +=> MONITOR_MODE(x : monitor_mode) >>
S [58]->
Q [253] << +=> MONITOR_MODE(x : monitor_mode) >>
What for:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmma:
 monitor_mode -> monitor_mode
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1102]: KSU_Isolette::isolette.single_sensor.a2ts
P [136] << air_temperature_air = CURRENT_TEMP >>
S [173]->
Q [93] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.a2ts:
 air_temperature -> air
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  82
#[serial 1102] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.a2ts:
step:  83
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1102]: KSU_Isolette::isolette.single_sensor.a2ts
P [136] << air_temperature_air = CURRENT_TEMP >>
S [173]->
Q [93] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.a2ts:
 air_temperature -> air
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1103]: KSU_Isolette::isolette.single_sensor.ct
P [95] << current_temperature = CURRENT_TEMP >>
S [175]->
Q [288] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ct:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  84
#[serial 1103] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ct:
step:  85
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1103]: KSU_Isolette::isolette.single_sensor.ct
P [95] << current_temperature = CURRENT_TEMP >>
S [175]->
Q [288] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ct:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1104]: KSU_Isolette::isolette.single_sensor.hc
P [290] << +=> HEAT_CONTROL(x : heat_control) >>
S [177]->
Q [156] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.hc:
 heat_control -> heat_control
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  86
#[serial 1104] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.hc:
step:  87
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1104]: KSU_Isolette::isolette.single_sensor.hc
P [290] << +=> HEAT_CONTROL(x : heat_control) >>
S [177]->
Q [156] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.hc:
 heat_control -> heat_control
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1105]: KSU_Isolette::isolette.single_sensor.ldt
P [442] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [183]->
Q [292] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  88
#[serial 1105] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ldt:
step:  89
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1105]: KSU_Isolette::isolette.single_sensor.ldt
P [442] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [183]->
Q [292] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1106]: KSU_Isolette::isolette.single_sensor.udt
P [444] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [185]->
Q [294] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  90
#[serial 1106] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.udt:
step:  91
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1106]: KSU_Isolette::isolette.single_sensor.udt
P [444] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [185]->
Q [294] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1107]: KSU_Isolette::isolette.single_sensor.lat
P [446] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [187]->
Q [296] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  92
#[serial 1107] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.lat:
step:  93
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1107]: KSU_Isolette::isolette.single_sensor.lat
P [446] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [187]->
Q [296] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1108]: KSU_Isolette::isolette.single_sensor.uat
P [448] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [189]->
Q [298] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  94
#[serial 1108] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.uat:
step:  95
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1108]: KSU_Isolette::isolette.single_sensor.uat
P [448] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [189]->
Q [298] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1109]: KSU_Isolette::isolette.single_sensor.rs
P [300] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [191]->
Q [451] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.rs:
 regulator_status -> regulator_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  96
#[serial 1109] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.rs:
step:  97
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1109]: KSU_Isolette::isolette.single_sensor.rs
P [300] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [191]->
Q [451] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.rs:
 regulator_status -> regulator_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1110]: KSU_Isolette::isolette.single_sensor.ms
P [302] << monitor_status = MONITOR_STATUS() >>
S [193]->
Q [453] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ms:
 monitor_status -> monitor_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  98
#[serial 1110] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ms:
step:  99
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1110]: KSU_Isolette::isolette.single_sensor.ms
P [302] << monitor_status = MONITOR_STATUS() >>
S [193]->
Q [453] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ms:
 monitor_status -> monitor_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1111]: KSU_Isolette::isolette.single_sensor.dt
P [304] << display_temperature = CURRENT_TEMP >>
S [195]->
Q [455] << display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.dt:
 display_temperature -> display_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  100
#[serial 1111] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.dt:
step:  101
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1111]: KSU_Isolette::isolette.single_sensor.dt
P [304] << display_temperature = CURRENT_TEMP >>
S [195]->
Q [455] << display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.dt:
 display_temperature -> display_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1112]: KSU_Isolette::isolette.single_sensor.al
P [306] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [197]->
Q [457] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.al:
 alarm_control -> alarm
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  102
#[serial 1112] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.al:
step:  103
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1112]: KSU_Isolette::isolette.single_sensor.al
P [306] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [197]->
Q [457] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.al:
 alarm_control -> alarm
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1113]: KSU_Isolette::isolette.dual_sensor.a2cs
P [136] << air_temperature_air = CURRENT_TEMP >>
S [260]->
Q [93] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2cs:
 air_temperature -> air
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  104
#[serial 1113] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2cs:
step:  105
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1113]: KSU_Isolette::isolette.dual_sensor.a2cs
P [136] << air_temperature_air = CURRENT_TEMP >>
S [260]->
Q [93] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2cs:
 air_temperature -> air
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1114]: KSU_Isolette::isolette.dual_sensor.a2ms
P [136] << air_temperature_air = CURRENT_TEMP >>
S [261]->
Q [93] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2ms:
 air_temperature -> air
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  106
#[serial 1114] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2ms:
step:  107
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1114]: KSU_Isolette::isolette.dual_sensor.a2ms
P [136] << air_temperature_air = CURRENT_TEMP >>
S [261]->
Q [93] << air_temperature_air = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2ms:
 air_temperature -> air
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1115]: KSU_Isolette::isolette.dual_sensor.cont
P [95] << current_temperature_control_temp = CURRENT_TEMP >>
S [266]->
Q [368] << current_temperature_control_temp = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.cont:
 current_temperature -> control_temp
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  108
#[serial 1115] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.cont:
step:  109
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1115]: KSU_Isolette::isolette.dual_sensor.cont
P [95] << current_temperature_control_temp = CURRENT_TEMP >>
S [266]->
Q [368] << current_temperature_control_temp = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.cont:
 current_temperature -> control_temp
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1116]: KSU_Isolette::isolette.dual_sensor.ct
P [95] << current_temperature_monitor_temp = CURRENT_TEMP >>
S [267]->
Q [371] << current_temperature_monitor_temp = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ct:
 current_temperature -> monitor_temp
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  110
#[serial 1116] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ct:
step:  111
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1116]: KSU_Isolette::isolette.dual_sensor.ct
P [95] << current_temperature_monitor_temp = CURRENT_TEMP >>
S [267]->
Q [371] << current_temperature_monitor_temp = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ct:
 current_temperature -> monitor_temp
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1117]: KSU_Isolette::isolette.dual_sensor.hc
P [373] << +=> HEAT_CONTROL(x : heat_control) >>
S [268]->
Q [156] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.hc:
 heat_control -> heat_control
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  112
#[serial 1117] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.hc:
step:  113
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1117]: KSU_Isolette::isolette.dual_sensor.hc
P [373] << +=> HEAT_CONTROL(x : heat_control) >>
S [268]->
Q [156] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.hc:
 heat_control -> heat_control
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1118]: KSU_Isolette::isolette.dual_sensor.ldt
P [442] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [269]->
Q [375] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  114
#[serial 1118] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ldt:
step:  115
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1118]: KSU_Isolette::isolette.dual_sensor.ldt
P [442] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [269]->
Q [375] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1119]: KSU_Isolette::isolette.dual_sensor.udt
P [444] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [270]->
Q [377] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  116
#[serial 1119] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.udt:
step:  117
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1119]: KSU_Isolette::isolette.dual_sensor.udt
P [444] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [270]->
Q [377] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1120]: KSU_Isolette::isolette.dual_sensor.lat
P [446] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [271]->
Q [379] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  118
#[serial 1120] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.lat:
step:  119
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1120]: KSU_Isolette::isolette.dual_sensor.lat
P [446] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [271]->
Q [379] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1121]: KSU_Isolette::isolette.dual_sensor.uat
P [448] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [272]->
Q [381] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  120
#[serial 1121] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.uat:
step:  121
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1121]: KSU_Isolette::isolette.dual_sensor.uat
P [448] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [272]->
Q [381] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1122]: KSU_Isolette::isolette.dual_sensor.rs
P [383] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [273]->
Q [451] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.rs:
 regulator_status -> regulator_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  122
#[serial 1122] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.rs:
step:  123
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1122]: KSU_Isolette::isolette.dual_sensor.rs
P [383] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [273]->
Q [451] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.rs:
 regulator_status -> regulator_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1123]: KSU_Isolette::isolette.dual_sensor.ms
P [385] << monitor_status = MONITOR_STATUS() >>
S [274]->
Q [453] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ms:
 monitor_status -> monitor_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  124
#[serial 1123] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ms:
step:  125
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1123]: KSU_Isolette::isolette.dual_sensor.ms
P [385] << monitor_status = MONITOR_STATUS() >>
S [274]->
Q [453] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ms:
 monitor_status -> monitor_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1124]: KSU_Isolette::isolette.dual_sensor.dt
P [387] << display_temperature = CURRENT_TEMP >>
S [275]->
Q [455] << display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.dt:
 display_temperature -> display_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  126
#[serial 1124] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.dt:
step:  127
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1124]: KSU_Isolette::isolette.dual_sensor.dt
P [387] << display_temperature = CURRENT_TEMP >>
S [275]->
Q [455] << display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.dt:
 display_temperature -> display_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1125]: KSU_Isolette::isolette.dual_sensor.al
P [389] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [276]->
Q [457] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.al:
 alarm_control -> alarm
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  128
#[serial 1125] Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.al:
step:  129
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1125]: KSU_Isolette::isolette.dual_sensor.al
P [389] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [276]->
Q [457] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.al:
 alarm_control -> alarm
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1126]: KSU_Isolette::thermostat_single_sensor.impl.tctm
P [288] << current_temperature = CURRENT_TEMP >>
S [337]->
Q [9] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctm:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  130
#[serial 1126] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctm:
step:  131
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1126]: KSU_Isolette::thermostat_single_sensor.impl.tctm
P [288] << current_temperature = CURRENT_TEMP >>
S [337]->
Q [9] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctm:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1127]: KSU_Isolette::thermostat_single_sensor.impl.tctr
P [288] << current_temperature = CURRENT_TEMP >>
S [338]->
Q [19] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctr:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  132
#[serial 1127] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctr:
step:  133
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1127]: KSU_Isolette::thermostat_single_sensor.impl.tctr
P [288] << current_temperature = CURRENT_TEMP >>
S [338]->
Q [19] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctr:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1128]: KSU_Isolette::thermostat_single_sensor.impl.thc
P [21] << +=> HEAT_CONTROL(x : heat_control) >>
S [339]->
Q [290] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.thc:
 heat_control -> heat_control
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  134
#[serial 1128] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.thc:
step:  135
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1128]: KSU_Isolette::thermostat_single_sensor.impl.thc
P [21] << +=> HEAT_CONTROL(x : heat_control) >>
S [339]->
Q [290] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.thc:
 heat_control -> heat_control
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1129]: KSU_Isolette::thermostat_single_sensor.impl.tudt
P [294] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [340]->
Q [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  136
#[serial 1129] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tudt:
step:  137
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1129]: KSU_Isolette::thermostat_single_sensor.impl.tudt
P [294] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [340]->
Q [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1130]: KSU_Isolette::thermostat_single_sensor.impl.tldt
P [292] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [341]->
Q [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  138
#[serial 1130] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tldt:
step:  139
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1130]: KSU_Isolette::thermostat_single_sensor.impl.tldt
P [292] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [341]->
Q [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1131]: KSU_Isolette::thermostat_single_sensor.impl.tuat
P [298] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [342]->
Q [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  140
#[serial 1131] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tuat:
step:  141
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1131]: KSU_Isolette::thermostat_single_sensor.impl.tuat
P [298] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [342]->
Q [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1132]: KSU_Isolette::thermostat_single_sensor.impl.tlat
P [296] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [343]->
Q [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  142
#[serial 1132] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tlat:
step:  143
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1132]: KSU_Isolette::thermostat_single_sensor.impl.tlat
P [296] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [343]->
Q [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1133]: KSU_Isolette::thermostat_single_sensor.impl.trs
P [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [344]->
Q [300] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.trs:
 regulator_status -> regulator_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  144
#[serial 1133] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.trs:
step:  145
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1133]: KSU_Isolette::thermostat_single_sensor.impl.trs
P [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [344]->
Q [300] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.trs:
 regulator_status -> regulator_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1134]: KSU_Isolette::thermostat_single_sensor.impl.tdt
P [17] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [345]->
Q [304] << displayed_temp_display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tdt:
 displayed_temp -> display_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  146
#[serial 1134] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tdt:
step:  147
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1134]: KSU_Isolette::thermostat_single_sensor.impl.tdt
P [17] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [345]->
Q [304] << displayed_temp_display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tdt:
 displayed_temp -> display_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1135]: KSU_Isolette::thermostat_single_sensor.impl.tms
P [17] << monitor_status = MONITOR_STATUS() >>
S [346]->
Q [302] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tms:
 monitor_status -> monitor_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  148
#[serial 1135] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tms:
step:  149
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1135]: KSU_Isolette::thermostat_single_sensor.impl.tms
P [17] << monitor_status = MONITOR_STATUS() >>
S [346]->
Q [302] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tms:
 monitor_status -> monitor_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1136]: KSU_Isolette::thermostat_single_sensor.impl.ta
P [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [347]->
Q [306] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.ta:
 alarm_control -> alarm_control
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  150
#[serial 1136] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.ta:
step:  151
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1136]: KSU_Isolette::thermostat_single_sensor.impl.ta
P [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [347]->
Q [306] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.ta:
 alarm_control -> alarm_control
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1137]: KSU_Isolette::thermostat_single_sensor.impl.tf
P [10] << INTERNAL_FAILURE >>
S [348]->
Q [19] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tf:
 internal_failure -> regulator_failure
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  152
#[serial 1137] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tf:
step:  153
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1137]: KSU_Isolette::thermostat_single_sensor.impl.tf
P [10] << INTERNAL_FAILURE >>
S [348]->
Q [19] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tf:
 internal_failure -> regulator_failure
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1138]: KSU_Isolette::thermostat_dual_sensor.impl.tctm
P [371] << monitor_temp_current_temperature = CURRENT_TEMP >>
S [416]->
Q [9] << monitor_temp_current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctm:
 monitor_temp -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  154
#[serial 1138] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctm:
step:  155
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1138]: KSU_Isolette::thermostat_dual_sensor.impl.tctm
P [371] << monitor_temp_current_temperature = CURRENT_TEMP >>
S [416]->
Q [9] << monitor_temp_current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctm:
 monitor_temp -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1139]: KSU_Isolette::thermostat_dual_sensor.impl.tctr
P [368] << control_temp_current_temperature = CURRENT_TEMP >>
S [417]->
Q [19] << control_temp_current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctr:
 control_temp -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  156
#[serial 1139] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctr:
step:  157
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1139]: KSU_Isolette::thermostat_dual_sensor.impl.tctr
P [368] << control_temp_current_temperature = CURRENT_TEMP >>
S [417]->
Q [19] << control_temp_current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctr:
 control_temp -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1140]: KSU_Isolette::thermostat_dual_sensor.impl.thc
P [21] << +=> HEAT_CONTROL(x : heat_control) >>
S [418]->
Q [373] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.thc:
 heat_control -> heat_control
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  158
#[serial 1140] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.thc:
step:  159
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1140]: KSU_Isolette::thermostat_dual_sensor.impl.thc
P [21] << +=> HEAT_CONTROL(x : heat_control) >>
S [418]->
Q [373] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.thc:
 heat_control -> heat_control
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1141]: KSU_Isolette::thermostat_dual_sensor.impl.tudt
P [377] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [419]->
Q [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  160
#[serial 1141] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tudt:
step:  161
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1141]: KSU_Isolette::thermostat_dual_sensor.impl.tudt
P [377] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [419]->
Q [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1142]: KSU_Isolette::thermostat_dual_sensor.impl.tldt
P [375] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [420]->
Q [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  162
#[serial 1142] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tldt:
step:  163
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1142]: KSU_Isolette::thermostat_dual_sensor.impl.tldt
P [375] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [420]->
Q [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1143]: KSU_Isolette::thermostat_dual_sensor.impl.tuat
P [381] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [421]->
Q [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  164
#[serial 1143] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tuat:
step:  165
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1143]: KSU_Isolette::thermostat_dual_sensor.impl.tuat
P [381] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [421]->
Q [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1144]: KSU_Isolette::thermostat_dual_sensor.impl.tlat
P [379] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [422]->
Q [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  166
#[serial 1144] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tlat:
step:  167
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1144]: KSU_Isolette::thermostat_dual_sensor.impl.tlat
P [379] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [422]->
Q [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1145]: KSU_Isolette::thermostat_dual_sensor.impl.trs
P [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [423]->
Q [383] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.trs:
 regulator_status -> regulator_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  168
#[serial 1145] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.trs:
step:  169
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1145]: KSU_Isolette::thermostat_dual_sensor.impl.trs
P [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [423]->
Q [383] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.trs:
 regulator_status -> regulator_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1146]: KSU_Isolette::thermostat_dual_sensor.impl.tdt
P [17] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [424]->
Q [387] << displayed_temp_display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tdt:
 displayed_temp -> display_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  170
#[serial 1146] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tdt:
step:  171
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1146]: KSU_Isolette::thermostat_dual_sensor.impl.tdt
P [17] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [424]->
Q [387] << displayed_temp_display_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tdt:
 displayed_temp -> display_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1147]: KSU_Isolette::thermostat_dual_sensor.impl.tms
P [17] << monitor_status = MONITOR_STATUS() >>
S [425]->
Q [385] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tms:
 monitor_status -> monitor_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  172
#[serial 1147] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tms:
step:  173
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1147]: KSU_Isolette::thermostat_dual_sensor.impl.tms
P [17] << monitor_status = MONITOR_STATUS() >>
S [425]->
Q [385] << monitor_status = MONITOR_STATUS() >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tms:
 monitor_status -> monitor_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1148]: KSU_Isolette::thermostat_dual_sensor.impl.ta
P [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [426]->
Q [389] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.ta:
 alarm_control -> alarm_control
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  174
#[serial 1148] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.ta:
step:  175
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1148]: KSU_Isolette::thermostat_dual_sensor.impl.ta
P [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [426]->
Q [389] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.ta:
 alarm_control -> alarm_control
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1149]: KSU_Isolette::thermostat_dual_sensor.impl.tf
P [10] << INTERNAL_FAILURE >>
S [427]->
Q [19] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tf:
 internal_failure -> regulator_failure
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  176
#[serial 1149] Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tf:
step:  177
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1149]: KSU_Isolette::thermostat_dual_sensor.impl.tf
P [10] << INTERNAL_FAILURE >>
S [427]->
Q [19] << INTERNAL_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tf:
 internal_failure -> regulator_failure
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1150]: Nursery::Room.Normal_Operation.tmp
P [19] << air_temperature = CURRENT_TEMP >>
S [124]->
Q [136] << air_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Nursery::Room.Normal_Operation.tmp:
 air_temperature -> air_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  178
#[serial 1150] Composition of Subcomponents via Directional Connection Nursery::Room.Normal_Operation.tmp:
step:  179
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1150]: Nursery::Room.Normal_Operation.tmp
P [19] << air_temperature = CURRENT_TEMP >>
S [124]->
Q [136] << air_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Nursery::Room.Normal_Operation.tmp:
 air_temperature -> air_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1151]: Regulate::regulate_temperature.impl.rudt
P [13] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
S [49]->
Q [88] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rudt:
 upper_desired_temperature -> upper_desired_temp
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  180
#[serial 1151] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rudt:
step:  181
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1151]: Regulate::regulate_temperature.impl.rudt
P [13] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
S [49]->
Q [88] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rudt:
 upper_desired_temperature -> upper_desired_temp
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1152]: Regulate::regulate_temperature.impl.rldt
P [11] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
S [50]->
Q [86] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rldt:
 lower_desired_temperature -> lower_desired_temp
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  182
#[serial 1152] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rldt:
step:  183
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1152]: Regulate::regulate_temperature.impl.rldt
P [11] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
S [50]->
Q [86] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rldt:
 lower_desired_temperature -> lower_desired_temp
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1153]: Regulate::regulate_temperature.impl.mudt
P [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [51]->
Q [301] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mudt:
 upper_desired_temperature -> upper_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  184
#[serial 1153] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mudt:
step:  185
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1153]: Regulate::regulate_temperature.impl.mudt
P [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [51]->
Q [301] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mudt:
 upper_desired_temperature -> upper_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1154]: Regulate::regulate_temperature.impl.mldt
P [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [52]->
Q [299] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mldt:
 lower_desired_temperature -> lower_desired_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  186
#[serial 1154] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mldt:
step:  187
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1154]: Regulate::regulate_temperature.impl.mldt
P [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [52]->
Q [299] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mldt:
 lower_desired_temperature -> lower_desired_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1155]: Regulate::regulate_temperature.impl.rrs
P [84] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [54]->
Q [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrs:
 regulator_status -> regulator_status
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  188
#[serial 1155] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrs:
step:  189
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1155]: Regulate::regulate_temperature.impl.rrs
P [84] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [54]->
Q [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrs:
 regulator_status -> regulator_status
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1156]: Regulate::regulate_temperature.impl.rdt
P [92] << displayed_temp = CURRENT_TEMP >>
S [56]->
Q [17] << displayed_temp = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rdt:
 displayed_temp -> displayed_temp
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  190
#[serial 1156] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rdt:
step:  191
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1156]: Regulate::regulate_temperature.impl.rdt
P [92] << displayed_temp = CURRENT_TEMP >>
S [56]->
Q [17] << displayed_temp = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rdt:
 displayed_temp -> displayed_temp
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1157]: Regulate::regulate_temperature.impl.rcti
P [19] << current_temperature = CURRENT_TEMP >>
S [58]->
Q [90] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcti:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  192
#[serial 1157] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcti:
step:  193
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1157]: Regulate::regulate_temperature.impl.rcti
P [19] << current_temperature = CURRENT_TEMP >>
S [58]->
Q [90] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcti:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1158]: Regulate::regulate_temperature.impl.rcth
P [19] << current_temperature = CURRENT_TEMP >>
S [59]->
Q [297] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcth:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  194
#[serial 1158] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcth:
step:  195
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1158]: Regulate::regulate_temperature.impl.rcth
P [19] << current_temperature = CURRENT_TEMP >>
S [59]->
Q [297] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcth:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1159]: Regulate::regulate_temperature.impl.rhc
P [295] << +=> HEAT_CONTROL(x : heat_control) >>
S [61]->
Q [21] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rhc:
 heat_control -> heat_control
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  196
#[serial 1159] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rhc:
step:  197
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1159]: Regulate::regulate_temperature.impl.rhc
P [295] << +=> HEAT_CONTROL(x : heat_control) >>
S [61]->
Q [21] << +=> HEAT_CONTROL(x : heat_control) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rhc:
 heat_control -> heat_control
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1160]: Regulate::regulate_temperature.impl.rrmh
P [161] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [62]->
Q [303] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmh:
 regulator_mode -> regulator_mode
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  198
#[serial 1160] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmh:
step:  199
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1160]: Regulate::regulate_temperature.impl.rrmh
P [161] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [62]->
Q [303] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmh:
 regulator_mode -> regulator_mode
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1161]: Regulate::regulate_temperature.impl.rrmi
P [161] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [63]->
Q [94] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmi:
 regulator_mode -> regulator_mode
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  200
#[serial 1161] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmi:
step:  201
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1161]: Regulate::regulate_temperature.impl.rrmi
P [161] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [63]->
Q [94] << +=> REGULATOR_MODE(x : regulator_mode) >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmi:
 regulator_mode -> regulator_mode
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1162]: Regulate::regulate_temperature.impl.rctm
P [19] << current_temperature = CURRENT_TEMP >>
S [64]->
Q [163] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rctm:
 current_temperature -> current_temperature
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  202
#[serial 1162] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rctm:
step:  203
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1162]: Regulate::regulate_temperature.impl.rctm
P [19] << current_temperature = CURRENT_TEMP >>
S [64]->
Q [163] << current_temperature = CURRENT_TEMP >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rctm:
 current_temperature -> current_temperature
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1163]: Regulate::regulate_temperature.impl.rif
P [96] << REGULATOR_INTERFACE_FAILURE >>
S [65]->
Q [165] << REGULATOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rif:
 interface_failure -> interface_failure
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  204
#[serial 1163] Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rif:
step:  205
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1163]: Regulate::regulate_temperature.impl.rif
P [96] << REGULATOR_INTERFACE_FAILURE >>
S [65]->
Q [165] << REGULATOR_INTERFACE_FAILURE >>
What for:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rif:
 interface_failure -> interface_failure
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [9.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
There are no more unsolved proof obligations.
All proof obligations have been solved.  Q.E.D.
opening proof file "/Applications/OSATE-for-HAMR-and-BLESS/Eclipse-OfHaB.app/Contents/MacOS/proof.txt" Sun Jul 09 06:50:26 CDT 2023
Theorem (1)                               [serial 1003] 
P [167] << true >>
S [158] ->
Q [158] << true >>
Why created:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (2)                               [serial 1004] 
P [172] << RUN() >>
S [158] ->
Q [158] << true >>
Why created:  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (3)                               [serial 1183] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << true >>
Why created:    normalization of [serial 1181]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (4)                               [serial 1181] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1180]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 3:
Theorem (3) [serial 1183] used for:
    normalization of [serial 1181] 


Theorem (5)                               [serial 1180] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1179]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 4:
Theorem (4) [serial 1181] used for:
  Law of And-Simplification:  P and P is P [serial 1180] 


Theorem (6)                               [serial 1179] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1178]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 5:
Theorem (5) [serial 1180] used for:
  Law of And-Simplification:  P and P is P [serial 1179] 


Theorem (7)                               [serial 1178] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1177]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 6:
Theorem (6) [serial 1179] used for:
  Law of And-Simplification:  P and P is P [serial 1178] 


Theorem (8)                               [serial 1177] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( status'Valid = current_temperature_status
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not INTERNAL_FAILURE^0
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( status'Valid = current_temperature_status
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not INTERNAL_FAILURE^0
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1176]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 7:
Theorem (7) [serial 1178] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1177] 


Theorem (9)                               [serial 1176] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1174]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 8:
Theorem (8) [serial 1177] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1176] 


Theorem (10)                               [serial 1174] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1172]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 9:
Theorem (9) [serial 1176] used for:
  Associativity: (b.c).a = a.b.c [serial 1174] 


Theorem (11)                               [serial 1172] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and not ( not ( status'Valid = current_temperature_status ) ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1171]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 10:
Theorem (10) [serial 1174] used for:
    normalization of [serial 1172] 


Theorem (12)                               [serial 1171] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1169]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 11:
Theorem (11) [serial 1172] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1171] 


Theorem (13)                               [serial 1169] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1167]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 12:
Theorem (12) [serial 1171] used for:
  Associativity: (b.c).a = a.b.c [serial 1169] 


Theorem (14)                               [serial 1167] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1165]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 13:
Theorem (13) [serial 1169] used for:
    normalization of [serial 1167] 


Theorem (15)                               [serial 1165] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
   or ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1005]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 14:
Theorem (14) [serial 1167] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1165] 


Theorem (16)                               [serial 1005] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
S [169] ->
Q [169] << ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 15:
Theorem (15) [serial 1165] used for:
    normalization of [serial 1005] 


Theorem (17)                               [serial 1006] 
P [166] << true >>
S [166] ->
Q [166] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (18)                               [serial 1198] 
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [173] << true >>
Why created:    normalization of [serial 1196]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (19)                               [serial 1196] 
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [173] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1195]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 18:
Theorem (18) [serial 1198] used for:
    normalization of [serial 1196] 


Theorem (20)                               [serial 1195] 
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [173] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1194]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 19:
Theorem (19) [serial 1196] used for:
  Law of And-Simplification:  P and P is P [serial 1195] 


Theorem (21)                               [serial 1194] 
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [173] << ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1193]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 20:
Theorem (20) [serial 1195] used for:
  Law of And-Simplification:  P and P is P [serial 1194] 


Theorem (22)                               [serial 1193] 
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [173] << ( status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1191]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 21:
Theorem (21) [serial 1194] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1193] 


Theorem (23)                               [serial 1191] 
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [173] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 1189]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 22:
Theorem (22) [serial 1193] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1191] 


Theorem (24)                               [serial 1189] 
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [173] << INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and status'Valid = current_temperature_status ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1188]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 23:
Theorem (23) [serial 1191] used for:
    normalization of [serial 1189] 


Theorem (25)                               [serial 1188] 
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [173] << ( status'Valid = current_temperature_status
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 ) ) )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1186]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 24:
Theorem (24) [serial 1189] used for:
  Associativity: (b.c).a = a.b.c [serial 1188] 


Theorem (26)                               [serial 1186] 
P [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [173] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) )
   or ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
Why created:    normalization of [serial 1007]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 25:
Theorem (25) [serial 1188] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1186] 


Theorem (27)                               [serial 1007] 
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [173] ->
Q [173] << ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 26:
Theorem (26) [serial 1186] used for:
    normalization of [serial 1007] 


Theorem (28)                               [serial 1222] 
P [166] << true >>
S [180] ->
Q [181] << true >>
Why created:  Law of And-Simplification:  P and true is P [serial 1213]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (29)                               [serial 1213] 
P [166] << true >>
S [180] ->
Q [181] << true
  and true
  and true >>
Why created:    normalization of [serial 1207]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 28:
Theorem (28) [serial 1222] used for:
  Law of And-Simplification:  P and true is P [serial 1213] 


Theorem (30)                               [serial 1207] 
P [166] << true >>
S [180] ->
Q [181] << ( true )
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 29:
Theorem (29) [serial 1213] used for:
    normalization of [serial 1207] 


Theorem (31)                               [serial 1222] 
P [166] << true >>
S [180] ->
Q [181] << true >>
Why created:  Law of And-Simplification:  P and true is P [serial 1213]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (32)                               [serial 1213] 
P [166] << true >>
S [180] ->
Q [181] << true
  and true
  and true >>
Why created:    normalization of [serial 1207]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 31:
Theorem (31) [serial 1222] used for:
  Law of And-Simplification:  P and true is P [serial 1213] 


Theorem (33)                               [serial 1207] 
P [166] << true >>
S [180] ->
Q [181] << ( true )
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 32:
Theorem (32) [serial 1213] used for:
    normalization of [serial 1207] 


Theorem (34)                               [serial 1205] 
P [166] << true >>
S [180] ->
Q [181] << ( true )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1202]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 33 33:
Theorem (33) [serial 1207] used for:
   add user-defined axioms to postcondition 
Theorem (33) [serial 1207] used for:
   add user-defined axioms to postcondition 


Theorem (35)                               [serial 1202] 
P [166] << true >>
S [180] ->
Q [181] << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
Why created:  applied wp for assignment [serial 1200]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 34:
Theorem (34) [serial 1205] used for:
  Equality Law (idistr):  a=a <-> true [serial 1202] 


Theorem (36)                               [serial 1200] 
P [166] << true >>
S [180] start_time := now
Q [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1008]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 35:
Theorem (35) [serial 1202] used for:
  applied wp for assignment [serial 1200] 


Theorem (37)                               [serial 1229] 
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183] ->
Q [78] << 0 < #Iso_Properties::Initialization_Timeout >>
Why created:  Remove units from quantities  [serial 1227]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (38)                               [serial 1227] 
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183] ->
Q [78] << 0 < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1224]
Solved by:  Remove units from quantities
and theorem 37:
Theorem (37) [serial 1229] used for:
  Remove units from quantities  [serial 1227] 


Theorem (39)                               [serial 1224] 
REMAINS UNSOLVED!
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183] ->
Q [78] << now - now < #Iso_Properties::Initialization_Timeout s >>
Why created:  Guided Substitution of Equals 
 replacing "start_time" with its = "now" in its postcondition [serial 1223]
and theorem 38:
Theorem (38) [serial 1227] used for:
    normalization of [serial 1224] 


Theorem (40)                               [serial 1223] 
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183] ->
Q [78] << now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1220]
Solved by:  Guided Substitution of Equals
and theorem 39:
Theorem (39) [serial 1224] used for:
  Guided Substitution of Equals 
 replacing "start_time" with its = "now" in its postcondition [serial 1223] 


Theorem (41)                               [serial 1220] 
P [181] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [183] ->
Q [78] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1217]
Solved by:  Guided Substitution of Equals
and theorem 40:
Theorem (40) [serial 1223] used for:
  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1220] 


Theorem (42)                               [serial 1217] 
P [181] << now = start_time
  and ( start_time = START_TIME )
  and ( 0 < #Iso_Properties::Initialization_Timeout ) >>
S [183] ->
Q [78] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1209]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 41:
Theorem (41) [serial 1220] used for:
    normalization of [serial 1217] 


Theorem (43)                               [serial 1209] 
P [181] << now = start_time
  and AXIOM_ST()
  and AXIOM_TOGT0() >>
S [183] ->
Q [78] << INI() >>
Why created:    normalization of [serial 1203]
Solved by:  Substitution of Assertion Labels
and theorem 42:
Theorem (42) [serial 1217] used for:
  Substituted assertions' predicates for labels  [serial 1209] 


Theorem (44)                               [serial 1203] 
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183] ->
Q [78] << INI() >>
Why created:  applied port output of enumeration type  monitor_mode!(') [serial 1201]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 43:
Theorem (43) [serial 1209] used for:
    normalization of [serial 1203] 


Theorem (45)                               [serial 1211] 
P [183] << now = start_time
  and AXIOM_ST()
  and AXIOM_TOGT0()
  and ( mmode'Init = monitor_mode )^0 >>
S [183] ->
Q [302] << true >>
Why created:    normalization of [serial 1206]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (46)                               [serial 1206] 
P [183] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST()
  and ( monitor_mode = mmode'Init )^0 >>
S [183] ->
Q [302] << ( true )^1 >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1204]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 45:
Theorem (45) [serial 1211] used for:
    normalization of [serial 1206] 


Theorem (47)                               [serial 1204] 
P [183] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Init )^0 >>
S [183] ->
Q [302] << ( true )^1 >>
Why created:  applied port output <<pre and (monitor_mode=mmode'Init)^0>> -> <<post>> [serial 1201]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 46:
Theorem (46) [serial 1206] used for:
  Associativity: (b.c).a = a.b.c [serial 1204] 


Theorem (48)                               [serial 1201] 
P [181] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_ST() >>
S [183] monitor_mode!(mmode'Init)
Q [302] << ( true )^1 >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1008]
Solved by:  Enumeration Type Port Output 
and theorems 44 47:
Theorem (44) [serial 1203] used for:
  applied port output of enumeration type  monitor_mode!(') [serial 1201] 
Theorem (47) [serial 1204] used for:
  applied port output <<pre and (monitor_mode=mmode'Init)^0>> -> <<post>> [serial 1201] 


Theorem (49)                               [serial 1008] 
P [166] << true >>
S [180]   start_time := now
  << ( start_time = now )
    and AXIOM_TOGT0()
    and AXIOM_ST() >>
  ;
  monitor_mode!(mmode'Init) 
Q [167] << ( true )^1 >>
Why created:   <<M(start)>> A <<M(init)>> for mmm1: start-[ ]->init{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 36 48:
Theorem (36) [serial 1200] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1008] 
Theorem (48) [serial 1201] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1008] 


Theorem (50)                               [serial 1246] 
P [191] << current_temperature_status = temperature.status >>
S [169] ->
Q [169] << current_temperature_status = temperature.status >>
Why created:    normalization of [serial 1244]
Solved by:  Identity (id):  P->P is tautology


Theorem (51)                               [serial 1244] 
P [191] << current_temperature_status = temperature.status >>
S [169] ->
Q [169] << ( current_temperature_status = temperature.status ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1243]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 50:
Theorem (50) [serial 1246] used for:
    normalization of [serial 1244] 


Theorem (52)                               [serial 1243] 
P [191] << current_temperature_status = temperature.status >>
S [169] ->
Q [169] << current_temperature_status = temperature.status
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 51:
Theorem (51) [serial 1244] used for:
  Law of And-Simplification:  P and true is P [serial 1243] 


Theorem (53)                               [serial 1246] 
P [191] << current_temperature_status = temperature.status >>
S [169] ->
Q [169] << current_temperature_status = temperature.status >>
Why created:    normalization of [serial 1244]
Solved by:  Identity (id):  P->P is tautology


Theorem (54)                               [serial 1244] 
P [191] << current_temperature_status = temperature.status >>
S [169] ->
Q [169] << ( current_temperature_status = temperature.status ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1243]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 53:
Theorem (53) [serial 1246] used for:
    normalization of [serial 1244] 


Theorem (55)                               [serial 1243] 
P [191] << current_temperature_status = temperature.status >>
S [169] ->
Q [169] << current_temperature_status = temperature.status
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 54:
Theorem (54) [serial 1244] used for:
  Law of And-Simplification:  P and true is P [serial 1243] 


Theorem (56)                               [serial 1236] 
P [191] << current_temperature_status = temperature.status >>
S [169] ->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
Why created:    normalization of [serial 1230]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 55 55:
Theorem (55) [serial 1243] used for:
   add user-defined axioms to postcondition 
Theorem (55) [serial 1243] used for:
   add user-defined axioms to postcondition 


Theorem (57)                               [serial 1230] 
P [191] << current_temperature_status = temperature.status >>
S [169] ->
Q [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1009]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 56:
Theorem (56) [serial 1236] used for:
    normalization of [serial 1230] 


Theorem (58)                               [serial 1238] 
P [188] << CURRENT_TEMP = temperature
  and true >>
S [188] ->
Q [188] << true >>
Why created:    normalization of [serial 1233]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (59)                               [serial 1233] 
P [188] << ( true )
  and temperature = CURRENT_TEMP >>
S [188] ->
Q [188] << true >>
Why created:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1231]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 58:
Theorem (58) [serial 1238] used for:
    normalization of [serial 1233] 


Theorem (60)                               [serial 1231] 
P [167] << true >>
S [188] current_temperature?(temperature)
Q [188] << true >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1009]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 59:
Theorem (59) [serial 1233] used for:
  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1231] 


Theorem (61)                               [serial 1242] 
P [188] << true >>
S [190] ->
Q [191] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1234]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (62)                               [serial 1234] 
P [188] << true >>
S [190] ->
Q [191] << temperature.status = temperature.status >>
Why created:  applied wp for assignment [serial 1232]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 61:
Theorem (61) [serial 1242] used for:
  Equality Law (idistr):  a=a <-> true [serial 1234] 


Theorem (63)                               [serial 1232] 
P [188] << true >>
S [190] current_temperature_status := temperature.status
Q [191] << current_temperature_status = temperature.status >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1009]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 62:
Theorem (62) [serial 1234] used for:
  applied wp for assignment [serial 1232] 


Theorem (64)                               [serial 1009] 
P [167] << true >>
S [188]   current_temperature?(temperature)
  ;
  current_temperature_status := temperature.status
  << current_temperature_status = temperature.status >> 
Q [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS() >>
Why created:   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 57 60 63:
Theorem (57) [serial 1230] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1009] 
Theorem (60) [serial 1231] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1009] 
Theorem (63) [serial 1232] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1009] 


Theorem (65)                               [serial 1311] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [198] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1305]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (66)                               [serial 1305] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 1299]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 65:
Theorem (65) [serial 1311] used for:
  Associativity: (b.c).a = a.b.c [serial 1305] 


Theorem (67)                               [serial 1299] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1294]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 66:
Theorem (66) [serial 1305] used for:
    normalization of [serial 1299] 


Theorem (68)                               [serial 1294] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 1288]
Solved by:  Substitution of Assertion Labels
and theorem 67:
Theorem (67) [serial 1299] used for:
  Substituted assertions' predicates for labels  [serial 1294] 


Theorem (69)                               [serial 1288] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1282]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 68:
Theorem (68) [serial 1294] used for:
    normalization of [serial 1288] 


Theorem (70)                               [serial 1282] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 1277]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 69:
Theorem (69) [serial 1288] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1282] 


Theorem (71)                               [serial 1277] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 70:
Theorem (70) [serial 1282] used for:
    normalization of [serial 1277] 


Theorem (72)                               [serial 1292] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1287]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (73)                               [serial 1287] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1278]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 72:
Theorem (72) [serial 1292] used for:
    normalization of [serial 1287] 


Theorem (74)                               [serial 1278] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 73:
Theorem (73) [serial 1287] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1278] 


Theorem (75)                               [serial 1272] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1269]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 71 74:
Theorem (71) [serial 1277] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272] 
Theorem (74) [serial 1278] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272] 


Theorem (76)                               [serial 1269] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1265]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 75:
Theorem (75) [serial 1272] used for:
    normalization of [serial 1269] 


Theorem (77)                               [serial 1265] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1261]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 76:
Theorem (76) [serial 1269] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1265] 


Theorem (78)                               [serial 1261] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( status'Valid = current_temperature_status )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1259]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 77:
Theorem (77) [serial 1265] used for:
    normalization of [serial 1261] 


Theorem (79)                               [serial 1259] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1258]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 78:
Theorem (78) [serial 1261] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1259] 


Theorem (80)                               [serial 1258] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and true
  and true >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1257]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 79:
Theorem (79) [serial 1259] used for:
  Law of And-Simplification:  P and true is P [serial 1258] 


Theorem (81)                               [serial 1257] 
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << true
  and true
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:   add user-defined axioms to postcondition
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 80:
Theorem (80) [serial 1258] used for:
  Assume Present:  P = P@now = P^0   [serial 1257] 


Theorem (82)                               [serial 1311] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [198] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1305]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (83)                               [serial 1305] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 1299]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 82:
Theorem (82) [serial 1311] used for:
  Associativity: (b.c).a = a.b.c [serial 1305] 


Theorem (84)                               [serial 1299] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1294]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 83:
Theorem (83) [serial 1305] used for:
    normalization of [serial 1299] 


Theorem (85)                               [serial 1294] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 1288]
Solved by:  Substitution of Assertion Labels
and theorem 84:
Theorem (84) [serial 1299] used for:
  Substituted assertions' predicates for labels  [serial 1294] 


Theorem (86)                               [serial 1288] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1282]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 85:
Theorem (85) [serial 1294] used for:
    normalization of [serial 1288] 


Theorem (87)                               [serial 1282] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 1277]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 86:
Theorem (86) [serial 1288] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1282] 


Theorem (88)                               [serial 1277] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 87:
Theorem (87) [serial 1282] used for:
    normalization of [serial 1277] 


Theorem (89)                               [serial 1292] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [169] ->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1287]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (90)                               [serial 1287] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1278]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 89:
Theorem (89) [serial 1292] used for:
    normalization of [serial 1287] 


Theorem (91)                               [serial 1278] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [200] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 90:
Theorem (90) [serial 1287] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1278] 


Theorem (92)                               [serial 1272] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1269]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 88 91:
Theorem (88) [serial 1277] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272] 
Theorem (91) [serial 1278] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1272] 


Theorem (93)                               [serial 1269] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1265]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 92:
Theorem (92) [serial 1272] used for:
    normalization of [serial 1269] 


Theorem (94)                               [serial 1265] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1261]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 93:
Theorem (93) [serial 1269] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1265] 


Theorem (95)                               [serial 1261] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( status'Valid = current_temperature_status )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1259]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 94:
Theorem (94) [serial 1265] used for:
    normalization of [serial 1261] 


Theorem (96)                               [serial 1259] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1258]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 95:
Theorem (95) [serial 1261] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1259] 


Theorem (97)                               [serial 1258] 
P [169] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and true
  and true >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1257]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 96:
Theorem (96) [serial 1259] used for:
  Law of And-Simplification:  P and true is P [serial 1258] 


Theorem (98)                               [serial 1257] 
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << true
  and true
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:   add user-defined axioms to postcondition
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 97:
Theorem (97) [serial 1258] used for:
  Assume Present:  P = P@now = P^0   [serial 1257] 


Theorem (99)                               [serial 1253] 
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [169] ->
Q [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1251]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 98 98:
Theorem (98) [serial 1257] used for:
   add user-defined axioms to postcondition 
Theorem (98) [serial 1257] used for:
   add user-defined axioms to postcondition 


Theorem (100)                               [serial 1327] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1315]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (101)                               [serial 1315] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1312]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
and theorem 100:
Theorem (100) [serial 1327] used for:
  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1315] 


Theorem (102)                               [serial 1312] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 101:
Theorem (101) [serial 1315] used for:
    normalization of [serial 1312] 


Theorem (103)                               [serial 1309] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1301]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 102:
Theorem (102) [serial 1312] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1309] 


Theorem (104)                               [serial 1301] 
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 1297]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 103:
Theorem (103) [serial 1309] used for:
  Associativity: (b.c).a = a.b.c [serial 1301] 


Theorem (105)                               [serial 1297] 
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1279]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 104:
Theorem (104) [serial 1301] used for:
    normalization of [serial 1297] 


Theorem (106)                               [serial 1279] 
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << RUN() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]
Solved by:  Substitution of Assertion Labels
and theorem 105:
Theorem (105) [serial 1297] used for:
  Substituted assertions' predicates for labels  [serial 1279] 


Theorem (107)                               [serial 1326] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1325]
Solved by:  Guided Substitution of Equals
  And Introduction Schema (aisph):  (X and Y)->X


Theorem (108)                               [serial 1325] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1323]
Solved by:  Guided Substitution of Equals
and theorem 107:
Theorem (107) [serial 1326] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1325] 


Theorem (109)                               [serial 1323] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:    normalization of [serial 1320]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 108:
Theorem (108) [serial 1325] used for:
  Associativity: (b.c).a = a.b.c [serial 1323] 


Theorem (110)                               [serial 1320] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1317]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 109:
Theorem (109) [serial 1323] used for:
    normalization of [serial 1320] 


Theorem (111)                               [serial 1317] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 1313]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 110:
Theorem (110) [serial 1320] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1317] 


Theorem (112)                               [serial 1313] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1310]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 111:
Theorem (111) [serial 1317] used for:
    normalization of [serial 1313] 


Theorem (113)                               [serial 1310] 
P [198] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1303]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 112:
Theorem (112) [serial 1313] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1310] 


Theorem (114)                               [serial 1303] 
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:    normalization of [serial 1298]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 113:
Theorem (113) [serial 1310] used for:
  Associativity: (b.c).a = a.b.c [serial 1303] 


Theorem (115)                               [serial 1298] 
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1280]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 114:
Theorem (114) [serial 1303] used for:
    normalization of [serial 1298] 


Theorem (116)                               [serial 1280] 
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << not MONITOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274]
Solved by:  Substitution of Assertion Labels
and theorem 115:
Theorem (115) [serial 1298] used for:
  Substituted assertions' predicates for labels  [serial 1280] 


Theorem (117)                               [serial 1274] 
P [198] << ( ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = current_temperature_status ) )
  and AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [202] ->
Q [80] << RUN()
  and not MONITOR_OK() >>
Why created:    normalization of [serial 1270]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 106 116:
Theorem (106) [serial 1279] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274] 
Theorem (116) [serial 1280] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1274] 


Theorem (118)                               [serial 1270] 
P [198] << ( not ( status'Valid = current_temperature_status )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202] ->
Q [80] << RUN()
  and not MONITOR_OK() >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1268]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 117:
Theorem (117) [serial 1274] used for:
    normalization of [serial 1270] 


Theorem (119)                               [serial 1268] 
P [198] << ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202] ->
Q [80] << RUN()
  and not MONITOR_OK() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1263]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 118:
Theorem (118) [serial 1270] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1268] 


Theorem (120)                               [serial 1263] 
P [198] << ( ( not ( status'Valid = current_temperature_status )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [202] ->
Q [80] << RUN()
  and not MONITOR_OK() >>
Why created:    normalization of [serial 1260]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 119:
Theorem (119) [serial 1268] used for:
  Associativity: (b.c).a = a.b.c [serial 1263] 


Theorem (121)                               [serial 1260] 
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( status'Valid = current_temperature_status )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) ) >>
S [202] ->
Q [80] << not MONITOR_OK()
  and RUN() >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1255]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 120:
Theorem (120) [serial 1263] used for:
    normalization of [serial 1260] 


Theorem (122)                               [serial 1255] 
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202] ->
Q [80] << not MONITOR_OK()
  and RUN() >>
Why created:  applied port output of enumeration type  monitor_mode!(') [serial 1254]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 121:
Theorem (121) [serial 1260] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1255] 


Theorem (123)                               [serial 1256] 
P [202] << ( AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( monitor_mode = mmode'Failed )^0 >>
S [202] ->
Q [175] << true >>
Why created:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1254]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (124)                               [serial 1254] 
P [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [202] monitor_mode!(mmode'Failed)
Q [175] << true >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1251]
Solved by:  Enumeration Type Port Output 
and theorems 122 123:
Theorem (122) [serial 1255] used for:
  applied port output of enumeration type  monitor_mode!(') [serial 1254] 
Theorem (123) [serial 1256] used for:
  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1254] 


Theorem (125)                               [serial 1251] 
P [169] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1249]
Solved by:  Introduction of Existential Quantification
and theorems 99 124:
Theorem (99) [serial 1253] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1251] 
Theorem (124) [serial 1254] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1251] 


Theorem (126)                               [serial 1249] 
P [169] << ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [198] << AXIOM_CTS()
  and AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
Why created:    normalization of [serial 1010]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 125:
Theorem (125) [serial 1251] used for:
  Associativity: (b.c).a = a.b.c [serial 1249] 


Theorem (127)                               [serial 1010] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [198] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( current_temperature_status = status'Valid )
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST()
  and AXIOM_CTS() >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
Why created:   <<M(check_init) and x>> A <<M(failed)>> for mmm: check_init-[x]->failed{A};
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 126:
Theorem (126) [serial 1249] used for:
    normalization of [serial 1010] 


Theorem (128)                               [serial 1352] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169] ->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
Why created:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1348]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (129)                               [serial 1348] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169] ->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Solved by:  Guided Substitution of Equals
and theorem 128:
Theorem (128) [serial 1352] used for:
  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1348] 


Theorem (130)                               [serial 1349] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169] ->
Q [70] << status'Valid = current_temperature_status >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (131)                               [serial 1350] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169] ->
Q [69] << not INTERNAL_FAILURE >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (132)                               [serial 1351] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169] ->
Q [69] << not MONITOR_INTERFACE_FAILURE >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (133)                               [serial 1347] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169] ->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1346]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 129 130 131 132:
Theorem (129) [serial 1348] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347] 
Theorem (130) [serial 1349] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347] 
Theorem (131) [serial 1350] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347] 
Theorem (132) [serial 1351] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1347] 


Theorem (134)                               [serial 1346] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
S [169] ->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1345]
Solved by:  Guided Substitution of Equals
and theorem 133:
Theorem (133) [serial 1347] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1346] 


Theorem (135)                               [serial 1345] 
P [169] << status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169] ->
Q [209] << not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1343]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 134:
Theorem (134) [serial 1346] used for:
  Assume Present:  P = P@now = P^0   [serial 1345] 


Theorem (136)                               [serial 1343] 
P [169] << ( status'Valid = current_temperature_status
  and not INTERNAL_FAILURE^0
  and not MONITOR_INTERFACE_FAILURE^0 )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169] ->
Q [209] << ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS >>
Why created:    normalization of [serial 1341]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 135:
Theorem (135) [serial 1345] used for:
  Associativity: (b.c).a = a.b.c [serial 1343] 


Theorem (137)                               [serial 1341] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and ( not ( INTERNAL_FAILURE^0 )
  and not ( MONITOR_INTERFACE_FAILURE^0 )
  and not ( not ( status'Valid = current_temperature_status ) ) ) >>
S [169] ->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1339]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 136:
Theorem (136) [serial 1343] used for:
    normalization of [serial 1341] 


Theorem (138)                               [serial 1339] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
S [169] ->
Q [209] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 1337]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 137:
Theorem (137) [serial 1341] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1339] 


Theorem (139)                               [serial 1337] 
P [169] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169] ->
Q [209] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1335]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 138:
Theorem (138) [serial 1339] used for:
    normalization of [serial 1337] 


Theorem (140)                               [serial 1335] 
P [169] << ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and not ( ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 )
   or not ( status'Valid = current_temperature_status ) ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [169] ->
Q [209] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 1333]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 139:
Theorem (139) [serial 1337] used for:
  Associativity: (b.c).a = a.b.c [serial 1335] 


Theorem (141)                               [serial 1333] 
P [169] << current_temperature_status = temperature.status
  and ( start_time = START_TIME )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169] ->
Q [209] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1328]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 140:
Theorem (140) [serial 1335] used for:
    normalization of [serial 1333] 


Theorem (142)                               [serial 1328] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [169] ->
Q [209] << MONITOR_OK()
  and RUN() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1011]
Solved by:  Substitution of Assertion Labels
and theorem 141:
Theorem (141) [serial 1333] used for:
  Substituted assertions' predicates for labels  [serial 1328] 


Theorem (143)                               [serial 1364] 
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172] ->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
Why created:    normalization of [serial 1362]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (144)                               [serial 1362] 
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172] ->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1360]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 143:
Theorem (143) [serial 1364] used for:
    normalization of [serial 1362] 


Theorem (145)                               [serial 1360] 
P [211] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172] ->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
Why created:    normalization of [serial 1358]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 144:
Theorem (144) [serial 1362] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1360] 


Theorem (146)                               [serial 1358] 
P [211] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [172] ->
Q [172] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1357]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 145:
Theorem (145) [serial 1360] used for:
    normalization of [serial 1358] 


Theorem (147)                               [serial 1357] 
P [211] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [172] ->
Q [172] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
Why created:  Transitivity: x<y and y<z -> x<z  [serial 1355]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 146:
Theorem (146) [serial 1358] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1357] 


Theorem (148)                               [serial 1355] 
P [211] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172] ->
Q [172] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
Why created:    normalization of [serial 1353]
Solved by:  Transitivity: x<y and y<z -> x<z
and theorem 147:
Theorem (147) [serial 1357] used for:
  Transitivity: x<y and y<z -> x<z  [serial 1355] 


Theorem (149)                               [serial 1353] 
P [211] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( ( now - START_TIME ) <= ( now - START_TIME )^1 ) >>
S [172] ->
Q [172] << ( ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1329]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 148:
Theorem (148) [serial 1355] used for:
    normalization of [serial 1353] 


Theorem (150)                               [serial 1329] 
P [211] << RUN()
  and AXIOM_PAST_INIT() >>
S [172] ->
Q [172] << ( RUN() )^1 >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]
Solved by:  Substitution of Assertion Labels
and theorem 149:
Theorem (149) [serial 1353] used for:
  Substituted assertions' predicates for labels  [serial 1329] 


Theorem (151)                               [serial 1331] 
P [209] << MONITOR_OK()
  and RUN() >>
S [210] ->
Q [79] << MONITOR_OK()
  and RUN() >>
Why created:  applied port output of enumeration type  monitor_mode!(') [serial 1330]
Solved by:  Identity (id):  P->P is tautology


Theorem (152)                               [serial 1368] 
P [210] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [210] ->
Q [211] << ( RUN() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1367]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (153)                               [serial 1367] 
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210] ->
Q [211] << ( RUN() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1366]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 152:
Theorem (152) [serial 1368] used for:
  Associativity: (b.c).a = a.b.c [serial 1367] 


Theorem (154)                               [serial 1366] 
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210] ->
Q [211] << RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 153:
Theorem (153) [serial 1367] used for:
  Law of And-Simplification:  P and true is P [serial 1366] 


Theorem (155)                               [serial 1368] 
P [210] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [210] ->
Q [211] << ( RUN() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1367]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (156)                               [serial 1367] 
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210] ->
Q [211] << ( RUN() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1366]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 155:
Theorem (155) [serial 1368] used for:
  Associativity: (b.c).a = a.b.c [serial 1367] 


Theorem (157)                               [serial 1366] 
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210] ->
Q [211] << RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 156:
Theorem (156) [serial 1367] used for:
  Law of And-Simplification:  P and true is P [serial 1366] 


Theorem (158)                               [serial 1332] 
P [210] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [210] ->
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
Why created:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1330]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 157 157:
Theorem (157) [serial 1366] used for:
   add user-defined axioms to postcondition 
Theorem (157) [serial 1366] used for:
   add user-defined axioms to postcondition 


Theorem (159)                               [serial 1330] 
P [209] << MONITOR_OK()
  and RUN() >>
S [210] monitor_mode!(mmode'Normal)
Q [211] << RUN()
  and AXIOM_PAST_INIT() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011]
Solved by:  Enumeration Type Port Output 
and theorems 151 158:
Theorem (151) [serial 1331] used for:
  applied port output of enumeration type  monitor_mode!(') [serial 1330] 
Theorem (158) [serial 1332] used for:
  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1330] 


Theorem (160)                               [serial 1011] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [209] << MONITOR_OK()
  and RUN() >>
monitor_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [172] << ( RUN() )^1 >>
Why created:   <<M(check_init) and x>> A <<M(normal)>> for mmm2: check_init-[x]->normal{A};
Solved by:  Introduction of Existential Quantification
and theorems 142 150 159:
Theorem (142) [serial 1328] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1011] 
Theorem (150) [serial 1329] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011] 
Theorem (159) [serial 1330] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1011] 


Theorem (161)                               [serial 1370] 
P [169] << now - start_time < #Iso_Properties::Initialization_Timeout s
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [213] ->
Q [167] << true >>
Why created:    normalization of [serial 1012]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (162)                               [serial 1012] 
P [169] << current_temperature_status = temperature.status
  and AXIOM_ST()
  and AXIOM_CTS()
  and ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
S [213] ->
Q [167] << ( true )^1 >>
Why created:   <<M(check_init) and x>> -> <<M(init)>> for mmm2x: check_init-[x]->init{};
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 161:
Theorem (161) [serial 1370] used for:
    normalization of [serial 1012] 


Theorem (163)                               [serial 1372] 
P [172] << RUN() >>
S [172] ->
Q [219] << RUN() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1013]
Solved by:  Identity (id):  P->P is tautology


Theorem (164)                               [serial 1391] 
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173] ->
Q [173] << current_temperature_status = temperature.status
  and RUN() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1390]
Solved by:  Identity (id):  P->P is tautology


Theorem (165)                               [serial 1390] 
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173] ->
Q [173] << current_temperature_status = temperature.status
  and true
  and true
  and RUN() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 164:
Theorem (164) [serial 1391] used for:
  Law of And-Simplification:  P and true is P [serial 1390] 


Theorem (166)                               [serial 1391] 
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173] ->
Q [173] << current_temperature_status = temperature.status
  and RUN() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1390]
Solved by:  Identity (id):  P->P is tautology


Theorem (167)                               [serial 1390] 
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173] ->
Q [173] << current_temperature_status = temperature.status
  and true
  and true
  and RUN() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 166:
Theorem (166) [serial 1391] used for:
  Law of And-Simplification:  P and true is P [serial 1390] 


Theorem (168)                               [serial 1382] 
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173] ->
Q [173] << current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
Why created:    normalization of [serial 1373]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 167 167:
Theorem (167) [serial 1390] used for:
   add user-defined axioms to postcondition 
Theorem (167) [serial 1390] used for:
   add user-defined axioms to postcondition 


Theorem (169)                               [serial 1373] 
P [223] << current_temperature_status = temperature.status
  and RUN() >>
S [173] ->
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1013]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 168:
Theorem (168) [serial 1382] used for:
    normalization of [serial 1373] 


Theorem (170)                               [serial 1384] 
P [220] << CURRENT_TEMP = temperature
  and RUN() >>
S [220] ->
Q [221] << CURRENT_TEMP = temperature
  and RUN() >>
Why created:    normalization of [serial 1376]
Solved by:  Identity (id):  P->P is tautology


Theorem (171)                               [serial 1376] 
P [220] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [220] ->
Q [221] << temperature = CURRENT_TEMP
  and RUN() >>
Why created:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1374]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 170:
Theorem (170) [serial 1384] used for:
    normalization of [serial 1376] 


Theorem (172)                               [serial 1374] 
P [219] << RUN() >>
S [220] current_temperature?(temperature)
Q [221] << temperature = CURRENT_TEMP
  and RUN() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1013]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 171:
Theorem (171) [serial 1376] used for:
  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 1374] 


Theorem (173)                               [serial 1386] 
P [221] << CURRENT_TEMP = temperature
  and RUN() >>
S [222] ->
Q [223] << RUN() >>
Why created:    normalization of [serial 1379]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (174)                               [serial 1379] 
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222] ->
Q [223] << ( RUN() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1378]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 173:
Theorem (173) [serial 1386] used for:
    normalization of [serial 1379] 


Theorem (175)                               [serial 1378] 
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222] ->
Q [223] << true
  and RUN() >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1377]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 174:
Theorem (174) [serial 1379] used for:
  Law of And-Simplification:  P and true is P [serial 1378] 


Theorem (176)                               [serial 1377] 
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222] ->
Q [223] << temperature.status = temperature.status
  and RUN() >>
Why created:  applied wp for assignment [serial 1375]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 175:
Theorem (175) [serial 1378] used for:
  Equality Law (idistr):  a=a <-> true [serial 1377] 


Theorem (177)                               [serial 1375] 
P [221] << temperature = CURRENT_TEMP
  and RUN() >>
S [222] current_temperature_status := temperature.status
Q [223] << current_temperature_status = temperature.status
  and RUN() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1013]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 176:
Theorem (176) [serial 1377] used for:
  applied wp for assignment [serial 1375] 


Theorem (178)                               [serial 1013] 
P [172] << RUN() >>
S [219]   << RUN() >>
  current_temperature?(temperature)
  ;
  << temperature = CURRENT_TEMP
    and RUN() >>
  current_temperature_status := temperature.status
  << current_temperature_status = temperature.status
    and RUN() >> 
Q [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
Why created:   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 163 169 172 177:
Theorem (163) [serial 1372] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1013] 
Theorem (169) [serial 1373] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1013] 
Theorem (172) [serial 1374] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1013] 
Theorem (177) [serial 1375] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1013] 


Theorem (179)                               [serial 1437] 
P [173] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173] ->
Q [70] << status'Valid = current_temperature_status >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1435]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (180)                               [serial 1435] 
P [173] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173] ->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
Why created:    normalization of [serial 1433]
Solved by:  Guided Substitution of Equals
and theorem 179:
Theorem (179) [serial 1437] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1435] 


Theorem (181)                               [serial 1433] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173] ->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1431]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 180:
Theorem (180) [serial 1435] used for:
    normalization of [serial 1433] 


Theorem (182)                               [serial 1431] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173] ->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1429]
Solved by:  Substitution of Assertion Labels
and theorem 181:
Theorem (181) [serial 1433] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1431] 


Theorem (183)                               [serial 1429] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173] ->
Q [70] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 182:
Theorem (182) [serial 1431] used for:
  Assume Present:  P = P@now = P^0   [serial 1429] 


Theorem (184)                               [serial 1432] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
S [173] ->
Q [69] << not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1430]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (185)                               [serial 1430] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173] ->
Q [69] << not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 184:
Theorem (184) [serial 1432] used for:
  Assume Present:  P = P@now = P^0   [serial 1430] 


Theorem (186)                               [serial 1427] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173] ->
Q [229] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 1425]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 183 185:
Theorem (183) [serial 1429] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427] 
Theorem (185) [serial 1430] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1427] 


Theorem (187)                               [serial 1425] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173] ->
Q [229] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1423]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 186:
Theorem (186) [serial 1427] used for:
    normalization of [serial 1425] 


Theorem (188)                               [serial 1423] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173] ->
Q [229] << MONITOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405]
Solved by:  Substitution of Assertion Labels
and theorem 187:
Theorem (187) [serial 1425] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1423] 


Theorem (189)                               [serial 1424] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173] ->
Q [229] << RUN() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (190)                               [serial 1405] 
P [173] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0 ) >>
S [173] ->
Q [229] << MONITOR_OK()
  and RUN() >>
Why created:    normalization of [serial 1398]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 188 189:
Theorem (188) [serial 1423] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405] 
Theorem (189) [serial 1424] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1405] 


Theorem (191)                               [serial 1398] 
P [173] << not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid )
  and current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST() >>
S [173] ->
Q [229] << MONITOR_OK()
  and RUN() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1392]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 190:
Theorem (190) [serial 1405] used for:
    normalization of [serial 1398] 


Theorem (192)                               [serial 1392] 
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [173] ->
Q [229] << MONITOR_OK()
  and RUN() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1014]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 191:
Theorem (191) [serial 1398] used for:
  Associativity: (b.c).a = a.b.c [serial 1392] 


Theorem (193)                               [serial 1422] 
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
S [172] ->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
Why created:  Transitivity: x<y and y<z -> x<z  [serial 1419]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (194)                               [serial 1419] 
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172] ->
Q [172] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
Why created:    normalization of [serial 1417]
Solved by:  Transitivity: x<y and y<z -> x<z
and theorem 193:
Theorem (193) [serial 1422] used for:
  Transitivity: x<y and y<z -> x<z  [serial 1419] 


Theorem (195)                               [serial 1417] 
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172] ->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1415]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 194:
Theorem (194) [serial 1419] used for:
    normalization of [serial 1417] 


Theorem (196)                               [serial 1415] 
P [231] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [172] ->
Q [172] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
Why created:    normalization of [serial 1413]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 195:
Theorem (195) [serial 1417] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1415] 


Theorem (197)                               [serial 1413] 
P [231] << ( ( now - START_TIME ) <= ( ( now )^1 - ( START_TIME )^1 ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [172] ->
Q [172] << ( ( now - START_TIME )^1 >= ( #Iso_Properties::Initialization_Timeout s )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1412]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Constants are always the same
and theorem 196:
Theorem (196) [serial 1415] used for:
    normalization of [serial 1413] 


Theorem (198)                               [serial 1412] 
P [231] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [172] ->
Q [172] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1411]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 197:
Theorem (197) [serial 1413] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1412] 


Theorem (199)                               [serial 1411] 
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172] ->
Q [172] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1402]
Solved by:  Substitution of Assertion Labels
and theorem 198:
Theorem (198) [serial 1412] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1411] 


Theorem (200)                               [serial 1402] 
P [231] << AXIOM_PAST_INIT()
  and RUN() >>
S [172] ->
Q [172] << RUN()^1 >>
Why created:    normalization of [serial 1393]
Solved by:  Substitution of Assertion Labels
and theorem 199:
Theorem (199) [serial 1411] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1402] 


Theorem (201)                               [serial 1393] 
P [231] << RUN()
  and AXIOM_PAST_INIT() >>
S [172] ->
Q [172] << ( RUN() )^1 >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 200:
Theorem (200) [serial 1402] used for:
    normalization of [serial 1393] 


Theorem (202)                               [serial 1395] 
P [229] << MONITOR_OK()
  and RUN() >>
S [230] ->
Q [79] << MONITOR_OK()
  and RUN() >>
Why created:  applied port output of enumeration type  monitor_mode!(') [serial 1394]
Solved by:  Identity (id):  P->P is tautology


Theorem (203)                               [serial 1407] 
P [230] << MONITOR_OK()
  and RUN()
  and ( mmode'Normal = monitor_mode )^0 >>
S [230] ->
Q [231] << RUN() >>
Why created:    normalization of [serial 1400]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (204)                               [serial 1400] 
P [230] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [230] ->
Q [231] << ( RUN() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1399]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 203:
Theorem (203) [serial 1407] used for:
    normalization of [serial 1400] 


Theorem (205)                               [serial 1399] 
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230] ->
Q [231] << ( RUN() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1397]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 204:
Theorem (204) [serial 1400] used for:
  Associativity: (b.c).a = a.b.c [serial 1399] 


Theorem (206)                               [serial 1397] 
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230] ->
Q [231] << RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 205:
Theorem (205) [serial 1399] used for:
  Law of And-Simplification:  P and true is P [serial 1397] 


Theorem (207)                               [serial 1407] 
P [230] << MONITOR_OK()
  and RUN()
  and ( mmode'Normal = monitor_mode )^0 >>
S [230] ->
Q [231] << RUN() >>
Why created:    normalization of [serial 1400]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (208)                               [serial 1400] 
P [230] << MONITOR_OK()
  and RUN()
  and ( monitor_mode = mmode'Normal )^0 >>
S [230] ->
Q [231] << ( RUN() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1399]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 207:
Theorem (207) [serial 1407] used for:
    normalization of [serial 1400] 


Theorem (209)                               [serial 1399] 
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230] ->
Q [231] << ( RUN() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1397]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 208:
Theorem (208) [serial 1400] used for:
  Associativity: (b.c).a = a.b.c [serial 1399] 


Theorem (210)                               [serial 1397] 
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230] ->
Q [231] << RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 209:
Theorem (209) [serial 1399] used for:
  Law of And-Simplification:  P and true is P [serial 1397] 


Theorem (211)                               [serial 1396] 
P [230] << ( MONITOR_OK()
  and RUN() )
  and ( monitor_mode = mmode'Normal )^0 >>
S [230] ->
Q [231] << RUN()
  and AXIOM_PAST_INIT() >>
Why created:  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1394]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 210 210:
Theorem (210) [serial 1397] used for:
   add user-defined axioms to postcondition 
Theorem (210) [serial 1397] used for:
   add user-defined axioms to postcondition 


Theorem (212)                               [serial 1394] 
P [229] << MONITOR_OK()
  and RUN() >>
S [230] monitor_mode!(mmode'Normal)
Q [231] << RUN()
  and AXIOM_PAST_INIT() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014]
Solved by:  Enumeration Type Port Output 
and theorems 202 211:
Theorem (202) [serial 1395] used for:
  applied port output of enumeration type  monitor_mode!(') [serial 1394] 
Theorem (211) [serial 1396] used for:
  applied port output <<pre and (monitor_mode=mmode'Normal)^0>> -> <<post>> [serial 1394] 


Theorem (213)                               [serial 1014] 
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( not ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [229] << MONITOR_OK()
  and RUN() >>
monitor_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [172] << ( RUN() )^1 >>
Why created:   <<M(check_normal) and x>> A <<M(normal)>> for mmm3: check_normal-[x]->normal{A};
Solved by:  Introduction of Existential Quantification
and theorems 192 201 212:
Theorem (192) [serial 1392] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1014] 
Theorem (201) [serial 1393] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014] 
Theorem (212) [serial 1394] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1014] 


Theorem (214)                               [serial 1518] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 1517]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (215)                               [serial 1517] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Guided Substitution of Equals At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1503]
Solved by:  Guided Substitution of Equals
and theorem 214:
Theorem (214) [serial 1518] used for:
  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 1517] 


Theorem (216)                               [serial 1503] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]
Solved by:  Guided Substitution of Equals
  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 215:
Theorem (215) [serial 1517] used for:
  Guided Substitution of Equals At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1503] 


Theorem (217)                               [serial 1494] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1490]
Solved by:  Guided Substitution of Equals
  Assume Present:  P = P@now = P^0 
and theorem 216:
Theorem (216) [serial 1503] used for:
  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494] 


Theorem (218)                               [serial 1490] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1471]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 217:
Theorem (217) [serial 1494] used for:
    normalization of [serial 1490] 


Theorem (219)                               [serial 1471] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]
Solved by:  Substitution of Assertion Labels
and theorem 218:
Theorem (218) [serial 1490] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1471] 


Theorem (220)                               [serial 1516] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1515]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (221)                               [serial 1515] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1513]
Solved by:  Guided Substitution of Equals
and theorem 220:
Theorem (220) [serial 1516] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1515] 


Theorem (222)                               [serial 1513] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:    normalization of [serial 1510]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 221:
Theorem (221) [serial 1515] used for:
  Associativity: (b.c).a = a.b.c [serial 1513] 


Theorem (223)                               [serial 1510] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1508]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 222:
Theorem (222) [serial 1513] used for:
    normalization of [serial 1510] 


Theorem (224)                               [serial 1508] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 1505]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 223:
Theorem (223) [serial 1510] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1508] 


Theorem (225)                               [serial 1505] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1504]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 224:
Theorem (224) [serial 1508] used for:
    normalization of [serial 1505] 


Theorem (226)                               [serial 1504] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1496]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 225:
Theorem (225) [serial 1505] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1504] 


Theorem (227)                               [serial 1496] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:    normalization of [serial 1491]
Solved by:  Guided Substitution of Equals
  Assume Present:  P = P@now = P^0 
and theorem 226:
Theorem (226) [serial 1504] used for:
  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1496] 


Theorem (228)                               [serial 1491] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1479]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 227:
Theorem (227) [serial 1496] used for:
    normalization of [serial 1491] 


Theorem (229)                               [serial 1479] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:    normalization of [serial 1475]
Solved by:  Substitution of Assertion Labels
and theorem 228:
Theorem (228) [serial 1491] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1479] 


Theorem (230)                               [serial 1475] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1472]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 229:
Theorem (229) [serial 1479] used for:
    normalization of [serial 1475] 


Theorem (231)                               [serial 1472] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not MONITOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]
Solved by:  Substitution of Assertion Labels
and theorem 230:
Theorem (230) [serial 1475] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1472] 


Theorem (232)                               [serial 1466] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
Why created:    normalization of [serial 1462]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 219 231:
Theorem (219) [serial 1471] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466] 
Theorem (231) [serial 1472] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466] 


Theorem (233)                               [serial 1462] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( MONITOR_OK() ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1458]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 232:
Theorem (232) [serial 1466] used for:
    normalization of [serial 1462] 


Theorem (234)                               [serial 1458] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
Why created:    normalization of [serial 1453]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 233:
Theorem (233) [serial 1462] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1458] 


Theorem (235)                               [serial 1453] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1448]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 234:
Theorem (234) [serial 1458] used for:
    normalization of [serial 1453] 


Theorem (236)                               [serial 1448] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() )
  and true >>
Why created:    normalization of [serial 1442]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 235:
Theorem (235) [serial 1453] used for:
  Law of And-Simplification:  P and true is P [serial 1448] 


Theorem (237)                               [serial 1442] 
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173] ->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 236:
Theorem (236) [serial 1448] used for:
    normalization of [serial 1442] 


Theorem (238)                               [serial 1518] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 1517]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (239)                               [serial 1517] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Guided Substitution of Equals At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1503]
Solved by:  Guided Substitution of Equals
and theorem 238:
Theorem (238) [serial 1518] used for:
  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 1517] 


Theorem (240)                               [serial 1503] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494]
Solved by:  Guided Substitution of Equals
  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 239:
Theorem (239) [serial 1517] used for:
  Guided Substitution of Equals At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1503] 


Theorem (241)                               [serial 1494] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1490]
Solved by:  Guided Substitution of Equals
  Assume Present:  P = P@now = P^0 
and theorem 240:
Theorem (240) [serial 1503] used for:
  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1494] 


Theorem (242)                               [serial 1490] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1471]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 241:
Theorem (241) [serial 1494] used for:
    normalization of [serial 1490] 


Theorem (243)                               [serial 1471] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]
Solved by:  Substitution of Assertion Labels
and theorem 242:
Theorem (242) [serial 1490] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1471] 


Theorem (244)                               [serial 1516] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1515]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (245)                               [serial 1515] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1513]
Solved by:  Guided Substitution of Equals
and theorem 244:
Theorem (244) [serial 1516] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 1515] 


Theorem (246)                               [serial 1513] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:    normalization of [serial 1510]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 245:
Theorem (245) [serial 1515] used for:
  Associativity: (b.c).a = a.b.c [serial 1513] 


Theorem (247)                               [serial 1510] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1508]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 246:
Theorem (246) [serial 1513] used for:
    normalization of [serial 1510] 


Theorem (248)                               [serial 1508] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 1505]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 247:
Theorem (247) [serial 1510] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1508] 


Theorem (249)                               [serial 1505] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1504]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 248:
Theorem (248) [serial 1508] used for:
    normalization of [serial 1505] 


Theorem (250)                               [serial 1504] 
P [173] << ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1496]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 249:
Theorem (249) [serial 1505] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1504] 


Theorem (251)                               [serial 1496] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:    normalization of [serial 1491]
Solved by:  Guided Substitution of Equals
  Assume Present:  P = P@now = P^0 
and theorem 250:
Theorem (250) [serial 1504] used for:
  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 1496] 


Theorem (252)                               [serial 1491] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1479]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 251:
Theorem (251) [serial 1496] used for:
    normalization of [serial 1491] 


Theorem (253)                               [serial 1479] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:    normalization of [serial 1475]
Solved by:  Substitution of Assertion Labels
and theorem 252:
Theorem (252) [serial 1491] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1479] 


Theorem (254)                               [serial 1475] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1472]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 253:
Theorem (253) [serial 1479] used for:
    normalization of [serial 1475] 


Theorem (255)                               [serial 1472] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not MONITOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466]
Solved by:  Substitution of Assertion Labels
and theorem 254:
Theorem (254) [serial 1475] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1472] 


Theorem (256)                               [serial 1466] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
Why created:    normalization of [serial 1462]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 243 255:
Theorem (243) [serial 1471] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466] 
Theorem (255) [serial 1472] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1466] 


Theorem (257)                               [serial 1462] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( MONITOR_OK() ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1458]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 256:
Theorem (256) [serial 1466] used for:
    normalization of [serial 1462] 


Theorem (258)                               [serial 1458] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
Why created:    normalization of [serial 1453]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 257:
Theorem (257) [serial 1462] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1458] 


Theorem (259)                               [serial 1453] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1448]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 258:
Theorem (258) [serial 1458] used for:
    normalization of [serial 1453] 


Theorem (260)                               [serial 1448] 
P [173] << ( INTERNAL_FAILURE^0
   or MONITOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTS()
  and AXIOM_ST()
  and RUN() >>
S [173] ->
Q [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() )
  and true >>
Why created:    normalization of [serial 1442]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 259:
Theorem (259) [serial 1453] used for:
  Law of And-Simplification:  P and true is P [serial 1448] 


Theorem (261)                               [serial 1442] 
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173] ->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 260:
Theorem (260) [serial 1448] used for:
    normalization of [serial 1442] 


Theorem (262)                               [serial 1438] 
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [173] ->
Q [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1015]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 261 261:
Theorem (261) [serial 1442] used for:
   add user-defined axioms to postcondition 
Theorem (261) [serial 1442] used for:
   add user-defined axioms to postcondition 


Theorem (263)                               [serial 1502] 
P [237] << START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [238] ->
Q [80] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1498]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (264)                               [serial 1498] 
P [237] << START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
S [238] ->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1492]
Solved by:  Guided Substitution of Equals
and theorem 263:
Theorem (263) [serial 1502] used for:
  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 1498] 


Theorem (265)                               [serial 1492] 
P [237] << ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
S [238] ->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1488]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 264:
Theorem (264) [serial 1498] used for:
    normalization of [serial 1492] 


Theorem (266)                               [serial 1488] 
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238] ->
Q [80] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1484]
Solved by:  Substitution of Assertion Labels
and theorem 265:
Theorem (265) [serial 1492] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1488] 


Theorem (267)                               [serial 1484] 
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238] ->
Q [80] << ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1481]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 266:
Theorem (266) [serial 1488] used for:
    normalization of [serial 1484] 


Theorem (268)                               [serial 1481] 
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() >>
S [238] ->
Q [80] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 1476]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 267:
Theorem (267) [serial 1484] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1481] 


Theorem (269)                               [serial 1476] 
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238] ->
Q [80] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1473]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 268:
Theorem (268) [serial 1481] used for:
    normalization of [serial 1476] 


Theorem (270)                               [serial 1473] 
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238] ->
Q [80] << RUN() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1469]
Solved by:  Substitution of Assertion Labels
and theorem 269:
Theorem (269) [serial 1476] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1473] 


Theorem (271)                               [serial 1469] 
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238] ->
Q [80] << RUN() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 270:
Theorem (270) [serial 1473] used for:
  Associativity: (b.c).a = a.b.c [serial 1469] 


Theorem (272)                               [serial 1474] 
P [237] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK()
  and AXIOM_ST() >>
S [238] ->
Q [80] << not MONITOR_OK() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1470]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (273)                               [serial 1470] 
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238] ->
Q [80] << not MONITOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 272:
Theorem (272) [serial 1474] used for:
  Associativity: (b.c).a = a.b.c [serial 1470] 


Theorem (274)                               [serial 1464] 
P [237] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not MONITOR_OK() )
  and AXIOM_ST() >>
S [238] ->
Q [80] << RUN()
  and not MONITOR_OK() >>
Why created:    normalization of [serial 1461]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 271 273:
Theorem (271) [serial 1469] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464] 
Theorem (273) [serial 1470] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1464] 


Theorem (275)                               [serial 1461] 
P [237] << AXIOM_ST()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( MONITOR_OK() ) ) >>
S [238] ->
Q [80] << RUN()
  and not MONITOR_OK() >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1444]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 274:
Theorem (274) [serial 1464] used for:
    normalization of [serial 1461] 


Theorem (276)                               [serial 1444] 
P [237] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238] ->
Q [80] << RUN()
  and not MONITOR_OK() >>
Why created:    normalization of [serial 1440]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 275:
Theorem (275) [serial 1461] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1444] 


Theorem (277)                               [serial 1440] 
P [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
S [238] ->
Q [80] << not MONITOR_OK()
  and RUN() >>
Why created:  applied port output of enumeration type  monitor_mode!(') [serial 1439]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 276:
Theorem (276) [serial 1444] used for:
    normalization of [serial 1440] 


Theorem (278)                               [serial 1456] 
P [238] << AXIOM_ST()
  and ( mmode'Failed = monitor_mode )^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) >>
S [238] ->
Q [175] << true >>
Why created:    normalization of [serial 1452]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (279)                               [serial 1452] 
P [238] << AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() )
  and ( mmode'Failed = monitor_mode )^0 >>
S [238] ->
Q [175] << true >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1446]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 278:
Theorem (278) [serial 1456] used for:
    normalization of [serial 1452] 


Theorem (280)                               [serial 1446] 
P [238] << ( AXIOM_ST()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or MONITOR_OK() ) )
  and ( mmode'Failed = monitor_mode )^0 >>
S [238] ->
Q [175] << true >>
Why created:    normalization of [serial 1441]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 279:
Theorem (279) [serial 1452] used for:
  Associativity: (b.c).a = a.b.c [serial 1446] 


Theorem (281)                               [serial 1441] 
P [238] << ( not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() )
  and ( monitor_mode = mmode'Failed )^0 >>
S [238] ->
Q [175] << true >>
Why created:  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1439]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 280:
Theorem (280) [serial 1446] used for:
    normalization of [serial 1441] 


Theorem (282)                               [serial 1439] 
P [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
S [238] monitor_mode!(mmode'Failed)
Q [175] << true >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1015]
Solved by:  Enumeration Type Port Output 
and theorems 277 281:
Theorem (277) [serial 1440] used for:
  applied port output of enumeration type  monitor_mode!(') [serial 1439] 
Theorem (281) [serial 1441] used for:
  applied port output <<pre and (monitor_mode=mmode'Failed)^0>> -> <<post>> [serial 1439] 


Theorem (283)                               [serial 1015] 
P [173] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTS()
  and AXIOM_ST()
  and ( ( MONITOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [237] << not ( MONITOR_OK()
   or ( now - start_time ) < #Iso_Properties::Initialization_Timeout s )
  and AXIOM_ST() >>
monitor_mode!(mmode'Failed)
Q [175] << true >>
Why created:   <<M(check_normal) and x>> A <<M(failed)>> for mmm3x: check_normal-[x]->failed{A};
Solved by:  Introduction of Existential Quantification
and theorems 262 282:
Theorem (262) [serial 1438] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1015] 
Theorem (282) [serial 1439] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1015] 


Theorem (284)                               [serial 1002] 
P [158] <<   >>
S [158] ->
Q [158] << manage_monitor_mode.impl proof obligations >>
Why created:  Initial proof obligations for manage_monitor_mode.impl
Solved by:  Component verification conditions
and theorems 1 2 16 17 27 49 64 127 160 162 178 213 283:
Theorem (1) [serial 1003] used for:
  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition. 
Theorem (2) [serial 1004] used for:
  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition. 
Theorem (16) [serial 1005] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>> 
Theorem (17) [serial 1006] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (27) [serial 1007] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>> 
Theorem (49) [serial 1008] used for:
   <<M(start)>> A <<M(init)>> for mmm1: start-[ ]->init{A}; 
Theorem (64) [serial 1009] used for:
   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A}; 
Theorem (127) [serial 1010] used for:
   <<M(check_init) and x>> A <<M(failed)>> for mmm: check_init-[x]->failed{A}; 
Theorem (160) [serial 1011] used for:
   <<M(check_init) and x>> A <<M(normal)>> for mmm2: check_init-[x]->normal{A}; 
Theorem (162) [serial 1012] used for:
   <<M(check_init) and x>> -> <<M(init)>> for mmm2x: check_init-[x]->init{}; 
Theorem (178) [serial 1013] used for:
   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A}; 
Theorem (213) [serial 1014] used for:
   <<M(check_normal) and x>> A <<M(normal)>> for mmm3: check_normal-[x]->normal{A}; 
Theorem (283) [serial 1015] used for:
   <<M(check_normal) and x>> A <<M(failed)>> for mmm3x: check_normal-[x]->failed{A}; 


Theorem (285)                               [serial 1521] 
P [310] << alarm_control^-1 = alarm_previous_period >>
S [303] ->
Q [303] << alarm_control^-1 = alarm_previous_period >>
Why created:    normalization of [serial 1519]
Solved by:  Identity (id):  P->P is tautology


Theorem (286)                               [serial 1519] 
P [310] << ( alarm_previous_period = alarm_control^-1 ) >>
S [303] ->
Q [303] << alarm_previous_period = alarm_control^-1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1017]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 285:
Theorem (285) [serial 1521] used for:
    normalization of [serial 1519] 


Theorem (287)                               [serial 1017] 
P [310] << INVMA() >>
S [303] ->
Q [303] << alarm_previous_period = alarm_control^-1 >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by:  Substitution of Assertion Labels
and theorem 286:
Theorem (286) [serial 1519] used for:
  Substituted assertions' predicates for labels  [serial 1017] 


Theorem (288)                               [serial 1537] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << true >>
Why created:    normalization of [serial 1535]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (289)                               [serial 1535] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1534]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 288:
Theorem (288) [serial 1537] used for:
    normalization of [serial 1535] 


Theorem (290)                               [serial 1534] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1533]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 289:
Theorem (289) [serial 1535] used for:
  Law of And-Simplification:  P and P is P [serial 1534] 


Theorem (291)                               [serial 1533] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1532]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 290:
Theorem (290) [serial 1534] used for:
  Law of And-Simplification:  P and P is P [serial 1533] 


Theorem (292)                               [serial 1532] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1531]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 291:
Theorem (291) [serial 1533] used for:
  Law of And-Simplification:  P and P is P [serial 1532] 


Theorem (293)                               [serial 1531] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or current_temperature.t < 0.5 F + lower_alarm_temperature.t
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( not ( upper_alarm_temperature.t < current_temperature.t )
   or not ( current_temperature.t < lower_alarm_temperature.t )
   or not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1529]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 292:
Theorem (292) [serial 1532] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1531] 


Theorem (294)                               [serial 1529] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and not ( upper_alarm_temperature.t < current_temperature.t ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and not ( current_temperature.t < lower_alarm_temperature.t ) )
   or ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t )
  and not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t >>
Why created:    normalization of [serial 1527]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 293:
Theorem (293) [serial 1531] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1529] 


Theorem (295)                               [serial 1527] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and ( not ( upper_alarm_temperature.t < current_temperature.t ) ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and ( not ( current_temperature.t < lower_alarm_temperature.t ) ) )
   or current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t
   or ( ( not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
  and ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t ) ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1526]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 294:
Theorem (294) [serial 1529] used for:
    normalization of [serial 1527] 


Theorem (296)                               [serial 1526] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << ( ( not ( current_temperature.t < 0.5 F + lower_alarm_temperature.t ) )
  and ( not ( upper_alarm_temperature.t - 0.5 F < current_temperature.t ) ) )
   or ( ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and ( not ( upper_alarm_temperature.t < current_temperature.t ) ) )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and ( not ( current_temperature.t < lower_alarm_temperature.t ) ) ) )
   or ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1524]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 295:
Theorem (295) [serial 1527] used for:
  Associativity: (b.c).a = a.b.c [serial 1526] 


Theorem (297)                               [serial 1524] 
P [312] << AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [312] << ( 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F )
   or ( ( upper_alarm_temperature.t - 0.5 F < current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t )
   or ( current_temperature.t < 0.5 F + lower_alarm_temperature.t
  and lower_alarm_temperature.t <= current_temperature.t ) )
   or ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t ) >>
Why created:    normalization of [serial 1018]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 296:
Theorem (296) [serial 1526] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1524] 


Theorem (298)                               [serial 1018] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
S [312] ->
Q [312] << ( ( current_temperature.t < lower_alarm_temperature.t )
   or ( current_temperature.t > upper_alarm_temperature.t ) )
   or ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) )
   or ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Addition: a+b=b+a
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 297:
Theorem (297) [serial 1524] used for:
    normalization of [serial 1018] 


Theorem (299)                               [serial 1019] 
P [309] << alarm_previous_period = cntrl'Off
  and ( INVMA() )^1 >>
S [309] ->
Q [309] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (300)                               [serial 1541] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [313] << cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period >>
Why created:    normalization of [serial 1539]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (301)                               [serial 1539] 
P [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) ) >>
S [313] ->
Q [313] << ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1020]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 300:
Theorem (300) [serial 1541] used for:
    normalization of [serial 1539] 


Theorem (302)                               [serial 1020] 
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON() >>
S [313] ->
Q [313] << ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>
Solved by:  Substitution of Assertion Labels
and theorem 301:
Theorem (301) [serial 1539] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1020] 


Theorem (303)                               [serial 1574] 
P [311] << INVMA() >>
S [311] ->
Q [311] << true >>
Why created:    normalization of [serial 1572]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (304)                               [serial 1572] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1571]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 303:
Theorem (303) [serial 1574] used for:
    normalization of [serial 1572] 


Theorem (305)                               [serial 1571] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1570]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 304:
Theorem (304) [serial 1572] used for:
  Law of And-Simplification:  P and P is P [serial 1571] 


Theorem (306)                               [serial 1570] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1568]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 305:
Theorem (305) [serial 1571] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1570] 


Theorem (307)                               [serial 1568] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not MONITOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 1566]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 306:
Theorem (306) [serial 1570] used for:
  Associativity: (b.c).a = a.b.c [serial 1568] 


Theorem (308)                               [serial 1566] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) )
   or ( not ( INTERNAL_FAILURE )
  and not ( MONITOR_INTERFACE_FAILURE ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1565]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 307:
Theorem (307) [serial 1568] used for:
    normalization of [serial 1566] 


Theorem (309)                               [serial 1565] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) >>
Why created:  Law of Or-Simplification: P or P is P [serial 1563]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 308:
Theorem (308) [serial 1566] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1565] 


Theorem (310)                               [serial 1563] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or status'Valid = CURRENT_TEMPERATURE_STATUS
   or INTERNAL_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and true
  and true >>
Why created:    normalization of [serial 1561]
Solved by:  Law of Or-Simplification: P or P is P
and theorem 309:
Theorem (309) [serial 1565] used for:
  Law of Or-Simplification: P or P is P [serial 1563] 


Theorem (311)                               [serial 1561] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1560]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 310:
Theorem (310) [serial 1563] used for:
    normalization of [serial 1561] 


Theorem (312)                               [serial 1560] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( true )
  and ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1559]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 311:
Theorem (311) [serial 1561] used for:
  Law of And-Simplification:  P and P is P [serial 1560] 


Theorem (313)                               [serial 1559] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( true )
  and ( true )
  and ( true )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( true )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1558]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 312:
Theorem (312) [serial 1560] used for:
  Law of And-Simplification:  P and P is P [serial 1559] 


Theorem (314)                               [serial 1558] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( status'Valid = CURRENT_TEMPERATURE_STATUS
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and ( not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1556]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 313:
Theorem (313) [serial 1559] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1558] 


Theorem (315)                               [serial 1556] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1554]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 314:
Theorem (314) [serial 1558] used for:
  Distributing Postcondition Or-Over-And [serial 1556] 


Theorem (316)                               [serial 1554] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE )
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1552]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 315:
Theorem (315) [serial 1556] used for:
    normalization of [serial 1554] 


Theorem (317)                               [serial 1552] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1550]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 316:
Theorem (316) [serial 1554] used for:
  Associativity: (b.c).a = a.b.c [serial 1552] 


Theorem (318)                               [serial 1550] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1548]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 317:
Theorem (317) [serial 1552] used for:
    normalization of [serial 1550] 


Theorem (319)                               [serial 1548] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
   or ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1546]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 318:
Theorem (318) [serial 1550] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1548] 


Theorem (320)                               [serial 1546] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
   or ( ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
   or ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1544]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 319:
Theorem (319) [serial 1548] used for:
    normalization of [serial 1546] 


Theorem (321)                               [serial 1544] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( MONITOR_OK()
  and RUN() )
   or ( RUN()
  and not MONITOR_OK() )
   or INI() >>
Why created:    normalization of [serial 1021]
Solved by:  Substitution of Assertion Labels
and theorem 320:
Theorem (320) [serial 1546] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1544] 


Theorem (322)                               [serial 1021] 
P [311] << INVMA() >>
S [311] ->
Q [311] << ( not MONITOR_OK()
  and RUN() )
   or ( INI() )
   or ( MONITOR_OK()
  and RUN() ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 321:
Theorem (321) [serial 1544] used for:
    normalization of [serial 1021] 


Theorem (323)                               [serial 1022] 
P [309] << alarm_previous_period = cntrl'Off
  and ( INVMA() )^1 >>
S [316] ->
Q [310] << ( INVMA() )^1 >>
Why created:   <<M(poweron)>> -> <<M(run)>> for maPo: poweron-[ ]->run{};
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (324)                               [serial 1023] 
P [310] << INVMA() >>
S [317] ->
Q [311] << INVMA() >>
Why created:   <<M(run) and x>> -> <<M(check_mode)>> for maRun: run-[x]->check_mode{};
Solved by:  Identity (id):  P->P is tautology


Theorem (325)                               [serial 1622] 
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311] ->
Q [320] << RUN()
  and not MONITOR_OK() >>
Why created:    normalization of [serial 1620]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (326)                               [serial 1620] 
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311] ->
Q [320] << ( not MONITOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1613]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 325:
Theorem (325) [serial 1622] used for:
    normalization of [serial 1620] 


Theorem (327)                               [serial 1613] 
P [311] << INVMA()
  and RUN()
  and not MONITOR_OK() >>
S [311] ->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
Why created:    normalization of [serial 1609]
Solved by:  Substitution of Assertion Labels
and theorem 326:
Theorem (326) [serial 1620] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1613] 


Theorem (328)                               [serial 1609] 
P [311] << RUN()
  and not MONITOR_OK()
  and INVMA() >>
S [311] ->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1604]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 327:
Theorem (327) [serial 1613] used for:
    normalization of [serial 1609] 


Theorem (329)                               [serial 1604] 
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311] ->
Q [320] << MONITOR_MODE(x : mmode'Failed) >>
Why created:    normalization of [serial 1600]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 328:
Theorem (328) [serial 1609] used for:
  Associativity: (b.c).a = a.b.c [serial 1604] 


Theorem (330)                               [serial 1600] 
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311] ->
Q [320] << ( MONITOR_MODE(x : mmode'Failed) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1586]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 329:
Theorem (329) [serial 1604] used for:
    normalization of [serial 1600] 


Theorem (331)                               [serial 1586] 
P [311] << ( RUN()
  and not MONITOR_OK() )
  and INVMA() >>
S [311] ->
Q [320] << REQMA5() >>
Why created:    normalization of [serial 1576]
Solved by:  Substitution of Assertion Labels
and theorem 330:
Theorem (330) [serial 1600] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1586] 


Theorem (332)                               [serial 1576] 
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [311] ->
Q [320] << REQMA5() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1024]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 331:
Theorem (331) [serial 1586] used for:
    normalization of [serial 1576] 


Theorem (333)                               [serial 1619] 
P [324] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_previous_period^1 = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1615]
Solved by:  Identity (id):  P->P is tautology


Theorem (334)                               [serial 1615] 
P [324] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
Why created:    normalization of [serial 1610]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 333:
Theorem (333) [serial 1619] used for:
  Assume Present:  P = P@now = P^0   [serial 1615] 


Theorem (335)                               [serial 1610] 
P [324] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1606]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 334:
Theorem (334) [serial 1615] used for:
    normalization of [serial 1610] 


Theorem (336)                               [serial 1606] 
P [324] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
Why created:    normalization of [serial 1601]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 335:
Theorem (335) [serial 1610] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1606] 


Theorem (337)                               [serial 1601] 
P [324] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1592]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 336:
Theorem (336) [serial 1606] used for:
    normalization of [serial 1601] 


Theorem (338)                               [serial 1592] 
P [324] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << INVMA()^1 >>
Why created:    normalization of [serial 1583]
Solved by:  Substitution of Assertion Labels
and theorem 337:
Theorem (337) [serial 1601] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1592] 


Theorem (339)                               [serial 1583] 
P [324] << ( alarm_previous_period )^1 = alarm_control >>
S [310] ->
Q [302] << ( INVMA() )^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1577]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 338:
Theorem (338) [serial 1592] used for:
    normalization of [serial 1583] 


Theorem (340)                               [serial 1577] 
P [324] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( INVMA() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1024]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 339:
Theorem (339) [serial 1583] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1577] 


Theorem (341)                               [serial 1588] 
P [320] << REQMA5() >>
S [321] ->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
Why created:    normalization of [serial 1580]
Solved by:  Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (342)                               [serial 1580] 
P [320] << REQMA5() >>
S [321] ->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
Why created:  applied port output of enumeration type  alarm_control!(') [serial 1578]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 341:
Theorem (341) [serial 1588] used for:
    normalization of [serial 1580] 


Theorem (343)                               [serial 1618] 
P [321] << cntrl'O_n = alarm_control
  and REQMA5() >>
S [321] ->
Q [322] << cntrl'O_n = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1594]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (344)                               [serial 1594] 
P [321] << cntrl'O_n^0 = alarm_control^0
  and REQMA5() >>
S [321] ->
Q [322] << cntrl'O_n = alarm_control >>
Why created:    normalization of [serial 1584]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 343:
Theorem (343) [serial 1618] used for:
  Assume Present:  P = P@now = P^0   [serial 1594] 


Theorem (345)                               [serial 1584] 
P [321] << ( REQMA5() )
  and ( ( alarm_control )^0 = ( cntrl'O_n )^0 ) >>
S [321] ->
Q [322] << alarm_control = cntrl'O_n >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1581]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 344:
Theorem (344) [serial 1594] used for:
    normalization of [serial 1584] 


Theorem (346)                               [serial 1581] 
P [321] << ( REQMA5() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [321] ->
Q [322] << alarm_control = cntrl'O_n >>
Why created:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1578]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 345:
Theorem (345) [serial 1584] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1581] 


Theorem (347)                               [serial 1578] 
P [320] << REQMA5() >>
S [321] alarm_control!(cntrl'O_n)
Q [322] << alarm_control = cntrl'O_n >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024]
Solved by:  Enumeration Type Port Output 
and theorems 342 346:
Theorem (342) [serial 1580] used for:
  applied port output of enumeration type  alarm_control!(') [serial 1578] 
Theorem (346) [serial 1581] used for:
  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1578] 


Theorem (348)                               [serial 1590] 
P [322] << cntrl'O_n = alarm_control >>
S [323] ->
Q [324] << cntrl'O_n = alarm_control >>
Why created:    normalization of [serial 1582]
Solved by:  Identity (id):  P->P is tautology


Theorem (349)                               [serial 1582] 
P [322] << alarm_control = cntrl'O_n >>
S [323] ->
Q [324] << ( cntrl'O_n ) = alarm_control >>
Why created:  applied wp for assignment [serial 1579]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 348:
Theorem (348) [serial 1590] used for:
    normalization of [serial 1582] 


Theorem (350)                               [serial 1579] 
P [322] << alarm_control = cntrl'O_n >>
S [323] alarm_previous_period' := cntrl'O_n
Q [324] << alarm_previous_period' = alarm_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1024]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 349:
Theorem (349) [serial 1582] used for:
  applied wp for assignment [serial 1579] 


Theorem (351)                               [serial 1024] 
P [311] << ( INVMA() )
  and ( not MONITOR_OK()
  and RUN() ) >>
S [320]   << REQMA5() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
Why created:   <<M(check_mode) and x>> A <<M(run)>> for maFailed: check_mode-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 332 340 347 350:
Theorem (332) [serial 1576] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1024] 
Theorem (340) [serial 1577] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1024] 
Theorem (347) [serial 1578] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024] 
Theorem (350) [serial 1579] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1024] 


Theorem (352)                               [serial 1671] 
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311] ->
Q [328] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1669]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (353)                               [serial 1669] 
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311] ->
Q [328] << ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1668]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 352:
Theorem (352) [serial 1671] used for:
    normalization of [serial 1669] 


Theorem (354)                               [serial 1668] 
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311] ->
Q [328] << ( INI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1665]
Solved by:  Substitution of Assertion Labels
and theorem 353:
Theorem (353) [serial 1669] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1668] 


Theorem (355)                               [serial 1665] 
P [311] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and alarm_control^-1 = alarm_previous_period >>
S [311] ->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 1662]
Solved by:  Substitution of Assertion Labels
and theorem 354:
Theorem (354) [serial 1668] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1665] 


Theorem (356)                               [serial 1662] 
P [311] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( alarm_previous_period = alarm_control^-1 ) >>
S [311] ->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1650]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 355:
Theorem (355) [serial 1665] used for:
    normalization of [serial 1662] 


Theorem (357)                               [serial 1650] 
P [311] << INI()
  and INVMA() >>
S [311] ->
Q [328] << MONITOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 1647]
Solved by:  Substitution of Assertion Labels
and theorem 356:
Theorem (356) [serial 1662] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1650] 


Theorem (358)                               [serial 1647] 
P [311] << INI()
  and INVMA() >>
S [311] ->
Q [328] << ( MONITOR_MODE(x : mmode'Init) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1632]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 357:
Theorem (357) [serial 1650] used for:
    normalization of [serial 1647] 


Theorem (359)                               [serial 1632] 
P [311] << INI()
  and INVMA() >>
S [311] ->
Q [328] << REQMA1() >>
Why created:    normalization of [serial 1624]
Solved by:  Substitution of Assertion Labels
and theorem 358:
Theorem (358) [serial 1647] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1632] 


Theorem (360)                               [serial 1624] 
P [311] << ( INVMA() )
  and ( INI() ) >>
S [311] ->
Q [328] << REQMA1() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 359:
Theorem (359) [serial 1632] used for:
    normalization of [serial 1624] 


Theorem (361)                               [serial 1663] 
P [332] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_previous_period^1 = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1658]
Solved by:  Identity (id):  P->P is tautology


Theorem (362)                               [serial 1658] 
P [332] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
Why created:    normalization of [serial 1655]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 361:
Theorem (361) [serial 1663] used for:
  Assume Present:  P = P@now = P^0   [serial 1658] 


Theorem (363)                               [serial 1655] 
P [332] << ( alarm_previous_period )^1 = alarm_control >>
S [310] ->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1652]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 362:
Theorem (362) [serial 1658] used for:
    normalization of [serial 1655] 


Theorem (364)                               [serial 1652] 
P [332] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
Why created:    normalization of [serial 1648]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 363:
Theorem (363) [serial 1655] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1652] 


Theorem (365)                               [serial 1648] 
P [332] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1634]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 364:
Theorem (364) [serial 1652] used for:
    normalization of [serial 1648] 


Theorem (366)                               [serial 1634] 
P [332] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << INVMA()^1 >>
Why created:    normalization of [serial 1625]
Solved by:  Substitution of Assertion Labels
and theorem 365:
Theorem (365) [serial 1648] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1634] 


Theorem (367)                               [serial 1625] 
P [332] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( INVMA() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 366:
Theorem (366) [serial 1634] used for:
    normalization of [serial 1625] 


Theorem (368)                               [serial 1636] 
P [328] << REQMA1() >>
S [329] ->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
Why created:    normalization of [serial 1628]
Solved by:  Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (369)                               [serial 1628] 
P [328] << REQMA1() >>
S [329] ->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
Why created:  applied port output of enumeration type  alarm_control!(') [serial 1626]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 368:
Theorem (368) [serial 1636] used for:
    normalization of [serial 1628] 


Theorem (370)                               [serial 1646] 
P [329] << cntrl'Off = alarm_control
  and REQMA1() >>
S [329] ->
Q [330] << cntrl'Off = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1638]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (371)                               [serial 1638] 
P [329] << REQMA1()
  and ( cntrl'Off = alarm_control )^0 >>
S [329] ->
Q [330] << cntrl'Off = alarm_control >>
Why created:    normalization of [serial 1629]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 370:
Theorem (370) [serial 1646] used for:
  Assume Present:  P = P@now = P^0   [serial 1638] 


Theorem (372)                               [serial 1629] 
P [329] << ( REQMA1() )
  and ( alarm_control = cntrl'Off )^0 >>
S [329] ->
Q [330] << alarm_control = cntrl'Off >>
Why created:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1626]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 371:
Theorem (371) [serial 1638] used for:
    normalization of [serial 1629] 


Theorem (373)                               [serial 1626] 
P [328] << REQMA1() >>
S [329] alarm_control!(cntrl'Off)
Q [330] << alarm_control = cntrl'Off >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]
Solved by:  Enumeration Type Port Output 
and theorems 369 372:
Theorem (369) [serial 1628] used for:
  applied port output of enumeration type  alarm_control!(') [serial 1626] 
Theorem (372) [serial 1629] used for:
  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1626] 


Theorem (374)                               [serial 1640] 
P [330] << cntrl'Off = alarm_control >>
S [331] ->
Q [332] << cntrl'Off = alarm_control >>
Why created:    normalization of [serial 1630]
Solved by:  Identity (id):  P->P is tautology


Theorem (375)                               [serial 1630] 
P [330] << alarm_control = cntrl'Off >>
S [331] ->
Q [332] << ( cntrl'Off ) = alarm_control >>
Why created:  applied wp for assignment [serial 1627]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 374:
Theorem (374) [serial 1640] used for:
    normalization of [serial 1630] 


Theorem (376)                               [serial 1627] 
P [330] << alarm_control = cntrl'Off >>
S [331] alarm_previous_period' := cntrl'Off
Q [332] << alarm_previous_period' = alarm_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 375:
Theorem (375) [serial 1630] used for:
  applied wp for assignment [serial 1627] 


Theorem (377)                               [serial 1025] 
P [311] << ( INVMA() )
  and ( INI() ) >>
S [328]   << REQMA1() >>
  alarm_control!(cntrl'Off)
  ;
  << alarm_control = cntrl'Off >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
Why created:   <<M(check_mode) and x>> A <<M(run)>> for maInit: check_mode-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 360 367 373 376:
Theorem (360) [serial 1624] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1025] 
Theorem (367) [serial 1625] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1025] 
Theorem (373) [serial 1626] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025] 
Theorem (376) [serial 1627] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025] 


Theorem (378)                               [serial 1675] 
P [311] << MONITOR_OK()
  and RUN()
  and ( INVMA() ) >>
S [334] ->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1674]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (379)                               [serial 1674] 
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334] ->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1673]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 378:
Theorem (378) [serial 1675] used for:
  Associativity: (b.c).a = a.b.c [serial 1674] 


Theorem (380)                               [serial 1673] 
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334] ->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 379:
Theorem (379) [serial 1674] used for:
  Law of And-Simplification:  P and true is P [serial 1673] 


Theorem (381)                               [serial 1675] 
P [311] << MONITOR_OK()
  and RUN()
  and ( INVMA() ) >>
S [334] ->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1674]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (382)                               [serial 1674] 
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334] ->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1673]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 381:
Theorem (381) [serial 1675] used for:
  Associativity: (b.c).a = a.b.c [serial 1674] 


Theorem (383)                               [serial 1673] 
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334] ->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 382:
Theorem (382) [serial 1674] used for:
  Law of And-Simplification:  P and true is P [serial 1673] 


Theorem (384)                               [serial 1026] 
P [311] << ( INVMA() )
  and ( MONITOR_OK()
  and RUN() ) >>
S [334] ->
Q [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
Why created:   <<M(check_mode) and x>> -> <<M(check_temp)>> for maNormal: check_mode-[x]->check_temp{};
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 383 383:
Theorem (383) [serial 1673] used for:
   add user-defined axioms to postcondition 
Theorem (383) [serial 1673] used for:
   add user-defined axioms to postcondition 


Theorem (385)                               [serial 1735] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312] ->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1734]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (386)                               [serial 1734] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312] ->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1732]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 385:
Theorem (385) [serial 1735] used for:
  Replacing port names with BLESS::Value properties  [serial 1734] 


Theorem (387)                               [serial 1732] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312] ->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
Why created:    normalization of [serial 1730]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 386:
Theorem (386) [serial 1734] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1732] 


Theorem (388)                               [serial 1730] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312] ->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1728]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 387:
Theorem (387) [serial 1732] used for:
    normalization of [serial 1730] 


Theorem (389)                               [serial 1728] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [49] << CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t >>
Why created:    normalization of [serial 1722]
Solved by:  Substitution of Assertion Labels
and theorem 388:
Theorem (388) [serial 1730] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1728] 


Theorem (390)                               [serial 1722] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [49] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 389:
Theorem (389) [serial 1728] used for:
    normalization of [serial 1722] 


Theorem (391)                               [serial 1738] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [48] << MONITOR_OK()
  and RUN() >>
Why created:    normalization of [serial 1736]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (392)                               [serial 1736] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [48] << ( MONITOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1723]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 391:
Theorem (391) [serial 1738] used for:
    normalization of [serial 1736] 


Theorem (393)                               [serial 1723] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [48] << MONITOR_MODE(x : mmode'Normal) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
Solved by:  Substitution of Assertion Labels
and theorem 392:
Theorem (392) [serial 1736] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1723] 


Theorem (394)                               [serial 1751] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and alarm_control^-1 = alarm_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
S [312] ->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1749]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (395)                               [serial 1749] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312] ->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1747]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 394:
Theorem (394) [serial 1751] used for:
    normalization of [serial 1749] 


Theorem (396)                               [serial 1747] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312] ->
Q [339] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1745]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 395:
Theorem (395) [serial 1749] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1747] 


Theorem (397)                               [serial 1745] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312] ->
Q [339] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1744]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 396:
Theorem (396) [serial 1747] used for:
    normalization of [serial 1745] 


Theorem (398)                               [serial 1744] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [339] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1742]
Solved by:  Substitution of Assertion Labels
and theorem 397:
Theorem (397) [serial 1745] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1744] 


Theorem (399)                               [serial 1742] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [339] << not INI() >>
Why created:    normalization of [serial 1740]
Solved by:  Substitution of Assertion Labels
and theorem 398:
Theorem (398) [serial 1744] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1742] 


Theorem (400)                               [serial 1740] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [339] << not ( INI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1724]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 399:
Theorem (399) [serial 1742] used for:
    normalization of [serial 1740] 


Theorem (401)                               [serial 1724] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [339] << not MONITOR_MODE(x : mmode'Init) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707]
Solved by:  Substitution of Assertion Labels
and theorem 400:
Theorem (400) [serial 1740] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1724] 


Theorem (402)                               [serial 1707] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [339] << ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal)
  and not MONITOR_MODE(x : mmode'Init) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1701]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 390 393 401:
Theorem (390) [serial 1722] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707] 
Theorem (393) [serial 1723] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707] 
Theorem (401) [serial 1724] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1707] 


Theorem (403)                               [serial 1701] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [339] << ( ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or UPPER_ALARM_TEMP.t < CURRENT_TEMP.t )
  and MONITOR_MODE(x : mmode'Normal) )
  and not MONITOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 1697]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 402:
Theorem (402) [serial 1707] used for:
  Associativity: (b.c).a = a.b.c [serial 1701] 


Theorem (404)                               [serial 1697] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [339] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t
   or CURRENT_TEMP.t > UPPER_ALARM_TEMP.t ) )
  and not ( MONITOR_MODE(x : mmode'Init) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1679]
Solved by:  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 403:
Theorem (403) [serial 1701] used for:
    normalization of [serial 1697] 


Theorem (405)                               [serial 1679] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [339] << REQMA2()
  and not REQMA1() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1677]
Solved by:  Substitution of Assertion Labels
and theorem 404:
Theorem (404) [serial 1697] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1679] 


Theorem (406)                               [serial 1725] 
P [343] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_previous_period^1 = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1717]
Solved by:  Identity (id):  P->P is tautology


Theorem (407)                               [serial 1717] 
P [343] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
Why created:    normalization of [serial 1713]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 406:
Theorem (406) [serial 1725] used for:
  Assume Present:  P = P@now = P^0   [serial 1717] 


Theorem (408)                               [serial 1713] 
P [343] << ( alarm_previous_period )^1 = alarm_control >>
S [310] ->
Q [302] << ( alarm_control^( -1 + 1 ) = ( alarm_previous_period )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1703]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 407:
Theorem (407) [serial 1717] used for:
    normalization of [serial 1713] 


Theorem (409)                               [serial 1703] 
P [343] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( alarm_control^-1 = alarm_previous_period )^1 >>
Why created:    normalization of [serial 1698]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 408:
Theorem (408) [serial 1713] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1703] 


Theorem (410)                               [serial 1698] 
P [343] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1680]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 409:
Theorem (409) [serial 1703] used for:
    normalization of [serial 1698] 


Theorem (411)                               [serial 1680] 
P [343] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << INVMA()^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1677]
Solved by:  Substitution of Assertion Labels
and theorem 410:
Theorem (410) [serial 1698] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1680] 


Theorem (412)                               [serial 1689] 
P [339] << REQMA2()
  and not REQMA1() >>
S [340] ->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
Why created:    normalization of [serial 1683]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (413)                               [serial 1683] 
P [339] << REQMA2()
  and not REQMA1() >>
S [340] ->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
Why created:  applied port output of enumeration type  alarm_control!(') [serial 1681]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 412:
Theorem (412) [serial 1689] used for:
    normalization of [serial 1683] 


Theorem (414)                               [serial 1726] 
P [340] << cntrl'O_n = alarm_control
  and REQMA2()
  and not REQMA1() >>
S [340] ->
Q [341] << cntrl'O_n = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1719]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (415)                               [serial 1719] 
P [340] << cntrl'O_n^0 = alarm_control^0
  and REQMA2()
  and not REQMA1() >>
S [340] ->
Q [341] << cntrl'O_n = alarm_control >>
Why created:    normalization of [serial 1714]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 414:
Theorem (414) [serial 1726] used for:
  Assume Present:  P = P@now = P^0   [serial 1719] 


Theorem (416)                               [serial 1714] 
P [340] << REQMA2()
  and ( ( cntrl'O_n )^0 = ( alarm_control )^0 )
  and not REQMA1() >>
S [340] ->
Q [341] << cntrl'O_n = alarm_control >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1710]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 415:
Theorem (415) [serial 1719] used for:
    normalization of [serial 1714] 


Theorem (417)                               [serial 1710] 
P [340] << REQMA2()
  and ( cntrl'O_n = alarm_control )^0
  and not REQMA1() >>
S [340] ->
Q [341] << cntrl'O_n = alarm_control >>
Why created:    normalization of [serial 1706]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 416:
Theorem (416) [serial 1714] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1710] 


Theorem (418)                               [serial 1706] 
P [340] << REQMA2()
  and not REQMA1()
  and ( cntrl'O_n = alarm_control )^0 >>
S [340] ->
Q [341] << cntrl'O_n = alarm_control >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1691]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 417:
Theorem (417) [serial 1710] used for:
    normalization of [serial 1706] 


Theorem (419)                               [serial 1691] 
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [340] ->
Q [341] << cntrl'O_n = alarm_control >>
Why created:    normalization of [serial 1684]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 418:
Theorem (418) [serial 1706] used for:
  Associativity: (b.c).a = a.b.c [serial 1691] 


Theorem (420)                               [serial 1684] 
P [340] << ( REQMA2()
  and not REQMA1() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [340] ->
Q [341] << cntrl'O_n = alarm_control >>
Why created:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1681]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 419:
Theorem (419) [serial 1691] used for:
    normalization of [serial 1684] 


Theorem (421)                               [serial 1681] 
P [339] << REQMA2()
  and not REQMA1() >>
S [340] alarm_control!(cntrl'O_n)
Q [341] << cntrl'O_n = alarm_control >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1677]
Solved by:  Enumeration Type Port Output 
and theorems 413 420:
Theorem (413) [serial 1683] used for:
  applied port output of enumeration type  alarm_control!(') [serial 1681] 
Theorem (420) [serial 1684] used for:
  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1681] 


Theorem (422)                               [serial 1693] 
P [341] << cntrl'O_n = alarm_control >>
S [342] ->
Q [343] << cntrl'O_n = alarm_control >>
Why created:    normalization of [serial 1685]
Solved by:  Identity (id):  P->P is tautology


Theorem (423)                               [serial 1685] 
P [341] << cntrl'O_n = alarm_control >>
S [342] ->
Q [343] << ( cntrl'O_n ) = alarm_control >>
Why created:  applied wp for assignment [serial 1682]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 422:
Theorem (422) [serial 1693] used for:
    normalization of [serial 1685] 


Theorem (424)                               [serial 1682] 
P [341] << cntrl'O_n = alarm_control >>
S [342] alarm_previous_period' := cntrl'O_n
Q [343] << alarm_previous_period' = alarm_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1677]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 423:
Theorem (423) [serial 1685] used for:
  applied wp for assignment [serial 1682] 


Theorem (425)                               [serial 1677] 
P [312] << ( current_temperature.t < lower_alarm_temperature.t
   or upper_alarm_temperature.t < current_temperature.t )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [339]   << REQMA2()
    and not REQMA1() >>
  alarm_control!(cntrl'O_n)
  ;
  << cntrl'O_n = alarm_control >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << INVMA()^1 >>
Why created:    normalization of [serial 1027]
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 405 411 421 424:
Theorem (405) [serial 1679] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1677] 
Theorem (411) [serial 1680] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1677] 
Theorem (421) [serial 1681] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1677] 
Theorem (424) [serial 1682] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1677] 


Theorem (426)                               [serial 1027] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t < lower_alarm_temperature.t )
   or ( current_temperature.t > upper_alarm_temperature.t ) ) >>
S [339]   << REQMA2()
    and not REQMA1() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
Why created:   <<M(check_temp) and x>> A <<M(run)>> for maOor: check_temp-[x]->run{A};
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 425:
Theorem (425) [serial 1677] used for:
    normalization of [serial 1027] 


Theorem (427)                               [serial 1813] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [62] << MONITOR_OK()
  and RUN() >>
Why created:    normalization of [serial 1808]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (428)                               [serial 1808] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [62] << ( MONITOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1805]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 427:
Theorem (427) [serial 1813] used for:
    normalization of [serial 1808] 


Theorem (429)                               [serial 1805] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [62] << MONITOR_MODE(x : mmode'Normal) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]
Solved by:  Substitution of Assertion Labels
and theorem 428:
Theorem (428) [serial 1808] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1805] 


Theorem (430)                               [serial 1822] 
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [63] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F >>
Why created:    normalization of [serial 1818]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (431)                               [serial 1818] 
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [63] << ( ( ( LOWER_ALARM_TEMP.t + 0.5 F ) ) <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= ( ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
Why created:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1816]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 430:
Theorem (430) [serial 1822] used for:
    normalization of [serial 1818] 


Theorem (432)                               [serial 1816] 
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1806]
Solved by:  Replace expression with range:   a<=x and x<=b  iff  x in a..b
and theorem 431:
Theorem (431) [serial 1818] used for:
  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1816] 


Theorem (433)                               [serial 1806] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 432:
Theorem (432) [serial 1816] used for:
  Replacing port names with BLESS::Value properties  [serial 1806] 


Theorem (434)                               [serial 1792] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << MONITOR_MODE(x : mmode'Normal)
  and CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
Why created:    normalization of [serial 1787]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 429 433:
Theorem (429) [serial 1805] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792] 
Theorem (433) [serial 1806] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792] 


Theorem (435)                               [serial 1787] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1781]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 434:
Theorem (434) [serial 1792] used for:
    normalization of [serial 1787] 


Theorem (436)                               [serial 1781] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << REQMA4() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]
Solved by:  Substitution of Assertion Labels
and theorem 435:
Theorem (435) [serial 1787] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1781] 


Theorem (437)                               [serial 1830] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F ) )
  and ( not ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312] ->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1828]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (438)                               [serial 1828] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312] ->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1826]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 437:
Theorem (437) [serial 1830] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1828] 


Theorem (439)                               [serial 1826] 
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312] ->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1825]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 438:
Theorem (438) [serial 1828] used for:
    normalization of [serial 1826] 


Theorem (440)                               [serial 1825] 
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1820]
Solved by:  Substitution of Assertion Labels
and theorem 439:
Theorem (439) [serial 1826] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1825] 


Theorem (441)                               [serial 1820] 
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not INI() >>
Why created:    normalization of [serial 1817]
Solved by:  Substitution of Assertion Labels
and theorem 440:
Theorem (440) [serial 1825] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1820] 


Theorem (442)                               [serial 1817] 
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not INI() >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1811]
Solved by:  Reflexivity of Addition: a+b=b+a
and theorem 441:
Theorem (441) [serial 1820] used for:
    normalization of [serial 1817] 


Theorem (443)                               [serial 1811] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not INI() >>
Why created:    normalization of [serial 1807]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 442:
Theorem (442) [serial 1817] used for:
  Replacing port names with BLESS::Value properties  [serial 1811] 


Theorem (444)                               [serial 1807] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not ( INI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1794]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 443:
Theorem (443) [serial 1811] used for:
    normalization of [serial 1807] 


Theorem (445)                               [serial 1794] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not MONITOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 1788]
Solved by:  Substitution of Assertion Labels
and theorem 444:
Theorem (444) [serial 1807] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1794] 


Theorem (446)                               [serial 1788] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not ( MONITOR_MODE(x : mmode'Init) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1782]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 445:
Theorem (445) [serial 1794] used for:
    normalization of [serial 1788] 


Theorem (447)                               [serial 1782] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not REQMA1() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]
Solved by:  Substitution of Assertion Labels
and theorem 446:
Theorem (446) [serial 1788] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1782] 


Theorem (448)                               [serial 1773] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << REQMA4()
  and not REQMA1() >>
Why created:    normalization of [serial 1764]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 436 447:
Theorem (436) [serial 1781] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773] 
Theorem (447) [serial 1782] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773] 


Theorem (449)                               [serial 1764] 
P [312] << ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) )
  and INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
S [312] ->
Q [348] << REQMA4()
  and not REQMA1() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1762]
Solved by:  Reflexivity of Addition: a+b=b+a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 448:
Theorem (448) [serial 1773] used for:
    normalization of [serial 1764] 


Theorem (450)                               [serial 1762] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312] ->
Q [348] << REQMA4()
  and not REQMA1() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1760]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 449:
Theorem (449) [serial 1764] used for:
  Associativity: (b.c).a = a.b.c [serial 1762] 


Theorem (451)                               [serial 1760] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312] ->
Q [348] << REQMA4()
  and not REQMA1()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 450:
Theorem (450) [serial 1762] used for:
  Law of And-Simplification:  P and true is P [serial 1760] 


Theorem (452)                               [serial 1813] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [62] << MONITOR_OK()
  and RUN() >>
Why created:    normalization of [serial 1808]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (453)                               [serial 1808] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [62] << ( MONITOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1805]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 452:
Theorem (452) [serial 1813] used for:
    normalization of [serial 1808] 


Theorem (454)                               [serial 1805] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [62] << MONITOR_MODE(x : mmode'Normal) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]
Solved by:  Substitution of Assertion Labels
and theorem 453:
Theorem (453) [serial 1808] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1805] 


Theorem (455)                               [serial 1822] 
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [63] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F >>
Why created:    normalization of [serial 1818]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (456)                               [serial 1818] 
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [63] << ( ( ( LOWER_ALARM_TEMP.t + 0.5 F ) ) <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= ( ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
Why created:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1816]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 455:
Theorem (455) [serial 1822] used for:
    normalization of [serial 1818] 


Theorem (457)                               [serial 1816] 
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1806]
Solved by:  Replace expression with range:   a<=x and x<=b  iff  x in a..b
and theorem 456:
Theorem (456) [serial 1818] used for:
  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1816] 


Theorem (458)                               [serial 1806] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [63] << CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 457:
Theorem (457) [serial 1816] used for:
  Replacing port names with BLESS::Value properties  [serial 1806] 


Theorem (459)                               [serial 1792] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << MONITOR_MODE(x : mmode'Normal)
  and CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) >>
Why created:    normalization of [serial 1787]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 454 458:
Theorem (454) [serial 1805] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792] 
Theorem (458) [serial 1806] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1792] 


Theorem (460)                               [serial 1787] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in ( LOWER_ALARM_TEMP.t + 0.5 F ) .. ( UPPER_ALARM_TEMP.t - 0.5 F ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1781]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 459:
Theorem (459) [serial 1792] used for:
    normalization of [serial 1787] 


Theorem (461)                               [serial 1781] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << REQMA4() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]
Solved by:  Substitution of Assertion Labels
and theorem 460:
Theorem (460) [serial 1787] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1781] 


Theorem (462)                               [serial 1830] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( not ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F ) )
  and ( not ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and alarm_control^-1 = alarm_previous_period >>
S [312] ->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1828]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (463)                               [serial 1828] 
P [312] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and alarm_control^-1 = alarm_previous_period >>
S [312] ->
Q [348] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 1826]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 462:
Theorem (462) [serial 1830] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1828] 


Theorem (464)                               [serial 1826] 
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [312] ->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1825]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 463:
Theorem (463) [serial 1828] used for:
    normalization of [serial 1826] 


Theorem (465)                               [serial 1825] 
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1820]
Solved by:  Substitution of Assertion Labels
and theorem 464:
Theorem (464) [serial 1826] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1825] 


Theorem (466)                               [serial 1820] 
P [312] << LOWER_ALARM_TEMP.t + 0.5 F <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not INI() >>
Why created:    normalization of [serial 1817]
Solved by:  Substitution of Assertion Labels
and theorem 465:
Theorem (465) [serial 1825] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1820] 


Theorem (467)                               [serial 1817] 
P [312] << 0.5 F + LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not INI() >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1811]
Solved by:  Reflexivity of Addition: a+b=b+a
and theorem 466:
Theorem (466) [serial 1820] used for:
    normalization of [serial 1817] 


Theorem (468)                               [serial 1811] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not INI() >>
Why created:    normalization of [serial 1807]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 467:
Theorem (467) [serial 1817] used for:
  Replacing port names with BLESS::Value properties  [serial 1811] 


Theorem (469)                               [serial 1807] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not ( INI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1794]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 468:
Theorem (468) [serial 1811] used for:
    normalization of [serial 1807] 


Theorem (470)                               [serial 1794] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not MONITOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 1788]
Solved by:  Substitution of Assertion Labels
and theorem 469:
Theorem (469) [serial 1807] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1794] 


Theorem (471)                               [serial 1788] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not ( MONITOR_MODE(x : mmode'Init) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1782]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 470:
Theorem (470) [serial 1794] used for:
    normalization of [serial 1788] 


Theorem (472)                               [serial 1782] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << not REQMA1() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773]
Solved by:  Substitution of Assertion Labels
and theorem 471:
Theorem (471) [serial 1788] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1782] 


Theorem (473)                               [serial 1773] 
P [312] << 0.5 F + lower_alarm_temperature.t <= current_temperature.t
  and current_temperature.t <= upper_alarm_temperature.t - 0.5 F
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [312] ->
Q [348] << REQMA4()
  and not REQMA1() >>
Why created:    normalization of [serial 1764]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 461 472:
Theorem (461) [serial 1781] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773] 
Theorem (472) [serial 1782] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1773] 


Theorem (474)                               [serial 1764] 
P [312] << ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) )
  and INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON() >>
S [312] ->
Q [348] << REQMA4()
  and not REQMA1() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1762]
Solved by:  Reflexivity of Addition: a+b=b+a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 473:
Theorem (473) [serial 1773] used for:
    normalization of [serial 1764] 


Theorem (475)                               [serial 1762] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312] ->
Q [348] << REQMA4()
  and not REQMA1() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1760]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 474:
Theorem (474) [serial 1764] used for:
  Associativity: (b.c).a = a.b.c [serial 1762] 


Theorem (476)                               [serial 1760] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312] ->
Q [348] << REQMA4()
  and not REQMA1()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 475:
Theorem (475) [serial 1762] used for:
  Law of And-Simplification:  P and true is P [serial 1760] 


Theorem (477)                               [serial 1753] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [312] ->
Q [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 476 476:
Theorem (476) [serial 1760] used for:
   add user-defined axioms to postcondition 
Theorem (476) [serial 1760] used for:
   add user-defined axioms to postcondition 


Theorem (478)                               [serial 1804] 
P [352] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_previous_period^1 = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1798]
Solved by:  Identity (id):  P->P is tautology


Theorem (479)                               [serial 1798] 
P [352] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
Why created:    normalization of [serial 1790]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 478:
Theorem (478) [serial 1804] used for:
  Assume Present:  P = P@now = P^0   [serial 1798] 


Theorem (480)                               [serial 1790] 
P [352] << ( alarm_previous_period )^1 = alarm_control >>
S [310] ->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1786]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 479:
Theorem (479) [serial 1798] used for:
    normalization of [serial 1790] 


Theorem (481)                               [serial 1786] 
P [352] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1767]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 480:
Theorem (480) [serial 1790] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1786] 


Theorem (482)                               [serial 1767] 
P [352] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << INVMA()^1 >>
Why created:    normalization of [serial 1754]
Solved by:  Substitution of Assertion Labels
and theorem 481:
Theorem (481) [serial 1786] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1767] 


Theorem (483)                               [serial 1754] 
P [352] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( INVMA() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1028]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 482:
Theorem (482) [serial 1767] used for:
    normalization of [serial 1754] 


Theorem (484)                               [serial 1769] 
P [348] << AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349] ->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
Why created:    normalization of [serial 1757]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (485)                               [serial 1757] 
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349] ->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
Why created:  applied port output of enumeration type  alarm_control!(') [serial 1755]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 484:
Theorem (484) [serial 1769] used for:
    normalization of [serial 1757] 


Theorem (486)                               [serial 1803] 
P [349] << cntrl'Off = alarm_control
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1796]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (487)                               [serial 1796] 
P [349] << cntrl'Off^0 = alarm_control^0
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control >>
Why created:    normalization of [serial 1789]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 486:
Theorem (486) [serial 1803] used for:
  Assume Present:  P = P@now = P^0   [serial 1796] 


Theorem (488)                               [serial 1789] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( ( cntrl'Off )^0 = ( alarm_control )^0 )
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1783]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 487:
Theorem (487) [serial 1796] used for:
    normalization of [serial 1789] 


Theorem (489)                               [serial 1783] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 488:
Theorem (488) [serial 1789] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1783] 


Theorem (490)                               [serial 1784] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349] ->
Q [350] << REQMA4() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (491)                               [serial 1785] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349] ->
Q [350] << not REQMA1() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (492)                               [serial 1775] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control
  and REQMA4()
  and not REQMA1() >>
Why created:    normalization of [serial 1765]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 489 490 491:
Theorem (489) [serial 1783] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775] 
Theorem (490) [serial 1784] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775] 
Theorem (491) [serial 1785] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775] 


Theorem (493)                               [serial 1765] 
P [349] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off )^0 >>
S [349] ->
Q [350] << REQMA4()
  and not REQMA1()
  and ( alarm_control = cntrl'Off ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1763]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 492:
Theorem (492) [serial 1775] used for:
    normalization of [serial 1765] 


Theorem (494)                               [serial 1763] 
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349] ->
Q [350] << REQMA4()
  and not REQMA1()
  and ( alarm_control = cntrl'Off ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1761]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 493:
Theorem (493) [serial 1765] used for:
  Associativity: (b.c).a = a.b.c [serial 1763] 


Theorem (495)                               [serial 1761] 
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349] ->
Q [350] << REQMA4()
  and not REQMA1()
  and true
  and ( alarm_control = cntrl'Off ) >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 494:
Theorem (494) [serial 1763] used for:
  Law of And-Simplification:  P and true is P [serial 1761] 


Theorem (496)                               [serial 1803] 
P [349] << cntrl'Off = alarm_control
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1796]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (497)                               [serial 1796] 
P [349] << cntrl'Off^0 = alarm_control^0
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control >>
Why created:    normalization of [serial 1789]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 496:
Theorem (496) [serial 1803] used for:
  Assume Present:  P = P@now = P^0   [serial 1796] 


Theorem (498)                               [serial 1789] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( ( cntrl'Off )^0 = ( alarm_control )^0 )
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1783]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 497:
Theorem (497) [serial 1796] used for:
    normalization of [serial 1789] 


Theorem (499)                               [serial 1783] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 498:
Theorem (498) [serial 1789] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1783] 


Theorem (500)                               [serial 1784] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349] ->
Q [350] << REQMA4() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (501)                               [serial 1785] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349] ->
Q [350] << not REQMA1() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (502)                               [serial 1775] 
P [349] << AXIOM_AR()
  and REQMA4()
  and ( cntrl'Off = alarm_control )^0
  and not REQMA1() >>
S [349] ->
Q [350] << cntrl'Off = alarm_control
  and REQMA4()
  and not REQMA1() >>
Why created:    normalization of [serial 1765]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 499 500 501:
Theorem (499) [serial 1783] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775] 
Theorem (500) [serial 1784] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775] 
Theorem (501) [serial 1785] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1775] 


Theorem (503)                               [serial 1765] 
P [349] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off )^0 >>
S [349] ->
Q [350] << REQMA4()
  and not REQMA1()
  and ( alarm_control = cntrl'Off ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1763]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 502:
Theorem (502) [serial 1775] used for:
    normalization of [serial 1765] 


Theorem (504)                               [serial 1763] 
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349] ->
Q [350] << REQMA4()
  and not REQMA1()
  and ( alarm_control = cntrl'Off ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1761]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 503:
Theorem (503) [serial 1765] used for:
  Associativity: (b.c).a = a.b.c [serial 1763] 


Theorem (505)                               [serial 1761] 
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349] ->
Q [350] << REQMA4()
  and not REQMA1()
  and true
  and ( alarm_control = cntrl'Off ) >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 504:
Theorem (504) [serial 1763] used for:
  Law of And-Simplification:  P and true is P [serial 1761] 


Theorem (506)                               [serial 1758] 
P [349] << ( REQMA4()
  and not REQMA1()
  and AXIOM_AR() )
  and ( alarm_control = cntrl'Off )^0 >>
S [349] ->
Q [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
Why created:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1755]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 505 505:
Theorem (505) [serial 1761] used for:
   add user-defined axioms to postcondition 
Theorem (505) [serial 1761] used for:
   add user-defined axioms to postcondition 


Theorem (507)                               [serial 1755] 
P [348] << REQMA4()
  and not REQMA1()
  and AXIOM_AR() >>
S [349] alarm_control!(cntrl'Off)
Q [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Solved by:  Enumeration Type Port Output 
and theorems 485 506:
Theorem (485) [serial 1757] used for:
  applied port output of enumeration type  alarm_control!(') [serial 1755] 
Theorem (506) [serial 1758] used for:
  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1755] 


Theorem (508)                               [serial 1771] 
P [350] << cntrl'Off = alarm_control
  and AXIOM_AR()
  and REQMA4()
  and not REQMA1() >>
S [351] ->
Q [352] << cntrl'Off = alarm_control >>
Why created:    normalization of [serial 1759]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (509)                               [serial 1759] 
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351] ->
Q [352] << ( cntrl'Off ) = alarm_control >>
Why created:  applied wp for assignment [serial 1756]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 508:
Theorem (508) [serial 1771] used for:
    normalization of [serial 1759] 


Theorem (510)                               [serial 1756] 
P [350] << REQMA4()
  and not REQMA1()
  and AXIOM_AR()
  and ( alarm_control = cntrl'Off ) >>
S [351] alarm_previous_period' := cntrl'Off
Q [352] << alarm_previous_period' = alarm_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 509:
Theorem (509) [serial 1759] used for:
  applied wp for assignment [serial 1756] 


Theorem (511)                               [serial 1028] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( current_temperature.t >= ( lower_alarm_temperature.t + 0.5 F ) )
  and ( current_temperature.t <= ( upper_alarm_temperature.t - 0.5 F ) ) ) >>
S [348]   << REQMA4()
    and not REQMA1()
    and AXIOM_AR() >>
  alarm_control!(cntrl'Off)
  ;
  << REQMA4()
    and not REQMA1()
    and AXIOM_AR()
    and ( alarm_control = cntrl'Off ) >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
Why created:   <<M(check_temp) and x>> A <<M(run)>> for maIr: check_temp-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 477 483 507 510:
Theorem (477) [serial 1753] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1028] 
Theorem (483) [serial 1754] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1028] 
Theorem (507) [serial 1755] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028] 
Theorem (510) [serial 1756] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1028] 


Theorem (512)                               [serial 1840] 
P [312] << ( ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t )
   or ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F
  and LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t ) )
  and AXIOM_OFFON()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [354] ->
Q [313] << ( UPPER_ALARM_TEMP.t - 0.5 F < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t )
   or ( CURRENT_TEMP.t < LOWER_ALARM_TEMP.t + 0.5 F
  and LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t ) >>
Why created:    normalization of [serial 1838]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (513)                               [serial 1838] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( CURRENT_TEMP.t >= LOWER_ALARM_TEMP.t )
  and ( CURRENT_TEMP.t < ( LOWER_ALARM_TEMP.t + 0.5 F ) ) )
   or ( ( CURRENT_TEMP.t > ( UPPER_ALARM_TEMP.t - 0.5 F ) )
  and ( CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
S [354] ->
Q [313] << ( ( ( LOWER_ALARM_TEMP.t <= CURRENT_TEMP.t
  and CURRENT_TEMP.t < ( ( LOWER_ALARM_TEMP.t + 0.5 F ) ) ) )
   or ( ( ( ( UPPER_ALARM_TEMP.t - 0.5 F ) ) < CURRENT_TEMP.t
  and CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
Why created:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1837]
Solved by:  Irreflexivity of Greater Than: (a>b) = (b<a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 512:
Theorem (512) [serial 1840] used for:
    normalization of [serial 1838] 


Theorem (514)                               [serial 1837] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( CURRENT_TEMP.t >= LOWER_ALARM_TEMP.t )
  and ( CURRENT_TEMP.t < ( LOWER_ALARM_TEMP.t + 0.5 F ) ) )
   or ( ( CURRENT_TEMP.t > ( UPPER_ALARM_TEMP.t - 0.5 F ) )
  and ( CURRENT_TEMP.t <= UPPER_ALARM_TEMP.t ) ) ) >>
S [354] ->
Q [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1836]
Solved by:  Replace expression with range:   a<=x and x<=b  iff  x in a..b
and theorem 513:
Theorem (513) [serial 1838] used for:
  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 1837] 


Theorem (515)                               [serial 1836] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354] ->
Q [313] << ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1831]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 514:
Theorem (514) [serial 1837] used for:
  Replacing port names with BLESS::Value properties  [serial 1836] 


Theorem (516)                               [serial 1831] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354] ->
Q [313] << EDGE_TEMP() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Solved by:  Substitution of Assertion Labels
and theorem 515:
Theorem (515) [serial 1836] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1831] 


Theorem (517)                               [serial 1832] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354] ->
Q [313] << MONITOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (518)                               [serial 1833] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354] ->
Q [313] << RUN() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (519)                               [serial 1834] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354] ->
Q [313] << INVMA() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (520)                               [serial 1835] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354] ->
Q [313] << AXIOM_OFFON() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (521)                               [serial 1029] 
P [312] << INVMA()
  and MONITOR_OK()
  and RUN()
  and AXIOM_OFFON()
  and ( ( ( current_temperature.t >= lower_alarm_temperature.t )
  and ( current_temperature.t < ( lower_alarm_temperature.t + 0.5 F ) ) )
   or ( ( current_temperature.t > ( upper_alarm_temperature.t - 0.5 F ) )
  and ( current_temperature.t <= upper_alarm_temperature.t ) ) ) >>
S [354] ->
Q [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON() >>
Why created:   <<M(check_temp) and x>> -> <<M(check_hyst)>> for maHys: check_temp-[x]->check_hyst{};
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 516 517 518 519 520:
Theorem (516) [serial 1831] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029] 
Theorem (517) [serial 1832] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029] 
Theorem (518) [serial 1833] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029] 
Theorem (519) [serial 1834] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029] 
Theorem (520) [serial 1835] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1029] 


Theorem (522)                               [serial 1865] 
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [362] << cntrl'O_n = alarm_previous_period >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (523)                               [serial 1869] 
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [361] << true >>
Why created:   add user-defined axioms to postcondition
Solved by:  True Conclusion Schema (tc): P->true


Theorem (524)                               [serial 1869] 
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [361] << true >>
Why created:   add user-defined axioms to postcondition
Solved by:  True Conclusion Schema (tc): P->true


Theorem (525)                               [serial 1866] 
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [361] << AXIOM_AC() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 524 524:
Theorem (524) [serial 1869] used for:
   add user-defined axioms to postcondition 
Theorem (524) [serial 1869] used for:
   add user-defined axioms to postcondition 


Theorem (526)                               [serial 1867] 
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [362] << INVMA() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (527)                               [serial 1893] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [56] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (528)                               [serial 1901] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 1899]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (529)                               [serial 1899] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1897]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 528:
Theorem (528) [serial 1901] used for:
    normalization of [serial 1899] 


Theorem (530)                               [serial 1897] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << MONITOR_OK()
  and RUN() >>
Why created:    normalization of [serial 1895]
Solved by:  Substitution of Assertion Labels
and theorem 529:
Theorem (529) [serial 1899] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1897] 


Theorem (531)                               [serial 1895] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << ( MONITOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1894]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 530:
Theorem (530) [serial 1897] used for:
    normalization of [serial 1895] 


Theorem (532)                               [serial 1894] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891]
Solved by:  Substitution of Assertion Labels
and theorem 531:
Theorem (531) [serial 1895] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1894] 


Theorem (533)                               [serial 1891] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [361] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) >>
Why created:    normalization of [serial 1889]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 527 532:
Theorem (527) [serial 1893] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891] 
Theorem (532) [serial 1894] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1891] 


Theorem (534)                               [serial 1889] 
P [313] << cntrl'O_n = alarm_previous_period
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 
0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [313] ->
Q [361] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1868]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 533:
Theorem (533) [serial 1891] used for:
    normalization of [serial 1889] 


Theorem (535)                               [serial 1868] 
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [361] << REQMA3() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850]
Solved by:  Substitution of Assertion Labels
and theorem 534:
Theorem (534) [serial 1889] used for:
  Substituted assertions' predicates for labels  [serial 1868] 


Theorem (536)                               [serial 1850] 
P [313] << cntrl'O_n = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
Why created:    normalization of [serial 1842]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 522 525 526 535:
Theorem (522) [serial 1865] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850] 
Theorem (525) [serial 1866] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850] 
Theorem (526) [serial 1867] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850] 
Theorem (535) [serial 1868] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1850] 


Theorem (537)                               [serial 1842] 
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'O_n ) >>
S [313] ->
Q [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1030]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 536:
Theorem (536) [serial 1850] used for:
    normalization of [serial 1842] 


Theorem (538)                               [serial 1876] 
P [366] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_previous_period^1 = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1873]
Solved by:  Identity (id):  P->P is tautology


Theorem (539)                               [serial 1873] 
P [366] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
Why created:    normalization of [serial 1871]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 538:
Theorem (538) [serial 1876] used for:
  Assume Present:  P = P@now = P^0   [serial 1873] 


Theorem (540)                               [serial 1871] 
P [366] << ( alarm_previous_period )^1 = alarm_control >>
S [310] ->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1870]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 539:
Theorem (539) [serial 1873] used for:
    normalization of [serial 1871] 


Theorem (541)                               [serial 1870] 
P [366] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1852]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 540:
Theorem (540) [serial 1871] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1870] 


Theorem (542)                               [serial 1852] 
P [366] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << INVMA()^1 >>
Why created:    normalization of [serial 1843]
Solved by:  Substitution of Assertion Labels
and theorem 541:
Theorem (541) [serial 1870] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1852] 


Theorem (543)                               [serial 1843] 
P [366] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( INVMA() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1030]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 542:
Theorem (542) [serial 1852] used for:
    normalization of [serial 1843] 


Theorem (544)                               [serial 1888] 
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363] ->
Q [36] << alarm_previous_period = alarm_control^-1
   or REQMA2()
   or REQMA5() >>
Why created:  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1887]
Solved by:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (545)                               [serial 1887] 
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363] ->
Q [36] << alarm_previous_period = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
Why created:  Guided Substitution of Equals 
 replacing "cntrl'O_n" with its = "alarm_previous_period" in its postcondition [serial 1886]
Solved by:  Guided Substitution of Equals
and theorem 544:
Theorem (544) [serial 1888] used for:
  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1887] 


Theorem (546)                               [serial 1886] 
P [361] << cntrl'O_n = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [363] ->
Q [36] << cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1881]
Solved by:  Guided Substitution of Equals
and theorem 545:
Theorem (545) [serial 1887] used for:
  Guided Substitution of Equals 
 replacing "cntrl'O_n" with its = "alarm_previous_period" in its postcondition [serial 1886] 


Theorem (547)                               [serial 1881] 
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363] ->
Q [36] << cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() >>
Why created:    normalization of [serial 1878]
Solved by:  Substitution of Assertion Labels
and theorem 546:
Theorem (546) [serial 1886] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1881] 


Theorem (548)                               [serial 1878] 
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363] ->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 547:
Theorem (547) [serial 1881] used for:
    normalization of [serial 1878] 


Theorem (549)                               [serial 1883] 
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363] ->
Q [36] << REQMA2()
   or REQMA3()
   or REQMA5() >>
Why created:    normalization of [serial 1879]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (550)                               [serial 1879] 
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363] ->
Q [36] << ( REQMA3()
   or REQMA2()
   or REQMA5() ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 549:
Theorem (549) [serial 1883] used for:
    normalization of [serial 1879] 


Theorem (551)                               [serial 1877] 
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363] ->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
   or REQMA2()
   or REQMA5() )
  and ( REQMA3()
   or REQMA2()
   or REQMA5() ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1854]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 548 550:
Theorem (548) [serial 1878] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877] 
Theorem (550) [serial 1879] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1877] 


Theorem (552)                               [serial 1854] 
P [361] << cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [363] ->
Q [36] << ( cntrl'O_n = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA2()
   or REQMA5() >>
Why created:    normalization of [serial 1846]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 551:
Theorem (551) [serial 1877] used for:
  Distributing Postcondition Or-Over-And [serial 1854] 


Theorem (553)                               [serial 1846] 
P [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
S [363] ->
Q [36] << REQMA2()
   or REQMA5()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'O_n ) ) >>
Why created:  applied port output of enumeration type  alarm_control!(') [serial 1844]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 552:
Theorem (552) [serial 1854] used for:
    normalization of [serial 1846] 


Theorem (554)                               [serial 1864] 
P [363] << ( cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and cntrl'O_n = alarm_control >>
S [363] ->
Q [364] << cntrl'O_n = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1856]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (555)                               [serial 1856] 
P [363] << ( cntrl'O_n = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'O_n = alarm_control )^0 >>
S [363] ->
Q [364] << cntrl'O_n = alarm_control >>
Why created:    normalization of [serial 1847]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 554:
Theorem (554) [serial 1864] used for:
  Assume Present:  P = P@now = P^0   [serial 1856] 


Theorem (556)                               [serial 1847] 
P [363] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() )
  and ( alarm_control = cntrl'O_n )^0 >>
S [363] ->
Q [364] << alarm_control = cntrl'O_n >>
Why created:  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1844]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 555:
Theorem (555) [serial 1856] used for:
    normalization of [serial 1847] 


Theorem (557)                               [serial 1844] 
P [361] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'O_n )
  and INVMA() >>
S [363] alarm_control!(cntrl'O_n)
Q [364] << alarm_control = cntrl'O_n >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1030]
Solved by:  Enumeration Type Port Output 
and theorems 553 556:
Theorem (553) [serial 1846] used for:
  applied port output of enumeration type  alarm_control!(') [serial 1844] 
Theorem (556) [serial 1847] used for:
  applied port output <<pre and (alarm_control=cntrl'O_n)^0>> -> <<post>> [serial 1844] 


Theorem (558)                               [serial 1858] 
P [364] << cntrl'O_n = alarm_control >>
S [365] ->
Q [366] << cntrl'O_n = alarm_control >>
Why created:    normalization of [serial 1848]
Solved by:  Identity (id):  P->P is tautology


Theorem (559)                               [serial 1848] 
P [364] << alarm_control = cntrl'O_n >>
S [365] ->
Q [366] << ( cntrl'O_n ) = alarm_control >>
Why created:  applied wp for assignment [serial 1845]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 558:
Theorem (558) [serial 1858] used for:
    normalization of [serial 1848] 


Theorem (560)                               [serial 1845] 
P [364] << alarm_control = cntrl'O_n >>
S [365] alarm_previous_period' := cntrl'O_n
Q [366] << alarm_previous_period' = alarm_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1030]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 559:
Theorem (559) [serial 1848] used for:
  applied wp for assignment [serial 1845] 


Theorem (561)                               [serial 1030] 
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'O_n ) >>
S [361]   << REQMA3()
    and AXIOM_AC()
    and ( alarm_previous_period = cntrl'O_n )
    and INVMA() >>
  alarm_control!(cntrl'O_n)
  ;
  << alarm_control = cntrl'O_n >>
  alarm_previous_period' := cntrl'O_n
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
Why created:   <<M(check_hyst) and x>> A <<M(run)>> for maHysOn: check_hyst-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 537 543 557 560:
Theorem (537) [serial 1842] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1030] 
Theorem (543) [serial 1843] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1030] 
Theorem (557) [serial 1844] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1030] 
Theorem (560) [serial 1845] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1030] 


Theorem (562)                               [serial 1928] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [371] << cntrl'Off = alarm_previous_period >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (563)                               [serial 1929] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [371] << INVMA() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (564)                               [serial 1938] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [56] << CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) >>
Why created:    normalization of [serial 1935]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (565)                               [serial 1935] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [56] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 564:
Theorem (564) [serial 1938] used for:
    normalization of [serial 1935] 


Theorem (566)                               [serial 1944] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 1942]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (567)                               [serial 1942] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << ( ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1941]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 566:
Theorem (566) [serial 1944] used for:
    normalization of [serial 1942] 


Theorem (568)                               [serial 1941] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << ( MONITOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1936]
Solved by:  Substitution of Assertion Labels
and theorem 567:
Theorem (567) [serial 1942] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1941] 


Theorem (569)                               [serial 1936] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]
Solved by:  Substitution of Assertion Labels
and theorem 568:
Theorem (568) [serial 1941] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1936] 


Theorem (570)                               [serial 1933] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [370] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) >>
Why created:    normalization of [serial 1931]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 565 569:
Theorem (565) [serial 1935] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933] 
Theorem (569) [serial 1936] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933] 


Theorem (571)                               [serial 1931] 
P [313] << cntrl'Off = alarm_previous_period
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 
0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [313] ->
Q [370] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1930]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 570:
Theorem (570) [serial 1933] used for:
    normalization of [serial 1931] 


Theorem (572)                               [serial 1930] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [370] << REQMA3() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Solved by:  Substitution of Assertion Labels
and theorem 571:
Theorem (571) [serial 1931] used for:
  Substituted assertions' predicates for labels  [serial 1930] 


Theorem (573)                               [serial 1927] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [370] << cntrl'Off = alarm_previous_period
  and INVMA()
  and REQMA3() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1926]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 562 563 572:
Theorem (562) [serial 1928] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927] 
Theorem (563) [serial 1929] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927] 
Theorem (572) [serial 1930] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927] 


Theorem (574)                               [serial 1926] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [370] << cntrl'Off = alarm_previous_period
  and true
  and INVMA()
  and REQMA3() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 573:
Theorem (573) [serial 1927] used for:
  Law of And-Simplification:  P and true is P [serial 1926] 


Theorem (575)                               [serial 1928] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [371] << cntrl'Off = alarm_previous_period >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (576)                               [serial 1929] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [371] << INVMA() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (577)                               [serial 1938] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [56] << CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) >>
Why created:    normalization of [serial 1935]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (578)                               [serial 1935] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [56] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 577:
Theorem (577) [serial 1938] used for:
    normalization of [serial 1935] 


Theorem (579)                               [serial 1944] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 1942]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (580)                               [serial 1942] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << ( ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1941]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 579:
Theorem (579) [serial 1944] used for:
    normalization of [serial 1942] 


Theorem (581)                               [serial 1941] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << ( MONITOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1936]
Solved by:  Substitution of Assertion Labels
and theorem 580:
Theorem (580) [serial 1942] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1941] 


Theorem (582)                               [serial 1936] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [55] << MONITOR_MODE(x : mmode'Normal) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933]
Solved by:  Substitution of Assertion Labels
and theorem 581:
Theorem (581) [serial 1941] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1936] 


Theorem (583)                               [serial 1933] 
P [313] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or MONITOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = alarm_previous_period
   or cntrl'Off = alarm_previous_period )
  and ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'Off = alarm_previous_period
  and alarm_control^-1 = alarm_previous_period >>
S [313] ->
Q [370] << ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) >>
Why created:    normalization of [serial 1931]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 578 582:
Theorem (578) [serial 1935] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933] 
Theorem (582) [serial 1936] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1933] 


Theorem (584)                               [serial 1931] 
P [313] << cntrl'Off = alarm_previous_period
  and ( ( alarm_previous_period = cntrl'O_n )
   or ( alarm_previous_period = cntrl'Off ) )
  and ( ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 
0.5 F ) )
   or ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( not ( MONITOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [313] ->
Q [370] << ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1930]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 583:
Theorem (583) [serial 1933] used for:
    normalization of [serial 1931] 


Theorem (585)                               [serial 1930] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [370] << REQMA3() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927]
Solved by:  Substitution of Assertion Labels
and theorem 584:
Theorem (584) [serial 1931] used for:
  Substituted assertions' predicates for labels  [serial 1930] 


Theorem (586)                               [serial 1927] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [370] << cntrl'Off = alarm_previous_period
  and INVMA()
  and REQMA3() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1926]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 575 576 585:
Theorem (575) [serial 1928] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927] 
Theorem (576) [serial 1929] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927] 
Theorem (585) [serial 1930] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1927] 


Theorem (587)                               [serial 1926] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [370] << cntrl'Off = alarm_previous_period
  and true
  and INVMA()
  and REQMA3() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 586:
Theorem (586) [serial 1927] used for:
  Law of And-Simplification:  P and true is P [serial 1926] 


Theorem (588)                               [serial 1911] 
P [313] << cntrl'Off = alarm_previous_period
  and AXIOM_OFFON()
  and EDGE_TEMP()
  and INVMA()
  and MONITOR_OK()
  and RUN() >>
S [313] ->
Q [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
Why created:    normalization of [serial 1903]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 587 587:
Theorem (587) [serial 1926] used for:
   add user-defined axioms to postcondition 
Theorem (587) [serial 1926] used for:
   add user-defined axioms to postcondition 


Theorem (589)                               [serial 1903] 
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'Off ) >>
S [313] ->
Q [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1031]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 588:
Theorem (588) [serial 1911] used for:
    normalization of [serial 1903] 


Theorem (590)                               [serial 1952] 
P [375] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_previous_period^1 = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1949]
Solved by:  Identity (id):  P->P is tautology


Theorem (591)                               [serial 1949] 
P [375] << alarm_previous_period^1 = alarm_control >>
S [310] ->
Q [302] << alarm_control^0 = alarm_previous_period^1 >>
Why created:    normalization of [serial 1947]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 590:
Theorem (590) [serial 1952] used for:
  Assume Present:  P = P@now = P^0   [serial 1949] 


Theorem (592)                               [serial 1947] 
P [375] << ( alarm_previous_period )^1 = alarm_control >>
S [310] ->
Q [302] << ( ( alarm_previous_period )^1 = alarm_control^( -1 + 1 ) ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1946]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 591:
Theorem (591) [serial 1949] used for:
    normalization of [serial 1947] 


Theorem (593)                               [serial 1946] 
P [375] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( alarm_previous_period = alarm_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1913]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 592:
Theorem (592) [serial 1947] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1946] 


Theorem (594)                               [serial 1913] 
P [375] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << INVMA()^1 >>
Why created:    normalization of [serial 1904]
Solved by:  Substitution of Assertion Labels
and theorem 593:
Theorem (593) [serial 1946] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1913] 


Theorem (595)                               [serial 1904] 
P [375] << alarm_previous_period' = alarm_control >>
S [310] ->
Q [302] << ( INVMA() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1031]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 594:
Theorem (594) [serial 1913] used for:
    normalization of [serial 1904] 


Theorem (596)                               [serial 1969] 
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372] ->
Q [39] << alarm_control^-1 = alarm_previous_period
   or REQMA1()
   or REQMA4() >>
Why created:    normalization of [serial 1967]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (597)                               [serial 1967] 
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372] ->
Q [39] << alarm_previous_period = alarm_control^-1
   or REQMA1()
   or REQMA4() >>
Why created:  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1966]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 596:
Theorem (596) [serial 1969] used for:
    normalization of [serial 1967] 


Theorem (598)                               [serial 1966] 
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372] ->
Q [39] << alarm_previous_period = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
Why created:  Guided Substitution of Equals 
 replacing "cntrl'Off" with its = "alarm_previous_period" in its postcondition [serial 1964]
Solved by:  Guided Substitution of Equals
and theorem 597:
Theorem (597) [serial 1967] used for:
  Guided Substitution of Equals 
 replacing "ALARM_CONTROL^-1" with its = "alarm_control^-1" in its postcondition [serial 1966] 


Theorem (599)                               [serial 1964] 
P [370] << ( ( CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t
   or CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F ) )
  and MONITOR_MODE(x : mmode'Normal) )
  and cntrl'Off = alarm_previous_period
  and ALARM_CONTROL^-1 = alarm_control^-1
  and alarm_control^-1 = alarm_previous_period >>
S [372] ->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
Why created:    normalization of [serial 1962]
Solved by:  Guided Substitution of Equals
and theorem 598:
Theorem (598) [serial 1966] used for:
  Guided Substitution of Equals 
 replacing "cntrl'Off" with its = "alarm_previous_period" in its postcondition [serial 1964] 


Theorem (600)                               [serial 1962] 
P [370] << cntrl'Off = alarm_previous_period
  and ( ALARM_CONTROL^-1 = alarm_control^-1 )
  and ( alarm_previous_period = alarm_control^-1 )
  and ( MONITOR_MODE(x : mmode'Normal)
  and ( CURRENT_TEMP.t in LOWER_ALARM_TEMP.t ., ( LOWER_ALARM_TEMP.t + 0.5 F )
   or CURRENT_TEMP.t in ( UPPER_ALARM_TEMP.t - 0.5 F ) ,. UPPER_ALARM_TEMP.t ) ) >>
S [372] ->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1957]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 599:
Theorem (599) [serial 1964] used for:
    normalization of [serial 1962] 


Theorem (601)                               [serial 1957] 
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372] ->
Q [39] << cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() >>
Why created:    normalization of [serial 1954]
Solved by:  Substitution of Assertion Labels
and theorem 600:
Theorem (600) [serial 1962] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1957] 


Theorem (602)                               [serial 1954] 
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372] ->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 601:
Theorem (601) [serial 1957] used for:
    normalization of [serial 1954] 


Theorem (603)                               [serial 1959] 
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372] ->
Q [39] << REQMA1()
   or REQMA3()
   or REQMA4() >>
Why created:    normalization of [serial 1955]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (604)                               [serial 1955] 
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372] ->
Q [39] << ( REQMA3()
   or REQMA1()
   or REQMA4() ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 603:
Theorem (603) [serial 1959] used for:
    normalization of [serial 1955] 


Theorem (605)                               [serial 1953] 
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372] ->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
   or REQMA1()
   or REQMA4() )
  and ( REQMA3()
   or REQMA1()
   or REQMA4() ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1915]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 602 604:
Theorem (602) [serial 1954] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953] 
Theorem (604) [serial 1955] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1953] 


Theorem (606)                               [serial 1915] 
P [370] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372] ->
Q [39] << ( cntrl'Off = ALARM_CONTROL^-1
  and REQMA3() )
   or REQMA1()
   or REQMA4() >>
Why created:    normalization of [serial 1907]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 605:
Theorem (605) [serial 1953] used for:
  Distributing Postcondition Or-Over-And [serial 1915] 


Theorem (607)                               [serial 1907] 
P [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
S [372] ->
Q [39] << REQMA1()
   or REQMA4()
   or ( REQMA3()
  and ( ALARM_CONTROL^-1 = cntrl'Off ) ) >>
Why created:  applied port output of enumeration type  alarm_control!(') [serial 1905]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 606:
Theorem (606) [serial 1915] used for:
    normalization of [serial 1907] 


Theorem (608)                               [serial 1971] 
P [372] << cntrl'Off = alarm_control
  and cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() >>
S [372] ->
Q [373] << cntrl'Off = alarm_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1925]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (609)                               [serial 1925] 
P [372] << cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3()
  and ( cntrl'Off = alarm_control )^0 >>
S [372] ->
Q [373] << cntrl'Off = alarm_control >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1917]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 608:
Theorem (608) [serial 1971] used for:
  Assume Present:  P = P@now = P^0   [serial 1925] 


Theorem (610)                               [serial 1917] 
P [372] << ( cntrl'Off = alarm_previous_period
  and AXIOM_AC()
  and INVMA()
  and REQMA3() )
  and ( cntrl'Off = alarm_control )^0 >>
S [372] ->
Q [373] << cntrl'Off = alarm_control >>
Why created:    normalization of [serial 1908]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 609:
Theorem (609) [serial 1925] used for:
  Associativity: (b.c).a = a.b.c [serial 1917] 


Theorem (611)                               [serial 1908] 
P [372] << ( REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() )
  and ( alarm_control = cntrl'Off )^0 >>
S [372] ->
Q [373] << alarm_control = cntrl'Off >>
Why created:  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1905]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 610:
Theorem (610) [serial 1917] used for:
    normalization of [serial 1908] 


Theorem (612)                               [serial 1905] 
P [370] << REQMA3()
  and AXIOM_AC()
  and ( alarm_previous_period = cntrl'Off )
  and INVMA() >>
S [372] alarm_control!(cntrl'Off)
Q [373] << alarm_control = cntrl'Off >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1031]
Solved by:  Enumeration Type Port Output 
and theorems 607 611:
Theorem (607) [serial 1907] used for:
  applied port output of enumeration type  alarm_control!(') [serial 1905] 
Theorem (611) [serial 1908] used for:
  applied port output <<pre and (alarm_control=cntrl'Off)^0>> -> <<post>> [serial 1905] 


Theorem (613)                               [serial 1919] 
P [373] << cntrl'Off = alarm_control >>
S [374] ->
Q [375] << cntrl'Off = alarm_control >>
Why created:    normalization of [serial 1909]
Solved by:  Identity (id):  P->P is tautology


Theorem (614)                               [serial 1909] 
P [373] << alarm_control = cntrl'Off >>
S [374] ->
Q [375] << ( cntrl'Off ) = alarm_control >>
Why created:  applied wp for assignment [serial 1906]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 613:
Theorem (613) [serial 1919] used for:
    normalization of [serial 1909] 


Theorem (615)                               [serial 1906] 
P [373] << alarm_control = cntrl'Off >>
S [374] alarm_previous_period' := cntrl'Off
Q [375] << alarm_previous_period' = alarm_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1031]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 614:
Theorem (614) [serial 1909] used for:
  applied wp for assignment [serial 1906] 


Theorem (616)                               [serial 1031] 
P [313] << EDGE_TEMP()
  and MONITOR_OK()
  and RUN()
  and INVMA()
  and AXIOM_OFFON()
  and ( alarm_previous_period = cntrl'Off ) >>
S [370]   << REQMA3()
    and AXIOM_AC()
    and ( alarm_previous_period = cntrl'Off )
    and INVMA() >>
  alarm_control!(cntrl'Off)
  ;
  << alarm_control = cntrl'Off >>
  alarm_previous_period' := cntrl'Off
  << alarm_previous_period' = alarm_control >> 
Q [310] << ( INVMA() )^1 >>
Why created:   <<M(check_hyst) and x>> A <<M(run)>> for maHysOff: check_hyst-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 589 595 612 615:
Theorem (589) [serial 1903] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1031] 
Theorem (595) [serial 1904] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1031] 
Theorem (612) [serial 1905] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1031] 
Theorem (615) [serial 1906] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1031] 


Theorem (617)                               [serial 1016] 
P [289] <<   >>
S [303] ->
Q [289] << manage_alarm.impl proof obligations >>
Why created:  Initial proof obligations for manage_alarm.impl
Solved by:  Component verification conditions
and theorems 287 298 299 302 322 323 324 351 377 384 426 511 521 561 616:
Theorem (287) [serial 1017] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (298) [serial 1018] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>> 
Theorem (299) [serial 1019] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>> 
Theorem (302) [serial 1020] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>> 
Theorem (322) [serial 1021] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>> 
Theorem (323) [serial 1022] used for:
   <<M(poweron)>> -> <<M(run)>> for maPo: poweron-[ ]->run{}; 
Theorem (324) [serial 1023] used for:
   <<M(run) and x>> -> <<M(check_mode)>> for maRun: run-[x]->check_mode{}; 
Theorem (351) [serial 1024] used for:
   <<M(check_mode) and x>> A <<M(run)>> for maFailed: check_mode-[x]->run{A}; 
Theorem (377) [serial 1025] used for:
   <<M(check_mode) and x>> A <<M(run)>> for maInit: check_mode-[x]->run{A}; 
Theorem (384) [serial 1026] used for:
   <<M(check_mode) and x>> -> <<M(check_temp)>> for maNormal: check_mode-[x]->check_temp{}; 
Theorem (426) [serial 1027] used for:
   <<M(check_temp) and x>> A <<M(run)>> for maOor: check_temp-[x]->run{A}; 
Theorem (511) [serial 1028] used for:
   <<M(check_temp) and x>> A <<M(run)>> for maIr: check_temp-[x]->run{A}; 
Theorem (521) [serial 1029] used for:
   <<M(check_temp) and x>> -> <<M(check_hyst)>> for maHys: check_temp-[x]->check_hyst{}; 
Theorem (561) [serial 1030] used for:
   <<M(check_hyst) and x>> A <<M(run)>> for maHysOn: check_hyst-[x]->run{A}; 
Theorem (616) [serial 1031] used for:
   <<M(check_hyst) and x>> A <<M(run)>> for maHysOff: check_hyst-[x]->run{A}; 


Theorem (618)                               [serial 1033] 
P [213] << true >>
S [204] ->
Q [204] << true >>
Why created:  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (619)                               [serial 1034] 
P [217] << RUN() >>
S [204] ->
Q [204] << true >>
Why created:  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (620)                               [serial 2548] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << true >>
Why created:    normalization of [serial 2546]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (621)                               [serial 2546] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 2545]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 620:
Theorem (620) [serial 2548] used for:
    normalization of [serial 2546] 


Theorem (622)                               [serial 2545] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2543]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 621:
Theorem (621) [serial 2546] used for:
  Law of And-Simplification:  P and P is P [serial 2545] 


Theorem (623)                               [serial 2543] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not INTERNAL_FAILURE^0 )
  and ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not REGULATOR_INTERFACE_FAILURE^0 ) >>
Why created:    normalization of [serial 2541]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 622:
Theorem (622) [serial 2545] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2543] 


Theorem (624)                               [serial 2541] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( not INTERNAL_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2539]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 623:
Theorem (623) [serial 2543] used for:
    normalization of [serial 2541] 


Theorem (625)                               [serial 2539] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 2537]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 624:
Theorem (624) [serial 2541] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2539] 


Theorem (626)                               [serial 2537] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not ( INTERNAL_FAILURE^0 )
  and not ( REGULATOR_INTERFACE_FAILURE^0 ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2535]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 625:
Theorem (625) [serial 2539] used for:
    normalization of [serial 2537] 


Theorem (627)                               [serial 2535] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
Why created:    normalization of [serial 2533]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 626:
Theorem (626) [serial 2537] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2535] 


Theorem (628)                               [serial 2533] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) ) ) >>
Why created:  Law of Or-Simplification: P or P is P [serial 2532]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 627:
Theorem (627) [serial 2535] used for:
    normalization of [serial 2533] 


Theorem (629)                               [serial 2532] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) ) ) >>
Why created:  Law of Or-Simplification: P or P is P [serial 2530]
Solved by:  Law of Or-Simplification: P or P is P
and theorem 628:
Theorem (628) [serial 2533] used for:
  Law of Or-Simplification: P or P is P [serial 2532] 


Theorem (630)                               [serial 2530] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
  and true
  and true >>
Why created:    normalization of [serial 2528]
Solved by:  Law of Or-Simplification: P or P is P
and theorem 629:
Theorem (629) [serial 2532] used for:
  Law of Or-Simplification: P or P is P [serial 2530] 


Theorem (631)                               [serial 2528] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( true )
  and ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2527]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 630:
Theorem (630) [serial 2530] used for:
    normalization of [serial 2528] 


Theorem (632)                               [serial 2527] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( true )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 2526]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 631:
Theorem (631) [serial 2528] used for:
  Associativity: (b.c).a = a.b.c [serial 2527] 


Theorem (633)                               [serial 2526] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( true )
  and ( true )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 2525]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 632:
Theorem (632) [serial 2527] used for:
  Law of And-Simplification:  P and P is P [serial 2526] 


Theorem (634)                               [serial 2525] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2524]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 633:
Theorem (633) [serial 2526] used for:
  Law of And-Simplification:  P and P is P [serial 2525] 


Theorem (635)                               [serial 2524] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
   or not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2522]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 634:
Theorem (634) [serial 2525] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2524] 


Theorem (636)                               [serial 2522] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
   or ( status'Valid = current_temperature_status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 2520]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 635:
Theorem (635) [serial 2524] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2522] 


Theorem (637)                               [serial 2520] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) )
   or ( ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2518]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 636:
Theorem (636) [serial 2522] used for:
    normalization of [serial 2520] 


Theorem (638)                               [serial 2518] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
   or ( #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
   or now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 1035]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 637:
Theorem (637) [serial 2520] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2518] 


Theorem (639)                               [serial 1035] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [215] << ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) )
   or ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>>
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 638:
Theorem (638) [serial 2518] used for:
    normalization of [serial 1035] 


Theorem (640)                               [serial 1036] 
P [212] << true >>
S [212] ->
Q [212] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (641)                               [serial 2568] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << true >>
Why created:    normalization of [serial 2566]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (642)                               [serial 2566] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 2565]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 641:
Theorem (641) [serial 2568] used for:
    normalization of [serial 2566] 


Theorem (643)                               [serial 2565] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2564]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 642:
Theorem (642) [serial 2566] used for:
  Law of And-Simplification:  P and P is P [serial 2565] 


Theorem (644)                               [serial 2564] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( not INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2562]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 643:
Theorem (643) [serial 2565] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2564] 


Theorem (645)                               [serial 2562] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 2560]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 644:
Theorem (644) [serial 2564] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2562] 


Theorem (646)                               [serial 2560] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) ) >>
Why created:  Law of Or-Simplification: P or P is P [serial 2558]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 645:
Theorem (645) [serial 2562] used for:
    normalization of [serial 2560] 


Theorem (647)                               [serial 2558] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and true >>
Why created:    normalization of [serial 2556]
Solved by:  Law of Or-Simplification: P or P is P
and theorem 646:
Theorem (646) [serial 2560] used for:
  Law of Or-Simplification: P or P is P [serial 2558] 


Theorem (648)                               [serial 2556] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( true ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2555]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 647:
Theorem (647) [serial 2558] used for:
    normalization of [serial 2556] 


Theorem (649)                               [serial 2555] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2554]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 648:
Theorem (648) [serial 2556] used for:
  Associativity: (b.c).a = a.b.c [serial 2555] 


Theorem (650)                               [serial 2554] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) )
  and ( status'Valid = current_temperature_status
   or INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2552]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 649:
Theorem (649) [serial 2555] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2554] 


Theorem (651)                               [serial 2552] 
P [219] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [219] << ( ( not INTERNAL_FAILURE^0
  and not REGULATOR_INTERFACE_FAILURE^0 )
  and status'Valid = current_temperature_status )
   or ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) ) >>
Why created:    normalization of [serial 2550]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 650:
Theorem (650) [serial 2554] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2552] 


Theorem (652)                               [serial 2550] 
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [219] ->
Q [219] << ( ( not ( REGULATOR_INTERFACE_FAILURE^0 )
  and not ( INTERNAL_FAILURE^0 ) )
  and ( current_temperature_status = status'Valid ) )
   or ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1037]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 651:
Theorem (651) [serial 2552] used for:
    normalization of [serial 2550] 


Theorem (653)                               [serial 1037] 
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [219] ->
Q [219] << ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) )
   or ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>>
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 652:
Theorem (652) [serial 2550] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1037] 


Theorem (654)                               [serial 2584] 
P [212] << true >>
S [226] ->
Q [227] << true >>
Why created:    normalization of [serial 2578]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (655)                               [serial 2578] 
P [212] << true >>
S [226] ->
Q [227] << ( ( true ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2577]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 654:
Theorem (654) [serial 2584] used for:
    normalization of [serial 2578] 


Theorem (656)                               [serial 2577] 
P [212] << true >>
S [226] ->
Q [227] << ( true )
  and true
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2575]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 655:
Theorem (655) [serial 2578] used for:
  Law of And-Simplification:  P and true is P [serial 2577] 


Theorem (657)                               [serial 2575] 
P [212] << true >>
S [226] ->
Q [227] << ( now = now )
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 656:
Theorem (656) [serial 2577] used for:
  Equality Law (idistr):  a=a <-> true [serial 2575] 


Theorem (658)                               [serial 2584] 
P [212] << true >>
S [226] ->
Q [227] << true >>
Why created:    normalization of [serial 2578]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (659)                               [serial 2578] 
P [212] << true >>
S [226] ->
Q [227] << ( ( true ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2577]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 658:
Theorem (658) [serial 2584] used for:
    normalization of [serial 2578] 


Theorem (660)                               [serial 2577] 
P [212] << true >>
S [226] ->
Q [227] << ( true )
  and true
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2575]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 659:
Theorem (659) [serial 2578] used for:
  Law of And-Simplification:  P and true is P [serial 2577] 


Theorem (661)                               [serial 2575] 
P [212] << true >>
S [226] ->
Q [227] << ( now = now )
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 660:
Theorem (660) [serial 2577] used for:
  Equality Law (idistr):  a=a <-> true [serial 2575] 


Theorem (662)                               [serial 2572] 
P [212] << true >>
S [226] ->
Q [227] << ( now = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
Why created:  applied wp for assignment [serial 2570]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 661 661:
Theorem (661) [serial 2575] used for:
   add user-defined axioms to postcondition 
Theorem (661) [serial 2575] used for:
   add user-defined axioms to postcondition 


Theorem (663)                               [serial 2570] 
P [212] << true >>
S [226] start_time := now
Q [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1038]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 662:
Theorem (662) [serial 2572] used for:
  applied wp for assignment [serial 2570] 


Theorem (664)                               [serial 2597] 
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230] ->
Q [133] << 0 < #Iso_Properties::Initialization_Timeout >>
Why created:  Remove units from quantities  [serial 2595]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (665)                               [serial 2595] 
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230] ->
Q [133] << 0 < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 2593]
Solved by:  Remove units from quantities
and theorem 664:
Theorem (664) [serial 2597] used for:
  Remove units from quantities  [serial 2595] 


Theorem (666)                               [serial 2593] 
REMAINS UNSOLVED!
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230] ->
Q [133] << start_time - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:  Guided Substitution of Equals 
 replacing "now" with its = "start_time" in its postcondition [serial 2592]
and theorem 665:
Theorem (665) [serial 2595] used for:
    normalization of [serial 2593] 


Theorem (667)                               [serial 2592] 
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230] ->
Q [133] << now - start_time < #Iso_Properties::Initialization_Timeout s >>
Why created:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2590]
Solved by:  Guided Substitution of Equals
and theorem 666:
Theorem (666) [serial 2593] used for:
  Guided Substitution of Equals 
 replacing "now" with its = "start_time" in its postcondition [serial 2592] 


Theorem (668)                               [serial 2590] 
P [227] << 0 < #Iso_Properties::Initialization_Timeout
  and START_TIME = start_time
  and now = start_time >>
S [230] ->
Q [133] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 2588]
Solved by:  Guided Substitution of Equals
and theorem 667:
Theorem (667) [serial 2592] used for:
  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2590] 


Theorem (669)                               [serial 2588] 
P [227] << now = start_time
  and ( start_time = START_TIME )
  and ( 0 < #Iso_Properties::Initialization_Timeout ) >>
S [230] ->
Q [133] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2580]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 668:
Theorem (668) [serial 2590] used for:
    normalization of [serial 2588] 


Theorem (670)                               [serial 2580] 
P [227] << now = start_time
  and AXIOM_STR()
  and AXIOM_TOGT0() >>
S [230] ->
Q [133] << INI() >>
Why created:    normalization of [serial 2573]
Solved by:  Substitution of Assertion Labels
and theorem 669:
Theorem (669) [serial 2588] used for:
  Substituted assertions' predicates for labels  [serial 2580] 


Theorem (671)                               [serial 2573] 
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230] ->
Q [133] << INI() >>
Why created:  applied port output of enumeration type  regulator_mode!(') [serial 2571]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 670:
Theorem (670) [serial 2580] used for:
    normalization of [serial 2573] 


Theorem (672)                               [serial 2582] 
P [230] << now = start_time
  and AXIOM_STR()
  and AXIOM_TOGT0()
  and ( mmode'Init = regulator_mode )^0 >>
S [230] ->
Q [302] << true >>
Why created:    normalization of [serial 2576]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (673)                               [serial 2576] 
P [230] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR()
  and ( regulator_mode = mmode'Init )^0 >>
S [230] ->
Q [302] << ( true )^1 >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2574]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 672:
Theorem (672) [serial 2582] used for:
    normalization of [serial 2576] 


Theorem (674)                               [serial 2574] 
P [230] << ( ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() )
  and ( regulator_mode = mmode'Init )^0 >>
S [230] ->
Q [302] << ( true )^1 >>
Why created:  applied port output <<pre and (regulator_mode=mmode'Init)^0>> -> <<post>> [serial 2571]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 673:
Theorem (673) [serial 2576] used for:
  Associativity: (b.c).a = a.b.c [serial 2574] 


Theorem (675)                               [serial 2571] 
P [227] << ( start_time = now )
  and AXIOM_TOGT0()
  and AXIOM_STR() >>
S [230] regulator_mode!(mmode'Init)
Q [302] << ( true )^1 >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1038]
Solved by:  Enumeration Type Port Output 
and theorems 671 674:
Theorem (671) [serial 2573] used for:
  applied port output of enumeration type  regulator_mode!(') [serial 2571] 
Theorem (674) [serial 2574] used for:
  applied port output <<pre and (regulator_mode=mmode'Init)^0>> -> <<post>> [serial 2571] 


Theorem (676)                               [serial 1038] 
P [212] << true >>
S [226]   start_time := now
  << ( start_time = now )
    and AXIOM_TOGT0()
    and AXIOM_STR() >>
  ;
  regulator_mode!(mmode'Init) 
Q [213] << ( true )^1 >>
Why created:   <<M(start)>> A <<M(init)>> for mrm1: start-[ ]->init{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 663 675:
Theorem (663) [serial 2570] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1038] 
Theorem (675) [serial 2571] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1038] 


Theorem (677)                               [serial 2605] 
P [235] << CURRENT_TEMP = temperature
  and true >>
S [235] ->
Q [235] << true >>
Why created:    normalization of [serial 2600]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (678)                               [serial 2600] 
P [235] << ( true )
  and temperature = CURRENT_TEMP >>
S [235] ->
Q [235] << true >>
Why created:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2598]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 677:
Theorem (677) [serial 2605] used for:
    normalization of [serial 2600] 


Theorem (679)                               [serial 2598] 
P [213] << true >>
S [235] current_temperature?(temperature)
Q [235] << true >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1039]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 678:
Theorem (678) [serial 2600] used for:
  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2598] 


Theorem (680)                               [serial 2609] 
P [235] << true >>
S [237] ->
Q [215] << true >>
Why created:  Law of And-Simplification:  P and true is P [serial 2608]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (681)                               [serial 2608] 
P [235] << true >>
S [237] ->
Q [215] << true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 680:
Theorem (680) [serial 2609] used for:
  Law of And-Simplification:  P and true is P [serial 2608] 


Theorem (682)                               [serial 2609] 
P [235] << true >>
S [237] ->
Q [215] << true >>
Why created:  Law of And-Simplification:  P and true is P [serial 2608]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (683)                               [serial 2608] 
P [235] << true >>
S [237] ->
Q [215] << true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 682:
Theorem (682) [serial 2609] used for:
  Law of And-Simplification:  P and true is P [serial 2608] 


Theorem (684)                               [serial 2603] 
P [235] << true >>
S [237] ->
Q [215] << AXIOM_CTSR()
  and AXIOM_STR() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2602]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 683 683:
Theorem (683) [serial 2608] used for:
   add user-defined axioms to postcondition 
Theorem (683) [serial 2608] used for:
   add user-defined axioms to postcondition 


Theorem (685)                               [serial 2602] 
P [235] << true >>
S [237] ->
Q [215] << true
  and AXIOM_CTSR()
  and AXIOM_STR() >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2601]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 684:
Theorem (684) [serial 2603] used for:
  Law of And-Simplification:  P and true is P [serial 2602] 


Theorem (686)                               [serial 2601] 
P [235] << true >>
S [237] ->
Q [215] << temperature.status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
Why created:  applied wp for assignment [serial 2599]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 685:
Theorem (685) [serial 2602] used for:
  Equality Law (idistr):  a=a <-> true [serial 2601] 


Theorem (687)                               [serial 2599] 
P [235] << true >>
S [237] current_temperature_status := temperature.status
Q [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1039]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 686:
Theorem (686) [serial 2601] used for:
  applied wp for assignment [serial 2599] 


Theorem (688)                               [serial 1039] 
P [213] << true >>
S [235]   current_temperature?(temperature)
  ;
  current_temperature_status := temperature.status 
Q [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
Why created:   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 679 687:
Theorem (679) [serial 2598] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1039] 
Theorem (687) [serial 2599] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1039] 


Theorem (689)                               [serial 2644] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (690)                               [serial 2669] 
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2668]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (691)                               [serial 2668] 
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2666]
Solved by:  Guided Substitution of Equals
and theorem 690:
Theorem (690) [serial 2669] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2668] 


Theorem (692)                               [serial 2666] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2661]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 691:
Theorem (691) [serial 2668] used for:
  Assume Present:  P = P@now = P^0   [serial 2666] 


Theorem (693)                               [serial 2661] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:    normalization of [serial 2658]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 692:
Theorem (692) [serial 2666] used for:
  Associativity: (b.c).a = a.b.c [serial 2661] 


Theorem (694)                               [serial 2658] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2653]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 693:
Theorem (693) [serial 2661] used for:
    normalization of [serial 2658] 


Theorem (695)                               [serial 2653] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2650]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 694:
Theorem (694) [serial 2658] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2653] 


Theorem (696)                               [serial 2650] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << ( not ( ( not ( REGULATOR_INTERFACE_FAILURE )
  and not ( INTERNAL_FAILURE ) ) )
   or not ( ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2648]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 695:
Theorem (695) [serial 2653] used for:
    normalization of [serial 2650] 


Theorem (697)                               [serial 2648] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2645]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 696:
Theorem (696) [serial 2650] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2648] 


Theorem (698)                               [serial 2645] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not REGULATOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]
Solved by:  Substitution of Assertion Labels
and theorem 697:
Theorem (697) [serial 2648] used for:
  Substituted assertions' predicates for labels  [serial 2645] 


Theorem (699)                               [serial 2640] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() >>
Why created:    normalization of [serial 2636]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 689 698:
Theorem (689) [serial 2644] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640] 
Theorem (698) [serial 2645] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640] 


Theorem (700)                               [serial 2636] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2635]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 699:
Theorem (699) [serial 2640] used for:
    normalization of [serial 2636] 


Theorem (701)                               [serial 2635] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2631]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 700:
Theorem (700) [serial 2636] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2635] 


Theorem (702)                               [serial 2631] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
Why created:    normalization of [serial 2626]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 701:
Theorem (701) [serial 2635] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2631] 


Theorem (703)                               [serial 2626] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2625]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 702:
Theorem (702) [serial 2631] used for:
    normalization of [serial 2626] 


Theorem (704)                               [serial 2625] 
P [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2620]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 703:
Theorem (703) [serial 2626] used for:
  Associativity: (b.c).a = a.b.c [serial 2625] 


Theorem (705)                               [serial 2620] 
P [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() )
  and true
  and true >>
Why created:    normalization of [serial 2614]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 704:
Theorem (704) [serial 2625] used for:
  Law of And-Simplification:  P and true is P [serial 2620] 


Theorem (706)                               [serial 2614] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215] ->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 705:
Theorem (705) [serial 2620] used for:
    normalization of [serial 2614] 


Theorem (707)                               [serial 2644] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (708)                               [serial 2669] 
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2668]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (709)                               [serial 2668] 
P [215] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2666]
Solved by:  Guided Substitution of Equals
and theorem 708:
Theorem (708) [serial 2669] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2668] 


Theorem (710)                               [serial 2666] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2661]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 709:
Theorem (709) [serial 2668] used for:
  Assume Present:  P = P@now = P^0   [serial 2666] 


Theorem (711)                               [serial 2661] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:    normalization of [serial 2658]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 710:
Theorem (710) [serial 2666] used for:
  Associativity: (b.c).a = a.b.c [serial 2661] 


Theorem (712)                               [serial 2658] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2653]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 711:
Theorem (711) [serial 2661] used for:
    normalization of [serial 2658] 


Theorem (713)                               [serial 2653] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2650]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 712:
Theorem (712) [serial 2658] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2653] 


Theorem (714)                               [serial 2650] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << ( not ( ( not ( REGULATOR_INTERFACE_FAILURE )
  and not ( INTERNAL_FAILURE ) ) )
   or not ( ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2648]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 713:
Theorem (713) [serial 2653] used for:
    normalization of [serial 2650] 


Theorem (715)                               [serial 2648] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2645]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 714:
Theorem (714) [serial 2650] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2648] 


Theorem (716)                               [serial 2645] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not REGULATOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640]
Solved by:  Substitution of Assertion Labels
and theorem 715:
Theorem (715) [serial 2648] used for:
  Substituted assertions' predicates for labels  [serial 2645] 


Theorem (717)                               [serial 2640] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [215] ->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() >>
Why created:    normalization of [serial 2636]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 707 716:
Theorem (707) [serial 2644] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640] 
Theorem (716) [serial 2645] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2640] 


Theorem (718)                               [serial 2636] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2635]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 717:
Theorem (717) [serial 2640] used for:
    normalization of [serial 2636] 


Theorem (719)                               [serial 2635] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2631]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 718:
Theorem (718) [serial 2636] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2635] 


Theorem (720)                               [serial 2631] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
Why created:    normalization of [serial 2626]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 719:
Theorem (719) [serial 2635] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2631] 


Theorem (721)                               [serial 2626] 
P [215] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2625]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 720:
Theorem (720) [serial 2631] used for:
    normalization of [serial 2626] 


Theorem (722)                               [serial 2625] 
P [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2620]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 721:
Theorem (721) [serial 2626] used for:
  Associativity: (b.c).a = a.b.c [serial 2625] 


Theorem (723)                               [serial 2620] 
P [215] << ( ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() )
  and true
  and true >>
Why created:    normalization of [serial 2614]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 722:
Theorem (722) [serial 2625] used for:
  Law of And-Simplification:  P and true is P [serial 2620] 


Theorem (724)                               [serial 2614] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215] ->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 723:
Theorem (723) [serial 2620] used for:
    normalization of [serial 2614] 


Theorem (725)                               [serial 2610] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [215] ->
Q [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1040]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 724 724:
Theorem (724) [serial 2614] used for:
   add user-defined axioms to postcondition 
Theorem (724) [serial 2614] used for:
   add user-defined axioms to postcondition 


Theorem (726)                               [serial 2673] 
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246] ->
Q [135] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 2671]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (727)                               [serial 2671] 
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246] ->
Q [135] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2670]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 726:
Theorem (726) [serial 2673] used for:
    normalization of [serial 2671] 


Theorem (728)                               [serial 2670] 
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2667]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 727:
Theorem (727) [serial 2671] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2670] 


Theorem (729)                               [serial 2667] 
P [244] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2663]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
and theorem 728:
Theorem (728) [serial 2670] used for:
  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2667] 


Theorem (730)                               [serial 2663] 
P [244] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 2659]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 729:
Theorem (729) [serial 2667] used for:
  Associativity: (b.c).a = a.b.c [serial 2663] 


Theorem (731)                               [serial 2659] 
P [244] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2655]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 730:
Theorem (730) [serial 2663] used for:
    normalization of [serial 2659] 


Theorem (732)                               [serial 2655] 
P [244] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s ) >>
S [246] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 2651]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 731:
Theorem (731) [serial 2659] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2655] 


Theorem (733)                               [serial 2651] 
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and ( not ( ( not ( REGULATOR_INTERFACE_FAILURE )
  and not ( INTERNAL_FAILURE ) ) )
   or not ( ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [246] ->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2649]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 732:
Theorem (732) [serial 2655] used for:
    normalization of [serial 2651] 


Theorem (734)                               [serial 2649] 
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [246] ->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2646]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 733:
Theorem (733) [serial 2651] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2649] 


Theorem (735)                               [serial 2646] 
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246] ->
Q [135] << RUN() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643]
Solved by:  Substitution of Assertion Labels
and theorem 734:
Theorem (734) [serial 2649] used for:
  Substituted assertions' predicates for labels  [serial 2646] 


Theorem (736)                               [serial 2647] 
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246] ->
Q [135] << not REGULATOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (737)                               [serial 2643] 
P [244] << not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246] ->
Q [135] << RUN()
  and not REGULATOR_OK() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2638]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 735 736:
Theorem (735) [serial 2646] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643] 
Theorem (736) [serial 2647] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2643] 


Theorem (738)                               [serial 2638] 
P [244] << ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not REGULATOR_OK() )
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [246] ->
Q [135] << RUN()
  and not REGULATOR_OK() >>
Why created:    normalization of [serial 2634]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 737:
Theorem (737) [serial 2643] used for:
  Associativity: (b.c).a = a.b.c [serial 2638] 


Theorem (739)                               [serial 2634] 
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( now - start_time < #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_OK() ) ) >>
S [246] ->
Q [135] << RUN()
  and not REGULATOR_OK() >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2616]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 738:
Theorem (738) [serial 2638] used for:
    normalization of [serial 2634] 


Theorem (740)                               [serial 2616] 
P [244] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246] ->
Q [135] << RUN()
  and not REGULATOR_OK() >>
Why created:    normalization of [serial 2612]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 739:
Theorem (739) [serial 2634] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2616] 


Theorem (741)                               [serial 2612] 
P [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [246] ->
Q [135] << not REGULATOR_OK()
  and RUN() >>
Why created:  applied port output of enumeration type  regulator_mode!(') [serial 2611]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 740:
Theorem (740) [serial 2616] used for:
    normalization of [serial 2612] 


Theorem (742)                               [serial 2629] 
P [246] << AXIOM_CTSR()
  and AXIOM_STR()
  and ( mmode'Failed = regulator_mode )^0
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) >>
S [246] ->
Q [220] << true >>
Why created:    normalization of [serial 2624]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (743)                               [serial 2624] 
P [246] << AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() )
  and ( mmode'Failed = regulator_mode )^0 >>
S [246] ->
Q [220] << true >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2618]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 742:
Theorem (742) [serial 2629] used for:
    normalization of [serial 2624] 


Theorem (744)                               [serial 2618] 
P [246] << ( AXIOM_CTSR()
  and AXIOM_STR()
  and not ( now - start_time < #Iso_Properties::Initialization_Timeout s
   or REGULATOR_OK() ) )
  and ( mmode'Failed = regulator_mode )^0 >>
S [246] ->
Q [220] << true >>
Why created:    normalization of [serial 2613]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 743:
Theorem (743) [serial 2624] used for:
  Associativity: (b.c).a = a.b.c [serial 2618] 


Theorem (745)                               [serial 2613] 
P [246] << ( not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [246] ->
Q [220] << true >>
Why created:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2611]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 744:
Theorem (744) [serial 2618] used for:
    normalization of [serial 2613] 


Theorem (746)                               [serial 2611] 
P [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [246] regulator_mode!(mmode'Failed)
Q [220] << true >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1040]
Solved by:  Enumeration Type Port Output 
and theorems 741 745:
Theorem (741) [serial 2612] used for:
  applied port output of enumeration type  regulator_mode!(') [serial 2611] 
Theorem (745) [serial 2613] used for:
  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2611] 


Theorem (747)                               [serial 1040] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [244] << not ( REGULATOR_OK()
   or ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
regulator_mode!(mmode'Failed)
Q [220] << true >>
Why created:   <<M(check_init) and x>> A <<M(failed)>> for mrm: check_init-[x]->failed{A};
Solved by:  Introduction of Existential Quantification
and theorems 725 746:
Theorem (725) [serial 2610] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1040] 
Theorem (746) [serial 2611] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1040] 


Theorem (748)                               [serial 2709] 
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [215] ->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2708]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (749)                               [serial 2708] 
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [215] ->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2706]
Solved by:  Guided Substitution of Equals
and theorem 748:
Theorem (748) [serial 2709] used for:
  Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2708] 


Theorem (750)                               [serial 2706] 
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215] ->
Q [253] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2703]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 749:
Theorem (749) [serial 2708] used for:
  Assume Present:  P = P@now = P^0   [serial 2706] 


Theorem (751)                               [serial 2703] 
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215] ->
Q [253] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2702]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 750:
Theorem (750) [serial 2706] used for:
    normalization of [serial 2703] 


Theorem (752)                               [serial 2702] 
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215] ->
Q [253] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2699]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 751:
Theorem (751) [serial 2703] used for:
  Associativity: (b.c).a = a.b.c [serial 2702] 


Theorem (753)                               [serial 2699] 
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215] ->
Q [253] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 2695]
Solved by:  Guided Substitution of Equals
and theorem 752:
Theorem (752) [serial 2702] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2699] 


Theorem (754)                               [serial 2695] 
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215] ->
Q [253] << ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2688]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 753:
Theorem (753) [serial 2699] used for:
    normalization of [serial 2695] 


Theorem (755)                               [serial 2688] 
P [215] << #Iso_Properties::Initialization_Timeout s <= now - start_time
  and status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [215] ->
Q [253] << REGULATOR_OK()
  and RUN() >>
Why created:    normalization of [serial 2681]
Solved by:  Substitution of Assertion Labels
and theorem 754:
Theorem (754) [serial 2695] used for:
  Substituted assertions' predicates for labels  [serial 2688] 


Theorem (756)                               [serial 2681] 
P [215] << ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [215] ->
Q [253] << REGULATOR_OK()
  and RUN() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2675]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 755:
Theorem (755) [serial 2688] used for:
    normalization of [serial 2681] 


Theorem (757)                               [serial 2675] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [215] ->
Q [253] << REGULATOR_OK()
  and RUN() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1041]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 756:
Theorem (756) [serial 2681] used for:
  Associativity: (b.c).a = a.b.c [serial 2675] 


Theorem (758)                               [serial 2717] 
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217] ->
Q [217] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
Why created:    normalization of [serial 2715]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (759)                               [serial 2715] 
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217] ->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2713]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 758:
Theorem (758) [serial 2717] used for:
    normalization of [serial 2715] 


Theorem (760)                               [serial 2713] 
P [255] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217] ->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
Why created:    normalization of [serial 2711]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 759:
Theorem (759) [serial 2715] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2713] 


Theorem (761)                               [serial 2711] 
P [255] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [217] ->
Q [217] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2710]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 760:
Theorem (760) [serial 2713] used for:
    normalization of [serial 2711] 


Theorem (762)                               [serial 2710] 
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [217] ->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
Why created:  Transitivity: x<y and y<z -> x<z  [serial 2697]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 761:
Theorem (761) [serial 2711] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2710] 


Theorem (763)                               [serial 2697] 
P [255] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217] ->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
Why created:    normalization of [serial 2694]
Solved by:  Transitivity: x<y and y<z -> x<z
and theorem 762:
Theorem (762) [serial 2710] used for:
  Transitivity: x<y and y<z -> x<z  [serial 2697] 


Theorem (764)                               [serial 2694] 
P [255] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [217] ->
Q [217] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2685]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 763:
Theorem (763) [serial 2697] used for:
    normalization of [serial 2694] 


Theorem (765)                               [serial 2685] 
P [255] << AXIOM_PAST_INIT()
  and RUN() >>
S [217] ->
Q [217] << RUN()^1 >>
Why created:    normalization of [serial 2676]
Solved by:  Substitution of Assertion Labels
and theorem 764:
Theorem (764) [serial 2694] used for:
  Substituted assertions' predicates for labels  [serial 2685] 


Theorem (766)                               [serial 2676] 
P [255] << RUN()
  and AXIOM_PAST_INIT() >>
S [217] ->
Q [217] << ( RUN() )^1 >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 765:
Theorem (765) [serial 2685] used for:
    normalization of [serial 2676] 


Theorem (767)                               [serial 2678] 
P [253] << REGULATOR_OK()
  and RUN() >>
S [254] ->
Q [134] << REGULATOR_OK()
  and RUN() >>
Why created:  applied port output of enumeration type  regulator_mode!(') [serial 2677]
Solved by:  Identity (id):  P->P is tautology


Theorem (768)                               [serial 2690] 
P [254] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [254] ->
Q [255] << RUN() >>
Why created:    normalization of [serial 2683]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (769)                               [serial 2683] 
P [254] << REGULATOR_OK()
  and RUN()
  and ( regulator_mode = mmode'Normal )^0 >>
S [254] ->
Q [255] << ( RUN() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2682]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 768:
Theorem (768) [serial 2690] used for:
    normalization of [serial 2683] 


Theorem (770)                               [serial 2682] 
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254] ->
Q [255] << ( RUN() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2680]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 769:
Theorem (769) [serial 2683] used for:
  Associativity: (b.c).a = a.b.c [serial 2682] 


Theorem (771)                               [serial 2680] 
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254] ->
Q [255] << RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 770:
Theorem (770) [serial 2682] used for:
  Law of And-Simplification:  P and true is P [serial 2680] 


Theorem (772)                               [serial 2690] 
P [254] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [254] ->
Q [255] << RUN() >>
Why created:    normalization of [serial 2683]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (773)                               [serial 2683] 
P [254] << REGULATOR_OK()
  and RUN()
  and ( regulator_mode = mmode'Normal )^0 >>
S [254] ->
Q [255] << ( RUN() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2682]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 772:
Theorem (772) [serial 2690] used for:
    normalization of [serial 2683] 


Theorem (774)                               [serial 2682] 
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254] ->
Q [255] << ( RUN() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2680]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 773:
Theorem (773) [serial 2683] used for:
  Associativity: (b.c).a = a.b.c [serial 2682] 


Theorem (775)                               [serial 2680] 
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254] ->
Q [255] << RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 774:
Theorem (774) [serial 2682] used for:
  Law of And-Simplification:  P and true is P [serial 2680] 


Theorem (776)                               [serial 2679] 
P [254] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [254] ->
Q [255] << RUN()
  and AXIOM_PAST_INIT() >>
Why created:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2677]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 775 775:
Theorem (775) [serial 2680] used for:
   add user-defined axioms to postcondition 
Theorem (775) [serial 2680] used for:
   add user-defined axioms to postcondition 


Theorem (777)                               [serial 2677] 
P [253] << REGULATOR_OK()
  and RUN() >>
S [254] regulator_mode!(mmode'Normal)
Q [255] << RUN()
  and AXIOM_PAST_INIT() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041]
Solved by:  Enumeration Type Port Output 
and theorems 767 776:
Theorem (767) [serial 2678] used for:
  applied port output of enumeration type  regulator_mode!(') [serial 2677] 
Theorem (776) [serial 2679] used for:
  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2677] 


Theorem (778)                               [serial 1041] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [253] << REGULATOR_OK()
  and RUN() >>
regulator_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [217] << ( RUN() )^1 >>
Why created:   <<M(check_init) and x>> A <<M(normal)>> for mrm2: check_init-[x]->normal{A};
Solved by:  Introduction of Existential Quantification
and theorems 757 766 777:
Theorem (757) [serial 2675] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1041] 
Theorem (766) [serial 2676] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041] 
Theorem (777) [serial 2677] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1041] 


Theorem (779)                               [serial 2721] 
P [215] << now - start_time < #Iso_Properties::Initialization_Timeout s
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [257] ->
Q [213] << true >>
Why created:    normalization of [serial 1042]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (780)                               [serial 1042] 
P [215] << current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( now - start_time ) < #Iso_Properties::Initialization_Timeout s ) >>
S [257] ->
Q [213] << ( true )^1 >>
Why created:   <<M(check_init) and x>> -> <<M(init)>> for mrm2x: check_init-[x]->init{};
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 779:
Theorem (779) [serial 2721] used for:
    normalization of [serial 1042] 


Theorem (781)                               [serial 2723] 
P [217] << RUN() >>
S [217] ->
Q [262] << RUN() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1043]
Solved by:  Identity (id):  P->P is tautology


Theorem (782)                               [serial 2741] 
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219] ->
Q [219] << current_temperature_status = temperature.status
  and RUN() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2736]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (783)                               [serial 2736] 
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219] ->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
Why created:    normalization of [serial 2729]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 782:
Theorem (782) [serial 2741] used for:
  Law of And-Simplification:  P and true is P [serial 2736] 


Theorem (784)                               [serial 2729] 
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219] ->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 783:
Theorem (783) [serial 2736] used for:
    normalization of [serial 2729] 


Theorem (785)                               [serial 2741] 
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219] ->
Q [219] << current_temperature_status = temperature.status
  and RUN() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2736]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (786)                               [serial 2736] 
P [266] << CURRENT_TEMP = temperature
  and current_temperature_status = temperature.status
  and RUN() >>
S [219] ->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
Why created:    normalization of [serial 2729]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 785:
Theorem (785) [serial 2741] used for:
  Law of And-Simplification:  P and true is P [serial 2736] 


Theorem (787)                               [serial 2729] 
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219] ->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 786:
Theorem (786) [serial 2736] used for:
    normalization of [serial 2729] 


Theorem (788)                               [serial 2724] 
P [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
S [219] ->
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1043]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 787 787:
Theorem (787) [serial 2729] used for:
   add user-defined axioms to postcondition 
Theorem (787) [serial 2729] used for:
   add user-defined axioms to postcondition 


Theorem (789)                               [serial 2732] 
P [263] << CURRENT_TEMP = temperature
  and RUN() >>
S [263] ->
Q [264] << CURRENT_TEMP = temperature
  and RUN() >>
Why created:    normalization of [serial 2727]
Solved by:  Identity (id):  P->P is tautology


Theorem (790)                               [serial 2727] 
P [263] << ( RUN() )
  and temperature = CURRENT_TEMP >>
S [263] ->
Q [264] << temperature = CURRENT_TEMP
  and RUN() >>
Why created:  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2725]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 789:
Theorem (789) [serial 2732] used for:
    normalization of [serial 2727] 


Theorem (791)                               [serial 2725] 
P [262] << RUN() >>
S [263] current_temperature?(temperature)
Q [264] << temperature = CURRENT_TEMP
  and RUN() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1043]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 790:
Theorem (790) [serial 2727] used for:
  applied port input of value <<pre and temperature=M(current_temperature)>> -> <<post>> [serial 2725] 


Theorem (792)                               [serial 2742] 
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265] ->
Q [266] << CURRENT_TEMP = temperature
  and RUN() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2740]
Solved by:  Identity (id):  P->P is tautology


Theorem (793)                               [serial 2740] 
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265] ->
Q [266] << CURRENT_TEMP = temperature
  and true
  and RUN() >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2734]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 792:
Theorem (792) [serial 2742] used for:
  Law of And-Simplification:  P and true is P [serial 2740] 


Theorem (794)                               [serial 2734] 
P [264] << CURRENT_TEMP = temperature
  and RUN() >>
S [265] ->
Q [266] << CURRENT_TEMP = temperature
  and temperature.status = temperature.status
  and RUN() >>
Why created:    normalization of [serial 2728]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 793:
Theorem (793) [serial 2740] used for:
  Equality Law (idistr):  a=a <-> true [serial 2734] 


Theorem (795)                               [serial 2728] 
P [264] << temperature = CURRENT_TEMP
  and RUN() >>
S [265] ->
Q [266] << ( temperature.status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
Why created:  applied wp for assignment [serial 2726]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 794:
Theorem (794) [serial 2734] used for:
    normalization of [serial 2728] 


Theorem (796)                               [serial 2726] 
P [264] << temperature = CURRENT_TEMP
  and RUN() >>
S [265] current_temperature_status := temperature.status
Q [266] << ( current_temperature_status = temperature.status )
  and ( temperature = CURRENT_TEMP )
  and RUN() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1043]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 795:
Theorem (795) [serial 2728] used for:
  applied wp for assignment [serial 2726] 


Theorem (797)                               [serial 1043] 
P [217] << RUN() >>
S [262]   << RUN() >>
  current_temperature?(temperature)
  ;
  << temperature = CURRENT_TEMP
    and RUN() >>
  current_temperature_status := temperature.status
  << ( current_temperature_status = temperature.status )
    and ( temperature = CURRENT_TEMP )
    and RUN() >> 
Q [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR() >>
Why created:   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 781 788 791 796:
Theorem (781) [serial 2723] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1043] 
Theorem (788) [serial 2724] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1043] 
Theorem (791) [serial 2725] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1043] 
Theorem (796) [serial 2726] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1043] 


Theorem (798)                               [serial 2781] 
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [219] ->
Q [273] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2780]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (799)                               [serial 2780] 
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219] ->
Q [273] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2777]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 798:
Theorem (798) [serial 2781] used for:
  Assume Present:  P = P@now = P^0   [serial 2780] 


Theorem (800)                               [serial 2777] 
P [219] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = current_temperature_status
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219] ->
Q [273] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2773]
Solved by:  Guided Substitution of Equals
and theorem 799:
Theorem (799) [serial 2780] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2777] 


Theorem (801)                               [serial 2773] 
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219] ->
Q [273] << ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2770]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 800:
Theorem (800) [serial 2777] used for:
    normalization of [serial 2773] 


Theorem (802)                               [serial 2770] 
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219] ->
Q [273] << REGULATOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765]
Solved by:  Substitution of Assertion Labels
and theorem 801:
Theorem (801) [serial 2773] used for:
  Substituted assertions' predicates for labels  [serial 2770] 


Theorem (803)                               [serial 2771] 
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219] ->
Q [273] << RUN() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (804)                               [serial 2765] 
P [219] << status'Valid = current_temperature_status
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN()
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) >>
S [219] ->
Q [273] << REGULATOR_OK()
  and RUN() >>
Why created:    normalization of [serial 2759]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 802 803:
Theorem (802) [serial 2770] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765] 
Theorem (803) [serial 2771] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2765] 


Theorem (805)                               [serial 2759] 
P [219] << status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [273] << REGULATOR_OK()
  and RUN() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2750]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 804:
Theorem (804) [serial 2765] used for:
    normalization of [serial 2759] 


Theorem (806)                               [serial 2750] 
P [219] << ( status'Valid = current_temperature_status
  and not ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0 ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [273] << REGULATOR_OK()
  and RUN() >>
Why created:    normalization of [serial 2743]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 805:
Theorem (805) [serial 2759] used for:
  Associativity: (b.c).a = a.b.c [serial 2750] 


Theorem (807)                               [serial 2743] 
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [219] ->
Q [273] << REGULATOR_OK()
  and RUN() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1044]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 806:
Theorem (806) [serial 2750] used for:
    normalization of [serial 2743] 


Theorem (808)                               [serial 2789] 
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217] ->
Q [217] << #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1 >>
Why created:    normalization of [serial 2787]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (809)                               [serial 2787] 
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217] ->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2785]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 808:
Theorem (808) [serial 2789] used for:
    normalization of [serial 2787] 


Theorem (810)                               [serial 2785] 
P [275] << now - START_TIME <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now^1 - START_TIME^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217] ->
Q [217] << #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
Why created:    normalization of [serial 2783]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 809:
Theorem (809) [serial 2787] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2785] 


Theorem (811)                               [serial 2783] 
P [275] << now - START_TIME <= ( ( now )^1 - ( START_TIME )^1 )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( ( now )^1 - ( START_TIME )^1 ) >>
S [217] ->
Q [217] << ( ( #Iso_Properties::Initialization_Timeout s )^1 <= ( now - START_TIME )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2782]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 810:
Theorem (810) [serial 2785] used for:
    normalization of [serial 2783] 


Theorem (812)                               [serial 2782] 
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and #Iso_Properties::Initialization_Timeout s <= ( now - START_TIME )^1 >>
S [217] ->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
Why created:  Transitivity: x<y and y<z -> x<z  [serial 2775]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 811:
Theorem (811) [serial 2783] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2782] 


Theorem (813)                               [serial 2775] 
P [275] << now - START_TIME <= ( now - START_TIME )^1
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
S [217] ->
Q [217] << ( #Iso_Properties::Initialization_Timeout s <= now - START_TIME )^1 >>
Why created:    normalization of [serial 2772]
Solved by:  Transitivity: x<y and y<z -> x<z
and theorem 812:
Theorem (812) [serial 2782] used for:
  Transitivity: x<y and y<z -> x<z  [serial 2775] 


Theorem (814)                               [serial 2772] 
P [275] << ( ( now - START_TIME ) <= ( now - START_TIME )^1 )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [217] ->
Q [217] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2752]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 813:
Theorem (813) [serial 2775] used for:
    normalization of [serial 2772] 


Theorem (815)                               [serial 2752] 
P [275] << AXIOM_PAST_INIT()
  and RUN() >>
S [217] ->
Q [217] << RUN()^1 >>
Why created:    normalization of [serial 2744]
Solved by:  Substitution of Assertion Labels
and theorem 814:
Theorem (814) [serial 2772] used for:
  Substituted assertions' predicates for labels  [serial 2752] 


Theorem (816)                               [serial 2744] 
P [275] << RUN()
  and AXIOM_PAST_INIT() >>
S [217] ->
Q [217] << ( RUN() )^1 >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 815:
Theorem (815) [serial 2752] used for:
    normalization of [serial 2744] 


Theorem (817)                               [serial 2746] 
P [273] << REGULATOR_OK()
  and RUN() >>
S [274] ->
Q [134] << REGULATOR_OK()
  and RUN() >>
Why created:  applied port output of enumeration type  regulator_mode!(') [serial 2745]
Solved by:  Identity (id):  P->P is tautology


Theorem (818)                               [serial 2767] 
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274] ->
Q [275] << RUN() >>
Why created:    normalization of [serial 2761]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (819)                               [serial 2761] 
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274] ->
Q [275] << ( RUN() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2760]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 818:
Theorem (818) [serial 2767] used for:
    normalization of [serial 2761] 


Theorem (820)                               [serial 2760] 
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( mmode'Normal = regulator_mode )^0 >>
S [274] ->
Q [275] << ( RUN() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2755]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 819:
Theorem (819) [serial 2761] used for:
  Associativity: (b.c).a = a.b.c [serial 2760] 


Theorem (821)                               [serial 2755] 
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( mmode'Normal = regulator_mode )^0 >>
S [274] ->
Q [275] << RUN()
  and true >>
Why created:    normalization of [serial 2748]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 820:
Theorem (820) [serial 2760] used for:
  Law of And-Simplification:  P and true is P [serial 2755] 


Theorem (822)                               [serial 2748] 
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274] ->
Q [275] << RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 821:
Theorem (821) [serial 2755] used for:
    normalization of [serial 2748] 


Theorem (823)                               [serial 2767] 
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274] ->
Q [275] << RUN() >>
Why created:    normalization of [serial 2761]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (824)                               [serial 2761] 
P [274] << REGULATOR_OK()
  and RUN()
  and ( mmode'Normal = regulator_mode )^0 >>
S [274] ->
Q [275] << ( RUN() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2760]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 823:
Theorem (823) [serial 2767] used for:
    normalization of [serial 2761] 


Theorem (825)                               [serial 2760] 
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( mmode'Normal = regulator_mode )^0 >>
S [274] ->
Q [275] << ( RUN() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2755]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 824:
Theorem (824) [serial 2761] used for:
  Associativity: (b.c).a = a.b.c [serial 2760] 


Theorem (826)                               [serial 2755] 
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( mmode'Normal = regulator_mode )^0 >>
S [274] ->
Q [275] << RUN()
  and true >>
Why created:    normalization of [serial 2748]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 825:
Theorem (825) [serial 2760] used for:
  Law of And-Simplification:  P and true is P [serial 2755] 


Theorem (827)                               [serial 2748] 
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274] ->
Q [275] << RUN()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 826:
Theorem (826) [serial 2755] used for:
    normalization of [serial 2748] 


Theorem (828)                               [serial 2747] 
P [274] << ( REGULATOR_OK()
  and RUN() )
  and ( regulator_mode = mmode'Normal )^0 >>
S [274] ->
Q [275] << RUN()
  and AXIOM_PAST_INIT() >>
Why created:  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2745]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 827 827:
Theorem (827) [serial 2748] used for:
   add user-defined axioms to postcondition 
Theorem (827) [serial 2748] used for:
   add user-defined axioms to postcondition 


Theorem (829)                               [serial 2745] 
P [273] << REGULATOR_OK()
  and RUN() >>
S [274] regulator_mode!(mmode'Normal)
Q [275] << RUN()
  and AXIOM_PAST_INIT() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044]
Solved by:  Enumeration Type Port Output 
and theorems 817 828:
Theorem (817) [serial 2746] used for:
  applied port output of enumeration type  regulator_mode!(') [serial 2745] 
Theorem (828) [serial 2747] used for:
  applied port output <<pre and (regulator_mode=mmode'Normal)^0>> -> <<post>> [serial 2745] 


Theorem (830)                               [serial 1044] 
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( not ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0 )
  and ( current_temperature_status = status'Valid ) ) >>
S [273] << REGULATOR_OK()
  and RUN() >>
regulator_mode!(mmode'Normal)
<< RUN()
  and AXIOM_PAST_INIT() >>
Q [217] << ( RUN() )^1 >>
Why created:   <<M(check_normal) and x>> A <<M(normal)>> for mrm3: check_normal-[x]->normal{A};
Solved by:  Introduction of Existential Quantification
and theorems 807 816 829:
Theorem (807) [serial 2743] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1044] 
Theorem (816) [serial 2744] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044] 
Theorem (829) [serial 2745] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1044] 


Theorem (831)                               [serial 2888] 
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2884]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (832)                               [serial 2884] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Law of Or-Simplification: P or P is P [serial 2882]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 831:
Theorem (831) [serial 2888] used for:
  Assume Present:  P = P@now = P^0   [serial 2884] 


Theorem (833)                               [serial 2882] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2879]
Solved by:  Law of Or-Simplification: P or P is P
and theorem 832:
Theorem (832) [serial 2884] used for:
  Law of Or-Simplification: P or P is P [serial 2882] 


Theorem (834)                               [serial 2879] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2876]
Solved by:  Guided Substitution of Equals
and theorem 833:
Theorem (833) [serial 2882] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2879] 


Theorem (835)                               [serial 2876] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2870]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 834:
Theorem (834) [serial 2879] used for:
  Associativity: (b.c).a = a.b.c [serial 2876] 


Theorem (836)                               [serial 2870] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 2861]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 835:
Theorem (835) [serial 2876] used for:
  Associativity: (b.c).a = a.b.c [serial 2870] 


Theorem (837)                               [serial 2861] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2855]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 836:
Theorem (836) [serial 2870] used for:
    normalization of [serial 2861] 


Theorem (838)                               [serial 2855] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 2846]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 837:
Theorem (837) [serial 2861] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2855] 


Theorem (839)                               [serial 2846] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2837]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 838:
Theorem (838) [serial 2855] used for:
    normalization of [serial 2846] 


Theorem (840)                               [serial 2837] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [281] << not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) >>
Why created:    normalization of [serial 2825]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 839:
Theorem (839) [serial 2846] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2837] 


Theorem (841)                               [serial 2825] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219] ->
Q [281] << not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2813]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 840:
Theorem (840) [serial 2837] used for:
    normalization of [serial 2825] 


Theorem (842)                               [serial 2813] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [281] << not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() >>
Why created:    normalization of [serial 2806]
Solved by:  Substitution of Assertion Labels
and theorem 841:
Theorem (841) [serial 2825] used for:
  Substituted assertions' predicates for labels  [serial 2813] 


Theorem (843)                               [serial 2806] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 842:
Theorem (842) [serial 2813] used for:
    normalization of [serial 2806] 


Theorem (844)                               [serial 2889] 
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 2885]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (845)                               [serial 2885] 
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
Why created:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2827]
Solved by:  Guided Substitution of Equals
and theorem 844:
Theorem (844) [serial 2889] used for:
  Guided Substitution of Equals 
 replacing "start_time" with its = "START_TIME" in its postcondition [serial 2885] 


Theorem (846)                               [serial 2827] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
Why created:    normalization of [serial 2820]
Solved by:  Guided Substitution of Equals
  Assume Present:  P = P@now = P^0 
and theorem 845:
Theorem (845) [serial 2885] used for:
  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2827] 


Theorem (847)                               [serial 2820] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219] ->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
Why created:  Substituted assertions' predicates for labels  [serial 2807]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 846:
Theorem (846) [serial 2827] used for:
    normalization of [serial 2820] 


Theorem (848)                               [serial 2807] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [164] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]
Solved by:  Substitution of Assertion Labels
and theorem 847:
Theorem (847) [serial 2820] used for:
  Substituted assertions' predicates for labels  [serial 2807] 


Theorem (849)                               [serial 2887] 
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [283] << true >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2883]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (850)                               [serial 2883] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [283] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2880]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 849:
Theorem (849) [serial 2887] used for:
  Assume Present:  P = P@now = P^0   [serial 2883] 


Theorem (851)                               [serial 2880] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [283] << current_temperature_status = current_temperature_status >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2829]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 850:
Theorem (850) [serial 2883] used for:
  Equality Law (idistr):  a=a <-> true [serial 2880] 


Theorem (852)                               [serial 2829] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [283] << CURRENT_TEMPERATURE_STATUS = current_temperature_status >>
Why created:    normalization of [serial 2821]
Solved by:  Guided Substitution of Equals
and theorem 851:
Theorem (851) [serial 2880] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2829] 


Theorem (853)                               [serial 2821] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219] ->
Q [283] << ( current_temperature_status = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2808]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 852:
Theorem (852) [serial 2829] used for:
    normalization of [serial 2821] 


Theorem (854)                               [serial 2808] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [283] << AXIOM_CTSR() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]
Solved by:  Substitution of Assertion Labels
and theorem 853:
Theorem (853) [serial 2821] used for:
  Substituted assertions' predicates for labels  [serial 2808] 


Theorem (855)                               [serial 2886] 
P [219] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [283] << START_TIME = start_time >>
Why created:  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2831]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (856)                               [serial 2831] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time
  and current_temperature_status = temperature.status >>
S [219] ->
Q [283] << START_TIME = start_time >>
Why created:    normalization of [serial 2822]
Solved by:  Guided Substitution of Equals
  Assume Present:  P = P@now = P^0 
and theorem 855:
Theorem (855) [serial 2886] used for:
  Guided Substitution of Equals Assume Present:  P = P@now = P^0   [serial 2831] 


Theorem (857)                               [serial 2822] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
S [219] ->
Q [283] << ( start_time = START_TIME ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2809]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 856:
Theorem (856) [serial 2831] used for:
    normalization of [serial 2822] 


Theorem (858)                               [serial 2809] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [283] << AXIOM_STR() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797]
Solved by:  Substitution of Assertion Labels
and theorem 857:
Theorem (857) [serial 2822] used for:
  Substituted assertions' predicates for labels  [serial 2809] 


Theorem (859)                               [serial 2797] 
P [219] << ( INTERNAL_FAILURE^0
   or REGULATOR_INTERFACE_FAILURE^0
   or not ( status'Valid = current_temperature_status ) )
  and current_temperature_status = temperature.status
  and AXIOM_CTSR()
  and AXIOM_STR()
  and RUN() >>
S [219] ->
Q [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
Why created:    normalization of [serial 2792]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 843 848 854 858:
Theorem (843) [serial 2806] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797] 
Theorem (848) [serial 2807] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797] 
Theorem (854) [serial 2808] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797] 
Theorem (858) [serial 2809] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2797] 


Theorem (860)                               [serial 2792] 
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [219] ->
Q [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1045]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 859:
Theorem (859) [serial 2797] used for:
    normalization of [serial 2792] 


Theorem (861)                               [serial 2890] 
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - start_time >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2877]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (862)                               [serial 2877] 
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2874]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
  Guided Substitution of Equals
and theorem 861:
Theorem (861) [serial 2890] used for:
  Guided Substitution of Equals Guided Substitution of Equals Guided Substitution of Equals 
 replacing "START_TIME" with its = "start_time" in its postcondition [serial 2877] 


Theorem (863)                               [serial 2874] 
P [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2866]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 862:
Theorem (862) [serial 2877] used for:
  Associativity: (b.c).a = a.b.c [serial 2874] 


Theorem (864)                               [serial 2866] 
P [281] << ( ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 2859]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 863:
Theorem (863) [serial 2874] used for:
  Associativity: (b.c).a = a.b.c [serial 2866] 


Theorem (865)                               [serial 2859] 
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2851]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 864:
Theorem (864) [serial 2866] used for:
    normalization of [serial 2859] 


Theorem (866)                               [serial 2851] 
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 2844]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 865:
Theorem (865) [serial 2859] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2851] 


Theorem (867)                               [serial 2844] 
P [281] << ( not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2833]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 866:
Theorem (866) [serial 2851] used for:
    normalization of [serial 2844] 


Theorem (868)                               [serial 2833] 
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << #Iso_Properties::Initialization_Timeout s <= now - START_TIME >>
Why created:    normalization of [serial 2823]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 867:
Theorem (867) [serial 2844] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2833] 


Theorem (869)                               [serial 2823] 
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [284] ->
Q [135] << ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2810]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 868:
Theorem (868) [serial 2833] used for:
    normalization of [serial 2823] 


Theorem (870)                               [serial 2810] 
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284] ->
Q [135] << RUN() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]
Solved by:  Substitution of Assertion Labels
and theorem 869:
Theorem (869) [serial 2823] used for:
  Substituted assertions' predicates for labels  [serial 2810] 


Theorem (871)                               [serial 2895] 
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Law of Or-Simplification: P or P is P [serial 2893]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (872)                               [serial 2893] 
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:    normalization of [serial 2891]
Solved by:  Law of Or-Simplification: P or P is P
and theorem 871:
Theorem (871) [serial 2895] used for:
  Law of Or-Simplification: P or P is P [serial 2893] 


Theorem (873)                               [serial 2891] 
P [281] << ( CURRENT_TEMPERATURE_STATUS = current_temperature_status )
  and ( START_TIME = start_time )
  and ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status )
   or not ( status'Valid = current_temperature_status ) )
  and ( #Iso_Properties::Initialization_Timeout s <= now - start_time ) >>
S [284] ->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Substituting Equals Within Conjunction [serial 2881]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 872:
Theorem (872) [serial 2893] used for:
    normalization of [serial 2891] 


Theorem (874)                               [serial 2881] 
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = current_temperature_status ) >>
Why created:  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
  Substituting Equals Within Conjunction
and theorem 873:
Theorem (873) [serial 2891] used for:
  Substituting Equals Within Conjunction [serial 2881] 


Theorem (875)                               [serial 2878] 
P [281] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2875]
Solved by:  Guided Substitution of Equals
and theorem 874:
Theorem (874) [serial 2881] used for:
  Guided Substitution of Equals 
 replacing "CURRENT_TEMPERATURE_STATUS" with its = "current_temperature_status" in its postcondition [serial 2878] 


Theorem (876)                               [serial 2875] 
P [281] << ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2868]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 875:
Theorem (875) [serial 2878] used for:
  Associativity: (b.c).a = a.b.c [serial 2875] 


Theorem (877)                               [serial 2868] 
P [281] << ( ( ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS ) >>
Why created:    normalization of [serial 2860]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 876:
Theorem (876) [serial 2875] used for:
  Associativity: (b.c).a = a.b.c [serial 2868] 


Theorem (878)                               [serial 2860] 
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or ( not ( not INTERNAL_FAILURE )
   or not ( not REGULATOR_INTERFACE_FAILURE ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2853]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Complement
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 877:
Theorem (877) [serial 2868] used for:
    normalization of [serial 2860] 


Theorem (879)                               [serial 2853] 
P [281] << ( ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) )
   or not ( status'Valid = current_temperature_status ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( not INTERNAL_FAILURE
  and not REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2845]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 878:
Theorem (878) [serial 2860] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 2853] 


Theorem (880)                               [serial 2845] 
P [281] << ( not ( status'Valid = current_temperature_status )
   or ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << ( not ( status'Valid = CURRENT_TEMPERATURE_STATUS )
   or not ( ( not ( INTERNAL_FAILURE )
  and not ( REGULATOR_INTERFACE_FAILURE ) ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2835]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 879:
Theorem (879) [serial 2853] used for:
    normalization of [serial 2845] 


Theorem (881)                               [serial 2835] 
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and CURRENT_TEMPERATURE_STATUS = current_temperature_status
  and START_TIME = start_time >>
S [284] ->
Q [135] << not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) >>
Why created:    normalization of [serial 2824]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 880:
Theorem (880) [serial 2845] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 2835] 


Theorem (882)                               [serial 2824] 
P [281] << ( not ( status'Valid = current_temperature_status )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and ( current_temperature_status = CURRENT_TEMPERATURE_STATUS )
  and ( start_time = START_TIME ) >>
S [284] ->
Q [135] << not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2811]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 881:
Theorem (881) [serial 2835] used for:
    normalization of [serial 2824] 


Theorem (883)                               [serial 2811] 
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284] ->
Q [135] << not REGULATOR_OK() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799]
Solved by:  Substitution of Assertion Labels
and theorem 882:
Theorem (882) [serial 2824] used for:
  Substituted assertions' predicates for labels  [serial 2811] 


Theorem (884)                               [serial 2799] 
P [281] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() >>
S [284] ->
Q [135] << RUN()
  and not REGULATOR_OK() >>
Why created:    normalization of [serial 2794]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 870 883:
Theorem (870) [serial 2810] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799] 
Theorem (883) [serial 2811] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2799] 


Theorem (885)                               [serial 2794] 
P [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [284] ->
Q [135] << not REGULATOR_OK()
  and RUN() >>
Why created:  applied port output of enumeration type  regulator_mode!(') [serial 2793]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 884:
Theorem (884) [serial 2799] used for:
    normalization of [serial 2794] 


Theorem (886)                               [serial 2805] 
P [284] << ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( mmode'Failed = regulator_mode )^0 >>
S [284] ->
Q [220] << true >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2801]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (887)                               [serial 2801] 
P [284] << ( ( not ( status'Valid = current_temperature_status )
   or not REGULATOR_OK() )
  and #Iso_Properties::Initialization_Timeout s <= now - start_time
  and AXIOM_CTSR()
  and AXIOM_STR() )
  and ( mmode'Failed = regulator_mode )^0 >>
S [284] ->
Q [220] << true >>
Why created:    normalization of [serial 2795]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 886:
Theorem (886) [serial 2805] used for:
  Associativity: (b.c).a = a.b.c [serial 2801] 


Theorem (888)                               [serial 2795] 
P [284] << ( ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() )
  and ( regulator_mode = mmode'Failed )^0 >>
S [284] ->
Q [220] << true >>
Why created:  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2793]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 887:
Theorem (887) [serial 2801] used for:
    normalization of [serial 2795] 


Theorem (889)                               [serial 2793] 
P [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
S [284] regulator_mode!(mmode'Failed)
Q [220] << true >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1045]
Solved by:  Enumeration Type Port Output 
and theorems 885 888:
Theorem (885) [serial 2794] used for:
  applied port output of enumeration type  regulator_mode!(') [serial 2793] 
Theorem (888) [serial 2795] used for:
  applied port output <<pre and (regulator_mode=mmode'Failed)^0>> -> <<post>> [serial 2793] 


Theorem (890)                               [serial 1045] 
P [219] << current_temperature_status = temperature.status
  and RUN()
  and AXIOM_CTSR()
  and AXIOM_STR()
  and ( ( REGULATOR_INTERFACE_FAILURE^0
   or INTERNAL_FAILURE^0
   or not ( current_temperature_status = status'Valid ) ) ) >>
S [281] << ( not REGULATOR_OK()
   or not ( current_temperature_status = status'Valid ) )
  and ( ( now - start_time ) >= #Iso_Properties::Initialization_Timeout s )
  and AXIOM_STR()
  and AXIOM_CTSR() >>
regulator_mode!(mmode'Failed)
Q [220] << true >>
Why created:   <<M(check_normal) and x>> A <<M(failed)>> for mrm3x: check_normal-[x]->failed{A};
Solved by:  Introduction of Existential Quantification
and theorems 860 889:
Theorem (860) [serial 2792] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1045] 
Theorem (889) [serial 2793] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1045] 


Theorem (891)                               [serial 1032] 
P [204] <<   >>
S [204] ->
Q [204] << manage_regulator_mode.impl proof obligations >>
Why created:  Initial proof obligations for manage_regulator_mode.impl
Solved by:  Component verification conditions
and theorems 618 619 639 640 653 676 688 747 778 780 797 830 890:
Theorem (618) [serial 1033] used for:
  <<M(init)>> -> <<I>> from invariant I when complete state init has Assertion <<M(init)>> in its definition. 
Theorem (619) [serial 1034] used for:
  <<M(normal)>> -> <<I>> from invariant I when complete state normal has Assertion <<M(normal)>> in its definition. 
Theorem (639) [serial 1035] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_init, <<M(check_init)>> -> <<e1 or e2 or . . . en>> 
Theorem (640) [serial 1036] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (653) [serial 1037] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_normal, <<M(check_normal)>> -> <<e1 or e2 or . . . en>> 
Theorem (676) [serial 1038] used for:
   <<M(start)>> A <<M(init)>> for mrm1: start-[ ]->init{A}; 
Theorem (688) [serial 1039] used for:
   <<M(init) and x>> A <<M(check_init)>> for wait_init: init-[x]->check_init{A}; 
Theorem (747) [serial 1040] used for:
   <<M(check_init) and x>> A <<M(failed)>> for mrm: check_init-[x]->failed{A}; 
Theorem (778) [serial 1041] used for:
   <<M(check_init) and x>> A <<M(normal)>> for mrm2: check_init-[x]->normal{A}; 
Theorem (780) [serial 1042] used for:
   <<M(check_init) and x>> -> <<M(init)>> for mrm2x: check_init-[x]->init{}; 
Theorem (797) [serial 1043] used for:
   <<M(normal) and x>> A <<M(check_normal)>> for wait_normal: normal-[x]->check_normal{A}; 
Theorem (830) [serial 1044] used for:
   <<M(check_normal) and x>> A <<M(normal)>> for mrm3: check_normal-[x]->normal{A}; 
Theorem (890) [serial 1045] used for:
   <<M(check_normal) and x>> A <<M(failed)>> for mrm3x: check_normal-[x]->failed{A}; 


Theorem (892)                               [serial 1974] 
P [341] << heat_control^-1 = heat_previous_period >>
S [336] ->
Q [336] << heat_control^-1 = heat_previous_period >>
Why created:    normalization of [serial 1972]
Solved by:  Identity (id):  P->P is tautology


Theorem (893)                               [serial 1972] 
P [341] << ( heat_previous_period = heat_control^-1 ) >>
S [336] ->
Q [336] << heat_previous_period = heat_control^-1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1047]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 892:
Theorem (892) [serial 1974] used for:
    normalization of [serial 1972] 


Theorem (894)                               [serial 1047] 
P [341] << INVMHS() >>
S [336] ->
Q [336] << heat_previous_period = heat_control^-1 >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by:  Substitution of Assertion Labels
and theorem 893:
Theorem (893) [serial 1972] used for:
  Substituted assertions' predicates for labels  [serial 1047] 


Theorem (895)                               [serial 1984] 
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [343] << true >>
Why created:    normalization of [serial 1982]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (896)                               [serial 1982] 
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [343] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1981]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 895:
Theorem (895) [serial 1984] used for:
    normalization of [serial 1982] 


Theorem (897)                               [serial 1981] 
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [343] << ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1980]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 896:
Theorem (896) [serial 1982] used for:
  Law of And-Simplification:  P and P is P [serial 1981] 


Theorem (898)                               [serial 1980] 
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) )
  and ( lower_desired_temperature.t < current_temperature.t
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1979]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 897:
Theorem (897) [serial 1981] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1980] 


Theorem (899)                               [serial 1979] 
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
   or ( not ( lower_desired_temperature.t < current_temperature.t ) )
   or ( not ( current_temperature.t < upper_desired_temperature.t ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1977]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 898:
Theorem (898) [serial 1980] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1979] 


Theorem (900)                               [serial 1977] 
P [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
   or current_temperature.t <= lower_desired_temperature.t
   or upper_desired_temperature.t <= current_temperature.t >>
Why created:    normalization of [serial 1048]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 899:
Theorem (899) [serial 1979] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1977] 


Theorem (901)                               [serial 1048] 
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT() >>
S [343] ->
Q [343] << ( current_temperature.t <= lower_desired_temperature.t )
   or ( current_temperature.t >= upper_desired_temperature.t )
   or ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>
Solved by:  Irreflexivity of Greater Than: (a>b) = (b<a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 900:
Theorem (900) [serial 1977] used for:
    normalization of [serial 1048] 


Theorem (902)                               [serial 1049] 
P [340] << heat_previous_period = cntrl'Off
  and ( INVMHS() )^1 >>
S [340] ->
Q [340] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (903)                               [serial 1988] 
P [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [344] << cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period >>
Why created:    normalization of [serial 1986]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (904)                               [serial 1986] 
P [344] << ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = heat_control^-1 )
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off ) >>
S [344] ->
Q [344] << ( ( heat_previous_period = cntrl'O_n ) )
   or ( heat_previous_period = cntrl'Off ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1050]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 903:
Theorem (903) [serial 1988] used for:
    normalization of [serial 1986] 


Theorem (905)                               [serial 1050] 
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT() >>
S [344] ->
Q [344] << ( ( heat_previous_period = cntrl'O_n ) )
   or ( heat_previous_period = cntrl'Off ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>
Solved by:  Substitution of Assertion Labels
and theorem 904:
Theorem (904) [serial 1986] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1050] 


Theorem (906)                               [serial 2012] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << true >>
Why created:    normalization of [serial 2010]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (907)                               [serial 2010] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 2009]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 906:
Theorem (906) [serial 2012] used for:
    normalization of [serial 2010] 


Theorem (908)                               [serial 2009] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 2008]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 907:
Theorem (907) [serial 2010] used for:
  Law of And-Simplification:  P and P is P [serial 2009] 


Theorem (909)                               [serial 2008] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2007]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 908:
Theorem (908) [serial 2009] used for:
  Law of And-Simplification:  P and P is P [serial 2008] 


Theorem (910)                               [serial 2007] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2005]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 909:
Theorem (909) [serial 2008] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2007] 


Theorem (911)                               [serial 2005] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
   or now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( now - START_TIME < #Iso_Properties::Initialization_Timeout s
   or #Iso_Properties::Initialization_Timeout s <= now - START_TIME
   or not ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) ) ) >>
Why created:    normalization of [serial 2003]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 910:
Theorem (910) [serial 2007] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2005] 


Theorem (912)                               [serial 2003] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
  and ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) )
  and ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
   or ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
   or not ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2002]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 911:
Theorem (911) [serial 2005] used for:
    normalization of [serial 2003] 


Theorem (913)                               [serial 2002] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2000]
Solved by:  Substitution of Assertion Labels
and theorem 912:
Theorem (912) [serial 2003] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2002] 


Theorem (914)                               [serial 2000] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() )
  and true >>
Why created:    normalization of [serial 1998]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 913:
Theorem (913) [serial 2002] used for:
  Law of And-Simplification:  P and true is P [serial 2000] 


Theorem (915)                               [serial 1998] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( true )
  and ( INI()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
Why created:  Law of Or-Simplification: P or P is P [serial 1997]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 914:
Theorem (914) [serial 2000] used for:
    normalization of [serial 1998] 


Theorem (916)                               [serial 1997] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( true )
  and ( INI()
   or RUN()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1995]
Solved by:  Law of Or-Simplification: P or P is P
and theorem 915:
Theorem (915) [serial 1998] used for:
  Law of Or-Simplification: P or P is P [serial 1997] 


Theorem (917)                               [serial 1995] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( INI()
   or REGULATOR_OK()
   or RUN() )
  and ( INI()
   or REGULATOR_OK()
   or not REGULATOR_OK() )
  and ( INI()
   or RUN()
   or RUN() )
  and ( INI()
   or RUN()
   or not REGULATOR_OK() ) >>
Why created:    normalization of [serial 1993]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 916:
Theorem (916) [serial 1997] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1995] 


Theorem (918)                               [serial 1993] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( REGULATOR_OK()
   or RUN()
   or INI() )
  and ( RUN()
   or RUN()
   or INI() )
  and ( REGULATOR_OK()
   or not REGULATOR_OK()
   or INI() )
  and ( RUN()
   or not REGULATOR_OK()
   or INI() ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1991]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 917:
Theorem (917) [serial 1995] used for:
    normalization of [serial 1993] 


Theorem (919)                               [serial 1991] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( REGULATOR_OK()
  and RUN() )
   or ( RUN()
  and not REGULATOR_OK() )
   or INI() >>
Why created:    normalization of [serial 1051]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 918:
Theorem (918) [serial 1993] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1991] 


Theorem (920)                               [serial 1051] 
P [342] << INVMHS() >>
S [342] ->
Q [342] << ( not REGULATOR_OK()
  and RUN() )
   or ( INI() )
   or ( REGULATOR_OK()
  and RUN() ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 919:
Theorem (919) [serial 1991] used for:
    normalization of [serial 1051] 


Theorem (921)                               [serial 1052] 
P [340] << heat_previous_period = cntrl'Off
  and ( INVMHS() )^1 >>
S [347] ->
Q [341] << ( INVMHS() )^1 >>
Why created:   <<M(poweron)>> -> <<M(run)>> for mhsPo: poweron-[ ]->run{};
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (922)                               [serial 1053] 
P [341] << INVMHS() >>
S [348] ->
Q [342] << INVMHS() >>
Why created:   <<M(run) and x>> -> <<M(check_mode)>> for mhsRun: run-[x]->check_mode{};
Solved by:  Identity (id):  P->P is tautology


Theorem (923)                               [serial 2060] 
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342] ->
Q [351] << RUN()
  and not REGULATOR_OK() >>
Why created:    normalization of [serial 2058]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (924)                               [serial 2058] 
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342] ->
Q [351] << ( not REGULATOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2051]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 923:
Theorem (923) [serial 2060] used for:
    normalization of [serial 2058] 


Theorem (925)                               [serial 2051] 
P [342] << INVMHS()
  and RUN()
  and not REGULATOR_OK() >>
S [342] ->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
Why created:    normalization of [serial 2047]
Solved by:  Substitution of Assertion Labels
and theorem 924:
Theorem (924) [serial 2058] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2051] 


Theorem (926)                               [serial 2047] 
P [342] << RUN()
  and not REGULATOR_OK()
  and INVMHS() >>
S [342] ->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2042]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 925:
Theorem (925) [serial 2051] used for:
    normalization of [serial 2047] 


Theorem (927)                               [serial 2042] 
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342] ->
Q [351] << REGULATOR_MODE(x : mmode'Failed) >>
Why created:    normalization of [serial 2038]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 926:
Theorem (926) [serial 2047] used for:
  Associativity: (b.c).a = a.b.c [serial 2042] 


Theorem (928)                               [serial 2038] 
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342] ->
Q [351] << ( REGULATOR_MODE(x : mmode'Failed) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2024]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 927:
Theorem (927) [serial 2042] used for:
    normalization of [serial 2038] 


Theorem (929)                               [serial 2024] 
P [342] << ( RUN()
  and not REGULATOR_OK() )
  and INVMHS() >>
S [342] ->
Q [351] << REQMHS5() >>
Why created:    normalization of [serial 2014]
Solved by:  Substitution of Assertion Labels
and theorem 928:
Theorem (928) [serial 2038] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2024] 


Theorem (930)                               [serial 2014] 
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [342] ->
Q [351] << REQMHS5() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1054]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 929:
Theorem (929) [serial 2024] used for:
    normalization of [serial 2014] 


Theorem (931)                               [serial 2057] 
P [355] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_previous_period^1 = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2053]
Solved by:  Identity (id):  P->P is tautology


Theorem (932)                               [serial 2053] 
P [355] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_control^0 = heat_previous_period^1 >>
Why created:    normalization of [serial 2048]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 931:
Theorem (931) [serial 2057] used for:
  Assume Present:  P = P@now = P^0   [serial 2053] 


Theorem (933)                               [serial 2048] 
P [355] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2044]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 932:
Theorem (932) [serial 2053] used for:
    normalization of [serial 2048] 


Theorem (934)                               [serial 2044] 
P [355] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
Why created:    normalization of [serial 2039]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 933:
Theorem (933) [serial 2048] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2044] 


Theorem (935)                               [serial 2039] 
P [355] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2030]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 934:
Theorem (934) [serial 2044] used for:
    normalization of [serial 2039] 


Theorem (936)                               [serial 2030] 
P [355] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:    normalization of [serial 2021]
Solved by:  Substitution of Assertion Labels
and theorem 935:
Theorem (935) [serial 2039] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2030] 


Theorem (937)                               [serial 2021] 
P [355] << ( heat_previous_period )^1 = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2015]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 936:
Theorem (936) [serial 2030] used for:
    normalization of [serial 2021] 


Theorem (938)                               [serial 2015] 
P [355] << heat_previous_period' = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1054]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 937:
Theorem (937) [serial 2021] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2015] 


Theorem (939)                               [serial 2026] 
P [351] << REQMHS5() >>
S [352] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
Why created:    normalization of [serial 2018]
Solved by:  Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (940)                               [serial 2018] 
P [351] << REQMHS5() >>
S [352] ->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
Why created:  applied port output of enumeration type  heat_control!(') [serial 2016]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 939:
Theorem (939) [serial 2026] used for:
    normalization of [serial 2018] 


Theorem (941)                               [serial 2056] 
P [352] << cntrl'Off = heat_control
  and REQMHS5() >>
S [352] ->
Q [353] << cntrl'Off = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2032]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (942)                               [serial 2032] 
P [352] << cntrl'Off^0 = heat_control^0
  and REQMHS5() >>
S [352] ->
Q [353] << cntrl'Off = heat_control >>
Why created:    normalization of [serial 2022]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 941:
Theorem (941) [serial 2056] used for:
  Assume Present:  P = P@now = P^0   [serial 2032] 


Theorem (943)                               [serial 2022] 
P [352] << ( REQMHS5() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [352] ->
Q [353] << heat_control = cntrl'Off >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2019]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 942:
Theorem (942) [serial 2032] used for:
    normalization of [serial 2022] 


Theorem (944)                               [serial 2019] 
P [352] << ( REQMHS5() )
  and ( heat_control = cntrl'Off )^0 >>
S [352] ->
Q [353] << heat_control = cntrl'Off >>
Why created:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2016]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 943:
Theorem (943) [serial 2022] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2019] 


Theorem (945)                               [serial 2016] 
P [351] << REQMHS5() >>
S [352] heat_control!(cntrl'Off)
Q [353] << heat_control = cntrl'Off >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1054]
Solved by:  Enumeration Type Port Output 
and theorems 940 944:
Theorem (940) [serial 2018] used for:
  applied port output of enumeration type  heat_control!(') [serial 2016] 
Theorem (944) [serial 2019] used for:
  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2016] 


Theorem (946)                               [serial 2028] 
P [353] << cntrl'Off = heat_control >>
S [354] ->
Q [355] << cntrl'Off = heat_control >>
Why created:    normalization of [serial 2020]
Solved by:  Identity (id):  P->P is tautology


Theorem (947)                               [serial 2020] 
P [353] << heat_control = cntrl'Off >>
S [354] ->
Q [355] << ( cntrl'Off ) = heat_control >>
Why created:  applied wp for assignment [serial 2017]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 946:
Theorem (946) [serial 2028] used for:
    normalization of [serial 2020] 


Theorem (948)                               [serial 2017] 
P [353] << heat_control = cntrl'Off >>
S [354] heat_previous_period' := cntrl'Off
Q [355] << heat_previous_period' = heat_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1054]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 947:
Theorem (947) [serial 2020] used for:
  applied wp for assignment [serial 2017] 


Theorem (949)                               [serial 1054] 
P [342] << ( INVMHS() )
  and ( not REGULATOR_OK()
  and RUN() ) >>
S [351]   << REQMHS5() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
Why created:   <<M(check_mode) and x>> A <<M(run)>> for mhsFailed: check_mode-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 930 938 945 948:
Theorem (930) [serial 2014] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1054] 
Theorem (938) [serial 2015] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1054] 
Theorem (945) [serial 2016] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1054] 
Theorem (948) [serial 2017] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1054] 


Theorem (950)                               [serial 2112] 
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342] ->
Q [359] << now - START_TIME < #Iso_Properties::Initialization_Timeout s >>
Why created:    normalization of [serial 2110]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (951)                               [serial 2110] 
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342] ->
Q [359] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2106]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 950:
Theorem (950) [serial 2112] used for:
    normalization of [serial 2110] 


Theorem (952)                               [serial 2106] 
P [342] << now - START_TIME < #Iso_Properties::Initialization_Timeout s
  and heat_control^-1 = heat_previous_period >>
S [342] ->
Q [359] << INI() >>
Why created:    normalization of [serial 2102]
Solved by:  Substitution of Assertion Labels
and theorem 951:
Theorem (951) [serial 2110] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2106] 


Theorem (953)                               [serial 2102] 
P [342] << ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s )
  and ( heat_previous_period = heat_control^-1 ) >>
S [342] ->
Q [359] << ( INI() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2090]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 952:
Theorem (952) [serial 2106] used for:
    normalization of [serial 2102] 


Theorem (954)                               [serial 2090] 
P [342] << INI()
  and INVMHS() >>
S [342] ->
Q [359] << REGULATOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 2086]
Solved by:  Substitution of Assertion Labels
and theorem 953:
Theorem (953) [serial 2102] used for:
  Substituted assertions' predicates for labels  [serial 2090] 


Theorem (955)                               [serial 2086] 
P [342] << INI()
  and INVMHS() >>
S [342] ->
Q [359] << ( REGULATOR_MODE(x : mmode'Init) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2072]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 954:
Theorem (954) [serial 2090] used for:
    normalization of [serial 2086] 


Theorem (956)                               [serial 2072] 
P [342] << INI()
  and INVMHS() >>
S [342] ->
Q [359] << REQMHS1() >>
Why created:    normalization of [serial 2062]
Solved by:  Substitution of Assertion Labels
and theorem 955:
Theorem (955) [serial 2086] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2072] 


Theorem (957)                               [serial 2062] 
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [342] ->
Q [359] << REQMHS1() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1055]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 956:
Theorem (956) [serial 2072] used for:
    normalization of [serial 2062] 


Theorem (958)                               [serial 2103] 
P [363] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_previous_period^1 = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2099]
Solved by:  Identity (id):  P->P is tautology


Theorem (959)                               [serial 2099] 
P [363] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_control^0 = heat_previous_period^1 >>
Why created:    normalization of [serial 2095]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 958:
Theorem (958) [serial 2103] used for:
  Assume Present:  P = P@now = P^0   [serial 2099] 


Theorem (960)                               [serial 2095] 
P [363] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2092]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 959:
Theorem (959) [serial 2099] used for:
    normalization of [serial 2095] 


Theorem (961)                               [serial 2092] 
P [363] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
Why created:    normalization of [serial 2087]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 960:
Theorem (960) [serial 2095] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2092] 


Theorem (962)                               [serial 2087] 
P [363] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2078]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 961:
Theorem (961) [serial 2092] used for:
    normalization of [serial 2087] 


Theorem (963)                               [serial 2078] 
P [363] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:    normalization of [serial 2069]
Solved by:  Substitution of Assertion Labels
and theorem 962:
Theorem (962) [serial 2087] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2078] 


Theorem (964)                               [serial 2069] 
P [363] << ( heat_previous_period )^1 = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2063]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 963:
Theorem (963) [serial 2078] used for:
    normalization of [serial 2069] 


Theorem (965)                               [serial 2063] 
P [363] << heat_previous_period' = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1055]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 964:
Theorem (964) [serial 2069] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2063] 


Theorem (966)                               [serial 2074] 
P [359] << REQMHS1() >>
S [360] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
Why created:    normalization of [serial 2066]
Solved by:  Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (967)                               [serial 2066] 
P [359] << REQMHS1() >>
S [360] ->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
Why created:  applied port output of enumeration type  heat_control!(') [serial 2064]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 966:
Theorem (966) [serial 2074] used for:
    normalization of [serial 2066] 


Theorem (968)                               [serial 2104] 
P [360] << cntrl'Off = heat_control
  and REGULATOR_MODE(x : mmode'Init) >>
S [360] ->
Q [361] << cntrl'Off = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2101]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (969)                               [serial 2101] 
P [360] << cntrl'Off^0 = heat_control^0
  and ( REGULATOR_MODE(x : mmode'Init) ) >>
S [360] ->
Q [361] << cntrl'Off = heat_control >>
Why created:  Substituted assertions' predicates for labels  [serial 2080]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 968:
Theorem (968) [serial 2104] used for:
  Assume Present:  P = P@now = P^0   [serial 2101] 


Theorem (970)                               [serial 2080] 
P [360] << cntrl'Off^0 = heat_control^0
  and REQMHS1() >>
S [360] ->
Q [361] << cntrl'Off = heat_control >>
Why created:    normalization of [serial 2070]
Solved by:  Substitution of Assertion Labels
and theorem 969:
Theorem (969) [serial 2101] used for:
  Substituted assertions' predicates for labels  [serial 2080] 


Theorem (971)                               [serial 2070] 
P [360] << ( REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [360] ->
Q [361] << heat_control = cntrl'Off >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2067]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 970:
Theorem (970) [serial 2080] used for:
    normalization of [serial 2070] 


Theorem (972)                               [serial 2067] 
P [360] << ( REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [360] ->
Q [361] << heat_control = cntrl'Off >>
Why created:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2064]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 971:
Theorem (971) [serial 2070] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2067] 


Theorem (973)                               [serial 2064] 
P [359] << REQMHS1() >>
S [360] heat_control!(cntrl'Off)
Q [361] << heat_control = cntrl'Off >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1055]
Solved by:  Enumeration Type Port Output 
and theorems 967 972:
Theorem (967) [serial 2066] used for:
  applied port output of enumeration type  heat_control!(') [serial 2064] 
Theorem (972) [serial 2067] used for:
  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2064] 


Theorem (974)                               [serial 2076] 
P [361] << cntrl'Off = heat_control >>
S [362] ->
Q [363] << cntrl'Off = heat_control >>
Why created:    normalization of [serial 2068]
Solved by:  Identity (id):  P->P is tautology


Theorem (975)                               [serial 2068] 
P [361] << heat_control = cntrl'Off >>
S [362] ->
Q [363] << ( cntrl'Off ) = heat_control >>
Why created:  applied wp for assignment [serial 2065]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 974:
Theorem (974) [serial 2076] used for:
    normalization of [serial 2068] 


Theorem (976)                               [serial 2065] 
P [361] << heat_control = cntrl'Off >>
S [362] heat_previous_period' := cntrl'Off
Q [363] << heat_previous_period' = heat_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1055]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 975:
Theorem (975) [serial 2068] used for:
  applied wp for assignment [serial 2065] 


Theorem (977)                               [serial 1055] 
P [342] << ( INVMHS() )
  and ( INI() ) >>
S [359]   << REQMHS1() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
Why created:   <<M(check_mode) and x>> A <<M(run)>> for mhsInit: check_mode-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 957 965 973 976:
Theorem (957) [serial 2062] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1055] 
Theorem (965) [serial 2063] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1055] 
Theorem (973) [serial 2064] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1055] 
Theorem (976) [serial 2065] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1055] 


Theorem (978)                               [serial 2120] 
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365] ->
Q [343] << INVMHS() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (979)                               [serial 2124] 
P [342] << INVMHS()
  and REGULATOR_OK()
  and RUN() >>
S [365] ->
Q [343] << REGULATOR_OK()
  and RUN() >>
Why created:    normalization of [serial 2122]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (980)                               [serial 2122] 
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365] ->
Q [343] << ( REGULATOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2121]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 979:
Theorem (979) [serial 2124] used for:
    normalization of [serial 2122] 


Theorem (981)                               [serial 2121] 
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365] ->
Q [343] << REGULATOR_MODE(x : mmode'Normal) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]
Solved by:  Substitution of Assertion Labels
and theorem 980:
Theorem (980) [serial 2122] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2121] 


Theorem (982)                               [serial 2119] 
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365] ->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2118]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 978 981:
Theorem (978) [serial 2120] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119] 
Theorem (981) [serial 2121] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119] 


Theorem (983)                               [serial 2118] 
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365] ->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2117]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 982:
Theorem (982) [serial 2119] used for:
  Associativity: (b.c).a = a.b.c [serial 2118] 


Theorem (984)                               [serial 2117] 
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365] ->
Q [343] << true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 983:
Theorem (983) [serial 2118] used for:
  Law of And-Simplification:  P and true is P [serial 2117] 


Theorem (985)                               [serial 2120] 
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365] ->
Q [343] << INVMHS() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (986)                               [serial 2124] 
P [342] << INVMHS()
  and REGULATOR_OK()
  and RUN() >>
S [365] ->
Q [343] << REGULATOR_OK()
  and RUN() >>
Why created:    normalization of [serial 2122]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (987)                               [serial 2122] 
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365] ->
Q [343] << ( REGULATOR_OK()
  and RUN() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2121]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 986:
Theorem (986) [serial 2124] used for:
    normalization of [serial 2122] 


Theorem (988)                               [serial 2121] 
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365] ->
Q [343] << REGULATOR_MODE(x : mmode'Normal) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119]
Solved by:  Substitution of Assertion Labels
and theorem 987:
Theorem (987) [serial 2122] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2121] 


Theorem (989)                               [serial 2119] 
P [342] << REGULATOR_OK()
  and RUN()
  and INVMHS() >>
S [365] ->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2118]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 985 988:
Theorem (985) [serial 2120] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119] 
Theorem (988) [serial 2121] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2119] 


Theorem (990)                               [serial 2118] 
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365] ->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2117]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 989:
Theorem (989) [serial 2119] used for:
  Associativity: (b.c).a = a.b.c [serial 2118] 


Theorem (991)                               [serial 2117] 
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365] ->
Q [343] << true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 990:
Theorem (990) [serial 2118] used for:
  Law of And-Simplification:  P and true is P [serial 2117] 


Theorem (992)                               [serial 2115] 
P [342] << ( REGULATOR_OK()
  and RUN() )
  and INVMHS() >>
S [365] ->
Q [343] << AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
Why created:    normalization of [serial 1056]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 991 991:
Theorem (991) [serial 2117] used for:
   add user-defined axioms to postcondition 
Theorem (991) [serial 2117] used for:
   add user-defined axioms to postcondition 


Theorem (993)                               [serial 1056] 
P [342] << ( INVMHS() )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [365] ->
Q [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT() >>
Why created:   <<M(check_mode) and x>> -> <<M(check_temp)>> for mhsNormal: check_mode-[x]->check_temp{};
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 992:
Theorem (992) [serial 2115] used for:
    normalization of [serial 1056] 


Theorem (994)                               [serial 2201] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343] ->
Q [108] << ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2194]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (995)                               [serial 2194] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343] ->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:    normalization of [serial 2188]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 994:
Theorem (994) [serial 2201] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2194] 


Theorem (996)                               [serial 2188] 
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2186]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 995:
Theorem (995) [serial 2194] used for:
    normalization of [serial 2188] 


Theorem (997)                               [serial 2186] 
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2179]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 996:
Theorem (996) [serial 2188] used for:
  Associativity: (b.c).a = a.b.c [serial 2186] 


Theorem (998)                               [serial 2179] 
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:    normalization of [serial 2173]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 997:
Theorem (997) [serial 2186] used for:
  Associativity: (b.c).a = a.b.c [serial 2179] 


Theorem (999)                               [serial 2173] 
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343] ->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2170]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 998:
Theorem (998) [serial 2179] used for:
    normalization of [serial 2173] 


Theorem (1000)                               [serial 2170] 
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343] ->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2167]
Solved by:  Substitution of Assertion Labels
and theorem 999:
Theorem (999) [serial 2173] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2170] 


Theorem (1001)                               [serial 2167] 
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2165]
Solved by:  Substitution of Assertion Labels
and theorem 1000:
Theorem (1000) [serial 2170] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2167] 


Theorem (1002)                               [serial 2165] 
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [108] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 1001:
Theorem (1001) [serial 2167] used for:
  Replacing port names with BLESS::Value properties  [serial 2165] 


Theorem (1003)                               [serial 2208] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343] ->
Q [369] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 2206]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1004)                               [serial 2206] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343] ->
Q [369] << not ( ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2205]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1003:
Theorem (1003) [serial 2208] used for:
    normalization of [serial 2206] 


Theorem (1005)                               [serial 2205] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343] ->
Q [369] << not ( INI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2202]
Solved by:  Substitution of Assertion Labels
and theorem 1004:
Theorem (1004) [serial 2206] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2205] 


Theorem (1006)                               [serial 2202] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343] ->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2196]
Solved by:  Substitution of Assertion Labels
and theorem 1005:
Theorem (1005) [serial 2205] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2202] 


Theorem (1007)                               [serial 2196] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343] ->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 2189]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1006:
Theorem (1006) [serial 2202] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2196] 


Theorem (1008)                               [serial 2189] 
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2187]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1007:
Theorem (1007) [serial 2196] used for:
    normalization of [serial 2189] 


Theorem (1009)                               [serial 2187] 
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2181]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1008:
Theorem (1008) [serial 2189] used for:
  Associativity: (b.c).a = a.b.c [serial 2187] 


Theorem (1010)                               [serial 2181] 
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 2174]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1009:
Theorem (1009) [serial 2187] used for:
  Associativity: (b.c).a = a.b.c [serial 2181] 


Theorem (1011)                               [serial 2174] 
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343] ->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2171]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1010:
Theorem (1010) [serial 2181] used for:
    normalization of [serial 2174] 


Theorem (1012)                               [serial 2171] 
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343] ->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2168]
Solved by:  Substitution of Assertion Labels
and theorem 1011:
Theorem (1011) [serial 2174] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2171] 


Theorem (1013)                               [serial 2168] 
P [343] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2166]
Solved by:  Substitution of Assertion Labels
and theorem 1012:
Theorem (1012) [serial 2171] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2168] 


Theorem (1014)                               [serial 2166] 
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [369] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 1013:
Theorem (1013) [serial 2168] used for:
  Replacing port names with BLESS::Value properties  [serial 2166] 


Theorem (1015)                               [serial 2154] 
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [369] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 2150]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1002 1014:
Theorem (1002) [serial 2165] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154] 
Theorem (1014) [serial 2166] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2154] 


Theorem (1016)                               [serial 2150] 
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [369] << ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2136]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1015:
Theorem (1015) [serial 2154] used for:
    normalization of [serial 2150] 


Theorem (1017)                               [serial 2136] 
P [343] << current_temperature.t <= lower_desired_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [369] << REQMHS2()
  and not REQMHS1() >>
Why created:    normalization of [serial 2126]
Solved by:  Substitution of Assertion Labels
and theorem 1016:
Theorem (1016) [serial 2150] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2136] 


Theorem (1018)                               [serial 2126] 
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [343] ->
Q [369] << REQMHS2()
  and not REQMHS1() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1057]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1017:
Theorem (1017) [serial 2136] used for:
    normalization of [serial 2126] 


Theorem (1019)                               [serial 2203] 
P [373] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_previous_period^1 = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2163]
Solved by:  Identity (id):  P->P is tautology


Theorem (1020)                               [serial 2163] 
P [373] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_control^0 = heat_previous_period^1 >>
Why created:    normalization of [serial 2159]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1019:
Theorem (1019) [serial 2203] used for:
  Assume Present:  P = P@now = P^0   [serial 2163] 


Theorem (1021)                               [serial 2159] 
P [373] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2156]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1020:
Theorem (1020) [serial 2163] used for:
    normalization of [serial 2159] 


Theorem (1022)                               [serial 2156] 
P [373] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
Why created:    normalization of [serial 2151]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1021:
Theorem (1021) [serial 2159] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2156] 


Theorem (1023)                               [serial 2151] 
P [373] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2142]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 1022:
Theorem (1022) [serial 2156] used for:
    normalization of [serial 2151] 


Theorem (1024)                               [serial 2142] 
P [373] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:    normalization of [serial 2133]
Solved by:  Substitution of Assertion Labels
and theorem 1023:
Theorem (1023) [serial 2151] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2142] 


Theorem (1025)                               [serial 2133] 
P [373] << ( heat_previous_period )^1 = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2127]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1024:
Theorem (1024) [serial 2142] used for:
    normalization of [serial 2133] 


Theorem (1026)                               [serial 2127] 
P [373] << heat_previous_period' = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1057]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1025:
Theorem (1025) [serial 2133] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2127] 


Theorem (1027)                               [serial 2138] 
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
Why created:    normalization of [serial 2130]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (1028)                               [serial 2130] 
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370] ->
Q [96] << REQMHS2()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'O_n ) ) >>
Why created:  applied port output of enumeration type  heat_control!(') [serial 2128]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1027:
Theorem (1027) [serial 2138] used for:
    normalization of [serial 2130] 


Theorem (1029)                               [serial 2204] 
P [370] << cntrl'O_n = heat_control
  and not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and not INI() >>
S [370] ->
Q [371] << cntrl'O_n = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2200]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1030)                               [serial 2200] 
P [370] << ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and cntrl'O_n^0 = heat_control^0
  and not INI() >>
S [370] ->
Q [371] << cntrl'O_n = heat_control >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2192]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1029:
Theorem (1029) [serial 2204] used for:
  Assume Present:  P = P@now = P^0   [serial 2200] 


Theorem (1031)                               [serial 2192] 
P [370] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and cntrl'O_n^0 = heat_control^0
  and not INI() >>
S [370] ->
Q [371] << cntrl'O_n = heat_control >>
Why created:    normalization of [serial 2185]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1030:
Theorem (1030) [serial 2200] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2192] 


Theorem (1032)                               [serial 2185] 
P [370] << CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not INI()
  and cntrl'O_n^0 = heat_control^0 >>
S [370] ->
Q [371] << cntrl'O_n = heat_control >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2177]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1031:
Theorem (1031) [serial 2192] used for:
    normalization of [serial 2185] 


Theorem (1033)                               [serial 2177] 
P [370] << ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t
  and not INI() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370] ->
Q [371] << cntrl'O_n = heat_control >>
Why created:    normalization of [serial 2172]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1032:
Theorem (1032) [serial 2185] used for:
  Associativity: (b.c).a = a.b.c [serial 2177] 


Theorem (1034)                               [serial 2172] 
P [370] << ( ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'O_n^0 = heat_control^0 >>
S [370] ->
Q [371] << cntrl'O_n = heat_control >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2169]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1033:
Theorem (1033) [serial 2177] used for:
    normalization of [serial 2172] 


Theorem (1035)                               [serial 2169] 
P [370] << ( ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'O_n^0 = heat_control^0 >>
S [370] ->
Q [371] << cntrl'O_n = heat_control >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2144]
Solved by:  Substitution of Assertion Labels
and theorem 1034:
Theorem (1034) [serial 2172] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2169] 


Theorem (1036)                               [serial 2144] 
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and cntrl'O_n^0 = heat_control^0 >>
S [370] ->
Q [371] << cntrl'O_n = heat_control >>
Why created:    normalization of [serial 2134]
Solved by:  Substitution of Assertion Labels
and theorem 1035:
Theorem (1035) [serial 2169] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2144] 


Theorem (1037)                               [serial 2134] 
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'O_n )^0 ) >>
S [370] ->
Q [371] << heat_control = cntrl'O_n >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2131]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1036:
Theorem (1036) [serial 2144] used for:
    normalization of [serial 2134] 


Theorem (1038)                               [serial 2131] 
P [370] << ( REQMHS2()
  and not REQMHS1() )
  and ( heat_control = cntrl'O_n )^0 >>
S [370] ->
Q [371] << heat_control = cntrl'O_n >>
Why created:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2128]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1037:
Theorem (1037) [serial 2134] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2131] 


Theorem (1039)                               [serial 2128] 
P [369] << REQMHS2()
  and not REQMHS1() >>
S [370] heat_control!(cntrl'O_n)
Q [371] << heat_control = cntrl'O_n >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1057]
Solved by:  Enumeration Type Port Output 
and theorems 1028 1038:
Theorem (1028) [serial 2130] used for:
  applied port output of enumeration type  heat_control!(') [serial 2128] 
Theorem (1038) [serial 2131] used for:
  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2128] 


Theorem (1040)                               [serial 2140] 
P [371] << cntrl'O_n = heat_control >>
S [372] ->
Q [373] << cntrl'O_n = heat_control >>
Why created:    normalization of [serial 2132]
Solved by:  Identity (id):  P->P is tautology


Theorem (1041)                               [serial 2132] 
P [371] << heat_control = cntrl'O_n >>
S [372] ->
Q [373] << ( cntrl'O_n ) = heat_control >>
Why created:  applied wp for assignment [serial 2129]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1040:
Theorem (1040) [serial 2140] used for:
    normalization of [serial 2132] 


Theorem (1042)                               [serial 2129] 
P [371] << heat_control = cntrl'O_n >>
S [372] heat_previous_period' := cntrl'O_n
Q [373] << heat_previous_period' = heat_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1057]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1041:
Theorem (1041) [serial 2132] used for:
  applied wp for assignment [serial 2129] 


Theorem (1043)                               [serial 1057] 
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t <= lower_desired_temperature.t ) >>
S [369]   << REQMHS2()
    and not REQMHS1() >>
  heat_control!(cntrl'O_n)
  ;
  << heat_control = cntrl'O_n >>
  heat_previous_period' := cntrl'O_n
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
Why created:   <<M(check_temp) and x>> A <<M(run)>> for mhsBelow: check_temp-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 1018 1026 1039 1042:
Theorem (1018) [serial 2126] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1057] 
Theorem (1026) [serial 2127] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1057] 
Theorem (1039) [serial 2128] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1057] 
Theorem (1042) [serial 2129] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1057] 


Theorem (1044)                               [serial 2295] 
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2293]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1045)                               [serial 2293] 
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2288]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1044:
Theorem (1044) [serial 2295] used for:
  Associativity: (b.c).a = a.b.c [serial 2293] 


Theorem (1046)                               [serial 2288] 
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2277]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1045:
Theorem (1045) [serial 2293] used for:
  Associativity: (b.c).a = a.b.c [serial 2288] 


Theorem (1047)                               [serial 2277] 
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
Why created:    normalization of [serial 2267]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1046:
Theorem (1046) [serial 2288] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2277] 


Theorem (1048)                               [serial 2267] 
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343] ->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2262]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1047:
Theorem (1047) [serial 2277] used for:
    normalization of [serial 2267] 


Theorem (1049)                               [serial 2262] 
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343] ->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
Why created:  Substituted assertions' predicates for labels  [serial 2257]
Solved by:  Substitution of Assertion Labels
and theorem 1048:
Theorem (1048) [serial 2267] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2262] 


Theorem (1050)                               [serial 2257] 
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2252]
Solved by:  Substitution of Assertion Labels
and theorem 1049:
Theorem (1049) [serial 2262] used for:
  Substituted assertions' predicates for labels  [serial 2257] 


Theorem (1051)                               [serial 2252] 
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 1050:
Theorem (1050) [serial 2257] used for:
  Replacing port names with BLESS::Value properties  [serial 2252] 


Theorem (1052)                               [serial 2303] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [343] ->
Q [377] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:    normalization of [serial 2301]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1053)                               [serial 2301] 
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [377] << not ( ( now - START_TIME ) < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2296]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1052:
Theorem (1052) [serial 2303] used for:
    normalization of [serial 2301] 


Theorem (1054)                               [serial 2296] 
P [343] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [377] << not INI() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2294]
Solved by:  Substitution of Assertion Labels
and theorem 1053:
Theorem (1053) [serial 2301] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2296] 


Theorem (1055)                               [serial 2294] 
P [343] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [377] << not INI() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2289]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1054:
Theorem (1054) [serial 2296] used for:
  Associativity: (b.c).a = a.b.c [serial 2294] 


Theorem (1056)                               [serial 2289] 
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [377] << not INI() >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2279]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1055:
Theorem (1055) [serial 2294] used for:
  Associativity: (b.c).a = a.b.c [serial 2289] 


Theorem (1057)                               [serial 2279] 
P [343] << ( ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period >>
S [343] ->
Q [377] << not INI() >>
Why created:    normalization of [serial 2268]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1056:
Theorem (1056) [serial 2289] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2279] 


Theorem (1058)                               [serial 2268] 
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) ) >>
S [343] ->
Q [377] << not ( INI() ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2263]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1057:
Theorem (1057) [serial 2279] used for:
    normalization of [serial 2268] 


Theorem (1059)                               [serial 2263] 
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() ) >>
S [343] ->
Q [377] << not ( INI() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2258]
Solved by:  Substitution of Assertion Labels
and theorem 1058:
Theorem (1058) [serial 2268] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2263] 


Theorem (1060)                               [serial 2258] 
P [343] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [377] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2253]
Solved by:  Substitution of Assertion Labels
and theorem 1059:
Theorem (1059) [serial 2263] used for:
  Substituted assertions' predicates for labels  [serial 2258] 


Theorem (1061)                               [serial 2253] 
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [377] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 1060:
Theorem (1060) [serial 2258] used for:
  Replacing port names with BLESS::Value properties  [serial 2253] 


Theorem (1062)                               [serial 2238] 
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [377] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not REGULATOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 2234]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1051 1061:
Theorem (1051) [serial 2252] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238] 
Theorem (1061) [serial 2253] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2238] 


Theorem (1063)                               [serial 2234] 
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [377] << ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2220]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1062:
Theorem (1062) [serial 2238] used for:
    normalization of [serial 2234] 


Theorem (1064)                               [serial 2220] 
P [343] << upper_desired_temperature.t <= current_temperature.t
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal) >>
S [343] ->
Q [377] << REQMHS3()
  and not REQMHS1() >>
Why created:    normalization of [serial 2210]
Solved by:  Substitution of Assertion Labels
and theorem 1063:
Theorem (1063) [serial 2234] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2220] 


Theorem (1065)                               [serial 2210] 
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [343] ->
Q [377] << REQMHS3()
  and not REQMHS1() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1058]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1064:
Theorem (1064) [serial 2220] used for:
    normalization of [serial 2210] 


Theorem (1066)                               [serial 2297] 
P [381] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_previous_period^1 = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2250]
Solved by:  Identity (id):  P->P is tautology


Theorem (1067)                               [serial 2250] 
P [381] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_control^0 = heat_previous_period^1 >>
Why created:    normalization of [serial 2246]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1066:
Theorem (1066) [serial 2297] used for:
  Assume Present:  P = P@now = P^0   [serial 2250] 


Theorem (1068)                               [serial 2246] 
P [381] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2240]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1067:
Theorem (1067) [serial 2250] used for:
    normalization of [serial 2246] 


Theorem (1069)                               [serial 2240] 
P [381] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
Why created:    normalization of [serial 2235]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1068:
Theorem (1068) [serial 2246] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2240] 


Theorem (1070)                               [serial 2235] 
P [381] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2226]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 1069:
Theorem (1069) [serial 2240] used for:
    normalization of [serial 2235] 


Theorem (1071)                               [serial 2226] 
P [381] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:    normalization of [serial 2217]
Solved by:  Substitution of Assertion Labels
and theorem 1070:
Theorem (1070) [serial 2235] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2226] 


Theorem (1072)                               [serial 2217] 
P [381] << ( heat_previous_period )^1 = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2211]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1071:
Theorem (1071) [serial 2226] used for:
    normalization of [serial 2217] 


Theorem (1073)                               [serial 2211] 
P [381] << heat_previous_period' = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1058]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1072:
Theorem (1072) [serial 2217] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2211] 


Theorem (1074)                               [serial 2222] 
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
Why created:    normalization of [serial 2214]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (1075)                               [serial 2214] 
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378] ->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
Why created:  applied port output of enumeration type  heat_control!(') [serial 2212]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1074:
Theorem (1074) [serial 2222] used for:
    normalization of [serial 2214] 


Theorem (1076)                               [serial 2298] 
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378] ->
Q [164] << not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2290]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1077)                               [serial 2290] 
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2285]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1076:
Theorem (1076) [serial 2298] used for:
  Assume Present:  P = P@now = P^0   [serial 2290] 


Theorem (1078)                               [serial 2285] 
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [164] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2271]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1077:
Theorem (1077) [serial 2290] used for:
  Associativity: (b.c).a = a.b.c [serial 2285] 


Theorem (1079)                               [serial 2271] 
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
Why created:    normalization of [serial 2264]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1078:
Theorem (1078) [serial 2285] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2271] 


Theorem (1080)                               [serial 2264] 
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2259]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1079:
Theorem (1079) [serial 2271] used for:
    normalization of [serial 2264] 


Theorem (1081)                               [serial 2259] 
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
Why created:  Substituted assertions' predicates for labels  [serial 2254]
Solved by:  Substitution of Assertion Labels
and theorem 1080:
Theorem (1080) [serial 2264] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2259] 


Theorem (1082)                               [serial 2254] 
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [164] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]
Solved by:  Substitution of Assertion Labels
and theorem 1081:
Theorem (1081) [serial 2259] used for:
  Substituted assertions' predicates for labels  [serial 2254] 


Theorem (1083)                               [serial 2299] 
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378] ->
Q [379] << cntrl'Off = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2291]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1084)                               [serial 2291] 
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << cntrl'Off = heat_control >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2286]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1083:
Theorem (1083) [serial 2299] used for:
  Assume Present:  P = P@now = P^0   [serial 2291] 


Theorem (1085)                               [serial 2286] 
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << cntrl'Off = heat_control >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2273]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1084:
Theorem (1084) [serial 2291] used for:
  Associativity: (b.c).a = a.b.c [serial 2286] 


Theorem (1086)                               [serial 2273] 
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << cntrl'Off = heat_control >>
Why created:    normalization of [serial 2265]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1085:
Theorem (1085) [serial 2286] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2273] 


Theorem (1087)                               [serial 2265] 
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << cntrl'Off = heat_control >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2260]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1086:
Theorem (1086) [serial 2273] used for:
    normalization of [serial 2265] 


Theorem (1088)                               [serial 2260] 
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << cntrl'Off = heat_control >>
Why created:  Substituted assertions' predicates for labels  [serial 2255]
Solved by:  Substitution of Assertion Labels
and theorem 1087:
Theorem (1087) [serial 2265] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2260] 


Theorem (1089)                               [serial 2255] 
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << cntrl'Off = heat_control >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]
Solved by:  Substitution of Assertion Labels
and theorem 1088:
Theorem (1088) [serial 2260] used for:
  Substituted assertions' predicates for labels  [serial 2255] 


Theorem (1090)                               [serial 2300] 
P [378] << cntrl'Off = heat_control
  and not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and not INI() >>
S [378] ->
Q [379] << not INI() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2292]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1091)                               [serial 2292] 
P [378] << ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI()
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << not INI() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2287]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1090:
Theorem (1090) [serial 2300] used for:
  Assume Present:  P = P@now = P^0   [serial 2292] 


Theorem (1092)                               [serial 2287] 
P [378] << ( ( not ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << not INI() >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2275]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1091:
Theorem (1091) [serial 2292] used for:
  Associativity: (b.c).a = a.b.c [serial 2287] 


Theorem (1093)                               [serial 2275] 
P [378] << ( UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and not INI() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << not INI() >>
Why created:    normalization of [serial 2266]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1092:
Theorem (1092) [serial 2287] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2275] 


Theorem (1094)                               [serial 2266] 
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( ( INI() ) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << not ( INI() ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2261]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1093:
Theorem (1093) [serial 2275] used for:
    normalization of [serial 2266] 


Theorem (1095)                               [serial 2261] 
P [378] << ( ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << not ( INI() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2256]
Solved by:  Substitution of Assertion Labels
and theorem 1094:
Theorem (1094) [serial 2266] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2261] 


Theorem (1096)                               [serial 2256] 
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << not REGULATOR_MODE(x : mmode'Init) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242]
Solved by:  Substitution of Assertion Labels
and theorem 1095:
Theorem (1095) [serial 2261] used for:
  Substituted assertions' predicates for labels  [serial 2256] 


Theorem (1097)                               [serial 2242] 
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
  and cntrl'Off = heat_control
  and not REGULATOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 2236]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1082 1089 1096:
Theorem (1082) [serial 2254] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242] 
Theorem (1089) [serial 2255] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242] 
Theorem (1096) [serial 2256] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2242] 


Theorem (1098)                               [serial 2236] 
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << cntrl'Off = heat_control
  and ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
  and not ( REGULATOR_MODE(x : mmode'Init) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2228]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1097:
Theorem (1097) [serial 2242] used for:
    normalization of [serial 2236] 


Theorem (1099)                               [serial 2228] 
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and cntrl'Off^0 = heat_control^0 >>
S [378] ->
Q [379] << cntrl'Off = heat_control
  and REQMHS3()
  and not REQMHS1() >>
Why created:    normalization of [serial 2218]
Solved by:  Substitution of Assertion Labels
and theorem 1098:
Theorem (1098) [serial 2236] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2228] 


Theorem (1100)                               [serial 2218] 
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and ( ( heat_control )^0 = ( cntrl'Off )^0 ) >>
S [378] ->
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2215]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1099:
Theorem (1099) [serial 2228] used for:
    normalization of [serial 2218] 


Theorem (1101)                               [serial 2215] 
P [378] << ( REQMHS3()
  and not REQMHS1() )
  and ( heat_control = cntrl'Off )^0 >>
S [378] ->
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
Why created:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2212]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1100:
Theorem (1100) [serial 2218] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2215] 


Theorem (1102)                               [serial 2212] 
P [377] << REQMHS3()
  and not REQMHS1() >>
S [378] heat_control!(cntrl'Off)
Q [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1058]
Solved by:  Enumeration Type Port Output 
and theorems 1075 1101:
Theorem (1075) [serial 2214] used for:
  applied port output of enumeration type  heat_control!(') [serial 2212] 
Theorem (1101) [serial 2215] used for:
  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2212] 


Theorem (1103)                               [serial 2224] 
P [379] << cntrl'Off = heat_control
  and REQMHS3()
  and not REQMHS1() >>
S [380] ->
Q [381] << cntrl'Off = heat_control >>
Why created:    normalization of [serial 2216]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1104)                               [serial 2216] 
P [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
S [380] ->
Q [381] << ( cntrl'Off ) = heat_control >>
Why created:  applied wp for assignment [serial 2213]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1103:
Theorem (1103) [serial 2224] used for:
    normalization of [serial 2216] 


Theorem (1105)                               [serial 2213] 
P [379] << REQMHS3()
  and not REQMHS1()
  and ( heat_control = cntrl'Off ) >>
S [380] heat_previous_period' := cntrl'Off
Q [381] << heat_previous_period' = heat_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1058]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1104:
Theorem (1104) [serial 2216] used for:
  applied wp for assignment [serial 2213] 


Theorem (1106)                               [serial 1058] 
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( current_temperature.t >= upper_desired_temperature.t ) >>
S [377]   << REQMHS3()
    and not REQMHS1() >>
  heat_control!(cntrl'Off)
  ;
  << REQMHS3()
    and not REQMHS1()
    and ( heat_control = cntrl'Off ) >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
Why created:   <<M(check_temp) and x>> A <<M(run)>> for mhsAbove: check_temp-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 1065 1073 1102 1105:
Theorem (1065) [serial 2210] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1058] 
Theorem (1073) [serial 2211] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1058] 
Theorem (1102) [serial 2212] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1058] 
Theorem (1105) [serial 2213] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1058] 


Theorem (1107)                               [serial 2314] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [383] ->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
Why created:    normalization of [serial 2312]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1108)                               [serial 2312] 
P [343] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383] ->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2311]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1107:
Theorem (1107) [serial 2314] used for:
    normalization of [serial 2312] 


Theorem (1109)                               [serial 2311] 
P [343] << current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383] ->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2310]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 1108:
Theorem (1108) [serial 2312] used for:
  Replacing port names with BLESS::Value properties  [serial 2311] 


Theorem (1110)                               [serial 2310] 
P [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383] ->
Q [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and heat_control^-1 = heat_previous_period >>
Why created:  Law of And-Simplification:  P and true is P [serial 2308]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1109:
Theorem (1109) [serial 2311] used for:
  Associativity: (b.c).a = a.b.c [serial 2310] 


Theorem (1111)                               [serial 2308] 
P [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383] ->
Q [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and heat_control^-1 = heat_previous_period
  and true >>
Why created:    normalization of [serial 2306]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1110:
Theorem (1110) [serial 2310] used for:
  Law of And-Simplification:  P and true is P [serial 2308] 


Theorem (1112)                               [serial 2306] 
P [343] << ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383] ->
Q [344] << ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = heat_control^-1 )
  and true >>
Why created:  Substituted assertions' predicates for labels  [serial 2305]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1111:
Theorem (1111) [serial 2308] used for:
    normalization of [serial 2306] 


Theorem (1113)                               [serial 2305] 
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383] ->
Q [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Substitution of Assertion Labels
and theorem 1112:
Theorem (1112) [serial 2306] used for:
  Substituted assertions' predicates for labels  [serial 2305] 


Theorem (1114)                               [serial 2314] 
P [343] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [383] ->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
Why created:    normalization of [serial 2312]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1115)                               [serial 2312] 
P [343] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383] ->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2311]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1114:
Theorem (1114) [serial 2314] used for:
    normalization of [serial 2312] 


Theorem (1116)                               [serial 2311] 
P [343] << current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383] ->
Q [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and heat_control^-1 = heat_previous_period >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2310]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 1115:
Theorem (1115) [serial 2312] used for:
  Replacing port names with BLESS::Value properties  [serial 2311] 


Theorem (1117)                               [serial 2310] 
P [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383] ->
Q [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and heat_control^-1 = heat_previous_period >>
Why created:  Law of And-Simplification:  P and true is P [serial 2308]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1116:
Theorem (1116) [serial 2311] used for:
  Associativity: (b.c).a = a.b.c [serial 2310] 


Theorem (1118)                               [serial 2308] 
P [343] << ( current_temperature.t < upper_desired_temperature.t
  and lower_desired_temperature.t < current_temperature.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and heat_control^-1 = heat_previous_period >>
S [383] ->
Q [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and heat_control^-1 = heat_previous_period
  and true >>
Why created:    normalization of [serial 2306]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1117:
Theorem (1117) [serial 2310] used for:
  Law of And-Simplification:  P and true is P [serial 2308] 


Theorem (1119)                               [serial 2306] 
P [343] << ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383] ->
Q [344] << ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( heat_previous_period = heat_control^-1 )
  and true >>
Why created:  Substituted assertions' predicates for labels  [serial 2305]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1118:
Theorem (1118) [serial 2308] used for:
    normalization of [serial 2306] 


Theorem (1120)                               [serial 2305] 
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383] ->
Q [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Substitution of Assertion Labels
and theorem 1119:
Theorem (1119) [serial 2306] used for:
  Substituted assertions' predicates for labels  [serial 2305] 


Theorem (1121)                               [serial 1059] 
P [343] << INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HEAT()
  and ( ( current_temperature.t > lower_desired_temperature.t )
  and ( current_temperature.t < upper_desired_temperature.t ) ) >>
S [383] ->
Q [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT() >>
Why created:   <<M(check_temp) and x>> -> <<M(check_hyst)>> for mhsHys: check_temp-[x]->check_hyst{};
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1120 1120:
Theorem (1120) [serial 2305] used for:
   add user-defined axioms to postcondition 
Theorem (1120) [serial 2305] used for:
   add user-defined axioms to postcondition 


Theorem (1122)                               [serial 2429] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [333] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1123)                               [serial 2430] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [164] << LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1124)                               [serial 2449] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [389] << cntrl'O_n = heat_previous_period >>
Why created:  Guided Substitution of Equals 
 replacing "heat_control^-1" with its = "heat_previous_period" in its postcondition [serial 2431]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1125)                               [serial 2431] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [389] << cntrl'O_n = heat_control^-1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  Guided Substitution of Equals
and theorem 1124:
Theorem (1124) [serial 2449] used for:
  Guided Substitution of Equals 
 replacing "heat_control^-1" with its = "heat_previous_period" in its postcondition [serial 2431] 


Theorem (1126)                               [serial 2432] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [129] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1127)                               [serial 2433] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [164] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1128)                               [serial 2434] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [128] << not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1129)                               [serial 2421] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2419]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1122 1123 1125 1126 1127 1128:
Theorem (1122) [serial 2429] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1123) [serial 2430] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1125) [serial 2431] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1126) [serial 2432] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1127) [serial 2433] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1128) [serial 2434] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 


Theorem (1130)                               [serial 2419] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and true
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2414]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1129:
Theorem (1129) [serial 2421] used for:
  Law of And-Simplification:  P and true is P [serial 2419] 


Theorem (1131)                               [serial 2414] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2411]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 1130:
Theorem (1130) [serial 2419] used for:
  Equality Law (idistr):  a=a <-> true [serial 2414] 


Theorem (1132)                               [serial 2411] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2409]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1131:
Theorem (1131) [serial 2414] used for:
    normalization of [serial 2411] 


Theorem (1133)                               [serial 2409] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "heat_previous_period"
 with its ="
 ( heat_control^-1 )" [serial 2405]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1132:
Theorem (1132) [serial 2411] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2409] 


Theorem (1134)                               [serial 2405] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2401]
Solved by:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 1133:
Theorem (1133) [serial 2409] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "heat_previous_period"
 with its ="
 ( heat_control^-1 )" [serial 2405] 


Theorem (1135)                               [serial 2401] 
P [344] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2397]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1134:
Theorem (1134) [serial 2405] used for:
    normalization of [serial 2401] 


Theorem (1136)                               [serial 2397] 
P [344] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2393]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1135:
Theorem (1135) [serial 2401] used for:
  Associativity: (b.c).a = a.b.c [serial 2397] 


Theorem (1137)                               [serial 2393] 
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2391]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1136:
Theorem (1136) [serial 2397] used for:
    normalization of [serial 2393] 


Theorem (1138)                               [serial 2391] 
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2387]
Solved by:  Substitution of Assertion Labels
and theorem 1137:
Theorem (1137) [serial 2393] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2391] 


Theorem (1139)                               [serial 2387] 
P [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:    normalization of [serial 2383]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1138:
Theorem (1138) [serial 2391] used for:
  Associativity: (b.c).a = a.b.c [serial 2387] 


Theorem (1140)                               [serial 2383] 
P [344] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2380]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1139:
Theorem (1139) [serial 2387] used for:
    normalization of [serial 2383] 


Theorem (1141)                               [serial 2380] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
Why created:    normalization of [serial 2377]
Solved by:  Substitution of Assertion Labels
and theorem 1140:
Theorem (1140) [serial 2383] used for:
  Substituted assertions' predicates for labels  [serial 2380] 


Theorem (1142)                               [serial 2377] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2363]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1141:
Theorem (1141) [serial 2380] used for:
    normalization of [serial 2377] 


Theorem (1143)                               [serial 2363] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:    normalization of [serial 2355]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1142:
Theorem (1142) [serial 2377] used for:
  Associativity: (b.c).a = a.b.c [serial 2363] 


Theorem (1144)                               [serial 2355] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2351]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1143:
Theorem (1143) [serial 2363] used for:
    normalization of [serial 2355] 


Theorem (1145)                               [serial 2351] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2343]
Solved by:  Substitution of Assertion Labels
and theorem 1144:
Theorem (1144) [serial 2355] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2351] 


Theorem (1146)                               [serial 2343] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and true >>
Why created:    normalization of [serial 2338]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1145:
Theorem (1145) [serial 2351] used for:
  Law of And-Simplification:  P and true is P [serial 2343] 


Theorem (1147)                               [serial 2338] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << cntrl'O_n = heat_previous_period
  and true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1146:
Theorem (1146) [serial 2343] used for:
    normalization of [serial 2338] 


Theorem (1148)                               [serial 2429] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [333] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1149)                               [serial 2430] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [164] << LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1150)                               [serial 2449] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [389] << cntrl'O_n = heat_previous_period >>
Why created:  Guided Substitution of Equals 
 replacing "heat_control^-1" with its = "heat_previous_period" in its postcondition [serial 2431]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1151)                               [serial 2431] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [389] << cntrl'O_n = heat_control^-1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  Guided Substitution of Equals
and theorem 1150:
Theorem (1150) [serial 2449] used for:
  Guided Substitution of Equals 
 replacing "heat_control^-1" with its = "heat_previous_period" in its postcondition [serial 2431] 


Theorem (1152)                               [serial 2432] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [129] << status'Valid = CURRENT_TEMPERATURE_STATUS >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1153)                               [serial 2433] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [164] << not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1154)                               [serial 2434] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [128] << not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1155)                               [serial 2421] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2419]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1148 1149 1151 1152 1153 1154:
Theorem (1148) [serial 2429] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1149) [serial 2430] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1151) [serial 2431] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1152) [serial 2432] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1153) [serial 2433] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 
Theorem (1154) [serial 2434] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2421] 


Theorem (1156)                               [serial 2419] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and true
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2414]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1155:
Theorem (1155) [serial 2421] used for:
  Law of And-Simplification:  P and true is P [serial 2419] 


Theorem (1157)                               [serial 2414] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2411]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 1156:
Theorem (1156) [serial 2419] used for:
  Equality Law (idistr):  a=a <-> true [serial 2414] 


Theorem (1158)                               [serial 2411] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2409]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1157:
Theorem (1157) [serial 2414] used for:
    normalization of [serial 2411] 


Theorem (1159)                               [serial 2409] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_control^-1
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_control^-1
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "heat_previous_period"
 with its ="
 ( heat_control^-1 )" [serial 2405]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1158:
Theorem (1158) [serial 2411] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2409] 


Theorem (1160)                               [serial 2405] 
P [344] << ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2401]
Solved by:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 1159:
Theorem (1159) [serial 2409] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "heat_previous_period"
 with its ="
 ( heat_control^-1 )" [serial 2405] 


Theorem (1161)                               [serial 2401] 
P [344] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2397]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1160:
Theorem (1160) [serial 2405] used for:
    normalization of [serial 2401] 


Theorem (1162)                               [serial 2397] 
P [344] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
Why created:    normalization of [serial 2393]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1161:
Theorem (1161) [serial 2401] used for:
  Associativity: (b.c).a = a.b.c [serial 2397] 


Theorem (1163)                               [serial 2393] 
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2391]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1162:
Theorem (1162) [serial 2397] used for:
    normalization of [serial 2393] 


Theorem (1164)                               [serial 2391] 
P [344] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2387]
Solved by:  Substitution of Assertion Labels
and theorem 1163:
Theorem (1163) [serial 2393] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2391] 


Theorem (1165)                               [serial 2387] 
P [344] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and ( cntrl'O_n = heat_previous_period
   or cntrl'Off = heat_previous_period )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
S [344] ->
Q [388] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:    normalization of [serial 2383]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1164:
Theorem (1164) [serial 2391] used for:
  Associativity: (b.c).a = a.b.c [serial 2387] 


Theorem (1166)                               [serial 2383] 
P [344] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = cntrl'O_n
   or heat_previous_period = cntrl'Off )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2380]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1165:
Theorem (1165) [serial 2387] used for:
    normalization of [serial 2383] 


Theorem (1167)                               [serial 2380] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
Why created:    normalization of [serial 2377]
Solved by:  Substitution of Assertion Labels
and theorem 1166:
Theorem (1166) [serial 2383] used for:
  Substituted assertions' predicates for labels  [serial 2380] 


Theorem (1168)                               [serial 2377] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2363]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1167:
Theorem (1167) [serial 2380] used for:
    normalization of [serial 2377] 


Theorem (1169)                               [serial 2363] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and heat_control^-1 = heat_previous_period >>
Why created:    normalization of [serial 2355]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1168:
Theorem (1168) [serial 2377] used for:
  Associativity: (b.c).a = a.b.c [serial 2363] 


Theorem (1170)                               [serial 2355] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << cntrl'O_n = heat_previous_period
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2351]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1169:
Theorem (1169) [serial 2363] used for:
    normalization of [serial 2355] 


Theorem (1171)                               [serial 2351] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2343]
Solved by:  Substitution of Assertion Labels
and theorem 1170:
Theorem (1170) [serial 2355] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2351] 


Theorem (1172)                               [serial 2343] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << cntrl'O_n = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and true >>
Why created:    normalization of [serial 2338]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1171:
Theorem (1171) [serial 2351] used for:
  Law of And-Simplification:  P and true is P [serial 2343] 


Theorem (1173)                               [serial 2338] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << cntrl'O_n = heat_previous_period
  and true
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1172:
Theorem (1172) [serial 2343] used for:
    normalization of [serial 2338] 


Theorem (1174)                               [serial 2324] 
P [344] << cntrl'O_n = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
Why created:    normalization of [serial 2316]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1173 1173:
Theorem (1173) [serial 2338] used for:
   add user-defined axioms to postcondition 
Theorem (1173) [serial 2338] used for:
   add user-defined axioms to postcondition 


Theorem (1175)                               [serial 2316] 
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( ( heat_previous_period = cntrl'O_n ) ) >>
S [344] ->
Q [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1060]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1174:
Theorem (1174) [serial 2324] used for:
    normalization of [serial 2316] 


Theorem (1176)                               [serial 2376] 
P [393] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_previous_period^1 = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2373]
Solved by:  Identity (id):  P->P is tautology


Theorem (1177)                               [serial 2373] 
P [393] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_control^0 = heat_previous_period^1 >>
Why created:    normalization of [serial 2368]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1176:
Theorem (1176) [serial 2376] used for:
  Assume Present:  P = P@now = P^0   [serial 2373] 


Theorem (1178)                               [serial 2368] 
P [393] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2361]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1177:
Theorem (1177) [serial 2373] used for:
    normalization of [serial 2368] 


Theorem (1179)                               [serial 2361] 
P [393] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
Why created:    normalization of [serial 2354]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1178:
Theorem (1178) [serial 2368] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2361] 


Theorem (1180)                               [serial 2354] 
P [393] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2345]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 1179:
Theorem (1179) [serial 2361] used for:
    normalization of [serial 2354] 


Theorem (1181)                               [serial 2345] 
P [393] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:    normalization of [serial 2339]
Solved by:  Substitution of Assertion Labels
and theorem 1180:
Theorem (1180) [serial 2354] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2345] 


Theorem (1182)                               [serial 2339] 
P [393] << ( heat_previous_period )^1 = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2326]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1181:
Theorem (1181) [serial 2345] used for:
    normalization of [serial 2339] 


Theorem (1183)                               [serial 2326] 
P [393] << heat_previous_period' = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:    normalization of [serial 2317]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1182:
Theorem (1182) [serial 2339] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2326] 


Theorem (1184)                               [serial 2317] 
P [393] << heat_previous_period' = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1060]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1183:
Theorem (1183) [serial 2326] used for:
    normalization of [serial 2317] 


Theorem (1185)                               [serial 2444] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
Why created:    normalization of [serial 2435]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (1186)                               [serial 2435] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1185:
Theorem (1185) [serial 2444] used for:
    normalization of [serial 2435] 


Theorem (1187)                               [serial 2450] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << heat_control^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "HEAT_CONTROL^-1" with its = "heat_control^-1" in its postcondition [serial 2446]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (1188)                               [serial 2446] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
Why created:    normalization of [serial 2436]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
and theorem 1187:
Theorem (1187) [serial 2450] used for:
  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "HEAT_CONTROL^-1" with its = "heat_control^-1" in its postcondition [serial 2446] 


Theorem (1189)                               [serial 2436] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1188:
Theorem (1188) [serial 2446] used for:
    normalization of [serial 2436] 


Theorem (1190)                               [serial 2428] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2426]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1186 1189:
Theorem (1186) [serial 2435] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428] 
Theorem (1189) [serial 2436] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2428] 


Theorem (1191)                               [serial 2426] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and true >>
Why created:    normalization of [serial 2423]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1190:
Theorem (1190) [serial 2428] used for:
  Law of And-Simplification:  P and true is P [serial 2426] 


Theorem (1192)                               [serial 2423] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( true )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2422]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1191:
Theorem (1191) [serial 2426] used for:
    normalization of [serial 2423] 


Theorem (1193)                               [serial 2422] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) )
  and ( HEAT_CONTROL^-1 = heat_previous_period
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2420]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 1192:
Theorem (1192) [serial 2423] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2422] 


Theorem (1194)                               [serial 2420] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and HEAT_CONTROL^-1 = heat_previous_period )
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2416]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 1193:
Theorem (1193) [serial 2422] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 2420] 


Theorem (1195)                               [serial 2416] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s )
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and HEAT_CONTROL^-1 = heat_previous_period )
   or not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) >>
Why created:    normalization of [serial 2412]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1194:
Theorem (1194) [serial 2420] used for:
  Associativity: (b.c).a = a.b.c [serial 2416] 


Theorem (1196)                               [serial 2412] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
Why created:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2410]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1195:
Theorem (1195) [serial 2416] used for:
    normalization of [serial 2412] 


Theorem (1197)                               [serial 2410] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( now - START_TIME < #Iso_Properties::Initialization_Timeout s ) )
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( not ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2408]
Solved by:  Replace expression with range:   a<=x and x<=b  iff  x in a..b
and theorem 1196:
Theorem (1196) [serial 2412] used for:
  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2410] 


Theorem (1198)                               [serial 2408] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( HEAT_CONTROL^-1 = heat_previous_period
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "cntrl'O_n"
 with its ="
 ( heat_previous_period )" [serial 2403]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1197:
Theorem (1197) [serial 2410] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2408] 


Theorem (1199)                               [serial 2403] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and status'Valid = CURRENT_TEMPERATURE_STATUS
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:    normalization of [serial 2400]
Solved by:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 1198:
Theorem (1198) [serial 2408] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "cntrl'O_n"
 with its ="
 ( heat_previous_period )" [serial 2403] 


Theorem (1200)                               [serial 2400] 
P [388] << status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2395]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1199:
Theorem (1199) [serial 2403] used for:
    normalization of [serial 2400] 


Theorem (1201)                               [serial 2395] 
P [388] << ( status'Valid = CURRENT_TEMPERATURE_STATUS
  and not ( INTERNAL_FAILURE
   or REGULATOR_INTERFACE_FAILURE ) )
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and #Iso_Properties::Initialization_Timeout s <= now - START_TIME
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:    normalization of [serial 2392]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1200:
Theorem (1200) [serial 2400] used for:
  Associativity: (b.c).a = a.b.c [serial 2395] 


Theorem (1202)                               [serial 2392] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and ( not ( REGULATOR_INTERFACE_FAILURE
   or INTERNAL_FAILURE )
  and ( CURRENT_TEMPERATURE_STATUS = status'Valid ) )
  and ( ( now - START_TIME ) >= #Iso_Properties::Initialization_Timeout s )
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2390]
Solved by:  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1201:
Theorem (1201) [serial 2395] used for:
    normalization of [serial 2392] 


Theorem (1203)                               [serial 2390] 
P [388] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2385]
Solved by:  Substitution of Assertion Labels
and theorem 1202:
Theorem (1202) [serial 2392] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2390] 


Theorem (1204)                               [serial 2385] 
P [388] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'O_n = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:    normalization of [serial 2382]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1203:
Theorem (1203) [serial 2390] used for:
  Associativity: (b.c).a = a.b.c [serial 2385] 


Theorem (1205)                               [serial 2382] 
P [388] << cntrl'O_n = heat_previous_period
  and ( HEAT_CONTROL^-1 = heat_control^-1 )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:  Substituted assertions' predicates for labels  [serial 2359]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1204:
Theorem (1204) [serial 2385] used for:
    normalization of [serial 2382] 


Theorem (1206)                               [serial 2359] 
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t >>
Why created:    normalization of [serial 2353]
Solved by:  Substitution of Assertion Labels
and theorem 1205:
Theorem (1205) [serial 2382] used for:
  Substituted assertions' predicates for labels  [serial 2359] 


Theorem (1207)                               [serial 2353] 
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and ( CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t ) )
   or ( CURRENT_TEMP.t <= LOWER_DESIRED_TEMP.t ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2328]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1206:
Theorem (1206) [serial 2359] used for:
    normalization of [serial 2353] 


Theorem (1208)                               [serial 2328] 
P [388] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390] ->
Q [96] << ( cntrl'O_n = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS2() >>
Why created:    normalization of [serial 2320]
Solved by:  Substitution of Assertion Labels
and theorem 1207:
Theorem (1207) [serial 2353] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2328] 


Theorem (1209)                               [serial 2320] 
P [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
S [390] ->
Q [96] << REQMHS2()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'O_n ) ) >>
Why created:  applied port output of enumeration type  heat_control!(') [serial 2318]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1208:
Theorem (1208) [serial 2328] used for:
    normalization of [serial 2320] 


Theorem (1210)                               [serial 2375] 
P [390] << cntrl'O_n = heat_control
  and cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390] ->
Q [391] << cntrl'O_n = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2357]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1211)                               [serial 2357] 
P [390] << cntrl'O_n = heat_previous_period
  and cntrl'O_n^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [390] ->
Q [391] << cntrl'O_n = heat_control >>
Why created:    normalization of [serial 2352]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1210:
Theorem (1210) [serial 2375] used for:
  Assume Present:  P = P@now = P^0   [serial 2357] 


Theorem (1212)                               [serial 2352] 
P [390] << cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and cntrl'O_n^0 = heat_control^0 >>
S [390] ->
Q [391] << cntrl'O_n = heat_control >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2347]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1211:
Theorem (1211) [serial 2357] used for:
    normalization of [serial 2352] 


Theorem (1213)                               [serial 2347] 
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and cntrl'O_n^0 = heat_control^0 >>
S [390] ->
Q [391] << cntrl'O_n = heat_control >>
Why created:    normalization of [serial 2340]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1212:
Theorem (1212) [serial 2352] used for:
  Associativity: (b.c).a = a.b.c [serial 2347] 


Theorem (1214)                               [serial 2340] 
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( ( cntrl'O_n )^0 = ( heat_control )^0 ) >>
S [390] ->
Q [391] << cntrl'O_n = heat_control >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2330]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1213:
Theorem (1213) [serial 2347] used for:
    normalization of [serial 2340] 


Theorem (1215)                               [serial 2330] 
P [390] << ( cntrl'O_n = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() )
  and ( cntrl'O_n = heat_control )^0 >>
S [390] ->
Q [391] << cntrl'O_n = heat_control >>
Why created:    normalization of [serial 2321]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1214:
Theorem (1214) [serial 2340] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2330] 


Theorem (1216)                               [serial 2321] 
P [390] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() )
  and ( heat_control = cntrl'O_n )^0 >>
S [390] ->
Q [391] << heat_control = cntrl'O_n >>
Why created:  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2318]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1215:
Theorem (1215) [serial 2330] used for:
    normalization of [serial 2321] 


Theorem (1217)                               [serial 2318] 
P [388] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'O_n )
  and INVMHS() >>
S [390] heat_control!(cntrl'O_n)
Q [391] << heat_control = cntrl'O_n >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1060]
Solved by:  Enumeration Type Port Output 
and theorems 1209 1216:
Theorem (1209) [serial 2320] used for:
  applied port output of enumeration type  heat_control!(') [serial 2318] 
Theorem (1216) [serial 2321] used for:
  applied port output <<pre and (heat_control=cntrl'O_n)^0>> -> <<post>> [serial 2318] 


Theorem (1218)                               [serial 2332] 
P [391] << cntrl'O_n = heat_control >>
S [392] ->
Q [393] << cntrl'O_n = heat_control >>
Why created:    normalization of [serial 2322]
Solved by:  Identity (id):  P->P is tautology


Theorem (1219)                               [serial 2322] 
P [391] << heat_control = cntrl'O_n >>
S [392] ->
Q [393] << ( cntrl'O_n ) = heat_control >>
Why created:  applied wp for assignment [serial 2319]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1218:
Theorem (1218) [serial 2332] used for:
    normalization of [serial 2322] 


Theorem (1220)                               [serial 2319] 
P [391] << heat_control = cntrl'O_n >>
S [392] heat_previous_period' := cntrl'O_n
Q [393] << heat_previous_period' = heat_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1060]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1219:
Theorem (1219) [serial 2322] used for:
  applied wp for assignment [serial 2319] 


Theorem (1221)                               [serial 1060] 
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( ( heat_previous_period = cntrl'O_n ) ) >>
S [388]   << TEMP_IN_DESIRED_RANGE()
    and REGULATOR_MODE(x : mmode'Normal)
    and AXIOM_HC()
    and ( heat_previous_period = cntrl'O_n )
    and INVMHS() >>
  heat_control!(cntrl'O_n)
  ;
  << heat_control = cntrl'O_n >>
  heat_previous_period' := cntrl'O_n
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
Why created:   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOn: check_hyst-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 1175 1184 1217 1220:
Theorem (1175) [serial 2316] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1060] 
Theorem (1184) [serial 2317] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1060] 
Theorem (1217) [serial 2318] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1060] 
Theorem (1220) [serial 2319] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1060] 


Theorem (1222)                               [serial 2470] 
P [344] << cntrl'Off = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [397] << cntrl'Off = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
Why created:    normalization of [serial 2460]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1223)                               [serial 2460] 
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344] ->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2458]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1222:
Theorem (1222) [serial 2470] used for:
    normalization of [serial 2460] 


Theorem (1224)                               [serial 2458] 
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344] ->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and true
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1223:
Theorem (1223) [serial 2460] used for:
  Law of And-Simplification:  P and true is P [serial 2458] 


Theorem (1225)                               [serial 2470] 
P [344] << cntrl'Off = heat_previous_period
  and AXIOM_HEAT()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [344] ->
Q [397] << cntrl'Off = heat_previous_period
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
Why created:    normalization of [serial 2460]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1226)                               [serial 2460] 
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344] ->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2458]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1225:
Theorem (1225) [serial 2470] used for:
    normalization of [serial 2460] 


Theorem (1227)                               [serial 2458] 
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344] ->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and true
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1226:
Theorem (1226) [serial 2460] used for:
  Law of And-Simplification:  P and true is P [serial 2458] 


Theorem (1228)                               [serial 2451] 
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [344] ->
Q [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1061]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1227 1227:
Theorem (1227) [serial 2458] used for:
   add user-defined axioms to postcondition 
Theorem (1227) [serial 2458] used for:
   add user-defined axioms to postcondition 


Theorem (1229)                               [serial 2499] 
P [402] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_previous_period^1 = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2497]
Solved by:  Identity (id):  P->P is tautology


Theorem (1230)                               [serial 2497] 
P [402] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << heat_control^0 = heat_previous_period^1 >>
Why created:    normalization of [serial 2494]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1229:
Theorem (1229) [serial 2499] used for:
  Assume Present:  P = P@now = P^0   [serial 2497] 


Theorem (1231)                               [serial 2494] 
P [402] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^( -1 + 1 ) = ( heat_previous_period )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2491]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1230:
Theorem (1230) [serial 2497] used for:
    normalization of [serial 2494] 


Theorem (1232)                               [serial 2491] 
P [402] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_control^-1 = heat_previous_period )^1 >>
Why created:    normalization of [serial 2487]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1231:
Theorem (1231) [serial 2494] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2491] 


Theorem (1233)                               [serial 2487] 
P [402] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << ( heat_previous_period = heat_control^-1 )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2480]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 1232:
Theorem (1232) [serial 2491] used for:
    normalization of [serial 2487] 


Theorem (1234)                               [serial 2480] 
P [402] << heat_previous_period^1 = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:    normalization of [serial 2476]
Solved by:  Substitution of Assertion Labels
and theorem 1233:
Theorem (1233) [serial 2487] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2480] 


Theorem (1235)                               [serial 2476] 
P [402] << ( heat_previous_period )^1 = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2462]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1234:
Theorem (1234) [serial 2480] used for:
    normalization of [serial 2476] 


Theorem (1236)                               [serial 2462] 
P [402] << heat_previous_period' = heat_control >>
S [341] ->
Q [302] << INVMHS()^1 >>
Why created:    normalization of [serial 2452]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1235:
Theorem (1235) [serial 2476] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2462] 


Theorem (1237)                               [serial 2452] 
P [402] << heat_previous_period' = heat_control >>
S [341] ->
Q [302] << ( INVMHS() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1061]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1236:
Theorem (1236) [serial 2462] used for:
    normalization of [serial 2452] 


Theorem (1238)                               [serial 2516] 
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399] ->
Q [98] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2515]
Solved by:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (1239)                               [serial 2515] 
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399] ->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:  Law of And-Simplification:  P and P is P [serial 2514]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1238:
Theorem (1238) [serial 2516] used for:
  Associativity: (b.c).a = a.b.c [serial 2515] 


Theorem (1240)                               [serial 2514] 
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399] ->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:  Law of And-Simplification:  P and P is P [serial 2512]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 1239:
Theorem (1239) [serial 2515] used for:
  Law of And-Simplification:  P and P is P [serial 2514] 


Theorem (1241)                               [serial 2512] 
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399] ->
Q [98] << ( ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and cntrl'Off = HEAT_CONTROL^-1 )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:    normalization of [serial 2510]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 1240:
Theorem (1240) [serial 2514] used for:
  Law of And-Simplification:  P and P is P [serial 2512] 


Theorem (1242)                               [serial 2510] 
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = HEAT_CONTROL^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2509]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1241:
Theorem (1241) [serial 2512] used for:
    normalization of [serial 2510] 


Theorem (1243)                               [serial 2509] 
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_control^-1
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and HEAT_CONTROL^-1 = heat_previous_period
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2508]
Solved by:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b
and theorem 1242:
Theorem (1242) [serial 2510] used for:
  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2509] 


Theorem (1244)                               [serial 2508] 
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2506]
Solved by:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b
and theorem 1243:
Theorem (1243) [serial 2509] used for:
  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b  [serial 2508] 


Theorem (1245)                               [serial 2506] 
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period
  and REGULATOR_OK()
  and RUN() >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:    normalization of [serial 2504]
Solved by:  Replace expression with range:   a<=x and x<=b  iff  x in a..b
and theorem 1244:
Theorem (1244) [serial 2508] used for:
  Replace expression with range:   a<=x and x<=b  iff  x in a..b  [serial 2506] 


Theorem (1246)                               [serial 2504] 
P [397] << CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t
  and REGULATOR_OK()
  and RUN()
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2502]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1245:
Theorem (1245) [serial 2506] used for:
    normalization of [serial 2504] 


Theorem (1247)                               [serial 2502] 
P [397] << ( CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t
  and LOWER_DESIRED_TEMP.t < CURRENT_TEMP.t )
  and ( REGULATOR_OK()
  and RUN() )
  and cntrl'Off = heat_previous_period
  and HEAT_CONTROL^-1 = heat_control^-1
  and heat_control^-1 = heat_previous_period >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or ( RUN()
  and not REGULATOR_OK() )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or INI() >>
Why created:    normalization of [serial 2500]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1246:
Theorem (1246) [serial 2504] used for:
  Associativity: (b.c).a = a.b.c [serial 2502] 


Theorem (1248)                               [serial 2500] 
P [397] << cntrl'Off = heat_previous_period
  and ( HEAT_CONTROL^-1 = heat_control^-1 )
  and ( heat_previous_period = heat_control^-1 )
  and ( REGULATOR_OK()
  and RUN() )
  and ( CURRENT_TEMP.t > LOWER_DESIRED_TEMP.t
  and CURRENT_TEMP.t < UPPER_DESIRED_TEMP.t ) >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or ( not REGULATOR_OK()
  and RUN() )
   or ( INI() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2489]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1247:
Theorem (1247) [serial 2502] used for:
    normalization of [serial 2500] 


Theorem (1249)                               [serial 2489] 
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t )
   or UPPER_DESIRED_TEMP.t <= CURRENT_TEMP.t
   or REGULATOR_MODE(x : mmode'Failed)
   or REGULATOR_MODE(x : mmode'Init) >>
Why created:    normalization of [serial 2486]
Solved by:  Substitution of Assertion Labels
and theorem 1248:
Theorem (1248) [serial 2500] used for:
  Substituted assertions' predicates for labels  [serial 2489] 


Theorem (1250)                               [serial 2486] 
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and ( CURRENT_TEMP.t in LOWER_DESIRED_TEMP.t ,, UPPER_DESIRED_TEMP.t ) )
   or ( REGULATOR_MODE(x : mmode'Init) )
   or ( CURRENT_TEMP.t >= UPPER_DESIRED_TEMP.t )
   or ( REGULATOR_MODE(x : mmode'Failed) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2464]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1249:
Theorem (1249) [serial 2489] used for:
    normalization of [serial 2486] 


Theorem (1251)                               [serial 2464] 
P [397] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399] ->
Q [98] << ( cntrl'Off = HEAT_CONTROL^-1
  and REQMHS4() )
   or REQMHS1()
   or REQMHS3()
   or REQMHS5() >>
Why created:    normalization of [serial 2455]
Solved by:  Substitution of Assertion Labels
and theorem 1250:
Theorem (1250) [serial 2486] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2464] 


Theorem (1252)                               [serial 2455] 
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399] ->
Q [98] << REQMHS1()
   or REQMHS3()
   or REQMHS5()
   or ( REQMHS4()
  and ( HEAT_CONTROL^-1 = cntrl'Off ) ) >>
Why created:  applied port output of enumeration type  heat_control!(') [serial 2453]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1251:
Theorem (1251) [serial 2464] used for:
    normalization of [serial 2455] 


Theorem (1253)                               [serial 2485] 
P [399] << cntrl'Off = heat_control
  and cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399] ->
Q [400] << cntrl'Off = heat_control >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2482]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1254)                               [serial 2482] 
P [399] << cntrl'Off = heat_previous_period
  and cntrl'Off^0 = heat_control^0
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE() >>
S [399] ->
Q [400] << cntrl'Off = heat_control >>
Why created:    normalization of [serial 2477]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1253:
Theorem (1253) [serial 2485] used for:
  Assume Present:  P = P@now = P^0   [serial 2482] 


Theorem (1255)                               [serial 2477] 
P [399] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and ( ( cntrl'Off )^0 = ( heat_control )^0 ) >>
S [399] ->
Q [400] << cntrl'Off = heat_control >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2468]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1254:
Theorem (1254) [serial 2482] used for:
    normalization of [serial 2477] 


Theorem (1256)                               [serial 2468] 
P [399] << cntrl'Off = heat_previous_period
  and AXIOM_HC()
  and INVMHS()
  and REGULATOR_MODE(x : mmode'Normal)
  and TEMP_IN_DESIRED_RANGE()
  and ( cntrl'Off = heat_control )^0 >>
S [399] ->
Q [400] << cntrl'Off = heat_control >>
Why created:    normalization of [serial 2459]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1255:
Theorem (1255) [serial 2477] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2468] 


Theorem (1257)                               [serial 2459] 
P [399] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS()
  and ( heat_control = cntrl'Off )^0 >>
S [399] ->
Q [400] << heat_control = cntrl'Off >>
Why created:  Associativity: (b.c).a = a.b.c [serial 2456]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1256:
Theorem (1256) [serial 2468] used for:
    normalization of [serial 2459] 


Theorem (1258)                               [serial 2456] 
P [399] << ( TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() )
  and ( heat_control = cntrl'Off )^0 >>
S [399] ->
Q [400] << heat_control = cntrl'Off >>
Why created:  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2453]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 1257:
Theorem (1257) [serial 2459] used for:
  Associativity: (b.c).a = a.b.c [serial 2456] 


Theorem (1259)                               [serial 2453] 
P [397] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and AXIOM_HC()
  and ( heat_previous_period = cntrl'Off )
  and INVMHS() >>
S [399] heat_control!(cntrl'Off)
Q [400] << heat_control = cntrl'Off >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1061]
Solved by:  Enumeration Type Port Output 
and theorems 1252 1258:
Theorem (1252) [serial 2455] used for:
  applied port output of enumeration type  heat_control!(') [serial 2453] 
Theorem (1258) [serial 2456] used for:
  applied port output <<pre and (heat_control=cntrl'Off)^0>> -> <<post>> [serial 2453] 


Theorem (1260)                               [serial 2466] 
P [400] << cntrl'Off = heat_control >>
S [401] ->
Q [402] << cntrl'Off = heat_control >>
Why created:    normalization of [serial 2457]
Solved by:  Identity (id):  P->P is tautology


Theorem (1261)                               [serial 2457] 
P [400] << heat_control = cntrl'Off >>
S [401] ->
Q [402] << ( cntrl'Off ) = heat_control >>
Why created:  applied wp for assignment [serial 2454]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1260:
Theorem (1260) [serial 2466] used for:
    normalization of [serial 2457] 


Theorem (1262)                               [serial 2454] 
P [400] << heat_control = cntrl'Off >>
S [401] heat_previous_period' := cntrl'Off
Q [402] << heat_previous_period' = heat_control >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1061]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1261:
Theorem (1261) [serial 2457] used for:
  applied wp for assignment [serial 2454] 


Theorem (1263)                               [serial 1061] 
P [344] << TEMP_IN_DESIRED_RANGE()
  and REGULATOR_MODE(x : mmode'Normal)
  and INVMHS()
  and AXIOM_HEAT()
  and ( heat_previous_period = cntrl'Off ) >>
S [397]   << TEMP_IN_DESIRED_RANGE()
    and REGULATOR_MODE(x : mmode'Normal)
    and AXIOM_HC()
    and ( heat_previous_period = cntrl'Off )
    and INVMHS() >>
  heat_control!(cntrl'Off)
  ;
  << heat_control = cntrl'Off >>
  heat_previous_period' := cntrl'Off
  << heat_previous_period' = heat_control >> 
Q [341] << ( INVMHS() )^1 >>
Why created:   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOff: check_hyst-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 1228 1237 1259 1262:
Theorem (1228) [serial 2451] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1061] 
Theorem (1237) [serial 2452] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1061] 
Theorem (1259) [serial 2453] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1061] 
Theorem (1262) [serial 2454] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1061] 


Theorem (1264)                               [serial 1046] 
P [331] <<   >>
S [336] ->
Q [331] << manage_heat_source.impl proof obligations >>
Why created:  Initial proof obligations for manage_heat_source.impl
Solved by:  Component verification conditions
and theorems 894 901 902 905 920 921 922 949 977 993 1043 1106 1121 1221 1263:
Theorem (894) [serial 1047] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (901) [serial 1048] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>> 
Theorem (902) [serial 1049] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>> 
Theorem (905) [serial 1050] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>> 
Theorem (920) [serial 1051] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>> 
Theorem (921) [serial 1052] used for:
   <<M(poweron)>> -> <<M(run)>> for mhsPo: poweron-[ ]->run{}; 
Theorem (922) [serial 1053] used for:
   <<M(run) and x>> -> <<M(check_mode)>> for mhsRun: run-[x]->check_mode{}; 
Theorem (949) [serial 1054] used for:
   <<M(check_mode) and x>> A <<M(run)>> for mhsFailed: check_mode-[x]->run{A}; 
Theorem (977) [serial 1055] used for:
   <<M(check_mode) and x>> A <<M(run)>> for mhsInit: check_mode-[x]->run{A}; 
Theorem (993) [serial 1056] used for:
   <<M(check_mode) and x>> -> <<M(check_temp)>> for mhsNormal: check_mode-[x]->check_temp{}; 
Theorem (1043) [serial 1057] used for:
   <<M(check_temp) and x>> A <<M(run)>> for mhsBelow: check_temp-[x]->run{A}; 
Theorem (1106) [serial 1058] used for:
   <<M(check_temp) and x>> A <<M(run)>> for mhsAbove: check_temp-[x]->run{A}; 
Theorem (1121) [serial 1059] used for:
   <<M(check_temp) and x>> -> <<M(check_hyst)>> for mhsHys: check_temp-[x]->check_hyst{}; 
Theorem (1221) [serial 1060] used for:
   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOn: check_hyst-[x]->run{A}; 
Theorem (1263) [serial 1061] used for:
   <<M(check_hyst) and x>> A <<M(run)>> for mhsHysOff: check_hyst-[x]->run{A}; 


Theorem (1265)                               [serial 1062] 
P [1] << REGULATOR_INTERFACE_FAILURE >>
S [2] ->
Q [1] << REGULATOR_INTERFACE_FAILURE >>
Why created:  Composition of Subcomponents via Directional Connection manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure:
 interface_failure -> interface_failure
Solved by:  Identity (id):  P->P is tautology


Theorem (1266)                               [serial 1063] 
P [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [2] ->
Q [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
Why created:  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode:
 regulator_mode -> regulator_mode
Solved by:  Identity (id):  P->P is tautology


Theorem (1267)                               [serial 1064] 
P [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [2] ->
Q [1] << +=> REGULATOR_MODE(x : regulator_mode) >>
Why created:  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode:
 regulator_mode -> regulator_mode
Solved by:  Identity (id):  P->P is tautology


Theorem (1268)                               [serial 1065] 
P [1] << MONITOR_INTERFACE_FAILURE >>
S [2] ->
Q [1] << MONITOR_INTERFACE_FAILURE >>
Why created:  Composition of Subcomponents via Directional Connection manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure:
 interface_failure -> interface_failure
Solved by:  Identity (id):  P->P is tautology


Theorem (1269)                               [serial 1066] 
P [1] << +=> MONITOR_MODE(x : monitor_mode) >>
S [2] ->
Q [1] << +=> MONITOR_MODE(x : monitor_mode) >>
Why created:  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode:
 monitor_mode -> monitor_mode
Solved by:  Identity (id):  P->P is tautology


Theorem (1270)                               [serial 1067] 
P [1] << +=> MONITOR_MODE(x : monitor_mode) >>
S [2] ->
Q [1] << +=> MONITOR_MODE(x : monitor_mode) >>
Why created:  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode:
 monitor_mode -> monitor_mode
Solved by:  Identity (id):  P->P is tautology


Theorem (1271)                               [serial 1068] 
P [1] << INTERNAL_FAILURE >>
S [2] ->
Q [1] << INTERNAL_FAILURE >>
Why created:  Composition of Subcomponents via Directional Connection detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure:
 internal_failure -> internal_failure
Solved by:  Identity (id):  P->P is tautology


Theorem (1272)                               [serial 1069] 
P [1] << air_temperature_air = CURRENT_TEMP >>
S [2] ->
Q [1] << air_temperature_air = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection air_temperature -> temperature_sensor.air:
 air_temperature -> air
Solved by:  Identity (id):  P->P is tautology


Theorem (1273)                               [serial 1070] 
P [1] << current_temperature = CURRENT_TEMP >>
S [2] ->
Q [1] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1274)                               [serial 1071] 
P [1] << current_temperature = CURRENT_TEMP >>
S [2] ->
Q [1] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1275)                               [serial 1072] 
P [1] << current_temperature = CURRENT_TEMP >>
S [2] ->
Q [1] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1276)                               [serial 1073] 
P [1] << current_temperature = CURRENT_TEMP >>
S [2] ->
Q [1] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1277)                               [serial 1074] 
P [1] << current_temperature = CURRENT_TEMP >>
S [2] ->
Q [1] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1278)                               [serial 1075] 
P [1] << current_temperature = CURRENT_TEMP >>
S [2] ->
Q [1] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1279)                               [serial 1076] 
P [1] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [2] ->
Q [1] << +=> REGULATOR_STATUS(x : regulator_status) >>
Why created:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status:
 regulator_status -> regulator_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1280)                               [serial 1077] 
P [1] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [2] ->
Q [1] << displayed_temp_display_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature:
 displayed_temp -> display_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1281)                               [serial 1078] 
P [1] << +=> HEAT_CONTROL(x : heat_control) >>
S [2] ->
Q [1] << +=> HEAT_CONTROL(x : heat_control) >>
Why created:  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control:
 heat_control -> heat_control
Solved by:  Identity (id):  P->P is tautology


Theorem (1282)                               [serial 1079] 
P [1] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [2] ->
Q [1] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Why created:  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm:
 alarm_control -> alarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1283)                               [serial 1080] 
P [1] << monitor_status = MONITOR_STATUS() >>
S [2] ->
Q [1] << monitor_status = MONITOR_STATUS() >>
Why created:  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status:
 monitor_status -> monitor_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1284)                               [serial 1081] 
P [1] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
S [2] ->
Q [1] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp:
 lower_desired_temperature -> lower_desired_temp
Solved by:  Identity (id):  P->P is tautology


Theorem (1285)                               [serial 1082] 
P [1] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [2] ->
Q [1] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature:
 lower_desired_temperature -> lower_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1286)                               [serial 1083] 
P [1] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
S [2] ->
Q [1] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp:
 upper_desired_temperature -> upper_desired_temp
Solved by:  Identity (id):  P->P is tautology


Theorem (1287)                               [serial 1084] 
P [1] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [2] ->
Q [1] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature:
 upper_desired_temperature -> upper_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1288)                               [serial 1085] 
P [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [2] ->
Q [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1289)                               [serial 1086] 
P [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [2] ->
Q [1] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1290)                               [serial 1087] 
P [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [2] ->
Q [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1291)                               [serial 1088] 
P [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [2] ->
Q [1] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1292)                               [serial 1089] 
P [9] << current_temperature = CURRENT_TEMP >>
S [42] ->
Q [77] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcti:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1293)                               [serial 1090] 
P [9] << current_temperature = CURRENT_TEMP >>
S [43] ->
Q [259] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcta:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1294)                               [serial 1091] 
P [9] << current_temperature = CURRENT_TEMP >>
S [44] ->
Q [126] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mctm:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1295)                               [serial 1092] 
P [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [46] ->
Q [81] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.muat:
 upper_alarm_temperature -> upper_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1296)                               [serial 1093] 
P [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [47] ->
Q [83] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mlat:
 lower_alarm_temperature -> lower_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1297)                               [serial 1094] 
P [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [48] ->
Q [257] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.maul:
 upper_alarm_temperature -> upper_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1298)                               [serial 1095] 
P [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [49] ->
Q [255] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mall:
 lower_alarm_temperature -> lower_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1299)                               [serial 1096] 
P [251] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [51] ->
Q [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.malrm:
 alarm_control -> alarm_control
Solved by:  Identity (id):  P->P is tautology


Theorem (1300)                               [serial 1097] 
P [85] << monitor_status = MONITOR_STATUS() >>
S [53] ->
Q [17] << monitor_status = MONITOR_STATUS() >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mms:
 monitor_status -> monitor_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1301)                               [serial 1098] 
P [87] << MONITOR_INTERFACE_FAILURE >>
S [54] ->
Q [122] << MONITOR_INTERFACE_FAILURE >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.intff:
 interface_failure -> interface_failure
Solved by:  Identity (id):  P->P is tautology


Theorem (1302)                               [serial 1099] 
P [19] << INTERNAL_FAILURE >>
S [56] ->
Q [124] << INTERNAL_FAILURE >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mf:
 regulator_failure -> internal_failure
Solved by:  Identity (id):  P->P is tautology


Theorem (1303)                               [serial 1100] 
P [120] << +=> MONITOR_MODE(x : monitor_mode) >>
S [57] ->
Q [79] << +=> MONITOR_MODE(x : monitor_mode) >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmmi:
 monitor_mode -> monitor_mode
Solved by:  Identity (id):  P->P is tautology


Theorem (1304)                               [serial 1101] 
P [120] << +=> MONITOR_MODE(x : monitor_mode) >>
S [58] ->
Q [253] << +=> MONITOR_MODE(x : monitor_mode) >>
Why created:  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmma:
 monitor_mode -> monitor_mode
Solved by:  Identity (id):  P->P is tautology


Theorem (1305)                               [serial 1102] 
P [136] << air_temperature_air = CURRENT_TEMP >>
S [173] ->
Q [93] << air_temperature_air = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.a2ts:
 air_temperature -> air
Solved by:  Identity (id):  P->P is tautology


Theorem (1306)                               [serial 1103] 
P [95] << current_temperature = CURRENT_TEMP >>
S [175] ->
Q [288] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ct:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1307)                               [serial 1104] 
P [290] << +=> HEAT_CONTROL(x : heat_control) >>
S [177] ->
Q [156] << +=> HEAT_CONTROL(x : heat_control) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.hc:
 heat_control -> heat_control
Solved by:  Identity (id):  P->P is tautology


Theorem (1308)                               [serial 1105] 
P [442] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [183] ->
Q [292] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1309)                               [serial 1106] 
P [444] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [185] ->
Q [294] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1310)                               [serial 1107] 
P [446] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [187] ->
Q [296] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1311)                               [serial 1108] 
P [448] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [189] ->
Q [298] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1312)                               [serial 1109] 
P [300] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [191] ->
Q [451] << +=> REGULATOR_STATUS(x : regulator_status) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.rs:
 regulator_status -> regulator_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1313)                               [serial 1110] 
P [302] << monitor_status = MONITOR_STATUS() >>
S [193] ->
Q [453] << monitor_status = MONITOR_STATUS() >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ms:
 monitor_status -> monitor_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1314)                               [serial 1111] 
P [304] << display_temperature = CURRENT_TEMP >>
S [195] ->
Q [455] << display_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.dt:
 display_temperature -> display_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1315)                               [serial 1112] 
P [306] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [197] ->
Q [457] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.al:
 alarm_control -> alarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1316)                               [serial 1113] 
P [136] << air_temperature_air = CURRENT_TEMP >>
S [260] ->
Q [93] << air_temperature_air = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2cs:
 air_temperature -> air
Solved by:  Identity (id):  P->P is tautology


Theorem (1317)                               [serial 1114] 
P [136] << air_temperature_air = CURRENT_TEMP >>
S [261] ->
Q [93] << air_temperature_air = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2ms:
 air_temperature -> air
Solved by:  Identity (id):  P->P is tautology


Theorem (1318)                               [serial 1115] 
P [95] << current_temperature_control_temp = CURRENT_TEMP >>
S [266] ->
Q [368] << current_temperature_control_temp = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.cont:
 current_temperature -> control_temp
Solved by:  Identity (id):  P->P is tautology


Theorem (1319)                               [serial 1116] 
P [95] << current_temperature_monitor_temp = CURRENT_TEMP >>
S [267] ->
Q [371] << current_temperature_monitor_temp = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ct:
 current_temperature -> monitor_temp
Solved by:  Identity (id):  P->P is tautology


Theorem (1320)                               [serial 1117] 
P [373] << +=> HEAT_CONTROL(x : heat_control) >>
S [268] ->
Q [156] << +=> HEAT_CONTROL(x : heat_control) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.hc:
 heat_control -> heat_control
Solved by:  Identity (id):  P->P is tautology


Theorem (1321)                               [serial 1118] 
P [442] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [269] ->
Q [375] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1322)                               [serial 1119] 
P [444] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [270] ->
Q [377] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1323)                               [serial 1120] 
P [446] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [271] ->
Q [379] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1324)                               [serial 1121] 
P [448] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [272] ->
Q [381] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1325)                               [serial 1122] 
P [383] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [273] ->
Q [451] << +=> REGULATOR_STATUS(x : regulator_status) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.rs:
 regulator_status -> regulator_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1326)                               [serial 1123] 
P [385] << monitor_status = MONITOR_STATUS() >>
S [274] ->
Q [453] << monitor_status = MONITOR_STATUS() >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ms:
 monitor_status -> monitor_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1327)                               [serial 1124] 
P [387] << display_temperature = CURRENT_TEMP >>
S [275] ->
Q [455] << display_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.dt:
 display_temperature -> display_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1328)                               [serial 1125] 
P [389] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [276] ->
Q [457] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.al:
 alarm_control -> alarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1329)                               [serial 1126] 
P [288] << current_temperature = CURRENT_TEMP >>
S [337] ->
Q [9] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctm:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1330)                               [serial 1127] 
P [288] << current_temperature = CURRENT_TEMP >>
S [338] ->
Q [19] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctr:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1331)                               [serial 1128] 
P [21] << +=> HEAT_CONTROL(x : heat_control) >>
S [339] ->
Q [290] << +=> HEAT_CONTROL(x : heat_control) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.thc:
 heat_control -> heat_control
Solved by:  Identity (id):  P->P is tautology


Theorem (1332)                               [serial 1129] 
P [294] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [340] ->
Q [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1333)                               [serial 1130] 
P [292] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [341] ->
Q [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1334)                               [serial 1131] 
P [298] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [342] ->
Q [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1335)                               [serial 1132] 
P [296] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [343] ->
Q [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1336)                               [serial 1133] 
P [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [344] ->
Q [300] << +=> REGULATOR_STATUS(x : regulator_status) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.trs:
 regulator_status -> regulator_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1337)                               [serial 1134] 
P [17] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [345] ->
Q [304] << displayed_temp_display_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tdt:
 displayed_temp -> display_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1338)                               [serial 1135] 
P [17] << monitor_status = MONITOR_STATUS() >>
S [346] ->
Q [302] << monitor_status = MONITOR_STATUS() >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tms:
 monitor_status -> monitor_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1339)                               [serial 1136] 
P [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [347] ->
Q [306] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.ta:
 alarm_control -> alarm_control
Solved by:  Identity (id):  P->P is tautology


Theorem (1340)                               [serial 1137] 
P [10] << INTERNAL_FAILURE >>
S [348] ->
Q [19] << INTERNAL_FAILURE >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tf:
 internal_failure -> regulator_failure
Solved by:  Identity (id):  P->P is tautology


Theorem (1341)                               [serial 1138] 
P [371] << monitor_temp_current_temperature = CURRENT_TEMP >>
S [416] ->
Q [9] << monitor_temp_current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctm:
 monitor_temp -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1342)                               [serial 1139] 
P [368] << control_temp_current_temperature = CURRENT_TEMP >>
S [417] ->
Q [19] << control_temp_current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctr:
 control_temp -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1343)                               [serial 1140] 
P [21] << +=> HEAT_CONTROL(x : heat_control) >>
S [418] ->
Q [373] << +=> HEAT_CONTROL(x : heat_control) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.thc:
 heat_control -> heat_control
Solved by:  Identity (id):  P->P is tautology


Theorem (1344)                               [serial 1141] 
P [377] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [419] ->
Q [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1345)                               [serial 1142] 
P [375] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [420] ->
Q [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1346)                               [serial 1143] 
P [381] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
S [421] ->
Q [13] << upper_alarm_temperature = UPPER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1347)                               [serial 1144] 
P [379] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
S [422] ->
Q [11] << lower_alarm_temperature = LOWER_ALARM_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1348)                               [serial 1145] 
P [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [423] ->
Q [383] << +=> REGULATOR_STATUS(x : regulator_status) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.trs:
 regulator_status -> regulator_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1349)                               [serial 1146] 
P [17] << displayed_temp_display_temperature = CURRENT_TEMP >>
S [424] ->
Q [387] << displayed_temp_display_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tdt:
 displayed_temp -> display_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1350)                               [serial 1147] 
P [17] << monitor_status = MONITOR_STATUS() >>
S [425] ->
Q [385] << monitor_status = MONITOR_STATUS() >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tms:
 monitor_status -> monitor_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1351)                               [serial 1148] 
P [15] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
S [426] ->
Q [389] << +=> TEMP_OUT_OF_RANGE(x : alarm_control) >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.ta:
 alarm_control -> alarm_control
Solved by:  Identity (id):  P->P is tautology


Theorem (1352)                               [serial 1149] 
P [10] << INTERNAL_FAILURE >>
S [427] ->
Q [19] << INTERNAL_FAILURE >>
Why created:  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tf:
 internal_failure -> regulator_failure
Solved by:  Identity (id):  P->P is tautology


Theorem (1353)                               [serial 1150] 
P [19] << air_temperature = CURRENT_TEMP >>
S [124] ->
Q [136] << air_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Nursery::Room.Normal_Operation.tmp:
 air_temperature -> air_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1354)                               [serial 1151] 
P [13] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
S [49] ->
Q [88] << upper_desired_temperature_upper_desired_temp = UPPER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rudt:
 upper_desired_temperature -> upper_desired_temp
Solved by:  Identity (id):  P->P is tautology


Theorem (1355)                               [serial 1152] 
P [11] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
S [50] ->
Q [86] << lower_desired_temperature_lower_desired_temp = LOWER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rldt:
 lower_desired_temperature -> lower_desired_temp
Solved by:  Identity (id):  P->P is tautology


Theorem (1356)                               [serial 1153] 
P [13] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
S [51] ->
Q [301] << upper_desired_temperature = UPPER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mudt:
 upper_desired_temperature -> upper_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1357)                               [serial 1154] 
P [11] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
S [52] ->
Q [299] << lower_desired_temperature = LOWER_DESIRED_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mldt:
 lower_desired_temperature -> lower_desired_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1358)                               [serial 1155] 
P [84] << +=> REGULATOR_STATUS(x : regulator_status) >>
S [54] ->
Q [15] << +=> REGULATOR_STATUS(x : regulator_status) >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrs:
 regulator_status -> regulator_status
Solved by:  Identity (id):  P->P is tautology


Theorem (1359)                               [serial 1156] 
P [92] << displayed_temp = CURRENT_TEMP >>
S [56] ->
Q [17] << displayed_temp = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rdt:
 displayed_temp -> displayed_temp
Solved by:  Identity (id):  P->P is tautology


Theorem (1360)                               [serial 1157] 
P [19] << current_temperature = CURRENT_TEMP >>
S [58] ->
Q [90] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcti:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1361)                               [serial 1158] 
P [19] << current_temperature = CURRENT_TEMP >>
S [59] ->
Q [297] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcth:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1362)                               [serial 1159] 
P [295] << +=> HEAT_CONTROL(x : heat_control) >>
S [61] ->
Q [21] << +=> HEAT_CONTROL(x : heat_control) >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rhc:
 heat_control -> heat_control
Solved by:  Identity (id):  P->P is tautology


Theorem (1363)                               [serial 1160] 
P [161] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [62] ->
Q [303] << +=> REGULATOR_MODE(x : regulator_mode) >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmh:
 regulator_mode -> regulator_mode
Solved by:  Identity (id):  P->P is tautology


Theorem (1364)                               [serial 1161] 
P [161] << +=> REGULATOR_MODE(x : regulator_mode) >>
S [63] ->
Q [94] << +=> REGULATOR_MODE(x : regulator_mode) >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmi:
 regulator_mode -> regulator_mode
Solved by:  Identity (id):  P->P is tautology


Theorem (1365)                               [serial 1162] 
P [19] << current_temperature = CURRENT_TEMP >>
S [64] ->
Q [163] << current_temperature = CURRENT_TEMP >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rctm:
 current_temperature -> current_temperature
Solved by:  Identity (id):  P->P is tautology


Theorem (1366)                               [serial 1163] 
P [96] << REGULATOR_INTERFACE_FAILURE >>
S [65] ->
Q [165] << REGULATOR_INTERFACE_FAILURE >>
Why created:  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rif:
 interface_failure -> interface_failure
Solved by:  Identity (id):  P->P is tautology


Theorem (1367)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
and theorems 284 617 891 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366:
Theorem (284) [serial 1002] used for:
  Initial proof obligations for manage_monitor_mode.impl 
Theorem (617) [serial 1016] used for:
  Initial proof obligations for manage_alarm.impl 
Theorem (891) [serial 1032] used for:
  Initial proof obligations for manage_regulator_mode.impl 
Theorem (1264) [serial 1046] used for:
  Initial proof obligations for manage_heat_source.impl 
Theorem (1265) [serial 1062] used for:
  Composition of Subcomponents via Directional Connection manage_regulator_interface.interface_failure -> manage_regulator_mode.interface_failure:
 interface_failure -> interface_failure 
Theorem (1266) [serial 1063] used for:
  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_heat_source.regulator_mode:
 regulator_mode -> regulator_mode 
Theorem (1267) [serial 1064] used for:
  Composition of Subcomponents via Directional Connection manage_regulator_mode.regulator_mode -> manage_regulator_interface.regulator_mode:
 regulator_mode -> regulator_mode 
Theorem (1268) [serial 1065] used for:
  Composition of Subcomponents via Directional Connection manage_monitor_interface.interface_failure -> manage_monitor_mode.interface_failure:
 interface_failure -> interface_failure 
Theorem (1269) [serial 1066] used for:
  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_monitor_interface.monitor_mode:
 monitor_mode -> monitor_mode 
Theorem (1270) [serial 1067] used for:
  Composition of Subcomponents via Directional Connection manage_monitor_mode.monitor_mode -> manage_alarm.monitor_mode:
 monitor_mode -> monitor_mode 
Theorem (1271) [serial 1068] used for:
  Composition of Subcomponents via Directional Connection detect_regulator_fail.internal_failure -> monitor_temperature.manage_monitor_mode.internal_failure:
 internal_failure -> internal_failure 
Theorem (1272) [serial 1069] used for:
  Composition of Subcomponents via Directional Connection air_temperature -> temperature_sensor.air:
 air_temperature -> air 
Theorem (1273) [serial 1070] used for:
  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_interface.current_temperature:
 current_temperature -> current_temperature 
Theorem (1274) [serial 1071] used for:
  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_alarm.current_temperature:
 current_temperature -> current_temperature 
Theorem (1275) [serial 1072] used for:
  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.monitor_temperature.manage_monitor_mode.current_temperature:
 current_temperature -> current_temperature 
Theorem (1276) [serial 1073] used for:
  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_interface.current_temperature:
 current_temperature -> current_temperature 
Theorem (1277) [serial 1074] used for:
  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_heat_source.current_temperature:
 current_temperature -> current_temperature 
Theorem (1278) [serial 1075] used for:
  Composition of Subcomponents via Directional Connection temperature_sensor.current_temperature -> thermostat.regulate_temperature.manage_regulator_mode.current_temperature:
 current_temperature -> current_temperature 
Theorem (1279) [serial 1076] used for:
  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.regulator_status -> operator_interface.regulator_status:
 regulator_status -> regulator_status 
Theorem (1280) [serial 1077] used for:
  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_regulator_interface.displayed_temp -> operator_interface.display_temperature:
 displayed_temp -> display_temperature 
Theorem (1281) [serial 1078] used for:
  Composition of Subcomponents via Directional Connection thermostat.regulate_temperature.manage_heat_source.heat_control -> heat_source.heat_control:
 heat_control -> heat_control 
Theorem (1282) [serial 1079] used for:
  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_alarm.alarm_control -> operator_interface.alarm:
 alarm_control -> alarm 
Theorem (1283) [serial 1080] used for:
  Composition of Subcomponents via Directional Connection thermostat.monitor_temperature.manage_monitor_interface.monitor_status -> operator_interface.monitor_status:
 monitor_status -> monitor_status 
Theorem (1284) [serial 1081] used for:
  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.lower_desired_temp:
 lower_desired_temperature -> lower_desired_temp 
Theorem (1285) [serial 1082] used for:
  Composition of Subcomponents via Directional Connection operator_interface.lower_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.lower_desired_temperature:
 lower_desired_temperature -> lower_desired_temperature 
Theorem (1286) [serial 1083] used for:
  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_regulator_interface.upper_desired_temp:
 upper_desired_temperature -> upper_desired_temp 
Theorem (1287) [serial 1084] used for:
  Composition of Subcomponents via Directional Connection operator_interface.upper_desired_temperature -> thermostat.regulate_temperature.manage_heat_source.upper_desired_temperature:
 upper_desired_temperature -> upper_desired_temperature 
Theorem (1288) [serial 1085] used for:
  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature 
Theorem (1289) [serial 1086] used for:
  Composition of Subcomponents via Directional Connection operator_interface.lower_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.lower_alarm_temperature:
 lower_alarm_temperature -> lower_alarm_temperature 
Theorem (1290) [serial 1087] used for:
  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_monitor_interface.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature 
Theorem (1291) [serial 1088] used for:
  Composition of Subcomponents via Directional Connection operator_interface.upper_alarm_temperature -> thermostat.monitor_temperature.manage_alarm.upper_alarm_temperature:
 upper_alarm_temperature -> upper_alarm_temperature 
Theorem (1292) [serial 1089] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcti:
 current_temperature -> current_temperature 
Theorem (1293) [serial 1090] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mcta:
 current_temperature -> current_temperature 
Theorem (1294) [serial 1091] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mctm:
 current_temperature -> current_temperature 
Theorem (1295) [serial 1092] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.muat:
 upper_alarm_temperature -> upper_alarm_temperature 
Theorem (1296) [serial 1093] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mlat:
 lower_alarm_temperature -> lower_alarm_temperature 
Theorem (1297) [serial 1094] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.maul:
 upper_alarm_temperature -> upper_alarm_temperature 
Theorem (1298) [serial 1095] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mall:
 lower_alarm_temperature -> lower_alarm_temperature 
Theorem (1299) [serial 1096] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.malrm:
 alarm_control -> alarm_control 
Theorem (1300) [serial 1097] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mms:
 monitor_status -> monitor_status 
Theorem (1301) [serial 1098] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.intff:
 interface_failure -> interface_failure 
Theorem (1302) [serial 1099] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mf:
 regulator_failure -> internal_failure 
Theorem (1303) [serial 1100] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmmi:
 monitor_mode -> monitor_mode 
Theorem (1304) [serial 1101] used for:
  Composition of Subcomponents via Directional Connection Monitor::monitor_temperature.impl.mmma:
 monitor_mode -> monitor_mode 
Theorem (1305) [serial 1102] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.a2ts:
 air_temperature -> air 
Theorem (1306) [serial 1103] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ct:
 current_temperature -> current_temperature 
Theorem (1307) [serial 1104] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.hc:
 heat_control -> heat_control 
Theorem (1308) [serial 1105] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature 
Theorem (1309) [serial 1106] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature 
Theorem (1310) [serial 1107] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature 
Theorem (1311) [serial 1108] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature 
Theorem (1312) [serial 1109] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.rs:
 regulator_status -> regulator_status 
Theorem (1313) [serial 1110] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.ms:
 monitor_status -> monitor_status 
Theorem (1314) [serial 1111] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.dt:
 display_temperature -> display_temperature 
Theorem (1315) [serial 1112] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.single_sensor.al:
 alarm_control -> alarm 
Theorem (1316) [serial 1113] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2cs:
 air_temperature -> air 
Theorem (1317) [serial 1114] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.a2ms:
 air_temperature -> air 
Theorem (1318) [serial 1115] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.cont:
 current_temperature -> control_temp 
Theorem (1319) [serial 1116] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ct:
 current_temperature -> monitor_temp 
Theorem (1320) [serial 1117] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.hc:
 heat_control -> heat_control 
Theorem (1321) [serial 1118] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ldt:
 lower_desired_temperature -> lower_desired_temperature 
Theorem (1322) [serial 1119] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.udt:
 upper_desired_temperature -> upper_desired_temperature 
Theorem (1323) [serial 1120] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.lat:
 lower_alarm_temperature -> lower_alarm_temperature 
Theorem (1324) [serial 1121] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.uat:
 upper_alarm_temperature -> upper_alarm_temperature 
Theorem (1325) [serial 1122] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.rs:
 regulator_status -> regulator_status 
Theorem (1326) [serial 1123] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.ms:
 monitor_status -> monitor_status 
Theorem (1327) [serial 1124] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.dt:
 display_temperature -> display_temperature 
Theorem (1328) [serial 1125] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::isolette.dual_sensor.al:
 alarm_control -> alarm 
Theorem (1329) [serial 1126] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctm:
 current_temperature -> current_temperature 
Theorem (1330) [serial 1127] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tctr:
 current_temperature -> current_temperature 
Theorem (1331) [serial 1128] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.thc:
 heat_control -> heat_control 
Theorem (1332) [serial 1129] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature 
Theorem (1333) [serial 1130] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature 
Theorem (1334) [serial 1131] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature 
Theorem (1335) [serial 1132] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature 
Theorem (1336) [serial 1133] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.trs:
 regulator_status -> regulator_status 
Theorem (1337) [serial 1134] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tdt:
 displayed_temp -> display_temperature 
Theorem (1338) [serial 1135] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tms:
 monitor_status -> monitor_status 
Theorem (1339) [serial 1136] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.ta:
 alarm_control -> alarm_control 
Theorem (1340) [serial 1137] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_single_sensor.impl.tf:
 internal_failure -> regulator_failure 
Theorem (1341) [serial 1138] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctm:
 monitor_temp -> current_temperature 
Theorem (1342) [serial 1139] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tctr:
 control_temp -> current_temperature 
Theorem (1343) [serial 1140] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.thc:
 heat_control -> heat_control 
Theorem (1344) [serial 1141] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tudt:
 upper_desired_temperature -> upper_desired_temperature 
Theorem (1345) [serial 1142] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tldt:
 lower_desired_temperature -> lower_desired_temperature 
Theorem (1346) [serial 1143] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tuat:
 upper_alarm_temperature -> upper_alarm_temperature 
Theorem (1347) [serial 1144] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tlat:
 lower_alarm_temperature -> lower_alarm_temperature 
Theorem (1348) [serial 1145] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.trs:
 regulator_status -> regulator_status 
Theorem (1349) [serial 1146] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tdt:
 displayed_temp -> display_temperature 
Theorem (1350) [serial 1147] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tms:
 monitor_status -> monitor_status 
Theorem (1351) [serial 1148] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.ta:
 alarm_control -> alarm_control 
Theorem (1352) [serial 1149] used for:
  Composition of Subcomponents via Directional Connection KSU_Isolette::thermostat_dual_sensor.impl.tf:
 internal_failure -> regulator_failure 
Theorem (1353) [serial 1150] used for:
  Composition of Subcomponents via Directional Connection Nursery::Room.Normal_Operation.tmp:
 air_temperature -> air_temperature 
Theorem (1354) [serial 1151] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rudt:
 upper_desired_temperature -> upper_desired_temp 
Theorem (1355) [serial 1152] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rldt:
 lower_desired_temperature -> lower_desired_temp 
Theorem (1356) [serial 1153] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mudt:
 upper_desired_temperature -> upper_desired_temperature 
Theorem (1357) [serial 1154] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.mldt:
 lower_desired_temperature -> lower_desired_temperature 
Theorem (1358) [serial 1155] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrs:
 regulator_status -> regulator_status 
Theorem (1359) [serial 1156] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rdt:
 displayed_temp -> displayed_temp 
Theorem (1360) [serial 1157] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcti:
 current_temperature -> current_temperature 
Theorem (1361) [serial 1158] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rcth:
 current_temperature -> current_temperature 
Theorem (1362) [serial 1159] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rhc:
 heat_control -> heat_control 
Theorem (1363) [serial 1160] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmh:
 regulator_mode -> regulator_mode 
Theorem (1364) [serial 1161] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rrmi:
 regulator_mode -> regulator_mode 
Theorem (1365) [serial 1162] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rctm:
 current_temperature -> current_temperature 
Theorem (1366) [serial 1163] used for:
  Composition of Subcomponents via Directional Connection Regulate::regulate_temperature.impl.rif:
 interface_failure -> interface_failure 


showing tree: Derivations
closing proof.txt file 
proof duration:  9.4 seconds 

