#manage_alarm_ma.impl
push
sort-by-component[Monitor::manage_alarm.impl]
#[serial 1017] <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition
make-an
substitute-both
normalize
axioms
#[serial 1018] Serban's Theorem:  disjunction of execute conditions leaving execution state check_temp, <<M(check_temp)>> -> <<e1 or e2 or . . . en>>
normalize
replace<=
laws
normalize
replace-port
cnf
laws
normalize
laws
normalize
now
laws
axioms
#[serial 1019] Serban's Theorem:  disjunction of execute conditions leaving execution state poweron, <<M(poweron)>> -> <<e1 or e2 or . . . en>>
axioms
#[serial 1020] Serban's Theorem:  disjunction of execute conditions leaving execution state check_hyst, <<M(check_hyst)>> -> <<e1 or e2 or . . . en>>
substitute-pre
normalize
axioms
#[serial 1021] Serban's Theorem:  disjunction of execute conditions leaving execution state check_mode, <<M(check_mode)>> -> <<e1 or e2 or . . . en>>
normalize
substitute-post
normalize
replace<=
normalize
laws
normalize
and-over-or-post
laws
normalize
laws
DeMorgan
normalize
laws
normalize
axioms
#[serial 1022]  <<M(poweron)>> -> <<M(run)>> for maPo:poweron-[ ]->run{};
axioms
#[serial 1023]  <<M(run) and x>> -> <<M(check_mode)>> for maRun:run-[x]->check_mode{};
axioms
#[serial 1024]  <<M(check_mode) and x>> A <<M(run)>> for maFailed:check_mode-[x]->run{A};
reduce
atomic
dist^
dist^
normalize
axioms
substitute-post
normalize
laws
dist^
normalize
now
axioms
substitute-post
normalize
axioms
#[serial 1025]  <<M(check_mode) and x>> A <<M(run)>> for maInit:check_mode-[x]->run{A};
reduce
atomic
normalize
axioms
now
axioms
substitute-post
normalize
alldist^
axioms
substitute-post
normalize
axioms
#[serial 1026]  <<M(check_mode) and x>> -> <<M(check_temp)>> for maNormal:check_mode-[x]->check_temp{};
normalize
remove-axioms-post
laws
split-post
axioms
#[serial 1027]  <<M(check_temp) and x>> A <<M(run)>> for maOor:check_temp-[x]->run{A};
reduce
atomic
normalize
axioms
substitute-post
normalize
laws
normalize
dist^
normalize
dist^
normalize
axioms
split-post
replace-port
axioms
substitute-post
normalize
axioms
substitute-post
substitute-pre
normalize
replace<=
normalize
axioms
#[serial 1028]  <<M(check_temp) and x>> A <<M(run)>> for maIr:check_temp-[x]->run{A};
reduce
atomic
laws
dist^
dist^
normalize
axioms
remove-axioms-post
substitute-post
normalize
laws
dist^
normalize
dist^
normalize
axioms
split-post
range-exp
normalize
replace-port
axioms
substitute-both
substitute-post
normalize
replace<=
laws
normalize
axioms
#[serial 1029]  <<M(check_temp) and x>> -> <<M(check_hyst)>> for maHys:check_temp-[x]->check_hyst{};
remove-axioms-post
substitute-both
normalize
range-exp
normalize
laws
dist^
replace-port
normalize
axioms
#[serial 1030]  <<M(check_hyst) and x>> A <<M(run)>> for maHysOn:check_hyst-[x]->run{A};
reduce
atomic
laws
normalize
axioms
dist^
dist^
normalize
axioms
remove-axioms-post
substitute-post
normalize
dist^
normalize
dist^
normalize
axioms
substitute-both
normalize
laws
substitute-pre
normalize
laws
normalize
sub-equals
substitute-post
normalize
laws
normalize
replace<=
normalize
split-post
normalize
axioms
guided-sub-equals[O_n]
axioms
#[serial 1031]  <<M(check_hyst) and x>> A <<M(run)>> for maHysOff:check_hyst-[x]->run{A};
reduce
atomic
normalize
remove-axioms-post
now
laws
axioms
split-post
axioms
push
#[serial 1567]   normalization of [serial 1558
make-an
substitute-post
alldist^
axioms
#[serial 1569]   normalization of [serial 1561]
substitute-post
normalize
laws
normalize
substitute-both
normalize
laws
normalize
guided-sub-equals[Off]
guided-sub-equals[alarm_previous_period]
equivalent
normalize
laws
equivalent
normalize
laws
axioms
#[serial 1586] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1581]
substitute-post
normalize
axioms
#[serial 1032]  <<M(run) and x>> -> <<M(halt)>> for maStop:run-[x]->halt{};
axioms